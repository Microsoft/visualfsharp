namespace FSComp
  type internal SR =
    class
      private new : unit -> SR
      static member
        ArgumentsInSigAndImplMismatch : a0:System.String * a1:System.String ->
                                          int * string
      static member
        CallerMemberNameIsOverriden : a0:System.String -> int * string
      static member
        DefaultParameterValueNotAppropriateForArgument : unit -> int * string
      static member
        DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig : a0:System.String *
                                                                      a1:System.String ->
                                                                        int *
                                                                        string
      static member
        DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer : a0:System.String *
                                                                  a1:System.String *
                                                                  a2:System.String *
                                                                  a3:System.String ->
                                                                    int * string
      static member
        DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl : a0:System.String *
                                                                          a1:System.String *
                                                                          a2:System.String ->
                                                                            int *
                                                                            string
      static member
        DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig : a0:System.String *
                                                                         a1:System.String *
                                                                         a2:System.String ->
                                                                           int *
                                                                           string
      static member
        DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer : a0:System.String *
                                                                  a1:System.String ->
                                                                    int * string
      static member
        DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden : a0:System.String *
                                                                               a1:System.String ->
                                                                                 int *
                                                                                 string
      static member
        DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig : a0:System.String *
                                                                     a1:System.String *
                                                                     a2:System.String ->
                                                                       int *
                                                                       string
      static member
        DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer : a0:System.String *
                                                               a1:System.String ->
                                                                 int * string
      static member
        DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified : a0:System.String *
                                                                           a1:System.String *
                                                                           a2:System.String ->
                                                                             int *
                                                                             string
      static member
        DefinitionsInSigAndImplNotCompatibleFieldWasPresent : a0:System.String *
                                                              a1:System.String *
                                                              a2:System.String ->
                                                                int * string
      static member
        DefinitionsInSigAndImplNotCompatibleILDiffer : a0:System.String *
                                                       a1:System.String ->
                                                         int * string
      static member
        DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot : a0:System.String *
                                                                             a1:System.String *
                                                                             a2:System.String *
                                                                             a3:System.String ->
                                                                               int *
                                                                               string
      static member
        DefinitionsInSigAndImplNotCompatibleImplDefinesStruct : a0:System.String *
                                                                a1:System.String ->
                                                                  int * string
      static member
        DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract : a0:System.String *
                                                                       a1:System.String ->
                                                                         int *
                                                                         string
      static member
        DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed : a0:System.String *
                                                                        a1:System.String ->
                                                                          int *
                                                                          string
      static member
        DefinitionsInSigAndImplNotCompatibleImplementationSaysNull : a0:System.String *
                                                                     a1:System.String ->
                                                                       int *
                                                                       string
      static member
        DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2 : a0:System.String *
                                                                      a1:System.String ->
                                                                        int *
                                                                        string
      static member
        DefinitionsInSigAndImplNotCompatibleImplementationSealed : a0:System.String *
                                                                   a1:System.String ->
                                                                     int *
                                                                     string
      static member
        DefinitionsInSigAndImplNotCompatibleMissingInterface : a0:System.String *
                                                               a1:System.String *
                                                               a2:System.String ->
                                                                 int * string
      static member
        DefinitionsInSigAndImplNotCompatibleNamesDiffer : a0:System.String *
                                                          a1:System.String *
                                                          a2:System.String ->
                                                            int * string
      static member
        DefinitionsInSigAndImplNotCompatibleNumbersDiffer : a0:System.String *
                                                            a1:System.String *
                                                            a2:System.String ->
                                                              int * string
      static member
        DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer : a0:System.String *
                                                                    a1:System.String ->
                                                                      int *
                                                                      string
      static member
        DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer : a0:System.String *
                                                                    a1:System.String ->
                                                                      int *
                                                                      string
      static member
        DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation : a0:System.String *
                                                                 a1:System.String ->
                                                                   int * string
      static member
        DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer : a0:System.String *
                                                                      a1:System.String *
                                                                      a2:System.String *
                                                                      a3:System.String ->
                                                                        int *
                                                                        string
      static member
        DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot : a0:System.String *
                                                                             a1:System.String *
                                                                             a2:System.String *
                                                                             a3:System.String ->
                                                                               int *
                                                                               string
      static member
        DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract : a0:System.String *
                                                                  a1:System.String ->
                                                                    int * string
      static member
        DefinitionsInSigAndImplNotCompatibleSignatureSaysNull : a0:System.String *
                                                                a1:System.String ->
                                                                  int * string
      static member
        DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2 : a0:System.String *
                                                                 a1:System.String ->
                                                                   int * string
      static member
        DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind : a0:System.String *
                                                                  a1:System.String ->
                                                                    int * string
      static member
        DefinitionsInSigAndImplNotCompatibleTypeIsHidden : a0:System.String *
                                                           a1:System.String ->
                                                             int * string
      static member
        DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes : a0:System.String *
                                                                          a1:System.String ->
                                                                            int *
                                                                            string
      static member
        ExceptionDefsNotCompatibleAbbreviationHiddenBySignature : a0:System.String *
                                                                  a1:System.String ->
                                                                    string
      static member
        ExceptionDefsNotCompatibleDotNetRepresentationsDiffer : a0:System.String *
                                                                a1:System.String ->
                                                                  string
      static member
        ExceptionDefsNotCompatibleExceptionDeclarationsDiffer : a0:System.String *
                                                                a1:System.String ->
                                                                  string
      static member
        ExceptionDefsNotCompatibleFieldInImplButNotSig : a0:System.String *
                                                         a1:System.String *
                                                         a2:System.String ->
                                                           string
      static member
        ExceptionDefsNotCompatibleFieldInSigButNotImpl : a0:System.String *
                                                         a1:System.String *
                                                         a2:System.String ->
                                                           string
      static member
        ExceptionDefsNotCompatibleFieldOrderDiffers : a0:System.String *
                                                      a1:System.String -> string
      static member
        ExceptionDefsNotCompatibleHiddenBySignature : a0:System.String *
                                                      a1:System.String -> string
      static member
        ExceptionDefsNotCompatibleSignaturesDiffer : a0:System.String *
                                                     a1:System.String -> string
      static member
        FieldNotContainedAccessibilitiesDiffer : a0:System.String *
                                                 a1:System.String -> string
      static member
        FieldNotContainedLiteralsDiffer : a0:System.String * a1:System.String ->
                                            string
      static member
        FieldNotContainedMutablesDiffer : a0:System.String * a1:System.String ->
                                            string
      static member
        FieldNotContainedNamesDiffer : a0:System.String * a1:System.String ->
                                         string
      static member
        FieldNotContainedStaticsDiffer : a0:System.String * a1:System.String ->
                                           string
      static member
        FieldNotContainedTypesDiffer : a0:System.String * a1:System.String ->
                                         string
      static member
        InvalidRecursiveReferenceToAbstractSlot : unit -> int * string
      static member
        ModuleContainsConstructorButAccessibilityDiffers : a0:System.String *
                                                           a1:System.String ->
                                                             string
      static member
        ModuleContainsConstructorButDataFieldsDiffer : a0:System.String *
                                                       a1:System.String ->
                                                         string
      static member
        ModuleContainsConstructorButNamesDiffer : a0:System.String *
                                                  a1:System.String -> string
      static member
        ModuleContainsConstructorButTypesOfFieldsDiffer : a0:System.String *
                                                          a1:System.String ->
                                                            string
      static member RunStartupValidation : unit -> unit
      static member
        ValueNotContainedMutabilityAbstractsDiffer : a0:System.String *
                                                     a1:System.String *
                                                     a2:System.String -> string
      static member
        ValueNotContainedMutabilityAccessibilityMore : a0:System.String *
                                                       a1:System.String *
                                                       a2:System.String ->
                                                         string
      static member
        ValueNotContainedMutabilityAritiesDiffer : a0:System.String *
                                                   a1:System.String *
                                                   a2:System.String *
                                                   a3:System.String *
                                                   a4:System.String *
                                                   a5:System.String *
                                                   a6:System.String -> string
      static member
        ValueNotContainedMutabilityArityNotInferred : a0:System.String *
                                                      a1:System.String *
                                                      a2:System.String -> string
      static member
        ValueNotContainedMutabilityAttributesDiffer : a0:System.String *
                                                      a1:System.String *
                                                      a2:System.String -> string
      static member
        ValueNotContainedMutabilityCompiledNamesDiffer : a0:System.String *
                                                         a1:System.String *
                                                         a2:System.String ->
                                                           string
      static member
        ValueNotContainedMutabilityDisplayNamesDiffer : a0:System.String *
                                                        a1:System.String *
                                                        a2:System.String ->
                                                          string
      static member
        ValueNotContainedMutabilityDotNetNamesDiffer : a0:System.String *
                                                       a1:System.String *
                                                       a2:System.String ->
                                                         string
      static member
        ValueNotContainedMutabilityExtensionsDiffer : a0:System.String *
                                                      a1:System.String *
                                                      a2:System.String -> string
      static member
        ValueNotContainedMutabilityFinalsDiffer : a0:System.String *
                                                  a1:System.String *
                                                  a2:System.String -> string
      static member
        ValueNotContainedMutabilityGenericParametersAreDifferentKinds : a0:System.String *
                                                                        a1:System.String *
                                                                        a2:System.String ->
                                                                          string
      static member
        ValueNotContainedMutabilityGenericParametersDiffer : a0:System.String *
                                                             a1:System.String *
                                                             a2:System.String *
                                                             a3:System.String *
                                                             a4:System.String ->
                                                               string
      static member
        ValueNotContainedMutabilityInlineFlagsDiffer : a0:System.String *
                                                       a1:System.String *
                                                       a2:System.String ->
                                                         string
      static member
        ValueNotContainedMutabilityInstanceButStatic : a0:System.String *
                                                       a1:System.String *
                                                       a2:System.String ->
                                                         string
      static member
        ValueNotContainedMutabilityLiteralConstantValuesDiffer : a0:System.String *
                                                                 a1:System.String *
                                                                 a2:System.String ->
                                                                   string
      static member
        ValueNotContainedMutabilityNamesDiffer : a0:System.String *
                                                 a1:System.String *
                                                 a2:System.String -> string
      static member
        ValueNotContainedMutabilityOneIsConstructor : a0:System.String *
                                                      a1:System.String *
                                                      a2:System.String -> string
      static member
        ValueNotContainedMutabilityOneIsTypeFunction : a0:System.String *
                                                       a1:System.String *
                                                       a2:System.String ->
                                                         string
      static member
        ValueNotContainedMutabilityOverridesDiffer : a0:System.String *
                                                     a1:System.String *
                                                     a2:System.String -> string
      static member
        ValueNotContainedMutabilityParameterCountsDiffer : a0:System.String *
                                                           a1:System.String *
                                                           a2:System.String ->
                                                             string
      static member
        ValueNotContainedMutabilityStaticButInstance : a0:System.String *
                                                       a1:System.String *
                                                       a2:System.String ->
                                                         string
      static member
        ValueNotContainedMutabilityStaticsDiffer : a0:System.String *
                                                   a1:System.String *
                                                   a2:System.String -> string
      static member
        ValueNotContainedMutabilityTypesDiffer : a0:System.String *
                                                 a1:System.String *
                                                 a2:System.String -> string
      static member
        ValueNotContainedMutabilityVirtualsDiffer : a0:System.String *
                                                    a1:System.String *
                                                    a2:System.String -> string
      static member abImplicitHeapAllocation : a0:System.String -> int * string
      static member
        activePatternChoiceHasFreeTypars : a0:System.String -> int * string
      static member
        activePatternIdentIsNotFunctionTyped : a0:System.String -> int * string
      static member addIndexerDot : unit -> string
      static member
        arrayElementHasWrongType : a0:System.String * a1:System.String -> string
      static member
        assemblyResolutionFoundByAssemblyFoldersExKey : unit -> string
      static member assemblyResolutionFoundByAssemblyFoldersKey : unit -> string
      static member assemblyResolutionGAC : unit -> string
      static member assemblyResolutionNetFramework : unit -> string
      static member astDeprecatedIndexerNotation : unit -> string
      static member astInvalidExprLeftHandOfAssignment : unit -> int * string
      static member astParseEmbeddedILError : unit -> int * string
      static member astParseEmbeddedILTypeError : unit -> int * string
      static member augCustomCompareNeedsIComp : unit -> int * string
      static member augCustomEqNeedsNoCompOrCustomComp : unit -> int * string
      static member augCustomEqNeedsObjEquals : unit -> int * string
      static member augInvalidAttrs : unit -> int * string
      static member augNoCompCantImpIComp : unit -> int * string
      static member augNoEqNeedsNoObjEquals : unit -> int * string
      static member augNoEqualityNeedsNoComparison : unit -> int * string
      static member augNoRefEqualsOnStruct : unit -> int * string
      static member augOnlyCertainTypesCanHaveAttrs : unit -> int * string
      static member augRefEqCantHaveObjEquals : unit -> int * string
      static member augStructCompNeedsStructEquality : unit -> int * string
      static member augStructEqNeedsNoCompOrStructComp : unit -> int * string
      static member augTypeCantHaveRefEqAndStructAttrs : unit -> int * string
      static member buildArgInvalidFloat : a0:System.String -> int * string
      static member buildArgInvalidInt : a0:System.String -> int * string
      static member buildAssemblyResolutionFailed : unit -> int * string
      static member buildCannotReadAssembly : a0:System.String -> int * string
      static member buildCompilingExtensionIsForML : unit -> string
      static member
        buildCouldNotFindSourceFile : a0:System.String -> int * string
      static member
        buildCouldNotResolveAssembly : a0:System.String -> int * string
      static member
        buildCouldNotResolveAssemblyRequiredByFile : a0:System.String *
                                                     a1:System.String ->
                                                       int * string
      static member
        buildDifferentVersionMustRecompile : a0:System.String -> int * string
      static member buildDirectivesInModulesAreIgnored : unit -> int * string
      static member
        buildErrorOpeningBinaryFile : a0:System.String * a1:System.String ->
                                        int * string
      static member
        buildExpectedFileAlongSideFSharpCore : a0:System.String *
                                               a1:System.String -> int * string
      static member buildExpectedSigdataFile : a0:System.String -> int * string
      static member
        buildImplementationAlreadyGiven : a0:System.String -> int * string
      static member
        buildImplementationAlreadyGivenDetail : a0:System.String -> int * string
      static member
        buildImplicitModuleIsNotLegalIdentifier : a0:System.String *
                                                  a1:System.String ->
                                                    int * string
      static member buildInvalidAssemblyName : a0:System.String -> int * string
      static member buildInvalidFilename : a0:System.String -> int * string
      static member buildInvalidHashIDirective : unit -> int * string
      static member buildInvalidHashloadDirective : unit -> int * string
      static member buildInvalidHashrDirective : unit -> int * string
      static member buildInvalidHashtimeDirective : unit -> int * string
      static member buildInvalidModuleOrNamespaceName : unit -> int * string
      static member buildInvalidPrivacy : a0:System.String -> int * string
      static member
        buildInvalidSearchDirectory : a0:System.String -> int * string
      static member
        buildInvalidSourceFileExtension : a0:System.String -> int * string
      static member buildInvalidVersionFile : a0:System.String -> int * string
      static member buildInvalidVersionString : a0:System.String -> int * string
      static member buildInvalidWarningNumber : a0:System.String -> int * string
      static member
        buildMultiFileRequiresNamespaceOrModule : unit -> int * string
      static member buildMultipleToplevelModules : unit -> int * string
      static member buildNoInputsSpecified : unit -> int * string
      static member
        buildOptionRequiresParameter : a0:System.String -> int * string
      static member buildPdbRequiresDebug : unit -> int * string
      static member
        buildProblemReadingAssembly : a0:System.String * a1:System.String ->
                                        int * string
      static member
        buildProblemWithFilename : a0:System.String * a1:System.String ->
                                     int * string
      static member
        buildSearchDirectoryNotFound : a0:System.String -> int * string
      static member
        buildSignatureAlreadySpecified : a0:System.String -> int * string
      static member
        buildSignatureWithoutImplementation : a0:System.String -> int * string
      static member
        buildUnexpectedFileNameCharacter : a0:System.String * a1:System.String ->
                                             int * string
      static member
        buildUnexpectedTypeArgs : a0:System.String * a1:System.Int32 -> string
      static member buildUnrecognizedOption : a0:System.String -> int * string
      static member
        cannotResolveNullableOperators : a0:System.String -> int * string
      static member
        checkLowercaseLiteralBindingInPattern : a0:System.String -> int * string
      static member
        checkNotSufficientlyGenericBecauseOfScope : a0:System.String ->
                                                      int * string
      static member
        checkNotSufficientlyGenericBecauseOfScopeAnon : unit -> int * string
      static member
        checkRaiseFamilyFunctionArgumentCount : a0:System.String *
                                                a1:System.Int32 *
                                                a2:System.Int32 -> int * string
      static member chkAttrHasAllowMultiFalse : a0:System.String -> int * string
      static member chkBaseUsedInInvalidWay : unit -> int * string
      static member chkByrefUsedInInvalidWay : a0:System.String -> int * string
      static member chkCantStoreByrefValue : unit -> int * string
      static member chkCurriedMethodsCantHaveOutParams : unit -> int * string
      static member
        chkDuplicateMethod : a0:System.String * a1:System.String -> int * string
      static member
        chkDuplicateMethodCurried : a0:System.String * a1:System.String ->
                                      int * string
      static member
        chkDuplicateMethodInheritedType : a0:System.String -> int * string
      static member
        chkDuplicateMethodInheritedTypeWithSuffix : a0:System.String ->
                                                      int * string
      static member
        chkDuplicateMethodWithSuffix : a0:System.String * a1:System.String ->
                                         int * string
      static member
        chkDuplicateProperty : a0:System.String * a1:System.String ->
                                 int * string
      static member
        chkDuplicatePropertyWithSuffix : a0:System.String * a1:System.String ->
                                           int * string
      static member chkEntryPointUsage : unit -> int * string
      static member chkErrorContainsCallToRethrow : unit -> int * string
      static member chkErrorUseOfByref : unit -> int * string
      static member
        chkFeatureNotLanguageSupported : a0:System.String * a1:System.String *
                                         a2:System.String -> int * string
      static member
        chkFeatureNotRuntimeSupported : a0:System.String -> int * string
      static member
        chkFeatureNotSupportedInLibrary : a0:System.String * a1:System.String ->
                                            int * string
      static member chkFirstClassFuncNoByref : unit -> int * string
      static member
        chkGetterAndSetterHaveSamePropertyType : a0:System.String *
                                                 a1:System.String *
                                                 a2:System.String ->
                                                   int * string
      static member
        chkGetterSetterDoNotMatchAbstract : a0:System.String * a1:System.String ->
                                              int * string
      static member chkInvalidCustAttrVal : unit -> int * string
      static member
        chkInvalidFunctionParameterType : a0:System.String * a1:System.String ->
                                            int * string
      static member
        chkInvalidFunctionReturnType : a0:System.String -> int * string
      static member chkLimitationsOfBaseKeyword : unit -> int * string
      static member
        chkMemberUsedInInvalidWay : a0:System.String * a1:System.String *
                                    a2:System.String -> int * string
      static member
        chkMultipleGenericInterfaceInstantiations : a0:System.String *
                                                    a1:System.String ->
                                                      int * string
      static member
        chkNoAddressFieldAtThisPoint : a0:System.String -> int * string
      static member chkNoAddressOfArrayElementAtThisPoint : unit -> int * string
      static member chkNoAddressOfAtThisPoint : a0:System.String -> int * string
      static member
        chkNoAddressStaticFieldAtThisPoint : a0:System.String -> int * string
      static member chkNoByrefAddressOfLocal : a0:System.String -> int * string
      static member
        chkNoByrefAddressOfValueFromExpression : unit -> int * string
      static member chkNoByrefAsTopValue : unit -> int * string
      static member chkNoByrefAtThisPoint : a0:System.String -> int * string
      static member chkNoByrefInTypeAbbrev : unit -> int * string
      static member chkNoByrefLikeFunctionCall : unit -> int * string
      static member chkNoByrefsOfByrefs : a0:System.String -> int * string
      static member chkNoFirstClassAddressOf : unit -> int * string
      static member chkNoFirstClassNameOf : unit -> int * string
      static member chkNoFirstClassRethrow : unit -> int * string
      static member chkNoFirstClassSplicing : unit -> int * string
      static member
        chkNoReflectedDefinitionOnStructMember : unit -> int * string
      static member chkNoSpanLikeValueFromExpression : unit -> int * string
      static member chkNoSpanLikeVariable : a0:System.String -> int * string
      static member chkNoWriteToLimitedSpan : a0:System.String -> int * string
      static member chkObjCtorsCantUseExceptionHandling : unit -> int * string
      static member
        chkPropertySameNameIndexer : a0:System.String * a1:System.String ->
                                       int * string
      static member
        chkPropertySameNameMethod : a0:System.String * a1:System.String ->
                                      int * string
      static member chkProtectedOrBaseCalled : unit -> int * string
      static member chkReflectedDefCantSplice : unit -> int * string
      static member chkReturnTypeNoByref : unit -> int * string
      static member chkSplicingOnlyInQuotations : unit -> int * string
      static member
        chkStructsMayNotReturnAddressesOfContents : unit -> int * string
      static member chkSystemVoidOnlyInTypeof : unit -> int * string
      static member chkTyparMultipleClassConstraints : unit -> int * string
      static member
        chkTypeLessAccessibleThanType : a0:System.String * a1:System.String ->
                                          int * string
      static member chkUnionCaseCompiledForm : unit -> string
      static member chkUnionCaseDefaultAugmentation : unit -> string
      static member chkUnusedThisVariable : a0:System.String -> int * string
      static member chkUnusedValue : a0:System.String -> int * string
      static member
        chkValueWithDefaultValueMustHaveDefaultValue : unit -> int * string
      static member chkVariableUsedInInvalidWay : a0:System.String -> string
      static member commaInsteadOfSemicolonInRecord : unit -> string
      static member
        considerUpcast : a0:System.String * a1:System.String -> int * string
      static member
        considerUpcastOperator : a0:System.String * a1:System.String ->
                                   int * string
      static member
        couldNotLoadDependencyManagerExtension : a0:System.String *
                                                 a1:System.String ->
                                                   int * string
      static member crefBoundVarUsedInSplice : a0:System.String -> int * string
      static member crefNoInnerGenericsInQuotations : unit -> int * string
      static member crefNoSetOfHole : unit -> int * string
      static member crefQuotationsCantCallTraitMembers : unit -> int * string
      static member crefQuotationsCantContainAddressOf : unit -> int * string
      static member
        crefQuotationsCantContainArrayPatternMatching : unit -> int * string
      static member
        crefQuotationsCantContainDescendingForLoops : unit -> int * string
      static member crefQuotationsCantContainGenericExprs : unit -> int * string
      static member
        crefQuotationsCantContainGenericFunctions : unit -> int * string
      static member crefQuotationsCantContainInlineIL : unit -> int * string
      static member crefQuotationsCantContainObjExprs : unit -> int * string
      static member
        crefQuotationsCantContainStaticFieldRef : unit -> int * string
      static member crefQuotationsCantContainThisConstant : unit -> int * string
      static member
        crefQuotationsCantContainThisPatternMatch : unit -> int * string
      static member crefQuotationsCantContainThisType : unit -> int * string
      static member crefQuotationsCantFetchUnionIndexes : unit -> int * string
      static member crefQuotationsCantRequireByref : unit -> int * string
      static member crefQuotationsCantSetExceptionFields : unit -> int * string
      static member crefQuotationsCantSetUnionFields : unit -> int * string
      static member csArgumentLengthMismatch : unit -> int * string
      static member csArgumentTypesDoNotMatch : unit -> int * string
      static member csAvailableOverloads : a0:System.String -> string
      static member csCandidates : a0:System.String -> string
      static member csCodeLessGeneric : unit -> int * string
      static member
        csCtorHasNoArgumentOrReturnProperty : a0:System.String *
                                              a1:System.String *
                                              a2:System.String -> string
      static member
        csCtorSignatureMismatchArity : a0:System.String * a1:System.Int32 *
                                       a2:System.Int32 * a3:System.String ->
                                         int * string
      static member
        csCtorSignatureMismatchArityProp : a0:System.String * a1:System.Int32 *
                                           a2:System.Int32 * a3:System.String ->
                                             int * string
      static member
        csExpectTypeWithOperatorButGivenFunction : a0:System.String -> string
      static member
        csExpectTypeWithOperatorButGivenTuple : a0:System.String -> string
      static member csExpectedArguments : unit -> string
      static member
        csGenericConstructRequiresNonAbstract : a0:System.String -> string
      static member
        csGenericConstructRequiresPublicDefaultConstructor : a0:System.String ->
                                                               string
      static member
        csGenericConstructRequiresReferenceSemantics : a0:System.String ->
                                                         string
      static member
        csGenericConstructRequiresStructOrReferenceConstraint : unit -> string
      static member
        csGenericConstructRequiresStructType : a0:System.String -> string
      static member
        csGenericConstructRequiresUnmanagedType : a0:System.String -> string
      static member
        csIncorrectGenericInstantiation : a0:System.String * a1:System.String *
                                          a2:System.Int32 -> int * string
      static member
        csIndexArgumentMismatch : a0:System.Int32 * a1:System.Int32 -> string
      static member
        csMemberHasNoArgumentOrReturnProperty : a0:System.String *
                                                a1:System.String *
                                                a2:System.String -> string
      static member
        csMemberIsNotAccessible : a0:System.String * a1:System.String ->
                                    int * string
      static member
        csMemberIsNotAccessible2 : a0:System.String * a1:System.String ->
                                     int * string
      static member csMemberIsNotInstance : a0:System.String -> int * string
      static member csMemberIsNotStatic : a0:System.String -> int * string
      static member
        csMemberNotAccessible : a0:System.String * a1:System.Int32 *
                                a2:System.String * a3:System.Int32 ->
                                  int * string
      static member
        csMemberOverloadArityMismatch : a0:System.String * a1:System.Int32 *
                                        a2:System.Int32 -> int * string
      static member
        csMemberSignatureMismatch : a0:System.String * a1:System.Int32 *
                                    a2:System.String -> int * string
      static member
        csMemberSignatureMismatch2 : a0:System.String * a1:System.Int32 *
                                     a2:System.String -> int * string
      static member
        csMemberSignatureMismatch3 : a0:System.String * a1:System.Int32 *
                                     a2:System.String * a3:System.String ->
                                       int * string
      static member
        csMemberSignatureMismatch4 : a0:System.String * a1:System.Int32 *
                                     a2:System.String * a3:System.String ->
                                       int * string
      static member
        csMemberSignatureMismatchArity : a0:System.String * a1:System.Int32 *
                                         a2:System.Int32 * a3:System.String ->
                                           int * string
      static member
        csMemberSignatureMismatchArityNamed : a0:System.String * a1:System.Int32 *
                                              a2:System.Int32 * a3:System.Int32 *
                                              a4:System.String -> int * string
      static member
        csMemberSignatureMismatchArityType : a0:System.String * a1:System.Int32 *
                                             a2:System.Int32 * a3:System.String ->
                                               int * string
      static member csMethodExpectsParams : unit -> int * string
      static member
        csMethodFoundButIsNotStatic : a0:System.String * a1:System.String *
                                      a2:System.String -> string
      static member
        csMethodFoundButIsStatic : a0:System.String * a1:System.String *
                                   a2:System.String -> string
      static member
        csMethodIsNotAStaticMethod : a0:System.String -> int * string
      static member
        csMethodIsNotAnInstanceMethod : a0:System.String -> int * string
      static member csMethodIsOverloaded : a0:System.String -> string
      static member csMethodNotFound : a0:System.String -> int * string
      static member
        csNoMemberTakesTheseArguments : a0:System.String * a1:System.String *
                                        a2:System.Int32 -> int * string
      static member
        csNoMemberTakesTheseArguments2 : a0:System.String * a1:System.String *
                                         a2:System.Int32 * a3:System.Int32 ->
                                           int * string
      static member
        csNoMemberTakesTheseArguments3 : a0:System.String * a1:System.String *
                                         a2:System.Int32 * a3:System.String ->
                                           int * string
      static member csNoOverloadsFound : a0:System.String -> string
      static member
        csNoOverloadsFoundArgumentsPrefixPlural : a0:System.String -> string
      static member
        csNoOverloadsFoundArgumentsPrefixSingular : a0:System.String -> string
      static member csNoOverloadsFoundReturnType : a0:System.String -> string
      static member
        csNoOverloadsFoundTypeParametersPrefixPlural : a0:System.String ->
                                                         string
      static member
        csNoOverloadsFoundTypeParametersPrefixSingular : a0:System.String ->
                                                           string
      static member csNullableTypeDoesNotHaveNull : a0:System.String -> string
      static member csOptionalArgumentNotPermittedHere : unit -> int * string
      static member
        csOverloadCandidateIndexedArgumentTypeMismatch : a0:System.Int32 ->
                                                           string
      static member
        csOverloadCandidateNamedArgumentTypeMismatch : a0:System.String ->
                                                         string
      static member csRequiredSignatureIs : a0:System.String -> int * string
      static member csStructConstraintInconsistent : unit -> int * string
      static member
        csTypeCannotBeResolvedAtCompileTime : a0:System.String -> string
      static member csTypeDoesNotHaveNull : a0:System.String -> string
      static member csTypeDoesNotSupportComparison1 : a0:System.String -> string
      static member csTypeDoesNotSupportComparison2 : a0:System.String -> string
      static member csTypeDoesNotSupportComparison3 : a0:System.String -> string
      static member
        csTypeDoesNotSupportConversion : a0:System.String * a1:System.String ->
                                           string
      static member csTypeDoesNotSupportEquality1 : a0:System.String -> string
      static member csTypeDoesNotSupportEquality2 : a0:System.String -> string
      static member csTypeDoesNotSupportEquality3 : a0:System.String -> string
      static member
        csTypeDoesNotSupportOperator : a0:System.String * a1:System.String ->
                                         string
      static member
        csTypeDoesNotSupportOperatorNullable : a0:System.String *
                                               a1:System.String -> string
      static member
        csTypeHasNonStandardDelegateType : a0:System.String -> string
      static member csTypeInferenceMaxDepth : unit -> int * string
      static member csTypeInstantiationLengthMismatch : unit -> int * string
      static member csTypeIsNotDelegateType : a0:System.String -> string
      static member csTypeIsNotEnumType : a0:System.String -> string
      static member
        csTypeNotCompatibleBecauseOfPrintf : a0:System.String * a1:System.String ->
                                               string
      static member csTypeParameterCannotBeNullable : unit -> string
      static member
        csTypesDoNotSupportOperator : a0:System.String * a1:System.String ->
                                        string
      static member
        csTypesDoNotSupportOperatorNullable : a0:System.String *
                                              a1:System.String -> string
      static member
        customOperationTextLikeGroupJoin : a0:System.String * a1:System.String *
                                           a2:System.String -> string
      static member
        customOperationTextLikeJoin : a0:System.String * a1:System.String *
                                      a2:System.String -> string
      static member customOperationTextLikeZip : a0:System.String -> string
      static member
        delegatesNotAllowedToHaveCurriedSignatures : unit -> int * string
      static member derefInsteadOfNot : unit -> string
      static member descriptionUnavailable : unit -> string
      static member descriptionWordIs : unit -> string
      static member docfileNoXmlSuffix : unit -> int * string
      static member elDeprecatedOperator : unit -> string
      static member elSysEnvExitDidntExit : unit -> string
      static member
        elseBranchHasWrongType : a0:System.String * a1:System.String -> string
      static member erasedTo : unit -> string
      static member
        estApplyStaticArgumentsForMethodNotImplemented : unit -> string
      static member etBadUnnamedStaticArgs : unit -> int * string
      static member
        etDirectReferenceToGeneratedTypeNotAllowed : a0:System.String ->
                                                       int * string
      static member
        etEmptyNamespaceNotAllowed : a0:System.String -> int * string
      static member
        etEmptyNamespaceOfTypeNotAllowed : a0:System.String * a1:System.String ->
                                             int * string
      static member
        etErasedTypeUsedInGeneration : a0:System.String * a1:System.String ->
                                         int * string
      static member
        etErrorApplyingStaticArgumentsToMethod : unit -> int * string
      static member etErrorApplyingStaticArgumentsToType : unit -> int * string
      static member
        etEventNoAdd : a0:System.String * a1:System.String -> int * string
      static member
        etEventNoRemove : a0:System.String * a1:System.String -> int * string
      static member
        etHostingAssemblyFoundWithoutHosts : a0:System.String * a1:System.String ->
                                               int * string
      static member
        etIllegalCharactersInNamespaceName : a0:System.String * a1:System.String ->
                                               int * string
      static member
        etIllegalCharactersInTypeName : a0:System.String * a1:System.String ->
                                          int * string
      static member
        etIncorrectParameterExpression : a0:System.String * a1:System.String ->
                                           int * string
      static member
        etIncorrectProvidedConstructor : a0:System.String * a1:System.String ->
                                           int * string
      static member
        etIncorrectProvidedMethod : a0:System.String * a1:System.String *
                                    a2:System.Int32 * a3:System.String ->
                                      int * string
      static member etInvalidStaticArgument : a0:System.String -> int * string
      static member
        etInvalidTypeProviderAssemblyName : a0:System.String * a1:System.String ->
                                              int * string
      static member
        etMethodHasRequirements : a0:System.String * a1:System.String ->
                                    int * string
      static member etMissingStaticArgumentsToMethod : unit -> int * string
      static member
        etMultipleStaticParameterWithName : a0:System.String -> int * string
      static member etMustNotBeAnArray : a0:System.String -> int * string
      static member etMustNotBeGeneric : a0:System.String -> int * string
      static member
        etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters : unit ->
                                                                             int *
                                                                             string
      static member
        etNoStaticParameterWithName : a0:System.String -> int * string
      static member etNullMember : a0:System.String -> int * string
      static member
        etNullMemberDeclaringType : a0:System.String * a1:System.String ->
                                      int * string
      static member
        etNullMemberDeclaringTypeDifferentFromProvidedType : a0:System.String *
                                                             a1:System.String *
                                                             a2:System.String ->
                                                               int * string
      static member etNullOrEmptyMemberName : a0:System.String -> int * string
      static member etNullProvidedExpression : a0:System.String -> int * string
      static member
        etOneOrMoreErrorsSeenDuringExtensionTypeSetting : unit -> int * string
      static member
        etPropertyCanReadButHasNoGetter : a0:System.String * a1:System.String ->
                                            int * string
      static member
        etPropertyCanWriteButHasNoSetter : a0:System.String * a1:System.String ->
                                             int * string
      static member
        etPropertyHasGetterButNoCanRead : a0:System.String * a1:System.String ->
                                            int * string
      static member
        etPropertyHasSetterButNoCanWrite : a0:System.String * a1:System.String ->
                                             int * string
      static member
        etPropertyNeedsCanWriteOrCanRead : a0:System.String * a1:System.String ->
                                             int * string
      static member
        etProvidedAppliedMethodHadWrongName : a0:System.String *
                                              a1:System.String *
                                              a2:System.String -> int * string
      static member
        etProvidedAppliedTypeHadWrongName : a0:System.String * a1:System.String *
                                            a2:System.String -> int * string
      static member
        etProvidedTypeHasUnexpectedName : a0:System.String * a1:System.String ->
                                            int * string
      static member
        etProvidedTypeHasUnexpectedPath : a0:System.String * a1:System.String ->
                                            int * string
      static member
        etProvidedTypeReferenceInvalidText : a0:System.String -> int * string
      static member
        etProvidedTypeReferenceMissingArgument : a0:System.String ->
                                                   int * string
      static member
        etProvidedTypeWithNameException : a0:System.String * a1:System.String ->
                                            int * string
      static member
        etProvidedTypeWithNullOrEmptyName : a0:System.String -> int * string
      static member etProviderDoesNotHaveValidConstructor : unit -> int * string
      static member
        etProviderError : a0:System.String * a1:System.String -> int * string
      static member
        etProviderErrorWithContext : a0:System.String * a1:System.String *
                                     a2:System.String * a3:System.String ->
                                       int * string
      static member
        etProviderHasDesignerAssemblyDependency : a0:System.String *
                                                  a1:System.String *
                                                  a2:System.String *
                                                  a3:System.String ->
                                                    int * string
      static member
        etProviderHasDesignerAssemblyException : a0:System.String *
                                                 a1:System.String *
                                                 a2:System.String *
                                                 a3:System.String ->
                                                   int * string
      static member
        etProviderHasWrongDesignerAssembly : a0:System.String * a1:System.String *
                                             a2:System.String * a3:System.String *
                                             a4:System.String -> int * string
      static member
        etProviderHasWrongDesignerAssemblyNoPath : a0:System.String *
                                                   a1:System.String *
                                                   a2:System.String *
                                                   a3:System.String ->
                                                     int * string
      static member etProviderReturnedNull : a0:System.String -> int * string
      static member
        etStaticParameterAlreadyHasValue : a0:System.String -> int * string
      static member
        etStaticParameterRequiresAValue : a0:System.String * a1:System.String *
                                          a2:System.String * a3:System.String ->
                                            int * string
      static member
        etTooManyStaticParameters : a0:System.Int32 * a1:System.Int32 *
                                    a2:System.Int32 -> int * string
      static member
        etTypeProviderConstructorException : a0:System.String -> int * string
      static member
        etUnexpectedExceptionFromProvidedMemberMember : a0:System.String *
                                                        a1:System.String *
                                                        a2:System.String *
                                                        a3:System.String ->
                                                          int * string
      static member
        etUnexpectedExceptionFromProvidedTypeMember : a0:System.String *
                                                      a1:System.String *
                                                      a2:System.String ->
                                                        int * string
      static member
        etUnexpectedNullFromProvidedTypeMember : a0:System.String *
                                                 a1:System.String ->
                                                   int * string
      static member
        etUnknownStaticArgumentKind : a0:System.String * a1:System.String ->
                                        int * string
      static member etUnsupportedConstantType : a0:System.String -> int * string
      static member
        etUnsupportedMemberKind : a0:System.String * a1:System.String ->
                                    int * string
      static member
        etUnsupportedProvidedExpression : a0:System.String -> int * string
      static member
        eventHasNonStandardType : a0:System.String * a1:System.String *
                                  a2:System.String -> int * string
      static member experimentalConstruct : unit -> string
      static member expressionHasNoName : unit -> int * string
      static member featureAndBang : unit -> string
      static member featureDefaultInterfaceMemberConsumption : unit -> string
      static member featureDotlessFloat32Literal : unit -> string
      static member featureExpandedMeasurables : unit -> string
      static member featureFixedIndexSlice3d4d : unit -> string
      static member featureFromEndSlicing : unit -> string
      static member featureImplicitYield : unit -> string
      static member
        featureInterfacesWithMultipleGenericInstantiation : unit -> string
      static member featureNameOf : unit -> string
      static member featureNullableOptionalInterop : unit -> string
      static member featureOpenTypeDeclaration : unit -> string
      static member featureOverloadsForCustomOperations : unit -> string
      static member featurePackageManagement : unit -> string
      static member featureRelaxWhitespace : unit -> string
      static member featureSingleUnderscorePattern : unit -> string
      static member featureStringInterpolation : unit -> string
      static member featureWildCardInForLoop : unit -> string
      static member featureWitnessPassing : unit -> string
      static member fieldIsNotAccessible : a0:System.String -> int * string
      static member
        followingPatternMatchClauseHasWrongType : a0:System.String *
                                                  a1:System.String -> string
      static member forBadFormatSpecifier : unit -> string
      static member forBadFormatSpecifierGeneral : a0:System.String -> string
      static member forBadPrecision : unit -> string
      static member forBadWidth : unit -> string
      static member
        forDoesNotSupportPrefixFlag : a0:System.String * a1:System.String ->
                                        string
      static member forDoesNotSupportZeroFlag : a0:System.String -> string
      static member forFlagSetTwice : a0:System.String -> string
      static member forFormatDoesntSupportPrecision : a0:System.String -> string
      static member forFormatInvalidForInterpolated : unit -> string
      static member forFormatInvalidForInterpolated2 : unit -> string
      static member forFormatInvalidForInterpolated3 : unit -> string
      static member forFormatInvalidForInterpolated4 : unit -> string
      static member forHIsUnnecessary : unit -> string
      static member forHashSpecifierIsInvalid : unit -> string
      static member forLIsUnnecessary : unit -> string
      static member forMissingFormatSpecifier : unit -> string
      static member forPositionalSpecifiersNotPermitted : unit -> string
      static member forPrecisionMissingAfterDot : unit -> string
      static member forPrefixFlagSpacePlusSetTwice : unit -> string
      static member formatDashItem : a0:System.String -> string
      static member fromEndSlicingRequiresVFive : unit -> int * string
      static member fscAssemblyCultureAttributeError : unit -> int * string
      static member
        fscAssemblyNotFoundInDependencySet : a0:System.String -> int * string
      static member fscAssemblyVersionAttributeIgnored : unit -> int * string
      static member
        fscAssemblyWildcardAndDeterminism : a0:System.String * a1:System.String ->
                                              int * string
      static member
        fscAssumeStaticLinkContainsNoDependencies : a0:System.String ->
                                                      int * string
      static member
        fscBadAssemblyVersion : a0:System.String * a1:System.String ->
                                  int * string
      static member fscDelaySignWarning : unit -> int * string
      static member
        fscDeterministicDebugRequiresPortablePdb : unit -> int * string
      static member
        fscIgnoringMixedWhenLinking : a0:System.String -> int * string
      static member
        fscKeyFileCouldNotBeOpened : a0:System.String -> int * string
      static member fscKeyFileWarning : unit -> int * string
      static member fscKeyNameWarning : unit -> int * string
      static member fscNoImplementationFiles : unit -> int * string
      static member fscPathMapDebugRequiresPortablePdb : unit -> int * string
      static member
        fscProblemWritingBinary : a0:System.String * a1:System.String ->
                                    int * string
      static member
        fscQuotationLiteralsStaticLinking : a0:System.String -> int * string
      static member fscQuotationLiteralsStaticLinking0 : unit -> int * string
      static member fscReferenceOnCommandLine : a0:System.String -> int * string
      static member fscRemotingError : unit -> int * string
      static member
        fscResxSourceFileDeprecated : a0:System.String -> int * string
      static member fscStaticLinkingNoEXE : unit -> int * string
      static member fscStaticLinkingNoMixedDLL : unit -> int * string
      static member fscStaticLinkingNoProfileMismatches : unit -> int * string
      static member
        fscSystemRuntimeInteropServicesIsRequired : unit -> int * string
      static member fscTooManyErrors : unit -> string
      static member fscTwoResourceManifests : unit -> int * string
      static member fsharpCoreNotFoundToBeCopied : unit -> int * string
      static member
        fsiInvalidDirective : a0:System.String * a1:System.String ->
                                int * string
      static member ifExpression : a0:System.String * a1:System.String -> string
      static member ilAddressOfLiteralFieldIsInvalid : unit -> int * string
      static member
        ilAddressOfValueHereIsInvalid : a0:System.String -> int * string
      static member
        ilCustomMarshallersCannotBeUsedInFSharp : unit -> int * string
      static member
        ilDefaultAugmentationAttributeCouldNotBeDecoded : unit -> int * string
      static member ilDllImportAttributeCouldNotBeDecoded : unit -> int * string
      static member ilDynamicInvocationNotSupported : a0:System.String -> string
      static member
        ilFieldDoesNotHaveValidOffsetForStructureLayout : a0:System.String *
                                                          a1:System.String ->
                                                            int * string
      static member ilFieldHasOffsetForSequentialLayout : unit -> int * string
      static member
        ilFieldOffsetAttributeCouldNotBeDecoded : unit -> int * string
      static member ilIncorrectNumberOfTypeArguments : unit -> int * string
      static member ilLabelNotFound : a0:System.String -> int * string
      static member ilLiteralFieldsCannotBeSet : unit -> int * string
      static member ilMainModuleEmpty : unit -> int * string
      static member ilMarshalAsAttributeCannotBeDecoded : unit -> int * string
      static member ilMutableVariablesCannotEscapeMethod : unit -> int * string
      static member
        ilReflectedDefinitionsCannotUseSliceOperator : unit -> int * string
      static member ilSignBadImageFormat : unit -> int * string
      static member ilSignInvalidAlgId : unit -> int * string
      static member ilSignInvalidBitLen : unit -> int * string
      static member ilSignInvalidMagicValue : unit -> int * string
      static member ilSignInvalidPKBlob : unit -> int * string
      static member ilSignInvalidRSAParams : unit -> int * string
      static member ilSignInvalidSignatureSize : unit -> int * string
      static member ilSignNoSignatureDirectory : unit -> int * string
      static member ilSignPrivateKeyExpected : unit -> int * string
      static member ilSignRsaKeyExpected : unit -> int * string
      static member
        ilSignatureForExternalFunctionContainsTypeParameters : unit ->
                                                                 int * string
      static member ilStaticMethodIsNotLambda : a0:System.String -> int * string
      static member
        ilStructLayoutAttributeCouldNotBeDecoded : unit -> int * string
      static member ilTypeCannotBeUsedForLiteralField : unit -> int * string
      static member ilUndefinedValue : a0:System.String -> int * string
      static member ilUnexpectedGetSetAnnotation : unit -> int * string
      static member ilUnexpectedUnrealizedValue : unit -> int * string
      static member ilreadFileChanged : a0:System.String -> int * string
      static member ilwriteErrorCreatingMdb : unit -> int * string
      static member ilwriteErrorCreatingPdb : a0:System.String -> int * string
      static member
        ilwriteMDBFileNameCannotBeChangedWarning : unit -> int * string
      static member ilwriteMDBMemberMissing : a0:System.String -> int * string
      static member
        ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen : unit ->
                                                                  int * string
      static member
        impImportedAssemblyUsesNotPublicType : a0:System.String -> int * string
      static member
        impInvalidMeasureArgument1 : a0:System.String * a1:System.String ->
                                       int * string
      static member
        impInvalidMeasureArgument2 : a0:System.String -> int * string
      static member
        impInvalidNumberOfGenericArguments : a0:System.String * a1:System.Int32 *
                                             a2:System.Int32 -> int * string
      static member
        impNotEnoughTypeParamsInScopeWhileImporting : unit -> int * string
      static member
        impReferenceToDllRequiredByAssembly : a0:System.String *
                                              a1:System.String *
                                              a2:System.String -> int * string
      static member
        impReferencedTypeCouldNotBeFoundInAssembly : a0:System.String *
                                                     a1:System.String ->
                                                       int * string
      static member
        impTypeRequiredUnavailable : a0:System.String * a1:System.String ->
                                       int * string
      static member
        implicitlyDiscardedInSequenceExpression : a0:System.String ->
                                                    int * string
      static member
        implicitlyDiscardedSequenceInSequenceExpression : a0:System.String ->
                                                            int * string
      static member
        infosInvalidProvidedLiteralValue : a0:System.String -> int * string
      static member invalidFullNameForProvidedType : unit -> string
      static member invalidNamespaceForProvidedType : unit -> string
      static member invalidPlatformTarget : unit -> int * string
      static member
        itemNotFoundDuringDynamicCodeGen : a0:System.String * a1:System.String *
                                           a2:System.String -> int * string
      static member
        itemNotFoundInTypeDuringDynamicCodeGen : a0:System.String *
                                                 a1:System.String *
                                                 a2:System.String *
                                                 a3:System.String ->
                                                   int * string
      static member keywordDescriptionAbstract : unit -> string
      static member keywordDescriptionAs : unit -> string
      static member keywordDescriptionAssert : unit -> string
      static member keywordDescriptionBase : unit -> string
      static member keywordDescriptionBegin : unit -> string
      static member keywordDescriptionCast : unit -> string
      static member keywordDescriptionClass : unit -> string
      static member keywordDescriptionConst : unit -> string
      static member keywordDescriptionDefault : unit -> string
      static member keywordDescriptionDelegate : unit -> string
      static member keywordDescriptionDo : unit -> string
      static member keywordDescriptionDone : unit -> string
      static member keywordDescriptionDowncast : unit -> string
      static member keywordDescriptionDownto : unit -> string
      static member keywordDescriptionDynamicCast : unit -> string
      static member keywordDescriptionElif : unit -> string
      static member keywordDescriptionElse : unit -> string
      static member keywordDescriptionEnd : unit -> string
      static member keywordDescriptionException : unit -> string
      static member keywordDescriptionExtern : unit -> string
      static member keywordDescriptionFinally : unit -> string
      static member keywordDescriptionFor : unit -> string
      static member keywordDescriptionFun : unit -> string
      static member keywordDescriptionFunction : unit -> string
      static member keywordDescriptionGlobal : unit -> string
      static member keywordDescriptionIf : unit -> string
      static member keywordDescriptionIn : unit -> string
      static member keywordDescriptionInherit : unit -> string
      static member keywordDescriptionInline : unit -> string
      static member keywordDescriptionInterface : unit -> string
      static member keywordDescriptionInternal : unit -> string
      static member keywordDescriptionLazy : unit -> string
      static member keywordDescriptionLeftArrow : unit -> string
      static member keywordDescriptionLet : unit -> string
      static member keywordDescriptionLetBang : unit -> string
      static member keywordDescriptionMatch : unit -> string
      static member keywordDescriptionMatchBang : unit -> string
      static member keywordDescriptionMember : unit -> string
      static member keywordDescriptionModule : unit -> string
      static member keywordDescriptionMutable : unit -> string
      static member keywordDescriptionNamespace : unit -> string
      static member keywordDescriptionNew : unit -> string
      static member keywordDescriptionNot : unit -> string
      static member keywordDescriptionNull : unit -> string
      static member keywordDescriptionOf : unit -> string
      static member keywordDescriptionOpen : unit -> string
      static member keywordDescriptionOr : unit -> string
      static member keywordDescriptionOverride : unit -> string
      static member keywordDescriptionPrivate : unit -> string
      static member keywordDescriptionPublic : unit -> string
      static member keywordDescriptionRec : unit -> string
      static member keywordDescriptionReturn : unit -> string
      static member keywordDescriptionReturnBang : unit -> string
      static member keywordDescriptionRightArrow : unit -> string
      static member keywordDescriptionSelect : unit -> string
      static member keywordDescriptionStatic : unit -> string
      static member keywordDescriptionStruct : unit -> string
      static member keywordDescriptionThen : unit -> string
      static member keywordDescriptionTo : unit -> string
      static member keywordDescriptionTrueFalse : unit -> string
      static member keywordDescriptionTry : unit -> string
      static member keywordDescriptionType : unit -> string
      static member keywordDescriptionTypedQuotation : unit -> string
      static member keywordDescriptionUntypedQuotation : unit -> string
      static member keywordDescriptionUpcast : unit -> string
      static member keywordDescriptionUse : unit -> string
      static member keywordDescriptionUseBang : unit -> string
      static member keywordDescriptionVal : unit -> string
      static member keywordDescriptionVoid : unit -> string
      static member keywordDescriptionWhen : unit -> string
      static member keywordDescriptionWhile : unit -> string
      static member keywordDescriptionWith : unit -> string
      static member keywordDescriptionYield : unit -> string
      static member keywordDescriptionYieldBang : unit -> string
      static member keyworkDescriptionAnd : unit -> string
      static member lexByteArrayCannotEncode : unit -> int * string
      static member lexByteStringMayNotBeInterpolated : unit -> int * string
      static member
        lexCharNotAllowedInOperatorNames : a0:System.String -> string
      static member lexHashBangMustBeFirstInFile : unit -> string
      static member lexHashElseMustBeFirst : unit -> int * string
      static member lexHashElseNoMatchingIf : unit -> string
      static member lexHashEndifMustBeFirst : unit -> int * string
      static member lexHashEndifRequiredForElse : unit -> string
      static member lexHashEndingNoMatchingIf : unit -> string
      static member lexHashIfMustBeFirst : unit -> int * string
      static member lexHashIfMustHaveIdent : unit -> int * string
      static member lexIdentEndInMarkReserved : a0:System.String -> int * string
      static member lexIndentOffForML : unit -> string
      static member lexInvalidByteLiteral : unit -> int * string
      static member lexInvalidCharLiteral : unit -> int * string
      static member lexInvalidFloat : unit -> int * string
      static member lexInvalidLineNumber : a0:System.String -> int * string
      static member lexInvalidNumericLiteral : unit -> int * string
      static member lexInvalidUnicodeLiteral : a0:System.String -> int * string
      static member lexOusideDecimal : unit -> int * string
      static member lexOusideThirtyTwoBitFloat : unit -> int * string
      static member lexOutsideEightBitSigned : unit -> int * string
      static member lexOutsideEightBitSignedHex : unit -> int * string
      static member lexOutsideEightBitUnsigned : unit -> int * string
      static member lexOutsideIntegerRange : unit -> int * string
      static member lexOutsideNativeSigned : unit -> int * string
      static member lexOutsideNativeUnsigned : unit -> int * string
      static member lexOutsideSixteenBitSigned : unit -> int * string
      static member lexOutsideSixteenBitUnsigned : unit -> int * string
      static member lexOutsideSixtyFourBitSigned : unit -> int * string
      static member lexOutsideSixtyFourBitUnsigned : unit -> int * string
      static member lexOutsideThirtyTwoBitSigned : unit -> int * string
      static member lexOutsideThirtyTwoBitUnsigned : unit -> int * string
      static member lexRBraceInInterpolatedString : unit -> int * string
      static member lexSingleQuoteInSingleQuote : unit -> int * string
      static member lexTabsNotAllowed : unit -> int * string
      static member lexThisUnicodeOnlyInStringLiterals : unit -> int * string
      static member lexTokenReserved : unit -> int * string
      static member lexTripleQuoteInTripleQuote : unit -> int * string
      static member lexUnexpectedChar : a0:System.String -> string
      static member lexWrongNestedHashEndif : unit -> int * string
      static member lexfltIncorrentIndentationOfIn : unit -> string
      static member
        lexfltSeparatorTokensOfPatternMatchMisaligned : unit -> string
      static member
        lexfltTokenIsOffsideOfContextStartedEarlier : a0:System.String -> string
      static member lexhlpIdentifierReserved : a0:System.String -> string
      static member
        lexhlpIdentifiersContainingAtSymbolReserved : unit -> int * string
      static member
        listElementHasWrongType : a0:System.String * a1:System.String -> string
      static member loadingDescription : unit -> string
      static member
        memberOperatorDefinitionWithCurriedArguments : a0:System.String ->
                                                         int * string
      static member
        memberOperatorDefinitionWithNoArguments : a0:System.String ->
                                                    int * string
      static member
        memberOperatorDefinitionWithNonPairArgument : a0:System.String *
                                                      a1:System.Int32 ->
                                                        int * string
      static member
        memberOperatorDefinitionWithNonTripleArgument : a0:System.String *
                                                        a1:System.Int32 ->
                                                          int * string
      static member methodIsNotStatic : a0:System.String -> int * string
      static member missingElseBranch : a0:System.String -> string
      static member mlCompatMessage : a0:System.String -> string
      static member moreThanOneInvokeMethodFound : unit -> string
      static member nativeResourceFormatError : unit -> string
      static member nativeResourceHeaderMalformed : a0:System.String -> string
      static member nicePrintOtherOverloads1 : unit -> string
      static member nicePrintOtherOverloadsN : a0:System.Int32 -> string
      static member noEqualSignAfterModule : unit -> int * string
      static member noInvokeMethodsFound : unit -> int * string
      static member notAFunction : unit -> string
      static member notAFunctionButMaybeDeclaration : unit -> string
      static member notAFunctionButMaybeIndexer : unit -> string
      static member notAFunctionButMaybeIndexerErrorCode : unit -> int * string
      static member
        notAFunctionButMaybeIndexerWithName : a0:System.String -> string
      static member nrGlobalUsedOnlyAsFirstName : unit -> int * string
      static member nrInvalidExpression : a0:System.String -> int * string
      static member nrInvalidFieldLabel : unit -> int * string
      static member nrInvalidModuleExprType : unit -> int * string
      static member nrIsNotConstructorOrLiteral : unit -> int * string
      static member
        nrNoConstructorsAvailableForType : a0:System.String -> int * string
      static member
        nrRecordDoesNotContainSuchLabel : a0:System.String * a1:System.String ->
                                            int * string
      static member
        nrRecordTypeNeedsQualifiedAccess : a0:System.String * a1:System.String ->
                                             int * string
      static member
        nrTypeInstantiationIsMissingAndCouldNotBeInferred : a0:System.String *
                                                            a1:System.String ->
                                                              int * string
      static member
        nrTypeInstantiationNeededToDisambiguateTypesWithSameName : a0:System.String *
                                                                   a1:System.String ->
                                                                     int *
                                                                     string
      static member nrUnexpectedEmptyLongId : unit -> int * string
      static member
        nrUnionTypeNeedsQualifiedAccess : a0:System.String * a1:System.String ->
                                            int * string
      static member optFailedToInlineValue : a0:System.String -> int * string
      static member
        optLocalValueNotFoundDuringOptimization : a0:System.String ->
                                                    int * string
      static member optRecursiveValValue : a0:System.String -> int * string
      static member
        optValueMarkedInlineButIncomplete : a0:System.String -> int * string
      static member
        optValueMarkedInlineButWasNotBoundInTheOptEnv : a0:System.String ->
                                                          int * string
      static member optValueMarkedInlineCouldNotBeInlined : unit -> int * string
      static member
        optValueMarkedInlineHasUnexpectedValue : unit -> int * string
      static member optsBaseaddress : unit -> string
      static member optsBuildConsole : unit -> string
      static member optsBuildLibrary : unit -> string
      static member optsBuildModule : unit -> string
      static member optsBuildWindows : unit -> string
      static member optsChecked : unit -> string
      static member optsChecksumAlgorithm : unit -> string
      static member optsClirootDeprecatedMsg : unit -> string
      static member optsClirootDescription : unit -> string
      static member optsCodepage : unit -> string
      static member optsCompilerTool : unit -> string
      static member optsConsoleColors : unit -> string
      static member optsCopyright : unit -> string
      static member optsCopyrightCommunity : unit -> string
      static member optsCrossoptimize : unit -> string
      static member
        optsDCLODeprecatedSuggestAlternative : a0:System.String *
                                               a1:System.String -> string
      static member optsDCLOHtmlDoc : a0:System.String -> string
      static member optsDCLONoDescription : a0:System.String -> string
      static member optsDebug : a0:System.String -> string
      static member optsDebugPM : unit -> string
      static member optsDefine : unit -> string
      static member optsDelaySign : unit -> string
      static member optsDeterministic : unit -> string
      static member optsEmbedAllSource : unit -> string
      static member optsEmbedSource : unit -> string
      static member optsEmbeddedSourceRequirePortablePDBs : unit -> int * string
      static member optsEmitDebugInfoInQuotations : unit -> string
      static member optsFullpaths : unit -> string
      static member optsHelp : unit -> string
      static member optsHelpBannerAdvanced : unit -> string
      static member optsHelpBannerCodeGen : unit -> string
      static member optsHelpBannerErrsAndWarns : unit -> string
      static member optsHelpBannerInputFiles : unit -> string
      static member optsHelpBannerLanguage : unit -> string
      static member optsHelpBannerMisc : unit -> string
      static member optsHelpBannerOutputFiles : unit -> string
      static member optsHelpBannerResources : unit -> string
      static member optsInternalNoDescription : a0:System.String -> string
      static member optsInvalidPathMapFormat : unit -> int * string
      static member
        optsInvalidResponseFile : a0:System.String * a1:System.String ->
                                    int * string
      static member
        optsInvalidSubSystemVersion : a0:System.String -> int * string
      static member optsInvalidTargetProfile : a0:System.String -> int * string
      static member optsInvalidWarningLevel : a0:System.Int32 -> int * string
      static member optsLangVersion : unit -> string
      static member optsLib : unit -> string
      static member optsLinkresource : unit -> string
      static member optsMlcompatibility : unit -> string
      static member optsNameOfOutputFile : unit -> string
      static member optsNoCopyFsharpCore : unit -> string
      static member optsNoInterface : unit -> string
      static member optsNoOpt : unit -> string
      static member optsNoframework : unit -> string
      static member optsNologo : unit -> string
      static member optsNowarn : unit -> string
      static member optsNowin32manifest : unit -> string
      static member optsOptimize : unit -> string
      static member optsPathMap : unit -> string
      static member optsPdb : unit -> string
      static member optsPlatform : unit -> string
      static member optsPreferredUiLang : unit -> string
      static member
        optsProblemWithCodepage : a0:System.Int32 * a1:System.String ->
                                    int * string
      static member optsPublicSign : unit -> string
      static member optsReference : unit -> string
      static member optsResident : unit -> string
      static member optsResource : unit -> string
      static member optsResponseFile : unit -> string
      static member
        optsResponseFileNameInvalid : a0:System.String -> int * string
      static member
        optsResponseFileNotFound : a0:System.String * a1:System.String ->
                                     int * string
      static member optsShortFormOf : a0:System.String -> string
      static member optsSig : unit -> string
      static member optsSimpleresolution : unit -> string
      static member optsSourceLink : unit -> string
      static member optsSourceLinkRequirePortablePDBs : unit -> int * string
      static member optsStandalone : unit -> string
      static member optsStaticlink : unit -> string
      static member optsStrongKeyContainer : unit -> string
      static member optsStrongKeyFile : unit -> string
      static member optsSubSystemVersion : unit -> string
      static member optsSupportedLangVersions : unit -> string
      static member optsTailcalls : unit -> string
      static member optsTargetProfile : unit -> string
      static member
        optsUnknownArgumentToTheTestSwitch : a0:System.String -> int * string
      static member
        optsUnknownChecksumAlgorithm : a0:System.String -> int * string
      static member optsUnknownPlatform : a0:System.String -> int * string
      static member optsUnrecognizedDebugType : a0:System.String -> int * string
      static member
        optsUnrecognizedLanguageVersion : a0:System.String -> int * string
      static member optsUnrecognizedTarget : a0:System.String -> int * string
      static member optsUseHighEntropyVA : unit -> string
      static member optsUtf8output : unit -> string
      static member optsVersion : unit -> string
      static member optsWarn : unit -> string
      static member optsWarnOn : unit -> string
      static member optsWarnaserror : unit -> string
      static member optsWarnaserrorPM : unit -> string
      static member optsWin32manifest : unit -> string
      static member optsWin32res : unit -> string
      static member optsWriteXml : unit -> string
      static member packageManagementRequiresVFive : unit -> int * string
      static member packageManagerError : a0:System.String -> int * string
      static member
        packageManagerUnknown : a0:System.String * a1:System.String *
                                a2:System.String -> int * string
      static member
        parsAccessibilityModsIllegalForAbstract : unit -> int * string
      static member parsActivePatternCaseContainsPipe : unit -> int * string
      static member
        parsActivePatternCaseMustBeginWithUpperCase : unit -> int * string
      static member parsAllEnumFieldsRequireValues : unit -> int * string
      static member parsArrowUseIsLimited : unit -> int * string
      static member parsAssertIsNotFirstClassValue : unit -> int * string
      static member parsAttributeOnIncompleteCode : unit -> int * string
      static member
        parsAttributesAreNotPermittedOnInterfaceImplementations : unit ->
                                                                    int * string
      static member parsAttributesIgnored : unit -> int * string
      static member parsAttributesIllegalHere : unit -> int * string
      static member parsAttributesIllegalOnInherit : unit -> int * string
      static member parsAttributesMustComeBeforeVal : unit -> string
      static member
        parsAugmentationsIllegalOnDelegateType : unit -> int * string
      static member parsConsiderUsingSeparateRecordType : unit -> string
      static member
        parsDoCannotHaveVisibilityDeclarations : a0:System.String ->
                                                   int * string
      static member parsEmptyFillInInterpolatedString : unit -> int * string
      static member parsEmptyTypeDefinition : unit -> int * string
      static member
        parsEnumFieldsCannotHaveVisibilityDeclarations : unit -> int * string
      static member
        parsEnumTypesCannotHaveVisibilityDeclarations : unit -> int * string
      static member parsEofInComment : unit -> int * string
      static member parsEofInDirective : unit -> int * string
      static member parsEofInHashIf : unit -> int * string
      static member parsEofInIfOcaml : unit -> int * string
      static member parsEofInInterpolatedString : unit -> int * string
      static member parsEofInInterpolatedStringFill : unit -> int * string
      static member
        parsEofInInterpolatedTripleQuoteString : unit -> int * string
      static member parsEofInInterpolatedVerbatimString : unit -> int * string
      static member parsEofInString : unit -> int * string
      static member parsEofInStringInComment : unit -> int * string
      static member parsEofInTripleQuoteString : unit -> int * string
      static member parsEofInTripleQuoteStringInComment : unit -> int * string
      static member parsEofInVerbatimString : unit -> int * string
      static member parsEofInVerbatimStringInComment : unit -> int * string
      static member
        parsEqualsMissingInTypeDefinition : a0:System.String -> int * string
      static member
        parsErrorInReturnForLetIncorrectIndentation : unit -> int * string
      static member parsErrorParsingAsOperatorName : unit -> int * string
      static member
        parsExpectedExpressionAfterLet : a0:System.String * a1:System.String ->
                                           int * string
      static member parsExpectedExpressionAfterToken : unit -> int * string
      static member parsExpectedNameAfterToken : unit -> int * string
      static member parsExpectedTypeAfterToken : unit -> int * string
      static member parsFieldBinding : unit -> int * string
      static member parsForDoExpected : unit -> int * string
      static member parsGetAndOrSetRequired : unit -> int * string
      static member parsGetOrSetRequired : unit -> int * string
      static member parsGetterAtMostOneArgument : unit -> int * string
      static member parsGetterMustHaveAtLeastOneArgument : unit -> int * string
      static member parsIdentifierExpected : unit -> int * string
      static member
        parsIgnoreAttributesOnModuleAbbreviation : unit -> int * string
      static member
        parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate : a0:System.String ->
                                                                  int * string
      static member
        parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate : a0:System.String ->
                                                                  int * string
      static member
        parsIllegalDenominatorForMeasureExponent : unit -> int * string
      static member
        parsIllegalMemberVarInObjectImplementation : unit -> int * string
      static member parsInOrEqualExpected : unit -> int * string
      static member parsIncompleteIf : unit -> int * string
      static member
        parsIndexerPropertyRequiresAtLeastOneArgument : unit -> int * string
      static member
        parsInheritDeclarationsCannotHaveAsBindings : unit -> int * string
      static member
        parsInlineAssemblyCannotHaveVisibilityDeclarations : unit ->
                                                               int * string
      static member
        parsIntegerForLoopRequiresSimpleIdentifier : unit -> int * string
      static member
        parsInterfacesHaveSameVisibilityAsEnclosingType : unit -> int * string
      static member parsInvalidAnonRecdExpr : unit -> int * string
      static member parsInvalidAnonRecdType : unit -> int * string
      static member parsInvalidDeclarationSyntax : unit -> int * string
      static member parsInvalidLiteralInType : unit -> int * string
      static member parsInvalidPrefixOperator : unit -> int * string
      static member parsInvalidPrefixOperatorDefinition : unit -> int * string
      static member parsInvalidProperty : unit -> int * string
      static member parsInvalidUseOfRec : unit -> int * string
      static member parsLetAndForNonRecBindings : unit -> int * string
      static member
        parsMemberIllegalInObjectImplementation : unit -> int * string
      static member
        parsMismatchedQuotationName : a0:System.String -> int * string
      static member parsMismatchedQuote : a0:System.String -> int * string
      static member parsMissingFunctionBody : unit -> int * string
      static member parsMissingGreaterThan : unit -> int * string
      static member parsMissingQualificationAfterDot : unit -> int * string
      static member parsMissingTypeArgs : unit -> int * string
      static member
        parsModuleAbbreviationMustBeSimpleName : unit -> int * string
      static member parsModuleDefnMustBeSimpleName : unit -> int * string
      static member parsMultiArgumentGenericTypeFormDeprecated : unit -> string
      static member parsMultipleAccessibilitiesForGetSet : unit -> int * string
      static member
        parsMutableOnAutoPropertyShouldBeGetSet : unit -> int * string
      static member
        parsMutableOnAutoPropertyShouldBeGetSetNotJustSet : unit -> int * string
      static member parsNamespaceOrModuleNotBoth : unit -> int * string
      static member parsNoEqualShouldFollowNamespace : unit -> string
      static member parsNoHashEndIfFound : unit -> int * string
      static member parsNoMatchingInForLet : unit -> int * string
      static member parsNonAdjacentTyargs : unit -> int * string
      static member parsNonAdjacentTypars : unit -> int * string
      static member parsNonAtomicType : unit -> string
      static member parsOnlyClassCanTakeValueArguments : unit -> int * string
      static member parsOnlyHashDirectivesAllowed : unit -> int * string
      static member parsOnlyOneWithAugmentationAllowed : unit -> int * string
      static member parsParenFormIsForML : unit -> string
      static member
        parsRecordFieldsCannotHaveVisibilityDeclarations : unit -> int * string
      static member parsSetSyntax : unit -> int * string
      static member parsSetterAtMostTwoArguments : unit -> int * string
      static member
        parsSuccessiveArgsShouldBeSpacedOrTupled : unit -> int * string
      static member
        parsSuccessivePatternsShouldBeSpacedOrTupled : unit -> int * string
      static member parsSyntaxError : unit -> int * string
      static member parsSyntaxErrorInLabeledType : unit -> int * string
      static member parsSyntaxModuleSigEndDeprecated : unit -> string
      static member parsSyntaxModuleStructEndDeprecated : unit -> string
      static member
        parsTypeAbbreviationsCannotHaveVisibilityDeclarations : unit ->
                                                                  int * string
      static member parsTypeAnnotationsOnGetSet : unit -> int * string
      static member parsTypeNameCannotBeEmpty : unit -> int * string
      static member parsUnClosedBlockInHashLight : unit -> int * string
      static member parsUnderscoreInvalidFieldName : unit -> int * string
      static member parsUnexpectedEmptyModuleDefn : unit -> int * string
      static member parsUnexpectedEndOfFile : unit -> int * string
      static member parsUnexpectedEndOfFileDefinition : unit -> int * string
      static member parsUnexpectedEndOfFileElse : unit -> int * string
      static member parsUnexpectedEndOfFileExpression : unit -> int * string
      static member parsUnexpectedEndOfFileFor : unit -> int * string
      static member parsUnexpectedEndOfFileFunBody : unit -> int * string
      static member parsUnexpectedEndOfFileMatch : unit -> int * string
      static member parsUnexpectedEndOfFileObjectMembers : unit -> int * string
      static member parsUnexpectedEndOfFileThen : unit -> int * string
      static member parsUnexpectedEndOfFileTry : unit -> int * string
      static member parsUnexpectedEndOfFileTypeArgs : unit -> int * string
      static member parsUnexpectedEndOfFileTypeDefinition : unit -> int * string
      static member parsUnexpectedEndOfFileTypeSignature : unit -> int * string
      static member parsUnexpectedEndOfFileWhile : unit -> int * string
      static member parsUnexpectedEndOfFileWith : unit -> int * string
      static member parsUnexpectedIdentifier : a0:System.String -> int * string
      static member parsUnexpectedInfixOperator : unit -> int * string
      static member
        parsUnexpectedIntegerLiteralForUnitOfMeasure : unit -> int * string
      static member
        parsUnexpectedOperatorForUnitOfMeasure : unit -> int * string
      static member
        parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString : unit ->
                                                                               int *
                                                                               string
      static member parsUnexpectedSemicolon : unit -> int * string
      static member parsUnexpectedSymbolDot : unit -> int * string
      static member parsUnexpectedSymbolEqualsInsteadOfIn : unit -> int * string
      static member parsUnexpectedTypeParameter : unit -> int * string
      static member
        parsUnexpectedVisibilityDeclaration : a0:System.String -> int * string
      static member parsUnfinishedExpression : a0:System.String -> int * string
      static member
        parsUnionCasesCannotHaveVisibilityDeclarations : unit -> int * string
      static member parsUnmatched : a0:System.String -> int * string
      static member parsUnmatchedBegin : unit -> int * string
      static member parsUnmatchedBeginOrStruct : unit -> int * string
      static member parsUnmatchedBrace : unit -> int * string
      static member parsUnmatchedBraceBar : unit -> int * string
      static member parsUnmatchedBracket : unit -> int * string
      static member parsUnmatchedBracketBar : unit -> int * string
      static member parsUnmatchedClassInterfaceOrStruct : unit -> int * string
      static member parsUnmatchedLBrackLess : unit -> int * string
      static member parsUnmatchedLet : unit -> int * string
      static member parsUnmatchedLetBang : unit -> int * string
      static member parsUnmatchedParen : unit -> int * string
      static member parsUnmatchedUse : unit -> int * string
      static member parsUnmatchedUseBang : unit -> int * string
      static member parsUnmatchedWith : unit -> int * string
      static member
        parsUseBindingsIllegalInImplicitClassConstructors : unit -> int * string
      static member parsUseBindingsIllegalInModules : unit -> int * string
      static member
        parsVisibilityDeclarationsShouldComePriorToIdentifier : unit ->
                                                                  int * string
      static member parsVisibilityIllegalOnInherit : unit -> int * string
      static member parsWhileDoExpected : unit -> int * string
      static member patcMissingVariable : a0:System.String -> int * string
      static member
        patcPartialActivePatternsGenerateOneResult : unit -> int * string
      static member pathIsInvalid : a0:System.String -> int * string
      static member patternMatchGuardIsNotBool : a0:System.String -> string
      static member
        pickleErrorReadingWritingMetadata : a0:System.String * a1:System.String ->
                                              string
      static member
        pickleMissingDefinition : a0:System.Int32 * a1:System.String *
                                  a2:System.String -> int * string
      static member pickleUnexpectedNonZero : a0:System.String -> int * string
      static member
        poundiNotSupportedByRegisteredDependencyManagers : unit -> int * string
      static member pplexExpectedSingleLineComment : unit -> int * string
      static member pplexUnexpectedChar : a0:System.String -> int * string
      static member ppparsIncompleteExpression : unit -> int * string
      static member ppparsMissingToken : a0:System.String -> int * string
      static member ppparsUnexpectedToken : a0:System.String -> int * string
      static member
        readOnlyAttributeOnStructWithMutableField : unit -> int * string
      static member recursiveClassHierarchy : a0:System.String -> int * string
      static member replaceWithSuggestion : a0:System.String -> string
      static member returnUsedInsteadOfReturnBang : unit -> string
      static member srcFileTooLarge : unit -> string
      static member
        structOrClassFieldIsNotAccessible : a0:System.String -> int * string
      static member tastActivePatternsLimitedToSeven : unit -> int * string
      static member tastCantTakeAddressOfExpression : unit -> int * string
      static member
        tastConflictingModuleAndTypeDefinitionInAssembly : a0:System.String *
                                                           a1:System.String ->
                                                             int * string
      static member tastConstantExpressionOverflow : unit -> int * string
      static member
        tastDuplicateTypeDefinitionInAssembly : a0:System.String *
                                                a1:System.String -> int * string
      static member
        tastInvalidAddressOfMutableAcrossAssemblyBoundary : unit -> int * string
      static member tastInvalidFormForPropertyGetter : unit -> int * string
      static member tastInvalidFormForPropertySetter : unit -> int * string
      static member tastInvalidMemberSignature : unit -> int * string
      static member tastInvalidMutationOfConstant : unit -> int * string
      static member
        tastNamespaceAndModuleWithSameNameInAssembly : a0:System.String ->
                                                         int * string
      static member tastNotAConstantExpression : unit -> int * string
      static member
        tastRecursiveValuesMayNotAppearInConstructionOfType : a0:System.String ->
                                                                int * string
      static member
        tastRecursiveValuesMayNotBeAssignedToNonMutableField : a0:System.String *
                                                               a1:System.String ->
                                                                 int * string
      static member
        tastRecursiveValuesMayNotBeInConstructionOfTuple : unit -> int * string
      static member
        tastTwoModulesWithSameNameInAssembly : a0:System.String -> int * string
      static member
        tastTypeHasAssemblyCodeRepresentation : a0:System.String -> string
      static member
        tastTypeOrModuleNotConcrete : a0:System.String -> int * string
      static member
        tastUndefinedItemRefModuleNamespace : a0:System.String *
                                              a1:System.String *
                                              a2:System.String -> int * string
      static member
        tastUndefinedItemRefModuleNamespaceType : a0:System.String *
                                                  a1:System.String *
                                                  a2:System.String ->
                                                    int * string
      static member
        tastUndefinedItemRefVal : a0:System.String * a1:System.String *
                                  a2:System.String -> int * string
      static member tastUnexpectedByRef : unit -> int * string
      static member tastUnexpectedDecodeOfAutoOpenAttribute : unit -> string
      static member
        tastUnexpectedDecodeOfInterfaceDataVersionAttribute : unit -> string
      static member
        tastUnexpectedDecodeOfInternalsVisibleToAttribute : unit -> string
      static member tastValueDoesNotHaveSetterType : unit -> int * string
      static member tastValueHasBeenCopied : unit -> string
      static member tastValueMustBeLocal : unit -> int * string
      static member tastValueMustBeMutable : unit -> int * string
      static member tastopsMaxArrayThirtyTwo : a0:System.Int32 -> int * string
      static member tcAbbreviatedTypesCannotBeSealed : unit -> int * string
      static member
        tcAbbreviationsFordotNetExceptionsCannotTakeArguments : unit ->
                                                                  int * string
      static member
        tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor : unit ->
                                                                                int *
                                                                                string
      static member
        tcAbstractMembersIllegalInAugmentation : unit -> int * string
      static member
        tcAbstractPropertyMissingGetOrSet : a0:System.String -> int * string
      static member tcAbstractTypeCannotBeInstantiated : unit -> int * string
      static member tcActivePatternsDoNotHaveFields : unit -> int * string
      static member
        tcAllImplementedInterfacesShouldBeDeclared : unit -> int * string
      static member
        tcAllowNullTypesMayOnlyInheritFromAllowNullTypes : unit -> int * string
      static member tcAndBangNotSupported : unit -> int * string
      static member
        tcAnonRecdCcuMismatch : a0:System.String * a1:System.String -> string
      static member tcAnonRecdFieldNameDifferent : a0:System.String -> string
      static member
        tcAnonRecdFieldNameMismatch : a0:System.String * a1:System.String ->
                                        string
      static member tcAnonRecdFieldNameSubset : a0:System.String -> string
      static member tcAnonRecdFieldNameSuperset : a0:System.String -> string
      static member tcAnonRecdInvalid : unit -> string
      static member tcAnonymousTypeInvalidInDeclaration : unit -> int * string
      static member
        tcAnonymousUnitsOfMeasureCannotBeNested : unit -> int * string
      static member
        tcArgumentArityMismatch : a0:System.String * a1:System.Int32 *
                                  a2:System.Int32 * a3:System.String *
                                  a4:System.String -> int * string
      static member
        tcArgumentArityMismatchOneOverload : a0:System.String * a1:System.Int32 *
                                             a2:System.Int32 * a3:System.String *
                                             a4:System.String -> int * string
      static member tcAtLeastOneOverrideIsInvalid : unit -> int * string
      static member tcAttribArgsDiffer : a0:System.String -> int * string
      static member
        tcAttributeAutoOpenWasIgnored : a0:System.String * a1:System.String ->
                                          int * string
      static member
        tcAttributeExpressionsMustBeConstructorCalls : unit -> int * string
      static member
        tcAttributeIsNotValidForLanguageElement : unit -> int * string
      static member
        tcAttributeIsNotValidForLanguageElementUseDo : unit -> int * string
      static member
        tcAttributesAreNotPermittedOnLetBindings : unit -> int * string
      static member tcAttributesInvalidInPatterns : unit -> int * string
      static member
        tcAttributesOfTypeSpecifyMultipleKindsForType : unit -> int * string
      static member tcAugmentationsCannotHaveAttributes : unit -> int * string
      static member
        tcAutoPropertyRequiresImplicitConstructionSequence : unit ->
                                                               int * string
      static member
        tcBinaryOperatorRequiresBody : a0:System.String * a1:System.String ->
                                         int * string
      static member
        tcBinaryOperatorRequiresVariable : a0:System.String * a1:System.String ->
                                             int * string
      static member tcBindMayNotBeUsedInQueries : unit -> int * string
      static member tcBindingCannotBeUseAndRec : unit -> int * string
      static member tcByRefLikeNotStruct : unit -> int * string
      static member tcByrefReturnImplicitlyDereferenced : unit -> int * string
      static member tcByrefsMayNotHaveTypeExtensions : unit -> int * string
      static member tcCallerInfoNotOptional : a0:System.String -> int * string
      static member
        tcCallerInfoWrongType : a0:System.String * a1:System.String *
                                a2:System.String -> int * string
      static member
        tcCannotCallAbstractBaseMember : a0:System.String -> int * string
      static member
        tcCannotCallExtensionMethodInrefToByref : a0:System.String ->
                                                    int * string
      static member tcCannotCreateExtensionOfSealedType : unit -> int * string
      static member tcCannotInheritFromErasedType : unit -> int * string
      static member tcCannotInheritFromInterfaceType : unit -> int * string
      static member tcCannotInheritFromSealedType : unit -> int * string
      static member tcCannotInheritFromVariableType : unit -> int * string
      static member
        tcCannotOverrideSealedMethod : a0:System.String -> int * string
      static member
        tcCannotPartiallyApplyExtensionMethodForByref : a0:System.String ->
                                                          int * string
      static member tcCompiledNameAttributeMisused : unit -> int * string
      static member tcConcreteMembersIllegalInInterface : unit -> int * string
      static member tcConditionalAttributeRequiresMembers : unit -> int * string
      static member tcConditionalAttributeUsage : unit -> int * string
      static member
        tcConstrainedTypeVariableCannotBeGeneralized : unit -> int * string
      static member
        tcConstructIsAmbiguousInComputationExpression : unit -> int * string
      static member
        tcConstructIsAmbiguousInSequenceExpression : unit -> int * string
      static member
        tcConstructRequiresComputationExpression : unit -> int * string
      static member
        tcConstructRequiresComputationExpressions : unit -> int * string
      static member
        tcConstructRequiresListArrayOrSequence : unit -> int * string
      static member
        tcConstructRequiresSequenceOrComputations : unit -> int * string
      static member tcConstructorCannotHaveTypeParameters : unit -> int * string
      static member
        tcConstructorDoesNotHaveFieldWithGivenName : a0:System.String ->
                                                       int * string
      static member
        tcConstructorForInterfacesDoNotTakeArguments : unit -> int * string
      static member tcConstructorRequiresArguments : unit -> int * string
      static member tcConstructorRequiresCall : a0:System.String -> int * string
      static member
        tcConstructorsCannotBeFirstClassValues : unit -> int * string
      static member
        tcConstructorsDisallowedInExceptionAugmentation : unit -> int * string
      static member tcConstructorsIllegalForThisType : unit -> int * string
      static member tcConstructorsIllegalInAugmentation : unit -> int * string
      static member tcCopyAndUpdateNeedsRecordType : unit -> int * string
      static member tcCouldNotFindIDisposable : unit -> string
      static member tcCouldNotFindOffsetToStringData : unit -> int * string
      static member tcCustomAttributeArgumentMismatch : unit -> int * string
      static member tcCustomAttributeMustBeReferenceType : unit -> int * string
      static member
        tcCustomAttributeMustInvokeConstructor : unit -> int * string
      static member
        tcCustomOperationHasIncorrectArgCount : a0:System.String *
                                                a1:System.Int32 *
                                                a2:System.Int32 -> int * string
      static member tcCustomOperationInvalid : a0:System.String -> int * string
      static member
        tcCustomOperationMayNotBeOverloaded : a0:System.String -> int * string
      static member tcCustomOperationMayNotBeUsedHere : unit -> int * string
      static member
        tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings : unit ->
                                                                               int *
                                                                               string
      static member
        tcCustomOperationNotUsedCorrectly : a0:System.String -> int * string
      static member
        tcCustomOperationNotUsedCorrectly2 : a0:System.String * a1:System.String ->
                                               int * string
      static member
        tcDeclarationElementNotPermittedInAugmentation : unit -> int * string
      static member
        tcDeclaredTypeParametersForExtensionDoNotMatchOriginal : a0:System.String ->
                                                                   int * string
      static member tcDefaultAmbiguous : unit -> int * string
      static member tcDefaultImplementationAlreadyExists : unit -> int * string
      static member
        tcDefaultImplementationForInterfaceHasAlreadyBeenAdded : unit ->
                                                                   int * string
      static member tcDefaultStructConstructorCall : unit -> int * string
      static member tcDefaultValueAttributeRequiresVal : unit -> int * string
      static member tcDelegateConstructorMustBePassed : unit -> int * string
      static member tcDelegatesCannotBeCurried : unit -> int * string
      static member tcDllImportNotAllowed : unit -> int * string
      static member tcDllImportStubsCannotBeInlined : unit -> int * string
      static member tcDoBangIllegalInSequenceExpression : unit -> int * string
      static member
        tcDoesNotAllowExplicitTypeArguments : a0:System.String -> int * string
      static member tcDuplicateSpecOfInterface : unit -> int * string
      static member tcEmptyCopyAndUpdateRecordInvalid : unit -> int * string
      static member tcEmptyRecordInvalid : unit -> int * string
      static member
        tcEntryPointAttributeRequiresFunctionInModule : unit -> int * string
      static member
        tcEnumTypeCannotBeEnumerated : a0:System.String -> int * string
      static member
        tcEnumerationsCannotHaveInterfaceDeclaration : unit -> int * string
      static member tcEnumerationsMayNotHaveMembers : unit -> int * string
      static member tcEventIsNotStatic : a0:System.String -> int * string
      static member tcEventIsStatic : a0:System.String -> int * string
      static member
        tcExceptionAbbreviationsMustReferToValidExceptions : unit ->
                                                               int * string
      static member
        tcExceptionAbbreviationsShouldNotHaveArgumentList : unit -> int * string
      static member
        tcExceptionConstructorDoesNotHaveFieldWithGivenName : a0:System.String *
                                                              a1:System.String ->
                                                                int * string
      static member tcExpectModuleOrNamespaceParent : a0:System.String -> string
      static member tcExpectedInterfaceType : unit -> int * string
      static member tcExpectedTypeNotUnitOfMeasure : unit -> int * string
      static member tcExpectedTypeParameter : unit -> int * string
      static member
        tcExpectedUnitOfMeasureMarkWithAttribute : unit -> int * string
      static member tcExpectedUnitOfMeasureNotType : unit -> int * string
      static member tcExplicitObjectConstructorSyntax : unit -> int * string
      static member tcExplicitStaticInitializerSyntax : unit -> int * string
      static member tcExplicitTypeParameterInvalid : unit -> int * string
      static member
        tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors : unit ->
                                                                            int *
                                                                            string
      static member tcExprUndelayed : unit -> int * string
      static member
        tcExpressionCountMisMatch : a0:System.Int32 * a1:System.Int32 ->
                                      int * string
      static member
        tcExpressionFormRequiresObjectConstructor : unit -> int * string
      static member tcExpressionFormRequiresRecordTypes : unit -> int * string
      static member tcExpressionRequiresSequence : unit -> int * string
      static member tcExpressionWithIfRequiresParenthesis : unit -> string
      static member tcExtraneousFieldsGivenValues : unit -> int * string
      static member tcFSharpCoreRequiresExplicit : unit -> int * string
      static member
        tcFieldAppearsTwiceInRecord : a0:System.String -> int * string
      static member tcFieldIsNotMutable : unit -> int * string
      static member tcFieldIsNotStatic : a0:System.String -> int * string
      static member tcFieldIsReadonly : unit -> int * string
      static member
        tcFieldNameConflictsWithGeneratedNameForAnonymousField : a0:System.String ->
                                                                   int * string
      static member
        tcFieldNameIsUsedModeThanOnce : a0:System.String -> int * string
      static member
        tcFieldNotLiteralCannotBeUsedInPattern : unit -> int * string
      static member
        tcFieldRequiresAssignment : a0:System.String * a1:System.String ->
                                      int * string
      static member tcFieldRequiresName : unit -> int * string
      static member tcFieldValIllegalHere : unit -> int * string
      static member
        tcFieldsDoNotDetermineUniqueRecordType : unit -> int * string
      static member tcFixedNotAllowed : unit -> int * string
      static member tcFormalArgumentIsNotOptional : unit -> int * string
      static member
        tcFunctionRequiresExplicitLambda : a0:System.Int32 -> int * string
      static member
        tcFunctionRequiresExplicitTypeArguments : a0:System.String ->
                                                    int * string
      static member
        tcGeneratedTypesShouldBeInternalOrPrivate : unit -> int * string
      static member
        tcGenericParameterHasBeenConstrained : a0:System.String -> int * string
      static member tcGenericTypesCannotHaveStructLayout : unit -> int * string
      static member tcGlobalsSystemTypeNotFound : a0:System.String -> string
      static member tcIDisposableTypeShouldUseNew : unit -> int * string
      static member tcIfThenElseMayNotBeUsedWithinQueries : unit -> int * string
      static member tcIllegalAttributesForLiteral : unit -> int * string
      static member tcIllegalByrefsInOpenTypeDeclaration : unit -> int * string
      static member
        tcIllegalFormForExplicitTypeDeclaration : unit -> int * string
      static member tcIllegalPattern : unit -> int * string
      static member
        tcIllegalStructTypeForConstantExpression : unit -> int * string
      static member tcIllegalSyntaxInTypeExpression : unit -> int * string
      static member
        tcImplementsGenericIComparableExplicitly : a0:System.String ->
                                                     int * string
      static member
        tcImplementsIComparableExplicitly : a0:System.String -> int * string
      static member
        tcImplementsIEquatableExplicitly : a0:System.String -> int * string
      static member
        tcImplementsIStructuralComparableExplicitly : a0:System.String ->
                                                        int * string
      static member
        tcImplementsIStructuralEquatableExplicitly : a0:System.String ->
                                                       int * string
      static member tcImplicitMeasureFollowingSlash : unit -> int * string
      static member
        tcInferredGenericTypeGivesRiseToInconsistency : a0:System.String *
                                                        a1:System.String ->
                                                          int * string
      static member tcInheritCannotBeUsedOnInterfaceType : unit -> int * string
      static member
        tcInheritConstructionCallNotPartOfImplicitSequence : unit ->
                                                               int * string
      static member tcInheritDeclarationMissingArguments : unit -> int * string
      static member tcInheritIllegalHere : unit -> int * string
      static member tcInheritedTypeIsNotObjectModelType : unit -> int * string
      static member tcInstanceMemberRequiresTarget : unit -> int * string
      static member
        tcInterfaceTypesAndDelegatesCannotContainFields : unit -> int * string
      static member tcInterfaceTypesCannotBeSealed : unit -> int * string
      static member
        tcInterfacesShouldUseInheritNotInterface : unit -> int * string
      static member tcInterpolationMixedWithPercent : unit -> int * string
      static member tcIntoNeedsRestOfQuery : unit -> int * string
      static member tcInvalidActivePatternName : unit -> int * string
      static member
        tcInvalidAlignmentInInterpolatedString : unit -> int * string
      static member tcInvalidArgForParameterizedPattern : unit -> int * string
      static member tcInvalidAssignment : unit -> int * string
      static member tcInvalidConstantExpression : unit -> int * string
      static member tcInvalidConstraint : unit -> int * string
      static member tcInvalidConstraintTypeSealed : unit -> int * string
      static member tcInvalidDeclaration : unit -> int * string
      static member tcInvalidDelegateSpecification : unit -> int * string
      static member tcInvalidEnumConstraint : unit -> int * string
      static member tcInvalidEnumerationLiteral : unit -> int * string
      static member tcInvalidIndexIntoActivePatternArray : unit -> int * string
      static member
        tcInvalidIndexOperatorDefinition : a0:System.String -> string
      static member tcInvalidIndexerExpression : unit -> int * string
      static member tcInvalidInlineSpecification : unit -> int * string
      static member
        tcInvalidMemberName : a0:System.String * a1:System.String -> string
      static member tcInvalidMemberNameCtor : unit -> int * string
      static member tcInvalidMemberNameFixedTypes : a0:System.String -> string
      static member
        tcInvalidMethodNameForEquality : a0:System.String * a1:System.String ->
                                           string
      static member
        tcInvalidMethodNameForRelationalOperator : a0:System.String *
                                                   a1:System.String -> string
      static member tcInvalidMixtureOfRecursiveForms : unit -> int * string
      static member tcInvalidModuleName : unit -> int * string
      static member tcInvalidNamespaceModuleTypeUnionName : unit -> int * string
      static member tcInvalidNewConstraint : unit -> int * string
      static member
        tcInvalidNonPrimitiveLiteralInPatternMatch : unit -> int * string
      static member tcInvalidObjectConstructionExpression : unit -> int * string
      static member tcInvalidObjectExpressionSyntaxForm : unit -> int * string
      static member
        tcInvalidObjectSequenceOrRecordExpression : unit -> int * string
      static member tcInvalidOperatorDefinition : a0:System.String -> string
      static member
        tcInvalidOperatorDefinitionEquality : a0:System.String -> string
      static member
        tcInvalidOperatorDefinitionRelational : a0:System.String -> string
      static member
        tcInvalidOptionalAssignmentToPropertyOrField : unit -> int * string
      static member tcInvalidPattern : unit -> int * string
      static member tcInvalidPropertyType : unit -> int * string
      static member tcInvalidRecordConstruction : unit -> int * string
      static member tcInvalidRelationInJoin : a0:System.String -> int * string
      static member tcInvalidSequenceExpressionSyntaxForm : unit -> int * string
      static member tcInvalidSignatureForSet : unit -> int * string
      static member
        tcInvalidTypeArgumentCount : a0:System.Int32 * a1:System.Int32 ->
                                       int * string
      static member tcInvalidTypeArgumentUsage : unit -> int * string
      static member tcInvalidTypeExtension : unit -> int * string
      static member tcInvalidTypeForLiteralEnumeration : unit -> int * string
      static member tcInvalidTypeForUnitsOfMeasure : unit -> int * string
      static member tcInvalidUnitsOfMeasurePrefix : unit -> int * string
      static member tcInvalidUseBangBinding : unit -> int * string
      static member tcInvalidUseBangBindingNoAndBangs : unit -> int * string
      static member tcInvalidUseBinding : unit -> int * string
      static member tcInvalidUseNullAsTrueValue : unit -> int * string
      static member tcInvalidUseOfDelegate : unit -> int * string
      static member tcInvalidUseOfInterfaceType : unit -> int * string
      static member tcInvalidUseOfTypeName : unit -> int * string
      static member tcIsReadOnlyNotStruct : unit -> int * string
      static member
        tcJoinMustUseSimplePattern : a0:System.String -> int * string
      static member
        tcKindOfTypeSpecifiedDoesNotMatchDefinition : unit -> int * string
      static member
        tcLessGenericBecauseOfAnnotation : a0:System.String * a1:System.String ->
                                             int * string
      static member
        tcLetAndDoRequiresImplicitConstructionSequence : unit -> int * string
      static member tcListLiteralMaxSize : unit -> int * string
      static member
        tcLiteralAttributeRequiresConstantValue : unit -> int * string
      static member tcLiteralCannotBeInline : unit -> int * string
      static member tcLiteralCannotBeMutable : unit -> int * string
      static member tcLiteralCannotHaveGenericParameters : unit -> int * string
      static member tcLiteralDoesNotTakeArguments : unit -> int * string
      static member tcLiteralFieldAssignmentNoArg : unit -> int * string
      static member
        tcLiteralFieldAssignmentWithArg : a0:System.String -> int * string
      static member tcLocalClassBindingsCannotBeInline : unit -> int * string
      static member tcLookupMayNotBeUsedHere : unit -> int * string
      static member tcMatchMayNotBeUsedWithQuery : unit -> int * string
      static member
        tcMeasureDeclarationsRequireStaticMembers : unit -> int * string
      static member
        tcMeasureDeclarationsRequireStaticMembersNotConstructors : unit ->
                                                                     int *
                                                                     string
      static member
        tcMeasureDefinitionsCannotHaveTypeParameters : unit -> int * string
      static member
        tcMemberAndLocalClassBindingHaveSameName : a0:System.String ->
                                                     int * string
      static member
        tcMemberFoundIsNotAbstractOrVirtual : a0:System.String *
                                              a1:System.String -> int * string
      static member tcMemberIsNotSufficientlyGeneric : unit -> int * string
      static member tcMemberKindPropertyGetSetNotExpected : unit -> string
      static member
        tcMemberNotPermittedInInterfaceImplementation : unit -> int * string
      static member tcMemberOperatorDefinitionInExtrinsic : unit -> int * string
      static member tcMemberOverridesIllegalInInterface : unit -> int * string
      static member
        tcMemberUsedInInvalidWay : a0:System.String * a1:System.String *
                                   a2:System.String -> int * string
      static member
        tcMembersThatExtendInterfaceMustBePlacedInSeparateModule : unit ->
                                                                     int *
                                                                     string
      static member tcMethodNotAccessible : a0:System.String -> int * string
      static member tcMethodOverridesIllegalHere : unit -> int * string
      static member tcMissingCustomOperation : a0:System.String -> int * string
      static member tcModuleAbbrevFirstInMutRec : unit -> int * string
      static member
        tcModuleAbbreviationForNamespace : a0:System.String -> int * string
      static member
        tcModuleRequiresQualifiedAccess : a0:System.String -> int * string
      static member tcMultipleVisibilityAttributes : unit -> int * string
      static member tcMultipleVisibilityAttributesWithLet : unit -> int * string
      static member tcMutableValuesCannotBeInline : unit -> int * string
      static member
        tcMutableValuesMayNotHaveGenericParameters : unit -> int * string
      static member tcMutableValuesSyntax : unit -> int * string
      static member tcNameArgumentsMustAppearLast : unit -> int * string
      static member tcNameNotBoundInPattern : a0:System.String -> int * string
      static member tcNamedActivePattern : a0:System.String -> int * string
      static member
        tcNamedArgumentDidNotMatch : a0:System.String -> int * string
      static member
        tcNamedArgumentsCannotBeUsedInMemberTraits : unit -> int * string
      static member tcNamedTypeRequired : a0:System.String -> int * string
      static member
        tcNamespaceCannotContainExtensionMembers : unit -> int * string
      static member tcNamespaceCannotContainValues : unit -> int * string
      static member tcNewCannotBeUsedOnInterfaceType : unit -> int * string
      static member
        tcNewMemberHidesAbstractMember : a0:System.String -> int * string
      static member
        tcNewMemberHidesAbstractMemberWithSuffix : a0:System.String ->
                                                     int * string
      static member tcNewMustBeUsedWithNamedType : unit -> int * string
      static member tcNewRequiresObjectConstructor : unit -> int * string
      static member
        tcNoAbstractOrVirtualMemberFound : a0:System.String -> int * string
      static member tcNoArgumentsForRecordValue : unit -> int * string
      static member
        tcNoComparisonNeeded1 : a0:System.String * a1:System.String *
                                a2:System.String -> int * string
      static member
        tcNoComparisonNeeded2 : a0:System.String * a1:System.String *
                                a2:System.String -> int * string
      static member
        tcNoEqualityNeeded1 : a0:System.String * a1:System.String *
                              a2:System.String -> int * string
      static member
        tcNoEqualityNeeded2 : a0:System.String * a1:System.String *
                              a2:System.String -> int * string
      static member tcNoIntegerForLoopInQuery : unit -> int * string
      static member
        tcNoInterfaceImplementationForConstructionExpression : unit ->
                                                                 int * string
      static member tcNoMemberFoundForOverride : unit -> int * string
      static member tcNoPropertyFoundForOverride : unit -> int * string
      static member tcNoTryFinallyInQuery : unit -> int * string
      static member tcNoWhileInQuery : unit -> int * string
      static member tcNonLiteralCannotBeUsedInPattern : unit -> int * string
      static member tcNonSimpleLetBindingInQuery : unit -> int * string
      static member tcNonUniformMemberUse : a0:System.String -> int * string
      static member
        tcNonZeroConstantCannotHaveGenericUnit : unit -> int * string
      static member tcNotAnException : unit -> int * string
      static member
        tcNotSufficientlyGenericBecauseOfScope : a0:System.String ->
                                                   int * string
      static member tcNotValidEnumCaseName : unit -> int * string
      static member
        tcNumericLiteralRequiresModule : a0:System.String -> int * string
      static member
        tcObjectConstructionCanOnlyBeUsedInClassTypes : unit -> int * string
      static member
        tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes : unit ->
                                                                                         int *
                                                                                         string
      static member tcObjectConstructorRequiresArgument : unit -> int * string
      static member
        tcObjectConstructorsIllegalInInterface : unit -> int * string
      static member
        tcObjectConstructorsOnTypeParametersCannotTakeArguments : unit ->
                                                                    int * string
      static member tcObjectExpressionFormDeprecated : unit -> string
      static member
        tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual : unit ->
                                                                int * string
      static member
        tcObjectOfIndeterminateTypeUsedRequireTypeConstraint : unit ->
                                                                 int * string
      static member
        tcObjectsMustBeInitializedWithObjectExpression : unit -> int * string
      static member tcOnlyClassesCanHaveAbstract : unit -> int * string
      static member tcOnlyFunctionsCanBeInline : unit -> int * string
      static member
        tcOnlyRecordFieldsAndSimpleLetCanBeMutable : unit -> int * string
      static member
        tcOnlySimpleBindingsCanBeUsedInConstructionExpressions : unit ->
                                                                   int * string
      static member tcOnlySimplePatternsInLetRec : unit -> int * string
      static member tcOnlyStructsCanHaveStructLayout : unit -> int * string
      static member
        tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure : unit ->
                                                                int * string
      static member tcOpenFirstInMutRec : unit -> int * string
      static member
        tcOpenUsedWithPartiallyQualifiedPath : a0:System.String -> int * string
      static member
        tcOperatorDoesntAcceptInto : a0:System.String -> int * string
      static member
        tcOperatorIncorrectSyntax : a0:System.String * a1:System.String ->
                                      int * string
      static member
        tcOperatorRequiresIn : a0:System.String * a1:System.String ->
                                 int * string
      static member
        tcOptionalArgsMustComeAfterNonOptionalArgs : unit -> int * string
      static member tcOptionalArgsOnlyOnMembers : unit -> int * string
      static member
        tcOptionalArgumentsCannotBeUsedInCustomAttribute : unit -> int * string
      static member tcOverloadsCannotHaveCurriedArguments : unit -> int * string
      static member tcOverrideArityMismatch : a0:System.String -> int * string
      static member
        tcOverridesCannotHaveVisibilityDeclarations : unit -> int * string
      static member
        tcOverridingMethodRequiresAllOrNoTypeParameters : unit -> int * string
      static member tcParameterInferredByref : a0:System.String -> int * string
      static member tcParameterRequiresName : unit -> int * string
      static member
        tcPredefinedTypeCannotBeUsedAsSuperType : unit -> int * string
      static member tcPropertyCannotBeSet0 : unit -> int * string
      static member tcPropertyCannotBeSet1 : a0:System.String -> int * string
      static member tcPropertyIsNotReadable : a0:System.String -> int * string
      static member tcPropertyIsNotStatic : a0:System.String -> int * string
      static member tcPropertyIsStatic : a0:System.String -> int * string
      static member tcPropertyOrFieldNotFoundInAttribute : unit -> int * string
      static member
        tcPropertyRequiresExplicitTypeParameters : unit -> int * string
      static member tcRecImplied : unit -> int * string
      static member tcRecordFieldInconsistentTypes : unit -> int * string
      static member
        tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute : unit ->
                                                                                   int *
                                                                                   string
      static member
        tcRecursiveBindingsWithMembersMustBeDirectAugmentation : unit ->
                                                                   int * string
      static member
        tcRepresentationOfTypeHiddenBySignature : unit -> int * string
      static member tcRequireActivePatternWithOneResult : unit -> int * string
      static member tcRequireBuilderMethod : a0:System.String -> int * string
      static member
        tcRequireMergeSourcesOrBindN : a0:System.String -> int * string
      static member tcRequireVarConstRecogOrLiteral : unit -> int * string
      static member tcReservedSyntaxForAugmentation : unit -> string
      static member tcReturnMayNotBeUsedInQueries : unit -> int * string
      static member tcReturnTypesForUnionMustBeSameAsType : unit -> int * string
      static member tcReturnValuesCannotHaveNames : unit -> int * string
      static member
        tcRuntimeSuppliedMethodCannotBeUsedInUserCode : a0:System.String ->
                                                          int * string
      static member tcSeqResultsUseYield : unit -> int * string
      static member tcSimpleMethodNameRequired : unit -> int * string
      static member
        tcStaticFieldUsedWhenInstanceFieldExpected : unit -> int * string
      static member tcStaticInitializerRequiresArgument : unit -> int * string
      static member
        tcStaticInitializersIllegalInInterface : unit -> int * string
      static member
        tcStaticLetBindingsRequireClassesWithImplicitConstructors : unit ->
                                                                      int *
                                                                      string
      static member tcStaticMemberShouldNotHaveThis : unit -> int * string
      static member
        tcStaticOptimizationConditionalsOnlyForFSharpLibrary : unit ->
                                                                 int * string
      static member
        tcStaticValFieldsMustBeMutableAndPrivate : unit -> int * string
      static member
        tcStructTypesCannotContainAbstractMembers : unit -> int * string
      static member tcStructUnionMultiCaseDistinctFields : unit -> int * string
      static member
        tcStructsCanOnlyBindThisAtMemberDeclaration : unit -> int * string
      static member
        tcStructsCannotHaveConstructorWithNoArguments : unit -> int * string
      static member
        tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes : unit ->
                                                                         int *
                                                                         string
      static member tcStructsMayNotContainDoBindings : unit -> string
      static member tcStructsMayNotContainLetBindings : unit -> int * string
      static member
        tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly : unit ->
                                                                  int * string
      static member
        tcStructuralComparisonNotSatisfied1 : a0:System.String *
                                              a1:System.String -> int * string
      static member
        tcStructuralComparisonNotSatisfied2 : a0:System.String *
                                              a1:System.String -> int * string
      static member
        tcStructuralEqualityNotSatisfied1 : a0:System.String * a1:System.String ->
                                              int * string
      static member
        tcStructuralEqualityNotSatisfied2 : a0:System.String * a1:System.String ->
                                              int * string
      static member
        tcSyntaxCanOnlyBeUsedToCreateObjectTypes : a0:System.String ->
                                                     int * string
      static member tcSyntaxErrorUnexpectedQMark : unit -> int * string
      static member
        tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields : unit ->
                                                                    int * string
      static member tcTPFieldMustBeLiteral : unit -> int * string
      static member
        tcThisTypeMayNotHaveACLIMutableAttribute : unit -> int * string
      static member tcThisValueMayNotBeInlined : unit -> int * string
      static member
        tcThreadStaticAndContextStaticMustBeStatic : unit -> int * string
      static member tcTryIllegalInSequenceExpression : unit -> int * string
      static member tcTryWithMayNotBeUsedInQueries : unit -> int * string
      static member tcTupleMemberNotNormallyUsed : unit -> int * string
      static member tcTupleStructMismatch : unit -> string
      static member
        tcTypeAbbreviationHasTypeParametersMissingOnType : unit -> string
      static member
        tcTypeAbbreviationsCannotHaveAugmentations : unit -> int * string
      static member
        tcTypeAbbreviationsCannotHaveInterfaceDeclaration : unit -> int * string
      static member tcTypeAbbreviationsCheckedAtCompileTime : unit -> string
      static member tcTypeAbbreviationsMayNotHaveMembers : unit -> int * string
      static member tcTypeCannotBeEnumerated : a0:System.String -> int * string
      static member
        tcTypeCastErased : a0:System.String * a1:System.String -> int * string
      static member tcTypeDefinitionIsCyclic : unit -> int * string
      static member
        tcTypeDefinitionIsCyclicThroughInheritance : unit -> int * string
      static member
        tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers : unit ->
                                                                                        int *
                                                                                        string
      static member
        tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit : unit ->
                                                                        int *
                                                                        string
      static member tcTypeDoesNotInheritAttribute : unit -> int * string
      static member tcTypeExceptionOrModule : unit -> string
      static member tcTypeHasNoAccessibleConstructor : unit -> int * string
      static member tcTypeHasNoNestedTypes : unit -> int * string
      static member tcTypeIsInaccessible : unit -> int * string
      static member tcTypeIsNotARecordType : unit -> int * string
      static member tcTypeIsNotARecordTypeNeedConstructor : unit -> int * string
      static member tcTypeIsNotInterfaceType0 : unit -> int * string
      static member tcTypeIsNotInterfaceType1 : a0:System.String -> int * string
      static member tcTypeOrModule : unit -> string
      static member
        tcTypeParameterArityMismatch : a0:System.Int32 * a1:System.Int32 ->
                                         int * string
      static member
        tcTypeParameterHasBeenConstrained : a0:System.String -> int * string
      static member
        tcTypeParameterInvalidAsTypeConstructor : unit -> int * string
      static member tcTypeParametersInferredAreNotStable : unit -> int * string
      static member tcTypeRequiresDefinition : unit -> int * string
      static member
        tcTypeTestErased : a0:System.String * a1:System.String -> int * string
      static member tcTypeTestLosesMeasures : a0:System.String -> int * string
      static member
        tcTypeTestLossy : a0:System.String * a1:System.String -> int * string
      static member
        tcTypeUsedInInvalidWay : a0:System.String * a1:System.String *
                                 a2:System.String -> int * string
      static member tcTypesAreAlwaysSealedAssemblyCode : unit -> int * string
      static member tcTypesAreAlwaysSealedDU : unit -> int * string
      static member tcTypesAreAlwaysSealedDelegate : unit -> int * string
      static member tcTypesAreAlwaysSealedEnum : unit -> int * string
      static member tcTypesAreAlwaysSealedRecord : unit -> int * string
      static member tcTypesAreAlwaysSealedStruct : unit -> int * string
      static member tcTypesCannotContainNestedTypes : unit -> int * string
      static member
        tcTypesCannotInheritFromMultipleConcreteTypes : unit -> int * string
      static member
        tcUnableToParseFormatString : a0:System.String -> int * string
      static member
        tcUnableToParseInterpolatedString : a0:System.String -> int * string
      static member
        tcUndefinedField : a0:System.String * a1:System.String -> int * string
      static member tcUnexpectedBigRationalConstant : unit -> string
      static member
        tcUnexpectedConditionInImportedAssembly : unit -> int * string
      static member tcUnexpectedConstByteArray : unit -> string
      static member tcUnexpectedConstUint16Array : unit -> string
      static member tcUnexpectedExprAtRecInfPoint : unit -> int * string
      static member tcUnexpectedMeasureAnon : unit -> int * string
      static member tcUnexpectedPropertyInSyntaxTree : unit -> int * string
      static member tcUnexpectedPropertySpec : unit -> int * string
      static member tcUnexpectedSlashInType : unit -> int * string
      static member
        tcUnexpectedSymbolInTypeExpression : a0:System.String -> int * string
      static member tcUnexpectedTypeArguments : unit -> int * string
      static member tcUninitializedValFieldsMustBeMutable : unit -> int * string
      static member
        tcUnionCaseConstructorDoesNotHaveFieldWithGivenName : a0:System.String *
                                                              a1:System.String ->
                                                                int * string
      static member tcUnionCaseDoesNotTakeArguments : unit -> int * string
      static member
        tcUnionCaseExpectsTupledArguments : a0:System.Int32 -> int * string
      static member
        tcUnionCaseFieldCannotBeUsedMoreThanOnce : a0:System.String ->
                                                     int * string
      static member
        tcUnionCaseNameConflictsWithGeneratedType : a0:System.String *
                                                    a1:System.String ->
                                                      int * string
      static member tcUnionCaseRequiresOneArgument : unit -> int * string
      static member
        tcUnitsOfMeasureInvalidInTypeConstructor : unit -> int * string
      static member tcUnknownUnion : unit -> int * string
      static member tcUnnamedArgumentsDoNotFormPrefix : unit -> string
      static member tcUnrecognizedAttributeTarget : unit -> int * string
      static member tcUnrecognizedQueryBinaryOperator : unit -> int * string
      static member tcUnrecognizedQueryOperator : unit -> int * string
      static member tcUnsupportedAttribute : unit -> int * string
      static member tcUnsupportedMutRecDecl : unit -> int * string
      static member tcUseForInSequenceExpression : unit -> int * string
      static member tcUseMayNotBeUsedInQueries : unit -> int * string
      static member tcUseWhenPatternGuard : unit -> string
      static member tcUseYieldBangForMultipleResults : unit -> int * string
      static member
        tcValueInSignatureRequiresLiteralAttribute : unit -> int * string
      static member tcVolatileFieldsMustBeMutable : unit -> int * string
      static member tcVolatileOnlyOnClassLetBindings : unit -> int * string
      static member
        tlrLambdaLiftingOptimizationsNotApplied : unit -> int * string
      static member tlrUnexpectedTExpr : unit -> int * string
      static member
        toolLocationHelperUnsupportedFrameworkVersion : a0:System.String ->
                                                          int * string
      static member tupleRequiredInAbstractMethod : unit -> string
      static member typeInfoActivePatternResult : unit -> string
      static member typeInfoActiveRecognizer : unit -> string
      static member typeInfoAnonRecdField : unit -> string
      static member typeInfoArgument : unit -> string
      static member typeInfoCallsWord : unit -> string
      static member typeInfoCustomOperation : unit -> string
      static member typeInfoEvent : unit -> string
      static member typeInfoExtension : unit -> string
      static member typeInfoField : unit -> string
      static member typeInfoFromFirst : a0:System.String -> string
      static member typeInfoFromNext : a0:System.String -> string
      static member typeInfoFullName : unit -> string
      static member typeInfoGeneratedProperty : unit -> string
      static member typeInfoGeneratedType : unit -> string
      static member typeInfoModule : unit -> string
      static member typeInfoNamespace : unit -> string
      static member typeInfoNamespaceOrModule : unit -> string
      static member typeInfoOtherOverloads : a0:System.Int32 -> string
      static member typeInfoPatternVariable : unit -> string
      static member typeInfoProperty : unit -> string
      static member typeInfoUnionCase : unit -> string
      static member typeIsNotAccessible : a0:System.String -> int * string
      static member
        typrelCannotResolveAmbiguityInDelegate : unit -> int * string
      static member typrelCannotResolveAmbiguityInEnum : unit -> int * string
      static member typrelCannotResolveAmbiguityInPrintf : unit -> int * string
      static member
        typrelCannotResolveAmbiguityInUnmanaged : unit -> int * string
      static member
        typrelCannotResolveImplicitGenericInstantiation : a0:System.String *
                                                          a1:System.String ->
                                                            int * string
      static member typrelDuplicateInterface : unit -> int * string
      static member
        typrelExplicitImplementationOfEquals : a0:System.String -> int * string
      static member
        typrelExplicitImplementationOfGetHashCode : a0:System.String ->
                                                      int * string
      static member
        typrelExplicitImplementationOfGetHashCodeOrEquals : a0:System.String ->
                                                              int * string
      static member
        typrelInterfaceMemberNoMostSpecificImplementation : a0:System.String ->
                                                              int * string
      static member
        typrelInterfaceWithConcreteAndVariable : a0:System.String *
                                                 a1:System.String *
                                                 a2:System.String *
                                                 a3:System.String ->
                                                   int * string
      static member
        typrelInterfaceWithConcreteAndVariableObjectExpression : a0:System.String *
                                                                 a1:System.String *
                                                                 a2:System.String ->
                                                                   int * string
      static member typrelInvalidValue : unit -> int * string
      static member
        typrelMemberCannotImplement : a0:System.String * a1:System.String *
                                      a2:System.String -> int * string
      static member
        typrelMemberDoesNotHaveCorrectKindsOfGenericParameters : a0:System.String *
                                                                 a1:System.String ->
                                                                   int * string
      static member
        typrelMemberDoesNotHaveCorrectNumberOfArguments : a0:System.String *
                                                          a1:System.String ->
                                                            int * string
      static member
        typrelMemberDoesNotHaveCorrectNumberOfTypeParameters : a0:System.String *
                                                               a1:System.String ->
                                                                 int * string
      static member
        typrelMemberHasMultiplePossibleDispatchSlots : a0:System.String *
                                                       a1:System.String ->
                                                         int * string
      static member typrelMethodIsOverconstrained : unit -> int * string
      static member typrelMethodIsSealed : a0:System.String -> int * string
      static member
        typrelModuleNamespaceAttributesDifferInSigAndImpl : unit -> int * string
      static member typrelMoreThenOneOverride : a0:System.String -> int * string
      static member
        typrelNamedArgumentHasBeenAssignedMoreThenOnce : a0:System.String ->
                                                           int * string
      static member
        typrelNeedExplicitImplementation : a0:System.String -> int * string
      static member
        typrelNoImplementationGiven : a0:System.String -> int * string
      static member
        typrelNoImplementationGivenSeveral : a0:System.String -> int * string
      static member
        typrelNoImplementationGivenSeveralTruncated : a0:System.String ->
                                                        int * string
      static member
        typrelNoImplementationGivenSeveralTruncatedWithSuggestion : a0:System.String ->
                                                                      int *
                                                                      string
      static member
        typrelNoImplementationGivenSeveralWithSuggestion : a0:System.String ->
                                                             int * string
      static member
        typrelNoImplementationGivenWithSuggestion : a0:System.String ->
                                                      int * string
      static member
        typrelOverloadNotFound : a0:System.String * a1:System.String ->
                                   int * string
      static member
        typrelOverrideImplementsMoreThenOneSlot : a0:System.String *
                                                  a1:System.String *
                                                  a2:System.String ->
                                                    int * string
      static member
        typrelOverrideWasAmbiguous : a0:System.String -> int * string
      static member
        typrelSigImplNotCompatibleCompileTimeRequirementsDiffer : unit ->
                                                                    int * string
      static member
        typrelSigImplNotCompatibleConstraintsDiffer : a0:System.String *
                                                      a1:System.String ->
                                                        int * string
      static member
        typrelSigImplNotCompatibleConstraintsDifferRemove : a0:System.String *
                                                            a1:System.String ->
                                                              int * string
      static member
        typrelSigImplNotCompatibleParamCountsDiffer : unit -> int * string
      static member
        typrelTypeImplementsIComparableDefaultObjectEqualsProvided : a0:System.String ->
                                                                       int *
                                                                       string
      static member
        typrelTypeImplementsIComparableShouldOverrideObjectEquals : a0:System.String ->
                                                                      int *
                                                                      string
      static member
        undefinedNameConstructorModuleOrNamespace : a0:System.String -> string
      static member
        undefinedNameFieldConstructorOrMember : a0:System.String -> string
      static member
        undefinedNameFieldConstructorOrMemberWhenTypeIsKnown : a0:System.String *
                                                               a1:System.String ->
                                                                 string
      static member undefinedNameNamespace : a0:System.String -> string
      static member undefinedNameNamespaceOrModule : a0:System.String -> string
      static member
        undefinedNamePatternDiscriminator : a0:System.String -> string
      static member undefinedNameRecordLabel : a0:System.String -> string
      static member
        undefinedNameRecordLabelOrNamespace : a0:System.String -> string
      static member undefinedNameSuggestionsIntro : unit -> string
      static member undefinedNameType : a0:System.String -> string
      static member
        undefinedNameTypeIn : a0:System.String * a1:System.String -> string
      static member undefinedNameTypeParameter : a0:System.String -> string
      static member
        undefinedNameValueConstructorNamespaceOrType : a0:System.String ->
                                                         string
      static member
        undefinedNameValueNamespaceTypeOrModule : a0:System.String -> string
      static member undefinedNameValueOfConstructor : a0:System.String -> string
      static member unionCaseIsNotAccessible : a0:System.String -> int * string
      static member
        unionCasesAreNotAccessible : a0:System.String -> int * string
      static member useSdkRefs : unit -> string
      static member valueIsNotAccessible : a0:System.String -> int * string
      static member writeToReadOnlyByref : unit -> int * string
      static member xmlDocBadlyFormed : a0:System.String -> int * string
      static member xmlDocDuplicateParameter : a0:System.String -> int * string
      static member
        xmlDocInvalidParameterName : a0:System.String -> int * string
      static member xmlDocMissingCrossReference : unit -> int * string
      static member xmlDocMissingParameter : a0:System.String -> int * string
      static member xmlDocMissingParameterName : unit -> int * string
      static member
        xmlDocUnresolvedCrossReference : a0:System.String -> int * string
      static member yieldUsedInsteadOfYieldBang : unit -> string
      static member SwallowResourceText : bool
    end

namespace DependencyManager
  type internal SR =
    class
      private new : unit -> SR
      static member RunStartupValidation : unit -> unit
      static member
        couldNotLoadDependencyManagerExtension : a0:System.String *
                                                 a1:System.String ->
                                                   int * string
      static member packageManagerError : a0:System.String -> int * string
      static member
        packageManagerUnknown : a0:System.String * a1:System.String *
                                a2:System.String -> int * string
      static member SwallowResourceText : bool
    end

namespace FSIstrings
  type internal SR =
    class
      private new : unit -> SR
      static member RunStartupValidation : unit -> unit
      static member fsiAbortingMainThread : unit -> string
      static member fsiAdvanced : unit -> string
      static member fsiBanner3 : unit -> string
      static member fsiBindingSessionTo : a0:System.String -> string
      static member fsiCodeGeneration : unit -> string
      static member fsiConsoleProblem : unit -> string
      static member fsiCouldNotInstallCtrlCHandler : a0:System.String -> string
      static member fsiDidAHashI : a0:System.String -> string
      static member fsiDidAHashr : a0:System.String -> string
      static member fsiDidAHashrWithLockWarning : a0:System.String -> string
      static member fsiDidAHashrWithStaleWarning : a0:System.String -> string
      static member fsiDirectoryDoesNotExist : a0:System.String -> int * string
      static member fsiEmitDebugInfoInQuotations : unit -> string
      static member fsiErrorsAndWarnings : unit -> string
      static member
        fsiExceptionDuringPrettyPrinting : a0:System.String -> string
      static member
        fsiExceptionRaisedStartingServer : a0:System.String -> string
      static member fsiExec : unit -> string
      static member fsiExit : unit -> string
      static member fsiFailedToResolveAssembly : a0:System.String -> string
      static member fsiGui : unit -> string
      static member fsiHelp : unit -> string
      static member fsiInputFiles : unit -> string
      static member fsiInterrupt : unit -> string
      static member fsiIntroPackageSourceUriInfo : unit -> string
      static member fsiIntroTextHashIInfo : unit -> string
      static member fsiIntroTextHashhelpInfo : unit -> string
      static member fsiIntroTextHashloadInfo : unit -> string
      static member fsiIntroTextHashquitInfo : unit -> string
      static member fsiIntroTextHashrInfo : unit -> string
      static member fsiIntroTextHashtimeInfo : unit -> string
      static member fsiIntroTextHeader1directives : unit -> string
      static member fsiIntroTextHeader2commandLine : unit -> string
      static member fsiIntroTextHeader3 : a0:System.String -> string
      static member fsiInvalidAssembly : a0:System.String -> int * string
      static member fsiLanguage : unit -> string
      static member fsiLineTooLong : unit -> string
      static member fsiLoad : unit -> string
      static member fsiLoadingFilesPrefixText : unit -> string
      static member fsiMiscellaneous : unit -> string
      static member fsiOperationCouldNotBeCompleted : unit -> string
      static member fsiOperationFailed : unit -> string
      static member fsiProductName : a0:System.String -> string
      static member fsiProductNameCommunity : a0:System.String -> string
      static member fsiQuiet : unit -> string
      static member fsiReadline : unit -> string
      static member fsiRemaining : unit -> string
      static member
        fsiTimeInfoGCGenerationLabelSomeShorthandForTheWordGeneration : unit ->
                                                                          string
      static member
        fsiTimeInfoMainString : a0:System.String * a1:System.String *
                                a2:System.String -> string
      static member fsiTurnedTimingOff : unit -> string
      static member fsiTurnedTimingOn : unit -> string
      static member fsiUnexpectedThreadAbortException : unit -> string
      static member fsiUsage : a0:System.String -> string
      static member fsiUse : unit -> string
      static member shadowCopyReferences : unit -> string
      static member stoppedDueToError : unit -> string
      static member SwallowResourceText : bool
    end

namespace UtilsStrings
  type internal SR =
    class
      private new : unit -> SR
      static member RunStartupValidation : unit -> unit
      static member buildProductName : a0:System.String -> string
      static member
        fSharpBannerVersion : a0:System.String * a1:System.String -> string
      static member SwallowResourceText : bool
    end

namespace FSharp
  module internal BuildProperties = begin
    val fsProductVersion : string
    val fsLanguageVersion : string
  end







namespace Internal.Utilities.StructuredFormat
  [<StructuralEqualityAttribute (); NoComparisonAttribute ()>]
  type LayoutTag =
    | ActivePatternCase
    | ActivePatternResult
    | Alias
    | Class
    | Union
    | UnionCase
    | Delegate
    | Enum
    | Event
    | Field
    | Interface
    | Keyword
    | LineBreak
    | Local
    | Record
    | RecordField
    | Method
    | Member
    | ModuleBinding
    | Function
    | Module
    | Namespace
    | NumericLiteral
    | Operator
    | Parameter
    | Property
    | Space
    | StringLiteral
    | Struct
    | TypeParameter
    | Text
    | Punctuation
    | UnknownType
    | UnknownEntity
  type TaggedText =
    interface
      abstract member Tag : LayoutTag
      abstract member Text : string
    end
  type TaggedTextWriter =
    interface
      abstract member Write : t:TaggedText -> unit
      abstract member WriteLine : unit -> unit
    end
  [<StructuralEqualityAttribute (); NoComparisonAttribute ()>]
  type Joint =
    | Unbreakable
    | Breakable of indentation: int
    | Broken of indentation: int
  [<NoEqualityAttribute (); NoComparisonAttribute ()>]
  type Layout =
    | ObjLeaf of juxtLeft: bool * object: obj * juxtRight: bool
    | Leaf of juxtLeft: bool * text: TaggedText * justRight: bool
    | Node of leftLayout: Layout * rightLayout: Layout * joint: Joint
    | Attr of text: string * attributes: (string * string) list * layout: Layout
    with
      static member JuxtapositionMiddle : left:Layout * right:Layout -> bool
      member JuxtapositionLeft : bool
      member JuxtapositionRight : bool
    end
  [<NoEqualityAttribute (); NoComparisonAttribute ()>]
  type IEnvironment =
    interface
      abstract member GetLayout : obj -> Layout
      abstract member MaxColumns : int
      abstract member MaxRows : int
    end
  module TaggedTextOps = begin
    val mkTag : LayoutTag -> string -> TaggedText
    val length : tt:TaggedText -> int
    val toText : tt:TaggedText -> string
    val tagAlias : string -> TaggedText
    val keywordFunctions : Set<string>
    val tagClass : string -> TaggedText
    val tagUnionCase : string -> TaggedText
    val tagDelegate : string -> TaggedText
    val tagEnum : string -> TaggedText
    val tagEvent : string -> TaggedText
    val tagField : string -> TaggedText
    val tagInterface : string -> TaggedText
    val tagKeyword : string -> TaggedText
    val tagLineBreak : string -> TaggedText
    val tagLocal : string -> TaggedText
    val tagRecord : string -> TaggedText
    val tagRecordField : string -> TaggedText
    val tagMethod : string -> TaggedText
    val tagModule : string -> TaggedText
    val tagModuleBinding : string -> TaggedText
    val tagFunction : string -> TaggedText
    val tagNamespace : string -> TaggedText
    val tagNumericLiteral : string -> TaggedText
    val tagOperator : string -> TaggedText
    val tagParameter : string -> TaggedText
    val tagProperty : string -> TaggedText
    val tagSpace : string -> TaggedText
    val tagStringLiteral : string -> TaggedText
    val tagStruct : string -> TaggedText
    val tagTypeParameter : string -> TaggedText
    val tagText : string -> TaggedText
    val tagPunctuation : string -> TaggedText
    module Literals = begin
      val lineBreak : TaggedText
      val space : TaggedText
      val comma : TaggedText
      val semicolon : TaggedText
      val leftParen : TaggedText
      val rightParen : TaggedText
      val leftBracket : TaggedText
      val rightBracket : TaggedText
      val leftBrace : TaggedText
      val rightBrace : TaggedText
      val leftBraceBar : TaggedText
      val rightBraceBar : TaggedText
      val equals : TaggedText
      val arrow : TaggedText
      val questionMark : TaggedText
    end
  end
  module LayoutOps = begin
    val mkNode : l:Layout -> r:Layout -> joint:Joint -> Layout
    val objL : value:obj -> Layout
    val sLeaf : l:bool * t:TaggedText * r:bool -> Layout
    val wordL : text:TaggedText -> Layout
    val sepL : text:TaggedText -> Layout
    val rightL : text:TaggedText -> Layout
    val leftL : text:TaggedText -> Layout
    val emptyL : Layout
    val isEmptyL : layout:Layout -> bool
    val aboveL : layout1:Layout -> layout2:Layout -> Layout
    val tagAttrL :
      text:string -> maps:(string * string) list -> layout:Layout -> Layout
    val apply2 :
      f:(Layout -> Layout -> Layout) -> l:Layout -> r:Layout -> Layout
    val ( ^^ ) : layout1:Layout -> layout2:Layout -> Layout
    val ( ++ ) : layout1:Layout -> layout2:Layout -> Layout
    val ( -- ) : layout1:Layout -> layout2:Layout -> Layout
    val ( --- ) : layout1:Layout -> layout2:Layout -> Layout
    val ( @@ ) : layout1:Layout -> layout2:Layout -> Layout
    val ( @@- ) : layout1:Layout -> layout2:Layout -> Layout
    val ( @@-- ) : layout1:Layout -> layout2:Layout -> Layout
    val tagListL : tagger:(Layout -> Layout) -> els:Layout list -> Layout
    val commaListL : layouts:Layout list -> Layout
    val semiListL : layouts:Layout list -> Layout
    val spaceListL : layouts:Layout list -> Layout
    val sepListL : layout1:Layout -> layouts:Layout list -> Layout
    val bracketL : layout:Layout -> Layout
    val tupleL : layouts:Layout list -> Layout
    val aboveListL : layouts:Layout list -> Layout
    val optionL : selector:('T -> Layout) -> value:'T option -> Layout
    val listL : selector:('T -> Layout) -> value:'T list -> Layout
    val squareBracketL : layout:Layout -> Layout
    val braceL : layout:Layout -> Layout
    val boundedUnfoldL :
      itemL:('a -> Layout) ->
        project:('z -> ('a * 'z) option) ->
          stopShort:('z -> bool) -> z:'z -> maxLength:int -> Layout list
    val unfoldL :
      selector:('T -> Layout) ->
        folder:('State -> ('T * 'State) option) ->
          state:'State -> count:int -> Layout list
  end
  [<NoEqualityAttribute (); NoComparisonAttribute ()>]
  type FormatOptions =
    { FloatingPointFormat: string
      AttributeProcessor: string -> (string * string) list -> bool -> unit
      PrintIntercepts: (IEnvironment -> obj -> Layout option) list
      StringLimit: int
      FormatProvider: System.IFormatProvider
      BindingFlags: System.Reflection.BindingFlags
      PrintWidth: int
      PrintDepth: int
      PrintLength: int
      PrintSize: int
      ShowProperties: bool
      ShowIEnumerable: bool }
    with
      static member Default : FormatOptions
    end
  module ReflectUtils = begin
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type TypeInfo =
      | TupleType of System.Type list
      | FunctionType of System.Type * System.Type
      | RecordType of (string * System.Type) list
      | SumType of (string * (string * System.Type) list) list
      | UnitType
      | ObjectType of System.Type
    val isNamedType : ty:System.Type -> bool
    val equivHeadTypes : ty1:System.Type -> ty2:System.Type -> bool
    val option : System.Type
    val func : System.Type
    val isOptionTy : ty:System.Type -> bool
    val isUnitType : ty:System.Type -> bool
    val isListType : ty:System.Type -> bool
    [<RequireQualifiedAccessAttribute (); StructuralComparisonAttribute ();
      StructuralEqualityAttribute ()>]
    type TupleType =
      | Value
      | Reference
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type ValueInfo =
      | TupleValue of TupleType * (obj * System.Type) []
      | FunctionClosureValue of System.Type
      | RecordValue of (string * obj * System.Type) []
      | UnionCaseValue of string * (string * (obj * System.Type)) []
      | ExceptionValue of System.Type * (string * (obj * System.Type)) []
      | NullValue
      | UnitValue
      | ObjectValue of obj
    module Value = begin
      val GetValueInfoOfObject :
        bindingFlags:System.Reflection.BindingFlags -> obj:obj -> ValueInfo
      val GetValueInfo :
        bindingFlags:System.Reflection.BindingFlags ->
          x:'a * ty:System.Type -> ValueInfo
    end
  end
  module Display = begin
    val string_of_int : i:int -> string
    val typeUsesSystemObjectToString : ty:System.Type -> bool
    val catchExn : f:(unit -> 'a) -> Choice<'a,exn>
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type Breaks =
      | Breaks of nextFreeSlot: int * nextOuterBreak: int * savingsStack: int []
    val chunkN : int
    val breaks0 : unit -> Breaks
    val pushBreak : saving:int -> Breaks -> Breaks
    val popBreak : Breaks -> Breaks * bool
    val forceBreak : Breaks -> (Breaks * int) option
    val squashToAux :
      maxWidth:int * leafFormatter:(obj -> TaggedText) ->
        layout:Layout -> Layout
    val combine : strs:string list -> string
    val showL :
      opts:FormatOptions ->
        leafFormatter:(obj -> string) -> layout:Layout -> string
    val outL :
      outAttribute:(string -> (string * string) list -> bool -> 'a) ->
        leafFormatter:(obj -> #TaggedText) ->
          chan:TaggedTextWriter -> layout:Layout -> unit
    val unpackCons : recd:('a * 'b) [] -> 'b * 'b
    val getListValueInfo :
      bindingFlags:System.Reflection.BindingFlags ->
        x:obj * ty:System.Type ->
          ((obj * System.Type) * (obj * System.Type)) option
    val structL : Layout
    val nullL : Layout
    val unitL : Layout
    val makeRecordL : nameXs:(#TaggedText * Layout) list -> Layout
    val makePropertiesL : nameXs:(#TaggedText * Layout option) list -> Layout
    val makeListL : itemLs:Layout list -> Layout
    val makeArrayL : xs:Layout list -> Layout
    val makeArray2L : xs:Layout list -> Layout
    val getProperty : ty:System.Type -> obj:obj -> name:string -> obj
    val getField : obj:'a -> fieldInfo:System.Reflection.FieldInfo -> obj
    val formatChar : isChar:bool -> c:char -> string
    val formatString : s:string -> string
    val formatStringInWidth : width:int -> str:string -> string
    type Precedence =
      | BracketIfTupleOrNotAtomic = 2
      | BracketIfTuple = 3
      | NeverBracket = 4
    [<StructuralEqualityAttribute (); NoComparisonAttribute ()>]
    type ShowMode =
      | ShowAll
      | ShowTopLevelBinding
    val isSetOrMapType : ty:System.Type -> bool
    type ObjectGraphFormatter =
      class
        new : opts:FormatOptions * bindingFlags:System.Reflection.BindingFlags ->
                ObjectGraphFormatter
        member Format : showMode:ShowMode * x:'a * xty:System.Type -> Layout
      end
    val leafFormatter : opts:FormatOptions -> obj:obj -> TaggedText
    val any_to_layout :
      options:FormatOptions -> value:'T * typValue:System.Type -> Layout
    val squashTo : width:int -> layout:Layout -> Layout
    val squash_layout : options:FormatOptions -> layout:Layout -> Layout
    val asTaggedTextWriter : writer:System.IO.TextWriter -> TaggedTextWriter
    val output_layout_tagged :
      options:FormatOptions -> writer:TaggedTextWriter -> layout:Layout -> unit
    val output_layout :
      options:FormatOptions ->
        writer:System.IO.TextWriter -> layout:Layout -> unit
    val layout_to_string : options:FormatOptions -> layout:Layout -> string
    val output_any_ex :
      opts:FormatOptions -> oc:System.IO.TextWriter -> 'a * System.Type -> unit
    val output_any : writer:System.IO.TextWriter -> 'a * System.Type -> unit
    val layout_as_string :
      options:FormatOptions -> value:'T * typValue:System.Type -> string
    val any_to_string : 'a * System.Type -> string
    val fsi_any_to_layout :
      options:FormatOptions -> value:'T * typValue:System.Type -> Layout
  end

namespace FSharp.Compiler
  module internal SR = begin
    val private resources : Lazy<System.Resources.ResourceManager>
    val GetString : string -> string
  end
  module internal DiagnosticMessage = begin
    val mkFunctionValue : tys:System.Type [] -> impl:(obj -> obj) -> obj
    val funTyC : System.Type
    val mkFunTy : a:System.Type -> b:System.Type -> System.Type
    val isNamedType : ty:System.Type -> bool
    val isFunctionType : ty1:System.Type -> bool
    val destFunTy : ty:System.Type -> System.Type * System.Type []
    val buildFunctionForOneArgPat :
      ty:System.Type -> impl:(System.Type -> obj -> obj) -> obj
    val capture1 :
      fmt:string ->
        i:int ->
          args:obj list ->
            ty:System.Type -> go:(obj list -> System.Type -> int -> obj) -> obj
    val postProcessString : s:string -> string
    val createMessageString :
      messageString:string -> fmt:Printf.StringFormat<'T> -> 'T
    type ResourceString<'T> =
      class
        new : string * Printf.StringFormat<'T> -> ResourceString<'T>
        member Format : 'T
      end
    val DeclareResourceString :
      string * Printf.StringFormat<'T> -> ResourceString<'T>
  end

namespace FSharp.Compiler
  type LogCompilerFunctionId =
    | Service_ParseAndCheckFileInProject = 1
    | Service_CheckOneFile = 2
    | Service_IncrementalBuildersCache_BuildingNewCache = 3
    | Service_IncrementalBuildersCache_GettingCache = 4
    | CompileOps_TypeCheckOneInputAndFinishEventually = 5
    | IncrementalBuild_CreateItemKeyStoreAndSemanticClassification = 6
    | IncrementalBuild_TypeCheck = 7
  [<SealedAttribute (); System.Diagnostics.Tracing.EventSource ()>]
  type FSharpCompilerEventSource =
    class
      inherit System.Diagnostics.Tracing.EventSource
      new : unit -> FSharpCompilerEventSource
      [<System.Diagnostics.Tracing.Event (5)>]
      member
        BlockMessageStart : message:string * functionId:LogCompilerFunctionId ->
                              unit
      [<System.Diagnostics.Tracing.Event (6)>]
      member
        BlockMessageStop : message:string * functionId:LogCompilerFunctionId ->
                             unit
      [<System.Diagnostics.Tracing.Event (3)>]
      member BlockStart : functionId:LogCompilerFunctionId -> unit
      [<System.Diagnostics.Tracing.Event (4)>]
      member BlockStop : functionId:LogCompilerFunctionId -> unit
      [<System.Diagnostics.Tracing.Event (1)>]
      member Log : functionId:LogCompilerFunctionId -> unit
      [<System.Diagnostics.Tracing.Event (2)>]
      member
        LogMessage : message:string * functionId:LogCompilerFunctionId -> unit
      static member Instance : FSharpCompilerEventSource
    end
  module Logger = begin
    val Log : LogCompilerFunctionId -> unit
    val LogMessage : message:string -> LogCompilerFunctionId -> unit
    val LogBlockStart : LogCompilerFunctionId -> unit
    val LogBlockStop : LogCompilerFunctionId -> unit
    val LogBlockMessageStart : message:string -> LogCompilerFunctionId -> unit
    val LogBlockMessageStop : message:string -> LogCompilerFunctionId -> unit
    val LogBlock : LogCompilerFunctionId -> System.IDisposable
    val LogBlockMessage :
      message:string -> LogCompilerFunctionId -> System.IDisposable
  end

namespace FSharp.Compiler
  module internal Features = begin
    [<RequireQualifiedAccessAttribute ()>]
    type LanguageFeature =
      | SingleUnderscorePattern
      | WildCardInForLoop
      | RelaxWhitespace
      | NameOf
      | ImplicitYield
      | OpenTypeDeclaration
      | DotlessFloat32Literal
      | PackageManagement
      | FromEndSlicing
      | FixedIndexSlice3d4d
      | AndBang
      | NullableOptionalInterop
      | DefaultInterfaceMemberConsumption
      | WitnessPassing
      | InterfacesWithMultipleGenericInstantiation
      | StringInterpolation
      | OverloadsForCustomOperations
      | ExpandedMeasurables
    type LanguageVersion =
      class
        new : string -> LanguageVersion
        member ContainsVersion : string -> bool
        member GetFeatureString : feature:LanguageFeature -> string
        member GetFeatureVersionString : feature:LanguageFeature -> string
        member SupportsFeature : LanguageFeature -> bool
        member IsPreviewEnabled : bool
        member SpecifiedVersion : decimal
        member SpecifiedVersionString : string
        member ValidOptions : string []
        member ValidVersions : string []
      end
  end

namespace FSharp.Compiler.Text
  type ISourceText =
    interface
      abstract member ContentEquals : sourceText:ISourceText -> bool
      abstract member
        CopyTo : sourceIndex:int * destination:char [] * destinationIndex:int *
                 count:int -> unit
      abstract member GetLastCharacterPosition : unit -> int * int
      abstract member GetLineCount : unit -> int
      abstract member GetLineString : lineIndex:int -> string
      abstract member GetSubTextString : start:int * length:int -> string
      abstract member SubTextEquals : target:string * startIndex:int -> bool
      abstract member Item : int -> char with get
      abstract member Length : int
    end
  [<SealedAttribute ()>]
  type StringText =
    class
      interface ISourceText
      new : str:string -> StringText
      override Equals : obj:obj -> bool
      override GetHashCode : unit -> int
      override ToString : unit -> string
      member String : string
    end
  module SourceText = begin
    val ofString : string -> ISourceText
  end
namespace Internal.Utilities.Text.Lexing
  [<StructAttribute ()>]
  type internal Position =
    struct
      new : fileIndex:int * line:int * originalLine:int *
            startOfLineAbsoluteOffset:int * absoluteOffset:int -> Position
      val FileIndex: int
      val Line: int
      val OriginalLine: int
      val AbsoluteOffset: int
      val StartOfLineAbsoluteOffset: int
      static member FirstLine : fileIdx:int -> Position
      member ApplyLineDirective : fileIdx:int * line:int -> Position
      member EndOfToken : n:int -> Position
      member ShiftColumnBy : by:int -> Position
      member Column : int
      member ColumnMinusOne : Position
      member NextLine : Position
      static member Empty : Position
    end
  type internal LexBufferFiller<'Char> = LexBuffer<'Char> -> unit
  [<SealedAttribute ()>]
  and internal LexBuffer<'Char> =
    class
      new : filler:LexBufferFiller<'Char> *
            supportsFeature:(FSharp.Compiler.Features.LanguageFeature -> bool) ->
              LexBuffer<'Char>
      static member
        FromArray : supportsFeature:(FSharp.Compiler.Features.LanguageFeature ->
                                       bool) * s:'Char [] -> LexBuffer<'Char>
      static member
        FromArrayNoCopy : supportsFeature:(FSharp.Compiler.Features.LanguageFeature ->
                                             bool) * buffer:'Char [] ->
                            LexBuffer<'Char>
      static member
        FromChars : (FSharp.Compiler.Features.LanguageFeature -> bool) * char [] ->
                      LexBuffer<char>
      static member
        FromFunction : (FSharp.Compiler.Features.LanguageFeature -> bool) *
                       ('Char [] * int * int -> int) -> LexBuffer<'Char>
      static member
        FromSourceText : (FSharp.Compiler.Features.LanguageFeature -> bool) *
                         FSharp.Compiler.Text.ISourceText -> LexBuffer<char>
      static member LexemeString : LexBuffer<char> -> System.String
      member DiscardInput : unit -> unit
      member EndOfScan : unit -> int
      member EnsureBufferSize : n:int -> unit
      member LexemeChar : int -> 'Char
      member LexemeContains : 'Char -> bool
      member RefillBuffer : unit -> unit
      member SupportsFeature : FSharp.Compiler.Features.LanguageFeature -> bool
      member Buffer : 'Char []
      member BufferAcceptAction : int
      member
        BufferLocalStore : System.Collections.Generic.IDictionary<string,obj>
      member BufferMaxScanLength : int
      member BufferScanLength : int
      member BufferScanPos : int
      member BufferScanStart : int
      member EndPos : Position
      member IsPastEndOfStream : bool
      member LexemeLength : int
      member LexemeView : System.ReadOnlySpan<'Char>
      member StartPos : Position
    end
  module GenericImplFragments = begin
    val startInterpret : lexBuffer:LexBuffer<char> -> unit
    val afterRefill :
      trans:uint16 [] [] * sentinel:int * lexBuffer:LexBuffer<char> *
      scanUntilSentinel:(LexBuffer<char> -> int -> 'a) * endOfScan:(unit -> 'a) *
      state:int * eofPos:int -> 'a
    val onAccept : lexBuffer:LexBuffer<char> * a:int -> unit
  end
  [<SealedAttribute ()>]
  type internal UnicodeTables =
    class
      new : trans:uint16 [] array * accept:uint16 [] -> UnicodeTables
      static member Create : uint16 [] array * uint16 [] -> UnicodeTables
      member Interpret : initialState:int * LexBuffer<char> -> int
    end

namespace Internal.Utilities.Text.Parsing
  exception RecoverableParseError
  exception Accept of obj
  [<SealedAttribute ()>]
  type internal IParseState =
    class
      new : ruleStartPoss:Lexing.Position [] * ruleEndPoss:Lexing.Position [] *
            lhsPos:Lexing.Position [] * ruleValues:obj [] *
            lexbuf:Lexing.LexBuffer<char> -> IParseState
      member GetInput : index:int -> obj
      member InputEndPosition : index:int -> Lexing.Position
      member InputRange : index:int -> Lexing.Position * Lexing.Position
      member InputStartPosition : index:int -> Lexing.Position
      member RaiseError : unit -> 'b
      member LexBuffer : Lexing.LexBuffer<char>
      member ResultEndPosition : Lexing.Position
      member ResultRange : Lexing.Position * Lexing.Position
      member ResultStartPosition : Lexing.Position
    end
  [<SealedAttribute ()>]
  type internal ParseErrorContext<'tok> =
    class
      new : stateStack:int list * parseState:IParseState * reduceTokens:int list *
            currentToken:'tok option * reducibleProductions:int list list *
            shiftableTokens:int list * message:string -> ParseErrorContext<'tok>
      member CurrentToken : 'tok option
      member Message : string
      member ParseState : IParseState
      member ReduceTokens : int list
      member ReducibleProductions : int list list
      member ShiftTokens : int list
      member StateStack : int list
    end
  type internal Tables<'tok> =
    { reductions: (IParseState -> obj) []
      endOfInputTag: int
      tagOfToken: 'tok -> int
      dataOfToken: 'tok -> obj
      actionTableElements: uint16 []
      actionTableRowOffsets: uint16 []
      reductionSymbolCounts: uint16 []
      immediateActions: uint16 []
      gotos: uint16 []
      sparseGotoTableRowOffsets: uint16 []
      stateToProdIdxsTableElements: uint16 []
      stateToProdIdxsTableRowOffsets: uint16 []
      productionToNonTerminalTable: uint16 []
      parseError: ParseErrorContext<'tok> -> unit
      numTerminals: int
      tagOfErrorTerminal: int }
    with
      member
        Interpret : lexer:(Lexing.LexBuffer<char> -> 'tok) *
                    lexbuf:Lexing.LexBuffer<char> * initialState:int -> obj
    end
  type Stack<'a> =
    class
      new : n:int -> Stack<'a>
      member Ensure : newSize:int -> unit
      member Peep : unit -> 'a
      member Pop : unit -> unit
      member PrintStack : unit -> unit
      member Push : x:'a -> unit
      member Top : n:int -> 'a list
      member Count : int
      member IsEmpty : bool
    end
  module Flags = begin
    val mutable debug : bool
  end
  module internal Implementation = begin
    val anyMarker : int
    val shiftFlag : int
    val reduceFlag : int
    val errorFlag : int
    val acceptFlag : int
    val actionMask : int
    val actionValue : action:int -> int
    val actionKind : action:int -> int
    type AssocTable =
      class
        new : elemTab:uint16 [] * offsetTab:uint16 [] * cache:int [] *
              cacheSize:int -> AssocTable
        member Read : rowNumber:int * keyToFind:int -> int
        member ReadAll : n:int -> (int * int) list * int
        member
          ReadAssoc : minElemNum:int * maxElemNum:int * defaultValueOfAssoc:int *
                      keyToFind:int -> int
      end
    type IdxToIdxListTable =
      class
        new : elemTab:uint16 [] * offsetTab:uint16 [] -> IdxToIdxListTable
        member ReadAll : n:int -> int list
      end
    [<NoEqualityAttribute (); NoComparisonAttribute (); StructAttribute ()>]
    type ValueInfo =
      struct
        new : value:obj * startPos:Lexing.Position * endPos:Lexing.Position ->
                ValueInfo
        val value: obj
        val startPos: Lexing.Position
        val endPos: Lexing.Position
      end
    val interpret :
      tables:Tables<'tok> ->
        lexer:(Lexing.LexBuffer<char> -> 'tok) ->
          lexbuf:Lexing.LexBuffer<char> -> initialState:int -> obj
  end
  module internal ParseHelpers = begin
    val parse_error : string -> unit
    val parse_error_rich : (ParseErrorContext<'tok> -> unit) option
  end

namespace Internal.Utilities
  module internal ResizeArray = begin
    val length : ResizeArray<'T> -> int
    val get : ResizeArray<'T> -> int -> 'T
    val set : ResizeArray<'T> -> int -> 'T -> unit
    val create : int -> 'T -> ResizeArray<'T>
    val init : int -> (int -> 'T) -> ResizeArray<'T>
    val blit : ResizeArray<'T> -> int -> ResizeArray<'T> -> int -> int -> unit
    val concat : ResizeArray<'T> list -> ResizeArray<'T>
    val append : ResizeArray<'T> -> ResizeArray<'T> -> ResizeArray<'T>
    val sub : ResizeArray<'T> -> int -> int -> ResizeArray<'T>
    val fill : ResizeArray<'T> -> int -> int -> 'T -> unit
    val copy : ResizeArray<'T> -> ResizeArray<'T>
    val toList : ResizeArray<'T> -> 'T list
    val ofList : 'T list -> ResizeArray<'T>
    val iter : ('T -> unit) -> ResizeArray<'T> -> unit
    val map : ('T -> 'U) -> ResizeArray<'T> -> ResizeArray<'U>
    val mapi : (int -> 'T -> 'U) -> ResizeArray<'T> -> ResizeArray<'U>
    val iteri : (int -> 'T -> unit) -> ResizeArray<'T> -> unit
    val exists : ('T -> bool) -> ResizeArray<'T> -> bool
    val forall : ('T -> bool) -> ResizeArray<'T> -> bool
    val indexNotFound : unit -> 'a
    val find : ('T -> bool) -> ResizeArray<'T> -> 'T
    val tryPick : ('T -> 'U option) -> ResizeArray<'T> -> 'U option
    val tryFind : ('T -> bool) -> ResizeArray<'T> -> 'T option
    val iter2 : ('T -> 'U -> unit) -> ResizeArray<'T> -> ResizeArray<'U> -> unit
    val map2 :
      ('T -> 'U -> 'c) -> ResizeArray<'T> -> ResizeArray<'U> -> ResizeArray<'c>
    val choose : ('T -> 'U option) -> ResizeArray<'T> -> ResizeArray<'U>
    val filter : ('T -> bool) -> ResizeArray<'T> -> ResizeArray<'T>
    val partition :
      ('T -> bool) -> ResizeArray<'T> -> ResizeArray<'T> * ResizeArray<'T>
    val rev : ResizeArray<'T> -> ResizeArray<'T>
    val foldBack : ('T -> 'U -> 'U) -> ResizeArray<'T> -> 'U -> 'U
    val fold : ('T -> 'U -> 'T) -> 'T -> ResizeArray<'U> -> 'T
    val toArray : ResizeArray<'T> -> 'T []
    val ofArray : 'T [] -> ResizeArray<'T>
    val toSeq : ResizeArray<'T> -> seq<'T>
    val sort : ('T -> 'T -> int) -> ResizeArray<'T> -> unit
    val sortBy : ('T -> 'Key) -> ResizeArray<'T> -> unit when 'Key : comparison
    val exists2 :
      ('T -> 'U -> bool) -> ResizeArray<'T> -> ResizeArray<'U> -> bool
    val findIndex : ('T -> bool) -> ResizeArray<'T> -> int
    val findIndexi : (int -> 'T -> bool) -> ResizeArray<'T> -> int
    val foldSub :
      f:('a -> 'b -> 'a) ->
        acc:'a -> arr:ResizeArray<'b> -> start:int -> fin:int -> 'a
    val foldBackSub :
      f:('a -> 'b -> 'b) ->
        arr:ResizeArray<'a> -> start:int -> fin:int -> acc:'b -> 'b
    val reduce : ('T -> 'T -> 'T) -> ResizeArray<'T> -> 'T
    val reduceBack : ('T -> 'T -> 'T) -> ResizeArray<'T> -> 'T
    val fold2 :
      ('state -> 'b1 -> 'b2 -> 'state) ->
        'state -> ResizeArray<'b1> -> ResizeArray<'b2> -> 'state
    val foldBack2 :
      ('a1 -> 'a2 -> 'U -> 'U) ->
        ResizeArray<'a1> -> ResizeArray<'a2> -> 'U -> 'U
    val forall2 :
      ('T -> 'U -> bool) -> ResizeArray<'T> -> ResizeArray<'U> -> bool
    val isEmpty : ResizeArray<'T> -> bool
    val iteri2 :
      (int -> 'T -> 'U -> unit) -> ResizeArray<'T> -> ResizeArray<'U> -> unit
    val mapi2 :
      (int -> 'T -> 'U -> 'c) ->
        ResizeArray<'T> -> ResizeArray<'U> -> ResizeArray<'c>
    val scanBackSub :
      f:('T -> 'a -> 'a) ->
        arr:ResizeArray<'T> -> start:int -> fin:int -> acc:'a -> ResizeArray<'a>
    val scanSub :
      f:('a -> 'T -> 'a) ->
        acc:'a -> arr:ResizeArray<'T> -> start:int -> fin:int -> ResizeArray<'a>
    val scan : ('U -> 'T -> 'U) -> 'U -> ResizeArray<'T> -> ResizeArray<'U>
    val scanBack : ('T -> 'c -> 'c) -> ResizeArray<'T> -> 'c -> ResizeArray<'c>
    val singleton : 'T -> ResizeArray<'T>
    val tryFindIndex : ('T -> bool) -> ResizeArray<'T> -> int option
    val tryFindIndexi : (int -> 'T -> bool) -> ResizeArray<'T> -> int option
    val zip : ResizeArray<'T> -> ResizeArray<'U> -> ResizeArray<'T * 'U>
    val unzip : ResizeArray<'T * 'U> -> ResizeArray<'T> * ResizeArray<'U>
  end

namespace Internal.Utilities.Collections
  [<SealedAttribute ()>]
  type internal HashMultiMap<'Key,'Value> =
    class
      interface
        System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<'Key,
                                                                                       'Value>>
      interface System.Collections.Generic.IDictionary<'Key,'Value>
      interface System.Collections.IEnumerable
      interface
        System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<'Key,
                                                                                       'Value>>
      new : entries:seq<'Key * 'Value> *
            comparer:System.Collections.Generic.IEqualityComparer<'Key> ->
              HashMultiMap<'Key,'Value>
      new : comparer:System.Collections.Generic.IEqualityComparer<'Key> ->
              HashMultiMap<'Key,'Value>
      new : size:int *
            comparer:System.Collections.Generic.IEqualityComparer<'Key> ->
              HashMultiMap<'Key,'Value>
      member Add : 'Key * 'Value -> unit
      member Clear : unit -> unit
      member Contains : y:'Key -> bool
      member ContainsKey : 'Key -> bool
      member Copy : unit -> HashMultiMap<'Key,'Value>
      member FindAll : 'Key -> 'Value list
      member Fold : ('Key -> 'Value -> 'State -> 'State) -> 'State -> 'State
      member GetRest : k:'Key -> 'Value list
      member Iterate : ('Key -> 'Value -> unit) -> unit
      member Remove : 'Key -> unit
      member Replace : 'Key * 'Value -> unit
      member TryFind : 'Key -> 'Value option
      member Count : int
      member FirstEntries : System.Collections.Generic.Dictionary<'Key,'Value>
      member Item : 'Key -> 'Value with get
      member Rest : System.Collections.Generic.Dictionary<'Key,'Value list>
    end

namespace Internal.Utilities
  module internal EditDistance = begin
    val inline existsInWin :
      mChar:char -> str:string -> offset:int -> rad:int -> bool
    val jaro : s1:string -> s2:string -> float
    val JaroWinklerDistance : s1:string -> s2:string -> float
    val private calcDamerauLevenshtein : a:string * b:string -> int
    val CalcEditDistance : a:string * b:string -> int
  end

namespace Internal.Utilities.Collections.Tagged
  [<NoEqualityAttribute (); NoComparisonAttribute ();
    AllowNullLiteralAttribute ()>]
  type internal SetTree<'T> =
    class
      new : k:'T -> SetTree<'T>
      member Key : 'T
    end
  [<NoEqualityAttribute (); NoComparisonAttribute (); SealedAttribute ();
    AllowNullLiteralAttribute ()>]
  type internal SetTreeNode<'T> =
    class
      inherit SetTree<'T>
      new : v:'T * left:SetTree<'T> * right:SetTree<'T> * h:int ->
              SetTreeNode<'T>
      member Height : int
      member Left : SetTree<'T>
      member Right : SetTree<'T>
    end
  module SetTree = begin
    val empty : 'a when 'a : null
    val inline isEmpty : t:SetTree<'T> -> bool
    val countAux : t:SetTree<'T> -> acc:int -> int
    val count : s:SetTree<'a> -> int
    val inline height : t:SetTree<'T> -> int
    [<LiteralAttribute ()>]
    val tolerance : int = 2
    val mk : l:SetTree<'T> -> k:'T -> r:SetTree<'T> -> SetTree<'T>
    val inline private asNode : value:SetTree<'T> -> SetTreeNode<'T>
    val rebalance : t1:SetTree<'a> -> v:'a -> t2:SetTree<'a> -> SetTree<'a>
    val add :
      comparer:System.Collections.Generic.IComparer<'T> ->
        k:'T -> t:SetTree<'T> -> SetTree<'T>
    val balance :
      comparer:System.Collections.Generic.IComparer<'T> ->
        t1:SetTree<'T> -> k:'T -> t2:SetTree<'T> -> SetTree<'T>
    val split :
      comparer:System.Collections.Generic.IComparer<'T> ->
        pivot:'T -> t:SetTree<'T> -> SetTree<'T> * bool * SetTree<'T>
    val spliceOutSuccessor : t:SetTree<'T> -> 'T * SetTree<'T>
    val remove :
      comparer:System.Collections.Generic.IComparer<'T> ->
        k:'T -> t:SetTree<'T> -> SetTree<'T>
    val contains :
      comparer:System.Collections.Generic.IComparer<'T> ->
        k:'T -> t:SetTree<'T> -> bool
    val iter : f:('T -> unit) -> t:SetTree<'T> -> unit
    val fold : f:('T -> 'a -> 'a) -> t:SetTree<'T> -> x:'a -> 'a
    val forall : f:('T -> bool) -> t:SetTree<'T> -> bool
    val exists : f:('T -> bool) -> t:SetTree<'T> -> bool
    val subset :
      comparer:System.Collections.Generic.IComparer<'a> ->
        a:SetTree<'a> -> b:SetTree<'a> -> bool
    val filterAux :
      comparer:System.Collections.Generic.IComparer<'T> ->
        f:('T -> bool) -> t:SetTree<'T> -> acc:SetTree<'T> -> SetTree<'T>
    val filter :
      comparer:System.Collections.Generic.IComparer<'a> ->
        f:('a -> bool) -> s:SetTree<'a> -> SetTree<'a>
    val diffAux :
      comparer:System.Collections.Generic.IComparer<'T> ->
        t:SetTree<'T> -> acc:SetTree<'T> -> SetTree<'T>
    val diff :
      comparer:System.Collections.Generic.IComparer<'a> ->
        a:SetTree<'a> -> b:SetTree<'a> -> SetTree<'a>
    val union :
      comparer:System.Collections.Generic.IComparer<'T> ->
        t1:SetTree<'T> -> t2:SetTree<'T> -> SetTree<'T>
    val intersectionAux :
      comparer:System.Collections.Generic.IComparer<'T> ->
        b:SetTree<'T> -> t:SetTree<'T> -> acc:SetTree<'T> -> SetTree<'T>
    val intersection :
      comparer:System.Collections.Generic.IComparer<'a> ->
        a:SetTree<'a> -> b:SetTree<'a> -> SetTree<'a>
    val partition1 :
      comparer:System.Collections.Generic.IComparer<'a> ->
        f:('a -> bool) ->
          k:'a ->
            acc1:SetTree<'a> * acc2:SetTree<'a> -> SetTree<'a> * SetTree<'a>
    val partitionAux :
      comparer:System.Collections.Generic.IComparer<'T> ->
        f:('T -> bool) ->
          t:SetTree<'T> ->
            SetTree<'T> * SetTree<'T> -> SetTree<'T> * SetTree<'T>
    val partition :
      comparer:System.Collections.Generic.IComparer<'a> ->
        f:('a -> bool) -> s:SetTree<'a> -> SetTree<'a> * SetTree<'a>
    val minimumElementAux : t:SetTree<'T> -> n:'T -> 'T
    val minimumElementOpt : t:SetTree<'T> -> 'T option
    val maximumElementAux : t:SetTree<'T> -> n:'T -> 'T
    val maximumElementOpt : t:SetTree<'T> -> 'T option
    val minimumElement : s:SetTree<'a> -> 'a
    val maximumElement : s:SetTree<'a> -> 'a
    type SetIterator<'T> =
      class
        new : s:SetTree<'T> -> SetTree.SetIterator<'T>
        member MoveNext : unit -> bool
        member Current : 'T
      end
    val toSeq : s:SetTree<'a> -> System.Collections.Generic.IEnumerator<'a>
    val compareStacks :
      comparer:System.Collections.Generic.IComparer<'T> ->
        l1:SetTree<'T> list -> l2:SetTree<'T> list -> int
    val compare :
      comparer:System.Collections.Generic.IComparer<'T> ->
        t1:SetTree<'T> -> t2:SetTree<'T> -> int
    val choose : s:SetTree<'a> -> 'a
    val toList : t:SetTree<'T> -> 'T list
    val copyToArray : s:SetTree<'a> -> arr:'a [] -> i:int -> unit
    val toArray : s:SetTree<'a> -> 'a []
    val mkFromEnumerator :
      comparer:System.Collections.Generic.IComparer<'a> ->
        acc:SetTree<'a> ->
          e:System.Collections.Generic.IEnumerator<'a> -> SetTree<'a>
    val ofSeq :
      comparer:System.Collections.Generic.IComparer<'a> ->
        c:System.Collections.Generic.IEnumerable<'a> -> SetTree<'a>
    val ofArray :
      comparer:System.Collections.Generic.IComparer<'a> ->
        l:'a [] -> SetTree<'a>
  end
  [<SealedAttribute (); System.Diagnostics.DebuggerDisplay ("Count = {Count}")>]
  type internal Set<'T,'ComparerTag
                      when 'ComparerTag :>
                                          System.Collections.Generic.IComparer<'T>> =
    class
      interface System.Collections.IEnumerable
      interface System.Collections.Generic.IEnumerable<'T>
      interface System.Collections.Generic.ICollection<'T>
      interface System.IComparable
      new : comparer:System.Collections.Generic.IComparer<'T> * tree:SetTree<'T> ->
              Set<'T,'ComparerTag>
      static member
        ( + ) : Set<'T,'ComparerTag> * Set<'T,'ComparerTag> ->
                  Set<'T,'ComparerTag>
      static member
        ( - ) : Set<'T,'ComparerTag> * Set<'T,'ComparerTag> ->
                  Set<'T,'ComparerTag>
      static member
        Compare : a:Set<'T,'ComparerTag> * b:Set<'T,'ComparerTag> -> int
      static member Create : 'ComparerTag * seq<'T> -> Set<'T,'ComparerTag>
      static member
        Difference : Set<'T,'ComparerTag> * Set<'T,'ComparerTag> ->
                       Set<'T,'ComparerTag>
      static member Empty : 'ComparerTag -> Set<'T,'ComparerTag>
      static member
        Equality : Set<'T,'ComparerTag> * Set<'T,'ComparerTag> -> bool
      static member
        Intersection : Set<'T,'ComparerTag> * Set<'T,'ComparerTag> ->
                         Set<'T,'ComparerTag>
      static member Singleton : 'ComparerTag * 'T -> Set<'T,'ComparerTag>
      static member
        Union : Set<'T,'ComparerTag> * Set<'T,'ComparerTag> ->
                  Set<'T,'ComparerTag>
      member Add : 'T -> Set<'T,'ComparerTag>
      member ComputeHashCode : unit -> int
      member Contains : 'T -> bool
      override Equals : obj -> bool
      member Exists : predicate:('T -> bool) -> bool
      member Filter : predicate:('T -> bool) -> Set<'T,'ComparerTag>
      member Fold : ('T -> 'State -> 'State) -> 'State -> 'State
      member ForAll : predicate:('T -> bool) -> bool
      override GetHashCode : unit -> int
      member IsSubsetOf : Set<'T,'ComparerTag> -> bool
      member IsSupersetOf : Set<'T,'ComparerTag> -> bool
      member Iterate : ('T -> unit) -> unit
      member
        Partition : predicate:('T -> bool) ->
                      Set<'T,'ComparerTag> * Set<'T,'ComparerTag>
      member Remove : 'T -> Set<'T,'ComparerTag>
      member ToArray : unit -> 'T []
      member ToList : unit -> 'T list
      member Choose : 'T
      member Comparer : System.Collections.Generic.IComparer<'T>
      member Count : int
      member IsEmpty : bool
      member MaximumElement : 'T
      member MinimumElement : 'T
      member Tree : SetTree<'T>
    end
  [<NoEqualityAttribute (); NoComparisonAttribute ();
    AllowNullLiteralAttribute ()>]
  type internal MapTree<'Key,'Value> =
    class
      new : k:'Key * v:'Value -> MapTree<'Key,'Value>
      member Key : 'Key
      member Value : 'Value
    end
  [<NoEqualityAttribute (); NoComparisonAttribute (); SealedAttribute ();
    AllowNullLiteralAttribute ()>]
  type internal MapTreeNode<'Key,'Value> =
    class
      inherit MapTree<'Key,'Value>
      new : k:'Key * v:'Value * left:MapTree<'Key,'Value> *
            right:MapTree<'Key,'Value> * h:int -> MapTreeNode<'Key,'Value>
      member Height : int
      member Left : MapTree<'Key,'Value>
      member Right : MapTree<'Key,'Value>
    end
  module MapTree = begin
    val empty : 'a when 'a : null
    val inline isEmpty : m:MapTree<'Key,'Value> -> bool
    val sizeAux : acc:int -> m:MapTree<'Key,'Value> -> int
    val size : x:MapTree<'a,'b> -> int
    val inline height : m:MapTree<'Key,'Value> -> int
    val mk :
      l:MapTree<'Key,'Value> ->
        k:'Key -> v:'Value -> r:MapTree<'Key,'Value> -> MapTree<'Key,'Value>
    val inline private asNode :
      value:MapTree<'Key,'Value> -> MapTreeNode<'Key,'Value>
    val rebalance :
      t1:MapTree<'Key,'Value> ->
        k:'Key -> v:'Value -> t2:MapTree<'Key,'Value> -> MapTree<'Key,'Value>
    val add :
      comparer:System.Collections.Generic.IComparer<'Key> ->
        k:'Key -> v:'Value -> m:MapTree<'Key,'Value> -> MapTree<'Key,'Value>
    val indexNotFound : unit -> 'a
    val tryGetValue :
      comparer:System.Collections.Generic.IComparer<'Key> ->
        k:'Key -> v:byref<'Value> -> m:MapTree<'Key,'Value> -> bool
    val find :
      comparer:System.Collections.Generic.IComparer<'Key> ->
        k:'Key -> m:MapTree<'Key,'Value> -> 'Value
    val tryFind :
      comparer:System.Collections.Generic.IComparer<'Key> ->
        k:'Key -> m:MapTree<'Key,'Value> -> 'Value option
    val partition1 :
      comparer:System.Collections.Generic.IComparer<'Key> ->
        f:OptimizedClosures.FSharpFunc<'Key,'a,bool> ->
          k:'Key ->
            v:'a ->
              acc1:MapTree<'Key,'a> * acc2:MapTree<'Key,'a> ->
                MapTree<'Key,'a> * MapTree<'Key,'a>
    val partitionAux :
      comparer:System.Collections.Generic.IComparer<'Key> ->
        f:OptimizedClosures.FSharpFunc<'Key,'Value,bool> ->
          m:MapTree<'Key,'Value> ->
            MapTree<'Key,'Value> * MapTree<'Key,'Value> ->
              MapTree<'Key,'Value> * MapTree<'Key,'Value>
    val partition :
      comparer:System.Collections.Generic.IComparer<'Key> ->
        f:('Key -> 'a -> bool) ->
          m:MapTree<'Key,'a> -> MapTree<'Key,'a> * MapTree<'Key,'a>
    val filter1 :
      comparer:System.Collections.Generic.IComparer<'Key> ->
        f:OptimizedClosures.FSharpFunc<'Key,'a,bool> ->
          k:'Key -> v:'a -> acc:MapTree<'Key,'a> -> MapTree<'Key,'a>
    val filterAux :
      comparer:System.Collections.Generic.IComparer<'Key> ->
        f:OptimizedClosures.FSharpFunc<'Key,'Value,bool> ->
          m:MapTree<'Key,'Value> ->
            acc:MapTree<'Key,'Value> -> MapTree<'Key,'Value>
    val filter :
      comparer:System.Collections.Generic.IComparer<'Key> ->
        f:('Key -> 'a -> bool) -> m:MapTree<'Key,'a> -> MapTree<'Key,'a>
    val spliceOutSuccessor :
      m:MapTree<'Key,'Value> -> 'Key * 'Value * MapTree<'Key,'Value>
    val remove :
      comparer:System.Collections.Generic.IComparer<'Key> ->
        k:'Key -> m:MapTree<'Key,'Value> -> MapTree<'Key,'Value>
    val mem :
      comparer:System.Collections.Generic.IComparer<'Key> ->
        k:'Key -> m:MapTree<'Key,'Value> -> bool
    val iterOpt :
      f:OptimizedClosures.FSharpFunc<'Key,'Value,unit> ->
        m:MapTree<'Key,'Value> -> unit
    val iter : f:('a -> 'b -> unit) -> m:MapTree<'a,'b> -> unit
    val tryPickOpt :
      f:OptimizedClosures.FSharpFunc<'Key,'Value,'a option> ->
        m:MapTree<'Key,'Value> -> 'a option
    val tryPick : f:('a -> 'b -> 'c option) -> m:MapTree<'a,'b> -> 'c option
    val existsOpt :
      f:OptimizedClosures.FSharpFunc<'Key,'Value,bool> ->
        m:MapTree<'Key,'Value> -> bool
    val exists : f:('a -> 'b -> bool) -> m:MapTree<'a,'b> -> bool
    val forallOpt :
      f:OptimizedClosures.FSharpFunc<'Key,'Value,bool> ->
        m:MapTree<'Key,'Value> -> bool
    val forall : f:('a -> 'b -> bool) -> m:MapTree<'a,'b> -> bool
    val map :
      f:('Value -> 'Result) -> m:MapTree<'Key,'Value> -> MapTree<'Key,'Result>
    val mapiOpt :
      f:OptimizedClosures.FSharpFunc<'Key,'Value,'Result> ->
        m:MapTree<'Key,'Value> -> MapTree<'Key,'Result>
    val mapi : f:('a -> 'b -> 'c) -> m:MapTree<'a,'b> -> MapTree<'a,'c>
    val foldBackOpt :
      f:OptimizedClosures.FSharpFunc<'Key,'Value,'a,'a> ->
        m:MapTree<'Key,'Value> -> x:'a -> 'a
    val foldBack : f:('a -> 'b -> 'c -> 'c) -> m:MapTree<'a,'b> -> x:'c -> 'c
    val foldSectionOpt :
      comparer:System.Collections.Generic.IComparer<'Key> ->
        lo:'Key ->
          hi:'Key ->
            f:OptimizedClosures.FSharpFunc<'Key,'Value,'a,'a> ->
              m:MapTree<'Key,'Value> -> x:'a -> 'a
    val foldSection :
      comparer:System.Collections.Generic.IComparer<'Key> ->
        lo:'Key ->
          hi:'Key ->
            f:('Key -> 'a -> 'b -> 'b) -> m:MapTree<'Key,'a> -> x:'b -> 'b
    val foldMapOpt :
      comparer:System.Collections.Generic.IComparer<'Key> ->
        f:OptimizedClosures.FSharpFunc<'Key,'Value,'a,('b * 'a)> ->
          m:MapTree<'Key,'Value> ->
            z:'a -> acc:MapTree<'Key,'b> -> MapTree<'Key,'b> * 'a
    val foldMap :
      comparer:System.Collections.Generic.IComparer<'Key> ->
        f:('Key -> 'Value -> 'a -> 'b * 'a) ->
          m:MapTree<'Key,'Value> ->
            z:'a -> acc:MapTree<'Key,'b> -> MapTree<'Key,'b> * 'a
    val toList : m:MapTree<'a,'b> -> ('a * 'b) list
    val toArray : m:MapTree<'a,'b> -> ('a * 'b) []
    val ofList :
      comparer:System.Collections.Generic.IComparer<'a> ->
        l:('a * 'b) list -> MapTree<'a,'b>
    val mkFromEnumerator :
      comparer:System.Collections.Generic.IComparer<'a> ->
        acc:MapTree<'a,'b> ->
          e:System.Collections.Generic.IEnumerator<'a * 'b> -> MapTree<'a,'b>
    val ofSeq :
      comparer:System.Collections.Generic.IComparer<'a> ->
        c:seq<'a * 'b> -> MapTree<'a,'b>
    val copyToArray :
      s:MapTree<'a,'b> ->
        arr:System.Collections.Generic.KeyValuePair<'a,'b> [] -> i:int -> unit
    type MapIterator<'Key,'Value> =
      class
        new : s:MapTree<'Key,'Value> -> MapTree.MapIterator<'Key,'Value>
        member MoveNext : unit -> bool
        member Current : System.Collections.Generic.KeyValuePair<'Key,'Value>
      end
    val toSeq :
      s:MapTree<'a,'b> ->
        System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<'a,
                                                                                       'b>>
  end
  [<SealedAttribute (); System.Diagnostics.DebuggerDisplay ("Count = {Count}")>]
  type internal Map<'Key,'Value,'ComparerTag
                      when 'ComparerTag :>
                                          System.Collections.Generic.IComparer<'Key>> =
    class
      interface System.IComparable
      interface System.Collections.IEnumerable
      interface
        System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<'Key,
                                                                                       'Value>>
      new : comparer:System.Collections.Generic.IComparer<'Key> *
            tree:MapTree<'Key,'Value> -> Map<'Key,'Value,'ComparerTag>
      static member
        Create : 'ComparerTag * seq<'Key * 'Value> ->
                   Map<'Key,'Value,'ComparerTag>
      static member Empty : 'ComparerTag -> Map<'Key,'Value,'ComparerTag>
      static member
        FromList : 'ComparerTag * ('Key * 'Value) list ->
                     Map<'Key,'Value,'ComparerTag>
      member Add : 'Key * 'Value -> Map<'Key,'Value,'ComparerTag>
      member ComputeHashCode : unit -> int
      member ContainsKey : 'Key -> bool
      override Equals : obj -> bool
      member Exists : ('Key -> 'Value -> bool) -> bool
      member Filter : ('Key -> 'Value -> bool) -> Map<'Key,'Value,'ComparerTag>
      member First : ('Key -> 'Value -> 'T option) -> 'T option
      member
        Fold : folder:('Key -> 'Value -> 'State -> 'State) -> 'State -> 'State
      member
        FoldAndMap : ('Key -> 'Value -> 'State -> 'T * 'State) ->
                       'State -> Map<'Key,'T,'ComparerTag> * 'State
      member
        FoldSection : 'Key ->
                        'Key ->
                          ('Key -> 'Value -> 'State -> 'State) ->
                            'State -> 'State
      member ForAll : ('Key -> 'Value -> bool) -> bool
      override GetHashCode : unit -> int
      member Iterate : action:('Key -> 'Value -> unit) -> unit
      member Map : mapping:('Key -> 'Value -> 'T) -> Map<'Key,'T,'ComparerTag>
      member MapRange : mapping:('Value -> 'T) -> Map<'Key,'T,'ComparerTag>
      member
        Partition : ('Key -> 'Value -> bool) ->
                      Map<'Key,'Value,'ComparerTag> *
                      Map<'Key,'Value,'ComparerTag>
      member Remove : 'Key -> Map<'Key,'Value,'ComparerTag>
      member ToArray : unit -> ('Key * 'Value) []
      member ToList : unit -> ('Key * 'Value) list
      member TryFind : 'Key -> 'Value option
      member Comparer : System.Collections.Generic.IComparer<'Key>
      member Count : int
      member IsEmpty : bool
      member Item : 'Key -> 'Value with get
      member Tree : MapTree<'Key,'Value>
    end
  type internal Map<'Key,'Value> =
    Map<'Key,'Value,System.Collections.Generic.IComparer<'Key>>
  type internal Set<'T> = Set<'T,System.Collections.Generic.IComparer<'T>>

namespace FSharp.Compiler.AbstractIL
  module internal Diagnostics = begin
    val mutable diagnosticsLog : System.IO.TextWriter option
    val setDiagnosticsChannel : System.IO.TextWriter option -> unit
    val dflushn : unit -> unit
    val dflush : unit -> unit
    val dprintn : string -> unit
    val dprintf : Format<'a,System.IO.TextWriter,unit,unit> -> 'a
    val dprintfn : Format<'a,System.IO.TextWriter,unit,unit> -> 'a
  end

namespace FSharp.Compiler.AbstractIL.Internal
  module Library = begin
    val ( >>>& ) : x:int32 -> n:int32 -> int32
    val notlazy : v:'a -> System.Lazy<'a>
    val inline isNil : l:'a list -> bool
    val inline isNilOrSingleton : l:'a list -> bool
    val inline isSingleton : l:'a list -> bool
    val inline isNonNull : x:'a -> bool when 'a : null
    val inline nonNull : msg:string -> x:'a -> 'a when 'a : null
    val inline ( === ) : x:'a -> y:'a -> bool when 'a : not struct
    val LOH_SIZE_THRESHOLD_BYTES : int
    val reportTime : (bool -> string -> unit)
    [<StructAttribute ()>]
    type InlineDelayInit<'T when 'T : not struct> =
      struct
        new : f:(unit -> 'T) -> InlineDelayInit<'T>
        val mutable store: 'T
        val mutable func: System.Func<'T>
        member Value : 'T
      end
    val foldOn : p:('a -> 'b) -> f:('c -> 'b -> 'd) -> z:'c -> x:'a -> 'd
    val notFound : unit -> 'a
    module Order = begin
      val orderBy :
        p:('T -> 'U) -> System.Collections.Generic.IComparer<'T>
          when 'U : comparison
      val orderOn :
        p:('T -> 'U) ->
          pxOrder:System.Collections.Generic.IComparer<'U> ->
            System.Collections.Generic.IComparer<'T>
      val toFunction :
        pxOrder:System.Collections.Generic.IComparer<'U> -> x:'U -> y:'U -> int
    end
    module Array = begin
      val mapq : f:('a -> 'a) -> inp:'a [] -> 'a [] when 'a : not struct
      val lengthsEqAndForall2 :
        p:('a -> 'b -> bool) -> l1:'a [] -> l2:'b [] -> bool
      val order :
        eltOrder:System.Collections.Generic.IComparer<'T> ->
          System.Collections.Generic.IComparer<'T array>
      val existsOne : p:('a -> bool) -> l:'a [] -> bool
      val existsTrue : arr:bool [] -> bool
      val findFirstIndexWhereTrue : arr:'a [] -> p:('a -> bool) -> int
      val revInPlace : array:'T [] -> unit
      val mapAsync : mapping:('T -> Async<'U>) -> array:'T [] -> Async<'U []>
      val replace : index:int -> value:'a -> array:'a [] -> 'a []
      val inline areEqual : xs:'T [] -> ys:'T [] -> bool when 'T : equality
      val heads : array:'T [] -> 'T [] []
      val inline isSubArray :
        subArray:'T [] -> wholeArray:'T [] -> index:int -> bool
          when 'T : equality
      val startsWith : prefix:'a [] -> whole:'a [] -> bool when 'a : equality
      val endsWith : suffix:'a [] -> whole:'a [] -> bool when 'a : equality
    end
    module Option = begin
      val mapFold :
        f:('a -> 'b -> 'c * 'a) -> s:'a -> opt:'b option -> 'c option * 'a
      val attempt : f:(unit -> 'T) -> 'T option
    end
    module List = begin
      val sortWithOrder :
        c:System.Collections.Generic.IComparer<'T> ->
          elements:'T list -> 'T list
      val splitAfter : n:int -> l:'a list -> 'a list * 'a list
      val existsi : f:(int -> 'a -> bool) -> xs:'a list -> bool
      val lengthsEqAndForall2 :
        p:('a -> 'b -> bool) -> l1:'a list -> l2:'b list -> bool
      val findi : n:int -> f:('a -> bool) -> l:'a list -> ('a * int) option
      val splitChoose :
        select:('a -> Choice<'b,'c>) -> l:'a list -> 'b list * 'c list
      val checkq : l1:'a list -> l2:'a list -> bool when 'a : not struct
      val mapq : f:('T -> 'T) -> inp:'T list -> 'T list when 'T : not struct
      val frontAndBack : l:'a list -> 'a list * 'a
      val tryRemove : f:('a -> bool) -> inp:'a list -> ('a * 'a list) option
      val zip4 :
        l1:'a list ->
          l2:'b list -> l3:'c list -> l4:'d list -> ('a * 'b * 'c * 'd) list
      val unzip4 :
        l:('a * 'b * 'c * 'd) list -> 'a list * 'b list * 'c list * 'd list
      val iter3 :
        f:('a -> 'b -> 'c -> unit) ->
          l1:'a list -> l2:'b list -> l3:'c list -> unit
      val takeUntil : p:('a -> bool) -> l:'a list -> 'a list * 'a list
      val order :
        eltOrder:System.Collections.Generic.IComparer<'T> ->
          System.Collections.Generic.IComparer<'T list>
      val indexNotFound : unit -> 'a
      val assoc : x:'a -> l:('a * 'b) list -> 'b when 'a : equality
      val memAssoc : x:'a -> l:('a * 'b) list -> bool when 'a : equality
      val memq : x:'a -> l:'a list -> bool when 'a : not struct
      val mapNth : n:int -> f:('a -> 'a) -> xs:'a list -> 'a list
      val count : pred:('a -> bool) -> xs:'a list -> int
      val headAndTail : l:'a list -> 'a * 'a list
      val mapHeadTail :
        fhead:('a -> 'b) -> ftail:('a -> 'b) -> _arg1:'a list -> 'b list
      val collectFold :
        f:('a -> 'b -> 'c list * 'a) -> s:'a -> l:'b list -> 'c list * 'a
      val collect2 :
        f:('a -> 'b -> 'c list) -> xs:'a list -> ys:'b list -> 'c list
      val toArraySquared : xss:'a list list -> 'a [] []
      val iterSquared : f:('a -> unit) -> xss:'a list list -> unit
      val collectSquared : f:('a -> 'b list) -> xss:'a list list -> 'b list
      val mapSquared : f:('a -> 'b) -> xss:'a list list -> 'b list list
      val mapFoldSquared :
        f:('a -> 'b -> 'c * 'a) -> z:'a -> xss:'b list list -> 'c list list * 'a
      val forallSquared : f:('a -> bool) -> xss:'a list list -> bool
      val mapiSquared :
        f:(int -> int -> 'a -> 'b) -> xss:'a list list -> 'b list list
      val existsSquared : f:('a -> bool) -> xss:'a list list -> bool
      val mapiFoldSquared :
        f:('a -> int * int * 'b -> 'c * 'a) ->
          z:'a -> xss:'b list list -> 'c list list * 'a
      val duplicates : xs:'T list -> 'T list when 'T : equality
      val internal allEqual : xs:'T list -> bool when 'T : equality
    end
    module ResizeArray = begin
      val chunkBySize :
        chunkSize:int -> f:('t -> 'a) -> items:ResizeArray<'t> -> 'a [] []
      val mapToSmallArrayChunks :
        f:('t -> 'a) -> inp:ResizeArray<'t> -> 'a [] []
    end
    module ValueOptionInternal = begin
      val inline ofOption : x:'a option -> 'a voption
      val inline bind : f:('a -> 'b voption) -> x:'a voption -> 'b voption
    end
    type String with
      member StartsWithOrdinal : value:string -> bool
    type String with
      member EndsWithOrdinal : value:string -> bool
    module String = begin
      val make : n:int -> c:char -> string
      val get : str:string -> i:int -> char
      val sub : s:string -> start:int -> len:int -> string
      val contains : s:string -> c:char -> bool
      val order : System.Collections.Generic.IComparer<string>
      val lowercase : s:string -> string
      val uppercase : s:string -> string
      val isLeadingIdentifierCharacterUpperCase : s:string -> bool
      val capitalize : s:string -> string
      val uncapitalize : s:string -> string
      val dropPrefix : s:string -> t:string -> string
      val dropSuffix : s:string -> t:string -> string
      val inline toCharArray : str:string -> char []
      val lowerCaseFirstChar : str:string -> string
      val extractTrailingIndex : str:string -> string * int option
      val trim : value:string -> string
      val split :
        options:System.StringSplitOptions ->
          separator:string [] -> value:string -> string []
      val ( |StartsWith|_| ) : pattern:string -> value:string -> unit option
      val ( |Contains|_| ) : pattern:string -> value:string -> unit option
      val getLines : str:string -> string []
    end
    module Dictionary = begin
      val inline newWithSize :
        size:int -> System.Collections.Generic.Dictionary<'a,'b>
          when 'a : equality
    end
    [<System.Runtime.CompilerServices.Extension (); ClassAttribute ()>]
    type DictionaryExtensions =
      class
        new : unit -> DictionaryExtensions
        [<System.Runtime.CompilerServices.Extension ()>]
        static member
          BagAdd : dic:System.Collections.Generic.Dictionary<'key,'value list> *
                   key:'key * value:'value -> unit
        [<System.Runtime.CompilerServices.Extension ()>]
        static member
          BagExistsValueForKey : dic:System.Collections.Generic.Dictionary<'key,
                                                                           'value list> *
                                 key:'key * f:('value -> bool) -> bool
      end
    module Lazy = begin
      val force : x:System.Lazy<'T> -> 'T
    end
    type ExecutionToken
    type CompilationThreadToken =
      class
        interface ExecutionToken
        new : unit -> CompilationThreadToken
      end
    val RequireCompilationThread : _ctok:CompilationThreadToken -> unit
    val DoesNotRequireCompilerThreadTokenAndCouldPossiblyBeMadeConcurrent :
      _ctok:CompilationThreadToken -> unit
    val AssumeCompilationThreadWithoutEvidence : unit -> CompilationThreadToken
    type AnyCallerThreadToken =
      class
        interface ExecutionToken
        new : unit -> AnyCallerThreadToken
      end
    val AnyCallerThread : AnyCallerThreadToken
    type LockToken =
      interface
        inherit ExecutionToken
      end
    val AssumeLockWithoutEvidence : unit -> #LockToken
    type Lock<'LockTokenType when 'LockTokenType :> LockToken> =
      class
        new : unit -> Lock<'LockTokenType>
        member AcquireLock : f:('LockTokenType -> 'a) -> 'a
      end
    val getHole : r:'a option ref -> 'a
    module Map = begin
      val tryFindMulti :
        k:'a -> map:Map<'a,'b list> -> 'b list when 'a : comparison
    end
    type ResultOrException<'TResult> =
      | Result of 'TResult
      | Exception of System.Exception
    module ResultOrException = begin
      val success : a:'a -> ResultOrException<'a>
      val raze : b:exn -> ResultOrException<'a>
      val ( |?> ) :
        res:ResultOrException<'a> -> f:('a -> 'b) -> ResultOrException<'b>
      val ForceRaise : res:ResultOrException<'a> -> 'a
      val otherwise :
        f:(unit -> ResultOrException<'a>) ->
          x:ResultOrException<'a> -> ResultOrException<'a>
    end
    [<RequireQualifiedAccessAttribute ()>]
    type ValueOrCancelled<'TResult> =
      | Value of 'TResult
      | Cancelled of System.OperationCanceledException
    [<StructAttribute ()>]
    type Cancellable<'TResult> =
      | Cancellable of
        (System.Threading.CancellationToken -> ValueOrCancelled<'TResult>)
    module Cancellable = begin
      val run :
        ct:System.Threading.CancellationToken ->
          Cancellable<'a> -> ValueOrCancelled<'a>
      val bind :
        f:('a -> Cancellable<'b>) -> comp1:Cancellable<'a> -> Cancellable<'b>
      val map : f:('a -> 'b) -> oper:Cancellable<'a> -> Cancellable<'b>
      val ret : x:'a -> Cancellable<'a>
      val fold :
        f:('a -> 'b -> Cancellable<'a>) ->
          acc:'a -> seq:seq<'b> -> Cancellable<'a>
      val each :
        f:('a -> Cancellable<'b>) -> seq:seq<'a> -> Cancellable<'b list>
      val delay : f:(unit -> Cancellable<'T>) -> Cancellable<'T>
      val runWithoutCancellation : comp:Cancellable<'a> -> 'a
      val token : unit -> Cancellable<System.Threading.CancellationToken>
      val canceled : unit -> Cancellable<'a>
      val private catch : Cancellable<'a> -> Cancellable<Choice<'a,exn>>
      val tryFinally :
        e:Cancellable<'a> -> compensation:(unit -> unit) -> Cancellable<'a>
      val tryWith :
        e:Cancellable<'a> -> handler:(exn -> Cancellable<'a>) -> Cancellable<'a>
    end
    type CancellableBuilder =
      class
        new : unit -> CancellableBuilder
        member
          Bind : e:Cancellable<'k> * k:('k -> Cancellable<'l>) ->
                   Cancellable<'l>
        member
          Combine : e1:Cancellable<unit> * e2:Cancellable<'h> -> Cancellable<'h>
        member Delay : f:(unit -> Cancellable<'a>) -> Cancellable<'a>
        member
          For : es:seq<'f> * f:('f -> Cancellable<'g>) -> Cancellable<'g list>
        member Return : v:'j -> Cancellable<'j>
        member ReturnFrom : v:'i -> 'i
        member
          TryFinally : e:Cancellable<'b> * compensation:(unit -> unit) ->
                         Cancellable<'b>
        member
          TryWith : e:Cancellable<'e> * handler:(exn -> Cancellable<'e>) ->
                      Cancellable<'e>
        member
          Using : resource:'c * e:('c -> Cancellable<'d>) -> Cancellable<'d>
                    when 'c :> System.IDisposable
        member Zero : unit -> Cancellable<unit>
      end
    val cancellable : CancellableBuilder
    type Eventually<'T> =
      | Done of 'T
      | NotYetDone of (CompilationThreadToken -> Eventually<'T>)
    module Eventually = begin
      val box : e:Eventually<'a> -> Eventually<obj>
      val forceWhile :
        ctok:CompilationThreadToken ->
          check:(unit -> bool) -> e:Eventually<'a> -> 'a option
      val force : ctok:CompilationThreadToken -> e:Eventually<'a> -> 'a
      val repeatedlyProgressUntilDoneOrTimeShareOverOrCanceled :
        timeShareInMilliseconds:int64 ->
          ct:System.Threading.CancellationToken ->
            runner:(CompilationThreadToken ->
                      (#CompilationThreadToken -> Eventually<'b>) ->
                      Eventually<'b>) -> e:Eventually<'b> -> Eventually<'b>
      val forceAsync :
        runner:((CompilationThreadToken -> Eventually<'T>) ->
                  Async<Eventually<'T>>) -> e:Eventually<'T> -> Async<'T option>
      val bind : k:('a -> Eventually<'b>) -> e:Eventually<'a> -> Eventually<'b>
      val fold :
        f:('a -> 'b -> Eventually<'a>) ->
          acc:'a -> seq:seq<'b> -> Eventually<'a>
      val catch : e:Eventually<'a> -> Eventually<ResultOrException<'a>>
      val delay : f:(unit -> Eventually<'T>) -> Eventually<'T>
      val tryFinally :
        e:Eventually<'a> -> compensation:(unit -> unit) -> Eventually<'a>
      val tryWith :
        e:Eventually<'a> ->
          handler:(System.Exception -> Eventually<'a>) -> Eventually<'a>
      val token : Eventually<CompilationThreadToken>
    end
    [<ClassAttribute ()>]
    type EventuallyBuilder =
      class
        new : unit -> EventuallyBuilder
        member
          Bind : e:Eventually<'g> * k:('g -> Eventually<'h>) -> Eventually<'h>
        member
          Combine : e1:Eventually<unit> * e2:Eventually<'d> -> Eventually<'d>
        member Delay : f:(unit -> Eventually<'a>) -> Eventually<'a>
        member Return : v:'f -> Eventually<'f>
        member ReturnFrom : v:'e -> 'e
        member
          TryFinally : e:Eventually<'b> * compensation:(unit -> unit) ->
                         Eventually<'b>
        member
          TryWith : e:Eventually<'c> *
                    handler:(System.Exception -> Eventually<'c>) ->
                      Eventually<'c>
        member Zero : unit -> Eventually<unit>
      end
    val eventually : EventuallyBuilder
    type UniqueStampGenerator<'T when 'T : equality> =
      class
        new : unit -> UniqueStampGenerator<'T>
        member Encode : str:'T -> int
        member Table : System.Collections.Generic.ICollection<'T>
      end
    type MemoizationTable<'T,'U> =
      class
        new : compute:('T -> 'U) *
              keyComparer:System.Collections.Generic.IEqualityComparer<'T> *
              ?canMemoize:('T -> bool) -> MemoizationTable<'T,'U>
        member Apply : x:'T -> 'U
      end
    exception UndefinedException
    type LazyWithContextFailure =
      class
        new : exn:exn -> LazyWithContextFailure
        member Exception : exn
        static member Undefined : LazyWithContextFailure
      end
    [<SealedAttribute (); DefaultAugmentationAttribute (false);
      NoEqualityAttribute (); NoComparisonAttribute ()>]
    type LazyWithContext<'T,'ctxt> =
      { mutable value: 'T
        mutable funcOrException: obj
        findOriginalException: exn -> exn }
      with
        static member
          Create : f:('ctxt -> 'T) * findOriginalException:(exn -> exn) ->
                     LazyWithContext<'T,'ctxt>
        static member NotLazy : x:'T -> LazyWithContext<'T,'ctxt>
        member Force : ctxt:'ctxt -> 'T
        member UnsynchronizedForce : ctxt:'ctxt -> 'T
        member IsDelayed : bool
        member IsForced : bool
      end
    module Tables = begin
      val memoize : f:('a -> 'b) -> ('a -> 'b) when 'a : equality
    end
    type IPartialEqualityComparer<'T> =
      interface
        inherit System.Collections.Generic.IEqualityComparer<'T>
        abstract member InEqualityRelation : 'T -> bool
      end
    module IPartialEqualityComparer = begin
      val On :
        f:('a -> 'b) ->
          c:IPartialEqualityComparer<'b> -> IPartialEqualityComparer<'a>
      [<StructuralEqualityAttribute (); NoComparisonAttribute ()>]
      type private WrapType<'T> = | Wrap of 'T
      val partialDistinctBy :
        per:IPartialEqualityComparer<'T> -> seq:'T list -> 'T list
    end
    type NameMap<'T> = Map<string,'T>
    type NameMultiMap<'T> = NameMap<'T list>
    type MultiMap<'T,'U when 'T : comparison> = Map<'T,'U list>
    module NameMap = begin
      val empty : Map<'a,'b> when 'a : comparison
      val range : m:Map<'a,'b> -> 'b list when 'a : comparison
      val foldBack : f:(string -> 'T -> 'a -> 'a) -> m:NameMap<'T> -> z:'a -> 'a
      val forall :
        f:('a -> 'b -> bool) -> m:Map<'a,'b> -> bool when 'a : comparison
      val exists :
        f:('a -> 'b -> bool) -> m:Map<'a,'b> -> bool when 'a : comparison
      val ofKeyedList :
        f:('a -> 'b) -> l:'a list -> Map<'b,'a> when 'b : comparison
      val ofList : l:(string * 'T) list -> NameMap<'T>
      val ofSeq : l:seq<string * 'T> -> NameMap<'T>
      val toList : l:NameMap<'T> -> (string * 'T) list
      val layer : m1:NameMap<'T> -> m2:Map<string,'T> -> Map<string,'T>
      val layerAdditive :
        addf:('a list -> 'b -> 'a list) ->
          m1:Map<'c,'b> -> m2:Map<'c,'a list> -> Map<'c,'a list>
          when 'c : comparison
      val union :
        unionf:(seq<'a> -> 'b) -> ms:seq<NameMap<'a>> -> Map<string,'b>
      val subfold2 :
        errf:('a -> 'b -> 'c) ->
          f:('a -> 'd -> 'b -> 'c -> 'c) ->
            m1:Map<'a,'d> -> m2:Map<'a,'b> -> acc:'c -> 'c when 'a : comparison
      val suball2 :
        errf:('a -> 'b -> bool) ->
          p:('c -> 'b -> bool) -> m1:Map<'a,'c> -> m2:Map<'a,'b> -> bool
          when 'a : comparison
      val mapFold :
        f:('a -> string -> 'T -> 'b * 'a) ->
          s:'a -> l:NameMap<'T> -> Map<string,'b> * 'a
      val foldBackRange : f:('T -> 'a -> 'a) -> l:NameMap<'T> -> acc:'a -> 'a
      val filterRange : f:('T -> bool) -> l:NameMap<'T> -> Map<string,'T>
      val mapFilter : f:('T -> 'a option) -> l:NameMap<'T> -> Map<string,'a>
      val map : f:('T -> 'a) -> l:NameMap<'T> -> Map<string,'a>
      val iter : f:('T -> unit) -> l:NameMap<'T> -> unit
      val partition :
        f:('T -> bool) -> l:NameMap<'T> -> Map<string,'T> * Map<string,'T>
      val mem : v:string -> m:NameMap<'T> -> bool
      val find : v:string -> m:NameMap<'T> -> 'T
      val tryFind : v:string -> m:NameMap<'T> -> 'T option
      val add : v:string -> x:'T -> m:NameMap<'T> -> Map<string,'T>
      val isEmpty : m:NameMap<'T> -> bool
      val existsInRange :
        p:('a -> bool) -> m:Map<'b,'a> -> bool when 'b : comparison
      val tryFindInRange :
        p:('a -> bool) -> m:Map<'b,'a> -> 'a option when 'b : comparison
    end
    module NameMultiMap = begin
      val existsInRange : f:('T -> bool) -> m:NameMultiMap<'T> -> bool
      val find : v:string -> m:NameMultiMap<'T> -> 'T list
      val add : v:string -> x:'T -> m:NameMultiMap<'T> -> Map<string,'T list>
      val range : m:NameMultiMap<'T> -> 'T list
      val rangeReversingEachBucket : m:NameMultiMap<'T> -> 'T list
      val chooseRange : f:('T -> 'a option) -> m:NameMultiMap<'T> -> 'a list
      val map : f:('T -> 'a) -> m:NameMultiMap<'T> -> Map<string,'a list>
      val empty : NameMultiMap<'T>
      val initBy : f:('T -> string) -> xs:seq<'T> -> NameMultiMap<'T>
      val ofList : xs:(string * 'T) list -> NameMultiMap<'T>
    end
    module MultiMap = begin
      val existsInRange :
        f:('a -> bool) -> m:MultiMap<'b,'a> -> bool when 'b : comparison
      val find : v:'a -> m:MultiMap<'a,'b> -> 'b list when 'a : comparison
      val add :
        v:'a -> x:'b -> m:MultiMap<'a,'b> -> Map<'a,'b list>
          when 'a : comparison
      val range : m:MultiMap<'a,'b> -> 'b list when 'a : comparison
      val empty : MultiMap<'a,'b> when 'a : comparison
      val initBy :
        f:('a -> 'b) -> xs:seq<'a> -> MultiMap<'b,'a> when 'b : comparison
    end
    type LayeredMap<'Key,'Value when 'Key : comparison> = Map<'Key,'Value>
    type Map<'Key,'Value when 'Key : comparison> with
      static member Empty : Map<'Key,'Value> when 'Key : comparison
    type Map<'Key,'Value when 'Key : comparison> with
      member Values : 'Value list
    type Map<'Key,'Value when 'Key : comparison> with
      member
        AddAndMarkAsCollapsible : kvs:System.Collections.Generic.KeyValuePair<'Key,
                                                                              'Value> [] ->
                                    Map<'Key,'Value> when 'Key : comparison
    type Map<'Key,'Value when 'Key : comparison> with
      member
        LinearTryModifyThenLaterFlatten : key:'Key * f:('Value option -> 'Value) ->
                                            Map<'Key,'Value>
                                            when 'Key : comparison
    type Map<'Key,'Value when 'Key : comparison> with
      member MarkAsCollapsible : unit -> Map<'Key,'Value> when 'Key : comparison
    [<SealedAttribute ()>]
    type LayeredMultiMap<'Key,'Value when 'Key : comparison> =
      class
        new : contents:LayeredMap<'Key,'Value list> ->
                LayeredMultiMap<'Key,'Value>
        member Add : k:'Key * v:'Value -> LayeredMultiMap<'Key,'Value>
        member
          AddAndMarkAsCollapsible : kvs:System.Collections.Generic.KeyValuePair<'Key,
                                                                                'Value> [] ->
                                      LayeredMultiMap<'Key,'Value>
        member MarkAsCollapsible : unit -> LayeredMultiMap<'Key,'Value>
        member TryFind : k:'Key -> 'Value list option
        member TryGetValue : k:'Key -> bool * 'Value list
        member Item : k:'Key -> 'Value list with get
        member Values : 'Value list
        static member Empty : LayeredMultiMap<'Key,'Value>
      end
    module Shim = begin
      type IFileSystem =
        interface
          abstract member
            AssemblyLoad : assemblyName:System.Reflection.AssemblyName ->
                             System.Reflection.Assembly
          abstract member
            AssemblyLoadFrom : fileName:string -> System.Reflection.Assembly
          abstract member FileDelete : fileName:string -> unit
          abstract member
            FileStreamCreateShim : fileName:string -> System.IO.Stream
          abstract member
            FileStreamReadShim : fileName:string -> System.IO.Stream
          abstract member
            FileStreamWriteExistingShim : fileName:string -> System.IO.Stream
          abstract member GetFullPathShim : fileName:string -> string
          abstract member
            GetLastWriteTimeShim : fileName:string -> System.DateTime
          abstract member GetTempPathShim : unit -> string
          abstract member IsInvalidPathShim : filename:string -> bool
          abstract member IsPathRootedShim : path:string -> bool
          abstract member IsStableFileHeuristic : fileName:string -> bool
          abstract member ReadAllBytesShim : fileName:string -> byte []
          abstract member SafeExists : fileName:string -> bool
        end
      type DefaultFileSystem =
        class
          interface IFileSystem
          new : unit -> DefaultFileSystem
        end
      val mutable FileSystem : IFileSystem
      val private retryDelayMilliseconds : int
      val private numRetries : int
      val private getReader :
        filename:string * codePage:int option * retryLocked:bool ->
          System.IO.StreamReader
      type File with
        static member
          ReadBinaryChunk : fileName:string * start:int * len:int -> byte []
      type File with
        static member
          OpenReaderAndRetry : filename:string * codepage:int option *
                               retryLocked:bool -> System.IO.StreamReader
    end
  end

namespace Internal.Utilities
  module internal Filename = begin
    exception IllegalFileNameChar of string * char
    val checkPathForIllegalChars : (string -> unit)
    val checkSuffix : string -> string -> bool
    val hasExtensionWithValidate : validate:bool -> s:string -> bool
    val hasExtension : string -> bool
    val chopExtension : string -> string
    val directoryName : string -> string
    val fileNameOfPath : string -> string
    val fileNameWithoutExtensionWithValidate : bool -> string -> string
    val fileNameWithoutExtension : string -> string
    val trimQuotes : string -> string
  end

namespace FSharp.Compiler.AbstractIL.Internal
  type internal Zmap<'Key,'T> =
    Internal.Utilities.Collections.Tagged.Map<'Key,'T>
  module internal Zmap = begin
    val empty :
      System.Collections.Generic.IComparer<'Key> ->
        Internal.Utilities.Collections.Tagged.Map<'Key,'T,
                                                  System.Collections.Generic.IComparer<'Key>>
    val add :
      'Key ->
        'T ->
          Zmap<'Key,'T> ->
            Internal.Utilities.Collections.Tagged.Map<'Key,'T,
                                                      System.Collections.Generic.IComparer<'Key>>
    val find : 'Key -> Zmap<'Key,'T> -> 'T
    val tryFind : 'Key -> Zmap<'Key,'T> -> 'T option
    val remove :
      'Key ->
        Zmap<'Key,'T> ->
          Internal.Utilities.Collections.Tagged.Map<'Key,'T,
                                                    System.Collections.Generic.IComparer<'Key>>
    val mem : 'Key -> Zmap<'Key,'T> -> bool
    val iter : action:('T -> 'U -> unit) -> Zmap<'T,'U> -> unit
    val first : ('Key -> 'T -> bool) -> Zmap<'Key,'T> -> ('Key * 'T) option
    val exists : ('Key -> 'T -> bool) -> Zmap<'Key,'T> -> bool
    val forall : ('Key -> 'T -> bool) -> Zmap<'Key,'T> -> bool
    val map :
      mapping:('T -> 'U) ->
        Zmap<'Key,'T> ->
          Internal.Utilities.Collections.Tagged.Map<'Key,'U,
                                                    System.Collections.Generic.IComparer<'Key>>
    val mapi :
      mapping:('Key -> 'T -> 'U) ->
        Zmap<'Key,'T> ->
          Internal.Utilities.Collections.Tagged.Map<'Key,'U,
                                                    System.Collections.Generic.IComparer<'Key>>
    val fold : ('Key -> 'T -> 'U -> 'U) -> Zmap<'Key,'T> -> 'U -> 'U
    val toList : Zmap<'Key,'T> -> ('Key * 'T) list
    val foldSection :
      'Key -> 'Key -> ('Key -> 'T -> 'U -> 'U) -> Zmap<'Key,'T> -> 'U -> 'U
    val isEmpty : Zmap<'Key,'T> -> bool
    val foldMap :
      ('State -> 'Key -> 'T -> 'State * 'U) ->
        'State ->
          Zmap<'Key,'T> ->
            'State *
            Internal.Utilities.Collections.Tagged.Map<'Key,'U,
                                                      System.Collections.Generic.IComparer<'Key>>
    val choose : ('Key -> 'T -> 'U option) -> Zmap<'Key,'T> -> 'U option
    val chooseL : ('Key -> 'T -> 'U option) -> Zmap<'Key,'T> -> 'U list
    val ofList :
      System.Collections.Generic.IComparer<'Key> ->
        ('Key * 'T) list ->
          Internal.Utilities.Collections.Tagged.Map<'Key,'T,
                                                    System.Collections.Generic.IComparer<'Key>>
    val keys : Zmap<'Key,'T> -> 'Key list
    val values : Zmap<'Key,'T> -> 'T list
    val memberOf : Zmap<'Key,'T> -> 'Key -> bool
  end

namespace FSharp.Compiler.AbstractIL.Internal
  type internal Zset<'T> = Internal.Utilities.Collections.Tagged.Set<'T>
  module internal Zset = begin
    val empty :
      System.Collections.Generic.IComparer<'T> ->
        Internal.Utilities.Collections.Tagged.Set<'T,
                                                  System.Collections.Generic.IComparer<'T>>
    val isEmpty : Zset<'T> -> bool
    val contains : 'T -> Zset<'T> -> bool
    val add :
      'T ->
        Zset<'T> ->
          Internal.Utilities.Collections.Tagged.Set<'T,
                                                    System.Collections.Generic.IComparer<'T>>
    val addList :
      'T list ->
        Internal.Utilities.Collections.Tagged.Set<'T,
                                                  System.Collections.Generic.IComparer<'T>> ->
          Internal.Utilities.Collections.Tagged.Set<'T,
                                                    System.Collections.Generic.IComparer<'T>>
    val singleton :
      System.Collections.Generic.IComparer<'T> ->
        'T ->
          Internal.Utilities.Collections.Tagged.Set<'T,
                                                    System.Collections.Generic.IComparer<'T>>
    val remove :
      'T ->
        Zset<'T> ->
          Internal.Utilities.Collections.Tagged.Set<'T,
                                                    System.Collections.Generic.IComparer<'T>>
    val fold : ('T -> 'State -> 'State) -> Zset<'T> -> 'State -> 'State
    val iter : ('T -> unit) -> Zset<'T> -> unit
    val forall : predicate:('T -> bool) -> Zset<'T> -> bool
    val count : Zset<'T> -> int
    val exists : predicate:('T -> bool) -> Zset<'T> -> bool
    val subset : Zset<'T> -> Zset<'T> -> bool
    val equal : Zset<'T> -> Zset<'T> -> bool
    val elements : Zset<'T> -> 'T list
    val filter :
      predicate:('T -> bool) ->
        Zset<'T> ->
          Internal.Utilities.Collections.Tagged.Set<'T,
                                                    System.Collections.Generic.IComparer<'T>>
    val union :
      Zset<'T> ->
        Zset<'T> ->
          Internal.Utilities.Collections.Tagged.Set<'T,
                                                    System.Collections.Generic.IComparer<'T>>
    val inter :
      Zset<'T> ->
        Zset<'T> ->
          Internal.Utilities.Collections.Tagged.Set<'T,
                                                    System.Collections.Generic.IComparer<'T>>
    val diff :
      Zset<'T> ->
        Zset<'T> ->
          Internal.Utilities.Collections.Tagged.Set<'T,
                                                    System.Collections.Generic.IComparer<'T>>
    val memberOf : Zset<'T> -> 'T -> bool
  end

namespace FSharp.Compiler.AbstractIL.Internal
  module Utils = begin
    val runningOnMono : bool
  end
  module internal Bytes = begin
    val b0 : n:int -> int
    val b1 : n:int -> int
    val b2 : n:int -> int
    val b3 : n:int -> int
    val dWw1 : n:int64 -> int32
    val dWw0 : n:int64 -> int32
    val get : byte [] -> int -> int32
    val zeroCreate : int -> byte []
    val sub : b:byte [] -> s:int -> l:int -> byte []
    val blit : byte [] -> int -> byte [] -> int -> int -> unit
    val ofInt32Array : int [] -> byte []
    val stringAsUtf8NullTerminated : string -> byte []
    val stringAsUnicodeNullTerminated : string -> byte []
  end
  [<AbstractClassAttribute ()>]
  type ByteMemory =
    class
      new : unit -> ByteMemory
      static member FromArray : bytes:byte [] -> ByteMemory
      static member
        FromArray : bytes:byte [] * offset:int * length:int -> ByteMemory
      static member
        FromFile : path:string * System.IO.FileAccess * ?canShadowCopy:bool ->
                     ByteMemory
      static member
        FromMemoryMappedFile : System.IO.MemoryMappedFiles.MemoryMappedFile ->
                                 ByteMemory
      static member
        FromUnsafePointer : addr:nativeint * length:int * holder:obj ->
                              ByteMemory
      member AsReadOnly : unit -> ReadOnlyByteMemory
      abstract member AsReadOnlyStream : unit -> System.IO.Stream
      abstract member AsStream : unit -> System.IO.Stream
      abstract member
        Copy : srcOffset:int * dest:byte [] * destOffset:int * count:int -> unit
      abstract member CopyTo : System.IO.Stream -> unit
      abstract member ReadBytes : pos:int * count:int -> byte []
      abstract member ReadInt32 : pos:int -> int
      abstract member ReadUInt16 : pos:int -> uint16
      abstract member ReadUtf8String : pos:int * count:int -> string
      abstract member Slice : pos:int * count:int -> ByteMemory
      abstract member ToArray : unit -> byte []
      abstract member Item : int -> byte with get
      abstract member Length : int
      static member Empty : ByteMemory
    end
  [<SealedAttribute ()>]
  type ByteArrayMemory =
    class
      inherit ByteMemory
      new : bytes:byte [] * offset:int * length:int -> ByteArrayMemory
      override AsReadOnlyStream : unit -> System.IO.Stream
      override AsStream : unit -> System.IO.Stream
      override
        Copy : srcOffset:int * dest:byte [] * destOffset:int * count:int -> unit
      override CopyTo : stream:System.IO.Stream -> unit
      override ReadBytes : pos:int * count:int -> byte []
      override ReadInt32 : pos:int -> int
      override ReadUInt16 : pos:int -> uint16
      override ReadUtf8String : pos:int * count:int -> string
      override Slice : pos:int * count:int -> ByteMemory
      override ToArray : unit -> byte []
      override Item : i:int -> byte with get
      override Length : int
    end
  [<SealedAttribute ()>]
  type SafeUnmanagedMemoryStream =
    class
      inherit System.IO.UnmanagedMemoryStream
      new : addr:nativeptr<byte> * length:int64 * capacity:int64 *
            access:System.IO.FileAccess * holder:obj ->
              SafeUnmanagedMemoryStream
      new : addr:nativeptr<byte> * length:int64 * holder:obj ->
              SafeUnmanagedMemoryStream
      val mutable private holder: obj
      val mutable private isDisposed: bool
      override Dispose : disposing:bool -> unit
    end
  type RawByteMemory =
    class
      inherit ByteMemory
      new : addr:nativeptr<byte> * length:int * holder:obj -> RawByteMemory
      override AsReadOnlyStream : unit -> System.IO.Stream
      override AsStream : unit -> System.IO.Stream
      override
        Copy : srcOffset:int * dest:byte [] * destOffset:int * count:int -> unit
      override CopyTo : stream:System.IO.Stream -> unit
      override ReadBytes : pos:int * count:int -> byte []
      override ReadInt32 : pos:int -> int
      override ReadUInt16 : pos:int -> uint16
      override ReadUtf8String : pos:int * count:int -> string
      override Slice : pos:int * count:int -> ByteMemory
      override ToArray : unit -> byte []
      override Item : i:int -> byte with get
      override Length : int
    end
  [<StructAttribute (); NoEqualityAttribute (); NoComparisonAttribute ()>]
  type ReadOnlyByteMemory =
    struct
      new : ByteMemory -> ReadOnlyByteMemory
      member AsStream : unit -> System.IO.Stream
      member
        Copy : srcOffset:int * dest:byte [] * destOffset:int * count:int -> unit
      member CopyTo : System.IO.Stream -> unit
      member ReadBytes : pos:int * count:int -> byte []
      member ReadInt32 : pos:int -> int
      member ReadUInt16 : pos:int -> uint16
      member ReadUtf8String : pos:int * count:int -> string
      member Slice : pos:int * count:int -> ReadOnlyByteMemory
      member ToArray : unit -> byte []
      member Item : int -> byte with get
      member Length : int
      member Underlying : ByteMemory
    end
  module MemoryMappedFileExtensions = begin
    type MemoryMappedFile with
      static member
        TryFromByteMemory : bytes:ReadOnlyByteMemory ->
                              System.IO.MemoryMappedFiles.MemoryMappedFile option
  end
  [<SealedAttribute ()>]
  type internal ByteStream =
    { bytes: ReadOnlyByteMemory
      mutable pos: int
      max: int }
    with
      static member
        FromBytes : ReadOnlyByteMemory * start:int * length:int -> ByteStream
      member ReadByte : unit -> byte
      member ReadBytes : int -> ReadOnlyByteMemory
      member ReadUtf8String : int -> string
      member Position : int
    end
  [<SealedAttribute ()>]
  type internal ByteBuffer =
    { mutable bbArray: byte []
      mutable bbCurrent: int }
    with
      static member Create : int -> ByteBuffer
      member Close : unit -> byte []
      member EmitBoolAsByte : bool -> unit
      member EmitByte : byte -> unit
      member EmitByteMemory : ReadOnlyByteMemory -> unit
      member EmitBytes : byte [] -> unit
      member EmitInt32 : int -> unit
      member EmitInt32AsUInt16 : int -> unit
      member EmitInt64 : int64 -> unit
      member EmitIntAsByte : int -> unit
      member EmitIntsAsBytes : int [] -> unit
      member EmitUInt16 : uint16 -> unit
      member Ensure : newSize:int -> unit
      member FixupInt32 : pos:int -> value:int -> unit
      member Position : int
    end
  [<SealedAttribute ()>]
  type ByteStorage =
    class
      new : getByteMemory:(unit -> ReadOnlyByteMemory) -> ByteStorage
      static member FromByteArray : byte [] -> ByteStorage
      static member
        FromByteArrayAndCopy : byte [] * useBackingMemoryMappedFile:bool ->
                                 ByteStorage
      static member FromByteMemory : ReadOnlyByteMemory -> ByteStorage
      static member
        FromByteMemoryAndCopy : ReadOnlyByteMemory *
                                useBackingMemoryMappedFile:bool -> ByteStorage
      member GetByteMemory : unit -> ReadOnlyByteMemory
    end

namespace FSharp.Compiler
  module internal XmlAdapters = begin
    val s_escapeChars : char []
    val getEscapeSequence : c:char -> string
    val escape : str:string -> string
  end

namespace Internal.Utilities.Collections
  [<StructuralEqualityAttribute (); NoComparisonAttribute ()>]
  type internal ValueStrength<'T when 'T : not struct> =
    | Strong of 'T
    | Weak of System.WeakReference<'T>
  type internal AgedLookup<'Token,'Key,'Value when 'Value : not struct> =
    class
      new : keepStrongly:int * areSimilar:('Key * 'Key -> bool) *
            ?requiredToKeep:('Value -> bool) * ?keepMax:int ->
              AgedLookup<'Token,'Key,'Value>
      member Clear : 'Token -> unit
      member Put : 'Token * 'Key * 'Value -> unit
      member Remove : 'Token * key:'Key -> unit
      member Resize : 'Token * newKeepStrongly:int * ?newKeepMax:int -> unit
      member TryGet : 'Token * key:'Key -> 'Value option
      member TryGetKeyValue : 'Token * key:'Key -> ('Key * 'Value) option
      member TryPeekKeyValue : 'Token * key:'Key -> ('Key * 'Value) option
    end
  type internal MruCache<'Token,'Key,'Value when 'Value : not struct> =
    class
      new : keepStrongly:int * areSame:('Key * 'Key -> bool) *
            ?isStillValid:('Key * 'Value -> bool) *
            ?areSimilar:('Key * 'Key -> bool) * ?requiredToKeep:('Value -> bool) *
            ?keepMax:int -> MruCache<'Token,'Key,'Value>
      member Clear : 'Token -> unit
      member ContainsSimilarKey : 'Token * key:'Key -> bool
      member RemoveAnySimilar : 'Token * key:'Key -> unit
      member Resize : 'Token * newKeepStrongly:int * ?newKeepMax:int -> unit
      member Set : 'Token * key:'Key * value:'Value -> unit
      member TryGet : 'Token * key:'Key -> 'Value option
      member TryGetAny : 'Token * key:'Key -> 'Value option
      member TryGetSimilar : 'Token * key:'Key -> 'Value option
      member TryGetSimilarAny : 'Token * key:'Key -> 'Value option
    end

namespace Internal.Utilities
  type internal QueueList<'T> =
    class
      interface System.Collections.IEnumerable
      interface System.Collections.Generic.IEnumerable<'T>
      new : xs:'T list -> QueueList<'T>
      new : firstElementsIn:'T list * lastElementsRevIn:'T list *
            numLastElementsIn:int -> QueueList<'T>
      member Append : ys:seq<'T> -> QueueList<'T>
      member AppendOne : y:'T -> QueueList<'T>
      member ToList : unit -> 'T list
      member FirstElements : 'T list
      member LastElements : 'T list
      static member Empty : QueueList<'T>
    end
  module internal QueueList = begin
    val empty<'T> : QueueList<'T>
    val ofSeq : x:seq<'a> -> QueueList<'a>
    val iter : f:('a -> unit) -> x:QueueList<'a> -> unit
    val map : f:('a -> 'b) -> x:QueueList<'a> -> QueueList<'b>
    val exists : f:('a -> bool) -> x:QueueList<'a> -> bool
    val filter : f:('a -> bool) -> x:QueueList<'a> -> QueueList<'a>
    val foldBack : f:('a -> 'b -> 'b) -> x:QueueList<'a> -> acc:'b -> 'b
    val forall : f:('a -> bool) -> x:QueueList<'a> -> bool
    val ofList : x:'a list -> QueueList<'a>
    val toList : x:QueueList<'a> -> 'a list
    val tryFind : f:('a -> bool) -> x:QueueList<'a> -> 'a option
    val one : x:'a -> QueueList<'a>
    val appendOne : x:QueueList<'a> -> y:'a -> QueueList<'a>
    val append : x:QueueList<'a> -> ys:QueueList<'a> -> QueueList<'a>
  end

namespace FSharp.Compiler
  module internal Lib = begin
    val debug : bool
    val verbose : bool
    val mutable progress : bool
    val mutable tracking : bool
    val condition : s:string -> bool
    val GetEnvInteger : e:string -> dflt:int -> int
    val dispose : x:System.IDisposable -> unit
    module Bits = begin
      val b0 : n:int -> int
      val b1 : n:int -> int
      val b2 : n:int -> int
      val b3 : n:int -> int
      val pown32 : n:int -> int
      val pown64 : n:int -> int64
      val mask32 : m:int32 -> n:int -> int
      val mask64 : m:int32 -> n:int -> int64
    end
    module Filename = begin
      val fullpath : cwd:string -> nm:string -> string
      val hasSuffixCaseInsensitive : suffix:string -> filename:string -> bool
      val isDll : file:string -> bool
    end
    module Bool = begin
      val order : System.Collections.Generic.IComparer<bool>
    end
    module Int32 = begin
      val order : System.Collections.Generic.IComparer<int>
    end
    module Int64 = begin
      val order : System.Collections.Generic.IComparer<int64>
    end
    module Pair = begin
      val order :
        compare1:System.Collections.Generic.IComparer<'T1> *
        compare2:System.Collections.Generic.IComparer<'T2> ->
          System.Collections.Generic.IComparer<'T1 * 'T2>
    end
    type NameSet = AbstractIL.Internal.Zset<string>
    module NameSet = begin
      val ofList : l:string list -> NameSet
    end
    module NameMap = begin
      val domain : m:Map<string,'a> -> AbstractIL.Internal.Zset<string>
      val domainL : m:Map<string,'a> -> string list
    end
    module Check = begin
      val NotNone : argName:string -> arg:'T option -> 'T
      val ArgumentNotNull : arg:'a -> argName:string -> unit
      val ArrayArgumentNotNullOrEmpty : arr:'T [] -> argName:string -> unit
      val StringArgumentNotNullOrEmpty : s:string -> argName:string -> unit
    end
    type IntMap<'T> = AbstractIL.Internal.Zmap<int,'T>
    module IntMap = begin
      val empty : unit -> AbstractIL.Internal.Zmap<int,'a>
      val add :
        k:int -> v:'T -> t:IntMap<'T> -> AbstractIL.Internal.Zmap<int,'T>
      val find : k:int -> t:IntMap<'T> -> 'T
      val tryFind : k:int -> t:IntMap<'T> -> 'T option
      val remove : k:int -> t:IntMap<'T> -> AbstractIL.Internal.Zmap<int,'T>
      val mem : k:int -> t:IntMap<'T> -> bool
      val iter : f:(int -> 'T -> unit) -> t:IntMap<'T> -> unit
      val map : f:('T -> 'a) -> t:IntMap<'T> -> AbstractIL.Internal.Zmap<int,'a>
      val fold : f:(int -> 'T -> 'a -> 'a) -> t:IntMap<'T> -> z:'a -> 'a
    end
    module ListAssoc = begin
      val find : f:('a -> 'b -> bool) -> x:'a -> l:('b * 'c) list -> 'c
      val tryFind :
        f:('key -> 'key -> bool) ->
          x:'key -> l:('key * 'value) list -> 'value option
    end
    module ListSet = begin
      val inline contains : f:('a -> 'b -> bool) -> x:'a -> l:'b list -> bool
      val insert : f:('a -> 'a -> bool) -> x:'a -> l:'a list -> 'a list
      val unionFavourRight :
        f:('a -> 'a -> bool) -> l1:'a list -> l2:'a list -> 'a list
      val private findIndexAux :
        eq:('a -> 'b -> bool) -> x:'b -> l:'a list -> n:int -> int
      val findIndex : eq:('a -> 'b -> bool) -> x:'b -> l:'a list -> int
      val remove : f:('a -> 'b -> bool) -> x:'a -> l:'b list -> 'b list
      val subtract : f:('a -> 'b -> bool) -> l1:'a list -> l2:'b list -> 'a list
      val isSubsetOf : f:('a -> 'b -> bool) -> l1:'a list -> l2:'b list -> bool
      val isSupersetOf :
        f:('a -> 'b -> bool) -> l1:'a list -> l2:'b list -> bool
      val equals : f:('a -> 'b -> bool) -> l1:'a list -> l2:'b list -> bool
      val unionFavourLeft :
        f:('a -> 'a -> bool) -> l1:'a list -> l2:'a list -> 'a list
      val intersect :
        f:('a -> 'b -> bool) -> l1:'b list -> l2:'a list -> 'a list
      val setify : f:('a -> 'a -> bool) -> l:'a list -> 'a list
      val hasDuplicates : f:('a -> 'a -> bool) -> l:'a list -> bool
    end
    val mapFoldFst :
      f:('a -> 'b -> 'c * 'd) -> s:'a -> x:'b * y:'e -> ('c * 'e) * 'd
    val mapFoldSnd :
      f:('a -> 'b -> 'c * 'd) -> s:'a -> x:'e * y:'b -> ('e * 'c) * 'd
    val pair : a:'a -> b:'b -> 'a * 'b
    val p13 : x:'a * _y:'b * _z:'c -> 'a
    val p23 : _x:'a * y:'b * _z:'c -> 'b
    val p33 : _x:'a * _y:'b * z:'c -> 'c
    val map1Of2 : f:('a -> 'b) -> a1:'a * a2:'c -> 'b * 'c
    val map2Of2 : f:('a -> 'b) -> a1:'c * a2:'a -> 'c * 'b
    val map1Of3 : f:('a -> 'b) -> a1:'a * a2:'c * a3:'d -> 'b * 'c * 'd
    val map2Of3 : f:('a -> 'b) -> a1:'c * a2:'a * a3:'d -> 'c * 'b * 'd
    val map3Of3 : f:('a -> 'b) -> a1:'c * a2:'d * a3:'a -> 'c * 'd * 'b
    val map3Of4 :
      f:('a -> 'b) -> a1:'c * a2:'d * a3:'a * a4:'e -> 'c * 'd * 'b * 'e
    val map4Of4 :
      f:('a -> 'b) -> a1:'c * a2:'d * a3:'e * a4:'a -> 'c * 'd * 'e * 'b
    val map5Of5 :
      f:('a -> 'b) ->
        a1:'c * a2:'d * a3:'e * a4:'f * a5:'a -> 'c * 'd * 'e * 'f * 'b
    val map6Of6 :
      f:('a -> 'b) ->
        a1:'c * a2:'d * a3:'e * a4:'f * a5:'g * a6:'a ->
          'c * 'd * 'e * 'f * 'g * 'b
    val foldPair :
      f1:('a -> 'b -> 'c) * f2:('c -> 'd -> 'e) -> acc:'a -> a1:'b * a2:'d -> 'e
    val fold1Of2 : f1:('a -> 'b -> 'c) -> acc:'a -> a1:'b * _a2:'d -> 'c
    val foldTriple :
      f1:('a -> 'b -> 'c) * f2:('c -> 'd -> 'e) * f3:('e -> 'f -> 'g) ->
        acc:'a -> a1:'b * a2:'d * a3:'f -> 'g
    val foldQuadruple :
      f1:('a -> 'b -> 'c) * f2:('c -> 'd -> 'e) * f3:('e -> 'f -> 'g) *
      f4:('g -> 'h -> 'i) -> acc:'a -> a1:'b * a2:'d * a3:'f * a4:'h -> 'i
    val mapPair : f1:('a -> 'b) * f2:('c -> 'd) -> a1:'a * a2:'c -> 'b * 'd
    val mapTriple :
      f1:('a -> 'b) * f2:('c -> 'd) * f3:('e -> 'f) ->
        a1:'a * a2:'c * a3:'e -> 'b * 'd * 'f
    val mapQuadruple :
      f1:('a -> 'b) * f2:('c -> 'd) * f3:('e -> 'f) * f4:('g -> 'h) ->
        a1:'a * a2:'c * a3:'e * a4:'g -> 'b * 'd * 'f * 'h
    val fmap2Of2 :
      f:('a -> 'b -> 'c * 'd) -> z:'a -> a1:'e * a2:'b -> 'c * ('e * 'd)
    module Zmap = begin
      val force : k:'a -> mp:AbstractIL.Internal.Zmap<'a,'b> -> 'b
      val mapKey :
        key:'a ->
          f:('b option -> 'b option) ->
            mp:AbstractIL.Internal.Zmap<'a,'b> ->
              AbstractIL.Internal.Zmap<'a,'b>
    end
    module Zset = begin
      val ofList :
        order:System.Collections.Generic.IComparer<'a> ->
          xs:'a list -> AbstractIL.Internal.Zset<'a>
      val fixpoint :
        f:(AbstractIL.Internal.Zset<'a> -> AbstractIL.Internal.Zset<'a>) ->
          AbstractIL.Internal.Zset<'a> -> AbstractIL.Internal.Zset<'a>
    end
    val equalOn : f:('a -> 'b) -> x:'a -> y:'a -> bool when 'b : equality
    val bufs : f:(System.Text.StringBuilder -> unit) -> string
    val writeViaBuffer :
      os:System.IO.TextWriter ->
        f:(System.Text.StringBuilder -> 'a -> unit) -> x:'a -> unit
    type GraphNode<'Data,'Id> =
      { nodeId: 'Id
        nodeData: 'Data
        mutable nodeNeighbours: GraphNode<'Data,'Id> list }
    type Graph<'Data,'Id when 'Id : comparison> =
      class
        new : nodeIdentity:('Data -> 'Id) * nodes:'Data list *
              edges:('Data * 'Data) list -> Graph<'Data,'Id>
        member GetNodeData : nodeId:'Id -> 'Data
        member IterateCycles : f:('Data list -> unit) -> unit
      end
    type NonNullSlot<'T> = 'T
    val nullableSlotEmpty : unit -> 'T
    val nullableSlotFull : x:'a -> 'a
    type cache<'T> =
      { mutable cacheVal: NonNullSlot<'T> }
    val newCache : unit -> cache<'a>
    val inline cached : cache:cache<'a> -> resF:(unit -> 'a) -> 'a
    val inline cacheOptByref : cache:byref<'T option> -> f:(unit -> 'T) -> 'T
    val inline cacheOptRef : cache:'a option ref -> f:(unit -> 'a) -> 'a
    val inline tryGetCacheValue : cache:cache<'a> -> NonNullSlot<'a> voption
    module AsyncUtil = begin
      [<NoEqualityAttribute (); NoComparisonAttribute ()>]
      type AsyncResult<'T> =
        | AsyncOk of 'T
        | AsyncException of exn
        | AsyncCanceled of System.OperationCanceledException
        with
          static member Commit : res:AsyncResult<'T> -> Async<'T>
        end
      [<SealedAttribute ()>]
      type AsyncResultCell<'T> =
        class
          new : unit -> AsyncResultCell<'T>
          member RegisterResult : res:AsyncResult<'T> -> unit
          member private AsyncPrimitiveResult : Async<AsyncResult<'T>>
          member AsyncResult : Async<'T>
        end
    end
    module UnmanagedProcessExecutionOptions = begin
      val private GetProcessHeap : unit -> System.UIntPtr
      val private HeapSetInformation :
        _HeapHandle:System.UIntPtr * _HeapInformationClass:System.UInt32 *
        _HeapInformation:System.UIntPtr * _HeapInformationLength:System.UIntPtr ->
          bool
      val private GetLastError : unit -> System.UInt32
      [<System.Security.Permissions.SecurityPermission
        (enum<System.Security.Permissions.SecurityAction> (3))>]
      val EnableHeapTerminationOnCorruption : unit -> unit
    end
    module StackGuard = begin
      [<LiteralAttribute ()>]
      val private MaxUncheckedRecursionDepth : int = 20
      val EnsureSufficientExecutionStack : recursionDepth:int -> unit
    end
    [<RequireQualifiedAccessAttribute ()>]
    type MaybeLazy<'T> =
      | Strict of 'T
      | Lazy of System.Lazy<'T>
      with
        member Force : unit -> 'T
        member Value : 'T
      end
    val inline vsnd : struct ('T * 'T) -> 'T
    type DisposablesTracker =
      class
        interface System.IDisposable
        new : unit -> DisposablesTracker
        member Register : i:System.IDisposable -> unit
      end
  end

namespace FSharp.Compiler
  module internal Rational = begin
    type Rational =
      { numerator: System.Numerics.BigInteger
        denominator: System.Numerics.BigInteger }
    val gcd :
      a:System.Numerics.BigInteger ->
        b:System.Numerics.BigInteger -> System.Numerics.BigInteger
    val lcm :
      a:System.Numerics.BigInteger ->
        b:System.Numerics.BigInteger -> System.Numerics.BigInteger
    val mkRational :
      p:System.Numerics.BigInteger -> q:System.Numerics.BigInteger -> Rational
    val intToRational : int -> Rational
    val ZeroRational : Rational
    val OneRational : Rational
    val AddRational : Rational -> Rational -> Rational
    val NegRational : Rational -> Rational
    val MulRational : Rational -> Rational -> Rational
    val DivRational : Rational -> Rational -> Rational
    val AbsRational : Rational -> Rational
    val RationalToString : Rational -> string
    val GcdRational : Rational -> Rational -> Rational
    val GetNumerator : Rational -> int
    val GetDenominator : Rational -> int
    val SignRational : Rational -> int
  end

namespace Internal.Utilities
  type PathMap = | PathMap of Map<string,string>
  module internal PathMap = begin
    val dirSepStr : string
    val empty : PathMap
    val addMapping : string -> string -> PathMap -> PathMap
    val apply : PathMap -> string -> string
    val applyDir : PathMap -> string -> string
  end

namespace Internal.Utilities
  module internal RidHelpers = begin
    val probingRids : string []
    val platformRid : string
    val baseRid : string
  end

namespace FSharp.Compiler
  module Range = begin
    type FileIndex = int32
    [<LiteralAttribute ()>]
    val columnBitCount : int = 20
    [<LiteralAttribute ()>]
    val lineBitCount : int = 31
    val posBitCount : int
    val posColumnMask : int64
    val lineColumnMask : int64
    [<StructAttribute (); CustomEqualityAttribute (); NoComparisonAttribute ();
      System.Diagnostics.DebuggerDisplay ("{Line},{Column}")>]
    type pos =
      struct
        new : l:int * c:int -> pos
        new : code:int64 -> pos
        static member Decode : int64 -> pos
        override Equals : obj:obj -> bool
        override GetHashCode : unit -> int
        override ToString : unit -> string
        member Column : int32
        member Encoding : int64
        member Line : int32
        static member EncodingSize : int
      end
    [<LiteralAttribute ()>]
    val fileIndexBitCount : int = 24
    [<LiteralAttribute ()>]
    val startColumnBitCount : int = 20
    [<LiteralAttribute ()>]
    val endColumnBitCount : int = 20
    [<LiteralAttribute ()>]
    val startLineBitCount : int = 31
    [<LiteralAttribute ()>]
    val heightBitCount : int = 27
    [<LiteralAttribute ()>]
    val isSyntheticBitCount : int = 1
    [<LiteralAttribute ()>]
    val fileIndexShift : int = 0
    [<LiteralAttribute ()>]
    val startColumnShift : int = 24
    [<LiteralAttribute ()>]
    val endColumnShift : int = 44
    [<LiteralAttribute ()>]
    val startLineShift : int = 0
    [<LiteralAttribute ()>]
    val heightShift : int = 31
    [<LiteralAttribute ()>]
    val isSyntheticShift : int = 58
    [<LiteralAttribute ()>]
    val fileIndexMask : int64 = 16777215L
    [<LiteralAttribute ()>]
    val startColumnMask : int64 = 17592169267200L
    [<LiteralAttribute ()>]
    val endColumnMask : int64 = -17592186044416L
    [<LiteralAttribute ()>]
    val startLineMask : int64 = 2147483647L
    [<LiteralAttribute ()>]
    val heightMask : int64 = 288230374004228096L
    [<LiteralAttribute ()>]
    val isSyntheticMask : int64 = 288230376151711744L
    val normalizeFilePath : filePath:string -> string
    type FileIndexTable =
      class
        new : unit -> FileIndexTable
        member FileToIndex : normalize:bool -> filePath:string -> int
        member IndexToFile : n:int -> string
      end
    val maxFileIndex : int
    val fileIndexTable : FileIndexTable
    val fileIndexOfFileAux : normalize:bool -> f:string -> int
    val fileIndexOfFile : filePath:string -> int
    val fileOfFileIndex : int -> string
    val mkPos : line:int -> column:int -> pos
    val unknownFileName : string
    val startupFileName : string
    val commandLineArgsFileName : string
    [<StructAttribute (); CustomEqualityAttribute (); NoComparisonAttribute ();
      System.Diagnostics.DebuggerDisplay
      ("({StartLine},{StartColumn}-{EndLine},{EndColumn}) {ShortFileName} -> {DebugCode}")>]
    type range =
      struct
        new : fIdx:int32 * b:pos * e:pos -> range
        new : fIdx:int32 * bl:int32 * bc:int32 * el:int32 * ec:int32 -> range
        new : code1:int64 * code2:int64 -> range
        override Equals : obj:obj -> bool
        override GetHashCode : unit -> int
        member MakeSynthetic : unit -> range
        member ToShortString : unit -> string
        override ToString : unit -> string
        member Code1 : int64
        member Code2 : int64
        member DebugCode : string
        member End : pos
        member EndColumn : int32
        member EndLine : int32
        member EndRange : range
        member FileIndex : int32
        member FileName : string
        member IsSynthetic : bool
        member ShortFileName : string
        member Start : pos
        member StartColumn : int32
        member StartLine : int32
        member StartRange : range
        static member Zero : range
      end
    val mkRange : string -> pos -> pos -> range
    val equals : range -> range -> bool
    val mkFileIndexRange : int32 -> pos -> pos -> range
    val posOrder : System.Collections.Generic.IComparer<pos>
    val rangeOrder : System.Collections.Generic.IComparer<range>
    val outputPos : System.IO.TextWriter -> pos -> unit
    val outputRange : System.IO.TextWriter -> range -> unit
    val posGt : pos -> pos -> bool
    val posEq : pos -> pos -> bool
    val posGeq : pos -> pos -> bool
    val posLt : pos -> pos -> bool
    val unionRanges : range -> range -> range
    val rangeContainsRange : range -> range -> bool
    val rangeContainsPos : range -> pos -> bool
    val rangeBeforePos : range -> pos -> bool
    val rangeN : string -> int -> range
    val pos0 : pos
    val range0 : range
    val rangeStartup : range
    val rangeCmdArgs : range
    val trimRangeToLine : range -> range
    val stringOfPos : pos -> string
    val stringOfRange : range -> string
    type Line0 = int
    type Pos01 = Line0 * int
    type Range01 = Pos01 * Pos01
    module Line = begin
      val fromZ : Line0 -> int
      val toZ : int -> Line0
    end
    module Pos = begin
      val fromZ : line:Line0 -> column:int -> pos
      val toZ : pos -> Line0 * int32
    end
    module Range = begin
      val toZ : range -> (Line0 * int32) * (Line0 * int32)
      val toFileZ : range -> string * ((Line0 * int32) * (Line0 * int32))
      val comparer : System.Collections.Generic.IEqualityComparer<range>
    end
  end

namespace FSharp.Compiler
  module ErrorLogger = begin
    [<RequireQualifiedAccessAttribute ()>]
    type ErrorStyle =
      | DefaultErrors
      | EmacsErrors
      | TestErrors
      | VSErrors
      | GccErrors
    exception WrappedError of exn * Range.range
    exception ReportedError of exn option
    val findOriginalException : err:exn -> exn
    type Suggestions = (string -> unit) -> unit
    val NoSuggestions : Suggestions
    exception StopProcessingExn of exn option
    val ( |StopProcessing|_| ) : exn:exn -> unit option
    val StopProcessing<'T> : exn
    exception NumberedError of (int * string) * Range.range
    exception Error of (int * string) * Range.range
    exception InternalError of msg: string * Range.range
    exception UserCompilerMessage of string * int * Range.range
    exception LibraryUseOnly of Range.range
    exception Deprecated of string * Range.range
    exception Experimental of string * Range.range
    exception PossibleUnverifiableCode of Range.range
    exception UnresolvedReferenceNoRange of string
    exception UnresolvedReferenceError of string * Range.range
    exception UnresolvedPathReferenceNoRange of string * string
    exception UnresolvedPathReference of string * string * Range.range
    exception ErrorWithSuggestions of
                                     (int * string) * Range.range * string *
                                     Suggestions
    val inline protectAssemblyExploration : dflt:'a -> f:(unit -> 'a) -> 'a
    val inline protectAssemblyExplorationF :
      dflt:(string * string -> 'a) -> f:(unit -> 'a) -> 'a
    val inline protectAssemblyExplorationNoReraise :
      dflt1:'a -> dflt2:'a -> f:(unit -> 'a) -> 'a
    val AttachRange : m:Range.range -> exn:exn -> exn
    type Exiter =
      interface
        abstract member Exit : int -> 'T
      end
    val QuitProcessExiter : Exiter
    [<RequireQualifiedAccessAttribute ()>]
    type BuildPhase =
      | DefaultPhase
      | Compile
      | Parameter
      | Parse
      | TypeCheck
      | CodeGen
      | Optimize
      | IlxGen
      | IlGen
      | Output
      | Interactive
    module BuildPhaseSubcategory = begin
      [<LiteralAttribute ()>]
      val DefaultPhase : string = ""
      [<LiteralAttribute ()>]
      val Compile : string = "compile"
      [<LiteralAttribute ()>]
      val Parameter : string = "parameter"
      [<LiteralAttribute ()>]
      val Parse : string = "parse"
      [<LiteralAttribute ()>]
      val TypeCheck : string = "typecheck"
      [<LiteralAttribute ()>]
      val CodeGen : string = "codegen"
      [<LiteralAttribute ()>]
      val Optimize : string = "optimize"
      [<LiteralAttribute ()>]
      val IlxGen : string = "ilxgen"
      [<LiteralAttribute ()>]
      val IlGen : string = "ilgen"
      [<LiteralAttribute ()>]
      val Output : string = "output"
      [<LiteralAttribute ()>]
      val Interactive : string = "interactive"
      [<LiteralAttribute ()>]
      val Internal : string = "internal"
    end
    [<System.Diagnostics.DebuggerDisplay ("{DebugDisplay()}")>]
    type PhasedDiagnostic =
      { Exception: exn
        Phase: BuildPhase }
      with
        static member Create : exn:exn * phase:BuildPhase -> PhasedDiagnostic
        static member IsSubcategoryOfCompile : subcategory:string -> bool
        member DebugDisplay : unit -> string
        member IsPhaseInCompile : unit -> bool
        member Subcategory : unit -> string
      end
    [<AbstractClassAttribute ();
      System.Diagnostics.DebuggerDisplay ("{DebugDisplay()}")>]
    type ErrorLogger =
      class
        new : nameForDebugging:string -> ErrorLogger
        member DebugDisplay : unit -> string
        abstract member
          DiagnosticSink : phasedError:PhasedDiagnostic * isError:bool -> unit
        abstract member ErrorCount : int
      end
    val DiscardErrorsLogger : ErrorLogger
    val AssertFalseErrorLogger : ErrorLogger
    type CapturingErrorLogger =
      class
        inherit ErrorLogger
        new : nm:string -> CapturingErrorLogger
        member CommitDelayedDiagnostics : errorLogger:ErrorLogger -> unit
        override
          DiagnosticSink : phasedError:PhasedDiagnostic * isError:bool -> unit
        member Diagnostics : (PhasedDiagnostic * bool) list
        override ErrorCount : int
      end
    [<ClassAttribute ()>]
    type internal CompileThreadStatic =
      class
        static member BuildPhase : BuildPhase
        static member BuildPhaseUnchecked : BuildPhase
        static member ErrorLogger : ErrorLogger
        static val mutable private buildPhase: BuildPhase
        static val mutable private errorLogger: ErrorLogger
      end
    module ErrorLoggerExtensions = begin
      val tryAndDetectDev15 : bool
      val PreserveStackTrace : exn:'a -> unit
      val ReraiseIfWatsonable : exn:exn -> unit
      type ErrorLogger with
        member ErrorR : exn:exn -> unit
      type ErrorLogger with
        member Warning : exn:exn -> unit
      type ErrorLogger with
        member Error : exn:exn -> 'b
      type ErrorLogger with
        member SimulateError : ph:PhasedDiagnostic -> 'a
      type ErrorLogger with
        member ErrorRecovery : exn:exn -> m:Range.range -> unit
      type ErrorLogger with
        member StopProcessingRecovery : exn:exn -> m:Range.range -> unit
      type ErrorLogger with
        member ErrorRecoveryNoRange : exn:exn -> unit
    end
    val PushThreadBuildPhaseUntilUnwind : phase:BuildPhase -> System.IDisposable
    val PushErrorLoggerPhaseUntilUnwind :
      errorLoggerTransformer:(ErrorLogger -> #ErrorLogger) -> System.IDisposable
    val SetThreadBuildPhaseNoUnwind : phase:BuildPhase -> unit
    val SetThreadErrorLoggerNoUnwind : errorLogger:ErrorLogger -> unit
    val errorR : exn:exn -> unit
    val warning : exn:exn -> unit
    val error : exn:exn -> 'a
    val simulateError : p:PhasedDiagnostic -> 'a
    val diagnosticSink : phasedError:PhasedDiagnostic * isError:bool -> unit
    val errorSink : pe:PhasedDiagnostic -> unit
    val warnSink : pe:PhasedDiagnostic -> unit
    val errorRecovery : exn:exn -> m:Range.range -> unit
    val stopProcessingRecovery : exn:exn -> m:Range.range -> unit
    val errorRecoveryNoRange : exn:exn -> unit
    val report : f:(unit -> 'a) -> 'a
    val deprecatedWithError : s:string -> m:Range.range -> unit
    val mutable reportLibraryOnlyFeatures : bool
    val libraryOnlyError : m:Range.range -> unit
    val libraryOnlyWarning : m:Range.range -> unit
    val deprecatedOperator : m:Range.range -> unit
    val mlCompatWarning : s:System.String -> m:Range.range -> unit
    val suppressErrorReporting : f:(unit -> 'a) -> 'a
    val conditionallySuppressErrorReporting : cond:bool -> f:(unit -> 'a) -> 'a
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type OperationResult<'T> =
      | OkResult of warnings: exn list * 'T
      | ErrorResult of warnings: exn list * exn
    type ImperativeOperationResult = OperationResult<unit>
    val ReportWarnings : warns:#exn list -> unit
    val CommitOperationResult : res:OperationResult<'a> -> 'a
    val RaiseOperationResult : res:OperationResult<unit> -> unit
    val ErrorD : err:exn -> OperationResult<'a>
    val WarnD : err:exn -> OperationResult<unit>
    val CompleteD : OperationResult<unit>
    val ResultD : x:'a -> OperationResult<'a>
    val CheckNoErrorsAndGetWarnings : res:OperationResult<'a> -> exn list option
    val ( ++ ) :
      res:OperationResult<'a> ->
        f:('a -> OperationResult<'b>) -> OperationResult<'b>
    val IterateD :
      f:('a -> OperationResult<unit>) -> xs:'a list -> OperationResult<unit>
    val WhileD :
      gd:(unit -> bool) ->
        body:(unit -> OperationResult<unit>) -> OperationResult<unit>
    val MapD :
      f:('a -> OperationResult<'b>) -> xs:'a list -> OperationResult<'b list>
    type TrackErrorsBuilder =
      class
        new : unit -> TrackErrorsBuilder
        member
          Bind : res:OperationResult<'h> * k:('h -> OperationResult<'i>) ->
                   OperationResult<'i>
        member
          Combine : expr1:OperationResult<'c> *
                    expr2:('c -> OperationResult<'d>) -> OperationResult<'d>
        member Delay : fn:(unit -> 'b) -> (unit -> 'b)
        member
          For : seq:'e list * k:('e -> OperationResult<unit>) ->
                  OperationResult<unit>
        member Return : res:'g -> OperationResult<'g>
        member ReturnFrom : res:'f -> 'f
        member Run : fn:(unit -> 'a) -> 'a
        member
          While : gd:(unit -> bool) * k:(unit -> OperationResult<unit>) ->
                    OperationResult<unit>
        member Zero : unit -> OperationResult<unit>
      end
    val trackErrors : TrackErrorsBuilder
    val OptionD :
      f:('a -> OperationResult<unit>) -> xs:'a option -> OperationResult<unit>
    val IterateIdxD :
      f:(int -> 'a -> OperationResult<unit>) ->
        xs:'a list -> OperationResult<unit>
    val Iterate2D :
      f:('a -> 'b -> OperationResult<unit>) ->
        xs:'a list -> ys:'b list -> OperationResult<unit>
    val TryD :
      f:(unit -> OperationResult<'a>) ->
        g:(exn -> OperationResult<'a>) -> OperationResult<'a>
    val RepeatWhileD :
      nDeep:int -> body:(int -> OperationResult<bool>) -> OperationResult<unit>
    val AtLeastOneD :
      f:('a -> OperationResult<bool>) -> l:'a list -> OperationResult<bool>
    module OperationResult = begin
      val inline ignore : res:OperationResult<'a> -> OperationResult<unit>
    end
    val stringThatIsAProxyForANewlineInFlatErrors : System.String
    val NewlineifyErrorString : message:string -> string
    val NormalizeErrorString : text:string -> string
    type FSharpErrorSeverityOptions =
      { WarnLevel: int
        GlobalWarnAsError: bool
        WarnOff: int list
        WarnOn: int list
        WarnAsError: int list
        WarnAsWarn: int list }
      with
        static member Default : FSharpErrorSeverityOptions
      end
    val private tryLanguageFeatureErrorAux :
      langVersion:Features.LanguageVersion ->
        langFeature:Features.LanguageFeature -> m:Range.range -> exn option
    val internal checkLanguageFeatureError :
      langVersion:Features.LanguageVersion ->
        langFeature:Features.LanguageFeature -> m:Range.range -> unit
    val internal checkLanguageFeatureErrorRecover :
      langVersion:Features.LanguageVersion ->
        langFeature:Features.LanguageFeature -> m:Range.range -> unit
    val internal tryLanguageFeatureErrorOption :
      langVersion:Features.LanguageVersion ->
        langFeature:Features.LanguageFeature -> m:Range.range -> exn option
    val internal languageFeatureNotSupportedInLibraryError :
      langVersion:Features.LanguageVersion ->
        langFeature:Features.LanguageFeature -> m:Range.range -> 'a
  end

namespace FSharp.Compiler
  module internal ErrorResolutionHints = begin
    val maxSuggestions : int
    val minThresholdForSuggestions : float
    val highConfidenceThreshold : float
    val minStringLengthForSuggestion : int
    val IsInEditDistanceProximity : idText:string -> suggestion:string -> bool
    val DemangleOperator : nm:string -> string
    type SuggestionBufferEnumerator =
      class
        interface System.IDisposable
        interface System.Collections.IEnumerator
        interface System.Collections.Generic.IEnumerator<string>
        new : tail:int *
              data:System.Collections.Generic.KeyValuePair<float,string> [] ->
                SuggestionBufferEnumerator
      end
    type SuggestionBuffer =
      class
        interface System.Collections.IEnumerable
        interface System.Collections.Generic.IEnumerable<string>
        new : idText:string -> SuggestionBuffer
        member Add : suggestion:string -> unit
        member Disabled : bool
        member IsEmpty : bool
      end
  end

namespace FSharp.Compiler.AbstractIL
  module IL = begin
    val logging : bool
    val int_order : System.Collections.Generic.IComparer<int>
    val notlazy : v:'a -> System.Lazy<'a>
    val lazyMap : f:('a -> 'b) -> x:System.Lazy<'a> -> System.Lazy<'b>
    [<RequireQualifiedAccessAttribute ()>]
    type PrimaryAssembly =
      | Mscorlib
      | System_Runtime
      | NetStandard
      with
        member Name : string
      end
    val splitNameAt : nm:string -> idx:int -> string * string
    val splitNamespaceAux : nm:string -> string list
    val memoizeNamespaceTable :
      System.Collections.Concurrent.ConcurrentDictionary<string,string list>
    val memoizeNamespaceRightTable :
      System.Collections.Concurrent.ConcurrentDictionary<string,
                                                         (string option * string)>
    val splitNamespace : string -> string list
    val splitNamespaceMemoized : nm:string -> string list
    val memoizeNamespaceArrayTable :
      System.Collections.Concurrent.ConcurrentDictionary<string,string []>
    val splitNamespaceToArray : string -> string []
    val splitILTypeName : string -> string list * string
    val emptyStringArray : string []
    val splitILTypeNameWithPossibleStaticArguments :
      string -> string [] * string
    val unsplitTypeName : ns:string list * n:string -> string
    val splitTypeNameRightAux : nm:string -> string option * string
    val splitTypeNameRight : string -> string option * string
    type LazyOrderedMultiMap<'Key,'Data when 'Key : equality> =
      class
        new : keyf:('Data -> 'Key) * lazyItems:System.Lazy<'Data list> ->
                LazyOrderedMultiMap<'Key,'Data>
        member Add : y:'Data -> LazyOrderedMultiMap<'Key,'Data>
        member Entries : unit -> 'Data list
        member Filter : f:('Data -> bool) -> LazyOrderedMultiMap<'Key,'Data>
        member Item : x:'Key -> 'Data list with get
      end
    val b0 : n:int -> int
    val b1 : n:int -> int
    val b2 : n:int -> int
    val b3 : n:int -> int
    module SHA1 = begin
      val inline ( >>>& ) : x:int -> y:int -> int32
      val f : t:int * b:int * c:int * d:int -> int
      [<LiteralAttribute ()>]
      val k0to19 : int = 1518500249
      [<LiteralAttribute ()>]
      val k20to39 : int = 1859775393
      [<LiteralAttribute ()>]
      val k40to59 : int = -1894007588
      [<LiteralAttribute ()>]
      val k60to79 : int = -899497514
      val k : t:int -> int
      type SHAStream =
        { stream: byte []
          mutable pos: int
          mutable eof: bool }
      val rotLeft32 : x:int32 -> n:int32 -> int32
      val shaAfterEof : sha:SHAStream -> int
      val shaRead8 : sha:SHAStream -> int
      val shaRead32 : sha:SHAStream -> int
      val sha1Hash : sha:SHAStream -> int * int * int * int * int
      val sha1HashBytes : s:byte [] -> byte []
      val sha1HashInt64 : s:byte [] -> int64
    end
    val sha1HashBytes : byte [] -> byte []
    val sha1HashInt64 : byte [] -> int64
    [<StructAttribute ()>]
    type ILVersionInfo =
      struct
        new : major:uint16 * minor:uint16 * build:uint16 * revision:uint16 ->
                ILVersionInfo
        val Major: uint16
        val Minor: uint16
        val Build: uint16
        val Revision: uint16
        override ToString : unit -> string
      end
    type Locale = string
    [<StructuralEqualityAttribute (); StructuralComparisonAttribute ()>]
    type PublicKey =
      | PublicKey of byte []
      | PublicKeyToken of byte []
      with
        static member KeyAsToken : byte [] -> PublicKey
        member ToToken : unit -> byte []
        member IsKey : bool
        member IsKeyToken : bool
        member Key : byte []
        member KeyToken : byte []
      end
    [<StructuralEqualityAttribute (); StructuralComparisonAttribute ()>]
    type AssemblyRefData =
      { assemRefName: string
        assemRefHash: byte [] option
        assemRefPublicKeyInfo: PublicKey option
        assemRefRetargetable: bool
        assemRefVersion: ILVersionInfo option
        assemRefLocale: Locale option }
    val AssemblyRefUniqueStampGenerator :
      Internal.Library.UniqueStampGenerator<AssemblyRefData>
    val isMscorlib : data:AssemblyRefData -> bool
    [<SealedAttribute ()>]
    type ILAssemblyRef =
      class
        interface System.IComparable
        new : data:AssemblyRefData -> ILAssemblyRef
        static member
          Create : name:string * hash:byte [] option *
                   publicKey:PublicKey option * retargetable:bool *
                   version:ILVersionInfo option * locale:Locale option ->
                     ILAssemblyRef
        static member
          FromAssemblyName : System.Reflection.AssemblyName -> ILAssemblyRef
        override Equals : yobj:obj -> bool
        member EqualsIgnoringVersion : ILAssemblyRef -> bool
        override GetHashCode : unit -> int
        member Hash : byte [] option
        member Locale : Locale option
        member Name : string
        member PublicKey : PublicKey option
        member QualifiedName : string
        member Retargetable : bool
        member UniqueIgnoringVersionStamp : int
        member UniqueStamp : int
        member Version : ILVersionInfo option
      end
    [<SealedAttribute (); StructuralEqualityAttribute ();
      StructuralComparisonAttribute ()>]
    type ILModuleRef =
      { name: string
        hasMetadata: bool
        hash: byte [] option }
      with
        static member
          Create : name:string * hasMetadata:bool * hash:byte [] option ->
                     ILModuleRef
        member HasMetadata : bool
        member Hash : byte [] option
        member Name : string
      end
    [<StructuralEqualityAttribute (); StructuralComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    type ILScopeRef =
      | Local
      | Module of ILModuleRef
      | Assembly of ILAssemblyRef
      | PrimaryAssembly
      with
        member IsLocalRef : bool
        member QualifiedName : string
      end
    type ILArrayBound = int32 option
    type ILArrayBounds = ILArrayBound * ILArrayBound
    [<StructuralEqualityAttribute (); StructuralComparisonAttribute ()>]
    type ILArrayShape =
      | ILArrayShape of ILArrayBounds list
      with
        static member FromRank : int -> ILArrayShape
        member Rank : int
        static member SingleDimensional : ILArrayShape
      end
    and ILArrayShapeStatics =
      class
        new : unit -> ILArrayShapeStatics
        static member SingleDimensional : ILArrayShape
      end
    [<StructuralEqualityAttribute (); StructuralComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    type ILArgConvention =
      | Default
      | CDecl
      | StdCall
      | ThisCall
      | FastCall
      | VarArg
    [<StructuralEqualityAttribute (); StructuralComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    type ILThisConvention =
      | Instance
      | InstanceExplicit
      | Static
    [<StructuralEqualityAttribute (); StructuralComparisonAttribute ()>]
    type ILCallingConv =
      | Callconv of ILThisConvention * ILArgConvention
      with
        member BasicConv : ILArgConvention
        member IsInstance : bool
        member IsInstanceExplicit : bool
        member IsStatic : bool
        member ThisConv : ILThisConvention
        static member Instance : ILCallingConv
        static member Static : ILCallingConv
      end
    and ILCallingConvStatics =
      class
        new : unit -> ILCallingConvStatics
        static member Instance : ILCallingConv
        static member Static : ILCallingConv
      end
    type ILBoxity =
      | AsObject
      | AsValue
    [<SealedAttribute (); CustomEqualityAttribute ();
      CustomComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    type ILTypeRef =
      { trefScope: ILScopeRef
        trefEnclosing: string list
        trefName: string
        hashCode: int
        mutable asBoxedType: ILType }
      with
        interface System.IComparable
        static member
          ComputeHash : scope:'a * enclosing:'b * name:'c -> int
                          when 'a : equality and 'b : equality and 'c : equality
        static member
          Create : scope:ILScopeRef * enclosing:string list * name:string ->
                     ILTypeRef
        member AddQualifiedNameExtension : basic:string -> string
        member AsBoxedType : tspec:ILTypeSpec -> ILType
        override Equals : yobj:obj -> bool
        member EqualsWithPrimaryScopeRef : ILScopeRef * obj -> bool
        override GetHashCode : unit -> int
        override ToString : unit -> string
        member ApproxId : int
        member BasicQualifiedName : string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member Enclosing : string list
        member FullName : string
        member Name : string
        member QualifiedName : string
        member Scope : ILScopeRef
      end
    [<SealedAttribute (); StructuralEqualityAttribute ();
      StructuralComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and ILTypeSpec =
      { tspecTypeRef: ILTypeRef
        tspecInst: ILGenericArgs }
      with
        static member
          Create : typeRef:ILTypeRef * instantiation:ILGenericArgs -> ILTypeSpec
        member AddQualifiedNameExtension : basic:string -> string
        member EqualsWithPrimaryScopeRef : ILScopeRef * obj -> bool
        override ToString : unit -> string
        member BasicQualifiedName : string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member Enclosing : string list
        member FullName : string
        member GenericArgs : ILGenericArgs
        member Name : string
        member Scope : ILScopeRef
        member TypeRef : ILTypeRef
      end
    [<RequireQualifiedAccessAttribute (); StructuralEqualityAttribute ();
      StructuralComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and ILType =
      | Void
      | Array of ILArrayShape * ILType
      | Value of ILTypeSpec
      | Boxed of ILTypeSpec
      | Ptr of ILType
      | Byref of ILType
      | FunctionPointer of ILCallingSignature
      | TypeVar of uint16
      | Modified of bool * ILTypeRef * ILType
      with
        member AddQualifiedNameExtension : basic:string -> string
        override ToString : unit -> string
        member BasicQualifiedName : string
        member Boxity : ILBoxity
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member GenericArgs : ILGenericArgs
        member IsNominal : bool
        member IsTyvar : bool
        member QualifiedName : string
        member TypeRef : ILTypeRef
        member TypeSpec : ILTypeSpec
      end
    [<StructuralEqualityAttribute (); StructuralComparisonAttribute ()>]
    and ILCallingSignature =
      { CallingConv: ILCallingConv
        ArgTypes: ILTypes
        ReturnType: ILType }
    and ILGenericArgs = ILType list
    and ILTypes = ILType list
    val mkILCallSig : ILCallingConv * ILTypes * ILType -> ILCallingSignature
    val mkILBoxedType : ILTypeSpec -> ILType
    [<SealedAttribute (); StructuralEqualityAttribute ();
      StructuralComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    type ILMethodRef =
      { mrefParent: ILTypeRef
        mrefCallconv: ILCallingConv
        mrefGenericArity: int
        mrefName: string
        mrefArgs: ILTypes
        mrefReturn: ILType }
      with
        static member
          Create : enclosingTypeRef:ILTypeRef * callingConv:ILCallingConv *
                   name:string * genericArity:int * argTypes:ILTypes *
                   returnType:ILType -> ILMethodRef
        override ToString : unit -> string
        member ArgCount : int
        member ArgTypes : ILTypes
        member CallingConv : ILCallingConv
        member CallingSignature : ILCallingSignature
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member DeclaringTypeRef : ILTypeRef
        member GenericArity : int
        member Name : string
        member ReturnType : ILType
      end
    [<StructuralEqualityAttribute (); StructuralComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    type ILFieldRef =
      { DeclaringTypeRef: ILTypeRef
        Name: string
        Type: ILType }
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<SealedAttribute (); StructuralEqualityAttribute ();
      StructuralComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    type ILMethodSpec =
      { mspecMethodRef: ILMethodRef
        mspecDeclaringType: ILType
        mspecMethodInst: ILGenericArgs }
      with
        static member
          Create : ILType * ILMethodRef * ILGenericArgs -> ILMethodSpec
        override ToString : unit -> string
        member CallingConv : ILCallingConv
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member DeclaringType : ILType
        member FormalArgTypes : ILTypes
        member FormalReturnType : ILType
        member GenericArgs : ILGenericArgs
        member GenericArity : int
        member MethodRef : ILMethodRef
        member Name : string
      end
    [<StructuralEqualityAttribute (); StructuralComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    type ILFieldSpec =
      { FieldRef: ILFieldRef
        DeclaringType: ILType }
      with
        override ToString : unit -> string
        member ActualType : ILType
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member DeclaringTypeRef : ILTypeRef
        member FormalType : ILType
        member Name : string
      end
    type ILGuid = byte []
    [<StructuralEqualityAttribute (); StructuralComparisonAttribute ()>]
    type ILPlatform =
      | X86
      | AMD64
      | IA64
    [<SealedAttribute ()>]
    type ILSourceDocument =
      { sourceLanguage: ILGuid option
        sourceVendor: ILGuid option
        sourceDocType: ILGuid option
        sourceFile: string }
      with
        static member
          Create : language:ILGuid option * vendor:ILGuid option *
                   documentType:ILGuid option * file:string -> ILSourceDocument
        member DocumentType : ILGuid option
        member File : string
        member Language : ILGuid option
        member Vendor : ILGuid option
      end
    [<SealedAttribute (); StructuralEqualityAttribute ();
      StructuralComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    type ILSourceMarker =
      { sourceDocument: ILSourceDocument
        sourceLine: int
        sourceColumn: int
        sourceEndLine: int
        sourceEndColumn: int }
      with
        static member
          Create : document:ILSourceDocument * line:int * column:int *
                   endLine:int * endColumn:int -> ILSourceMarker
        override ToString : unit -> string
        member Column : int
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member Document : ILSourceDocument
        member EndColumn : int
        member EndLine : int
        member Line : int
      end
    [<RequireQualifiedAccessAttribute ()>]
    type ILAttribElem =
      | String of string option
      | Bool of bool
      | Char of char
      | SByte of int8
      | Int16 of int16
      | Int32 of int32
      | Int64 of int64
      | Byte of uint8
      | UInt16 of uint16
      | UInt32 of uint32
      | UInt64 of uint64
      | Single of single
      | Double of double
      | Null
      | Type of ILType option
      | TypeRef of ILTypeRef option
      | Array of ILType * ILAttribElem list
    type ILAttributeNamedArg = string * ILType * bool * ILAttribElem
    [<RequireQualifiedAccessAttribute (); StructuralEqualityAttribute ();
      StructuralComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    type ILAttribute =
      | Encoded of
        method: ILMethodSpec * data: byte [] * elements: ILAttribElem list
      | Decoded of
        method: ILMethodSpec * fixedArgs: ILAttribElem list *
        namedArgs: ILAttributeNamedArg list
      with
        override ToString : unit -> string
        member WithMethod : method:ILMethodSpec -> ILAttribute
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member Elements : ILAttribElem list
        member Method : ILMethodSpec
      end
    [<NoEqualityAttribute (); NoComparisonAttribute (); StructAttribute ()>]
    type ILAttributes =
      struct
        new : array:ILAttribute [] -> ILAttributes
        member AsArray : ILAttribute []
        member AsList : ILAttribute list
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type ILAttributesStored =
      | Reader of (int32 -> ILAttribute [])
      | Given of ILAttributes
      with
        member GetCustomAttrs : metadataIndex:int32 -> ILAttributes
      end
    val emptyILCustomAttrs : ILAttributes
    val mkILCustomAttrsFromArray : ILAttribute [] -> ILAttributes
    val mkILCustomAttrs : ILAttribute list -> ILAttributes
    val emptyILCustomAttrsStored : ILAttributesStored
    val storeILCustomAttrs : ILAttributes -> ILAttributesStored
    val mkILCustomAttrsReader : (int32 -> ILAttribute []) -> ILAttributesStored
    type ILCodeLabel = int
    [<StructuralEqualityAttribute (); StructuralComparisonAttribute ()>]
    type ILBasicType =
      | DT_R
      | DT_I1
      | DT_U1
      | DT_I2
      | DT_U2
      | DT_I4
      | DT_U4
      | DT_I8
      | DT_U8
      | DT_R4
      | DT_R8
      | DT_I
      | DT_U
      | DT_REF
    [<StructuralEqualityAttribute (); StructuralComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    type ILToken =
      | ILType of ILType
      | ILMethod of ILMethodSpec
      | ILField of ILFieldSpec
    [<StructuralEqualityAttribute (); StructuralComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    type ILConst =
      | I4 of int32
      | I8 of int64
      | R4 of single
      | R8 of double
    type ILTailcall =
      | Tailcall
      | Normalcall
    type ILAlignment =
      | Aligned
      | Unaligned1
      | Unaligned2
      | Unaligned4
    type ILVolatility =
      | Volatile
      | Nonvolatile
    type ILReadonly =
      | ReadonlyAddress
      | NormalAddress
    type ILVarArgs = ILTypes option
    [<StructuralEqualityAttribute (); StructuralComparisonAttribute ()>]
    type ILComparisonInstr =
      | BI_beq
      | BI_bge
      | BI_bge_un
      | BI_bgt
      | BI_bgt_un
      | BI_ble
      | BI_ble_un
      | BI_blt
      | BI_blt_un
      | BI_bne_un
      | BI_brfalse
      | BI_brtrue
    [<StructuralEqualityAttribute (); NoComparisonAttribute ()>]
    type ILInstr =
      | AI_add
      | AI_add_ovf
      | AI_add_ovf_un
      | AI_and
      | AI_div
      | AI_div_un
      | AI_ceq
      | AI_cgt
      | AI_cgt_un
      | AI_clt
      | AI_clt_un
      | AI_conv of ILBasicType
      | AI_conv_ovf of ILBasicType
      | AI_conv_ovf_un of ILBasicType
      | AI_mul
      | AI_mul_ovf
      | AI_mul_ovf_un
      | AI_rem
      | AI_rem_un
      | AI_shl
      | AI_shr
      | AI_shr_un
      | AI_sub
      | AI_sub_ovf
      | AI_sub_ovf_un
      | AI_xor
      | AI_or
      | AI_neg
      | AI_not
      | AI_ldnull
      | AI_dup
      | AI_pop
      | AI_ckfinite
      | AI_nop
      | AI_ldc of ILBasicType * ILConst
      | I_ldarg of uint16
      | I_ldarga of uint16
      | I_ldind of ILAlignment * ILVolatility * ILBasicType
      | I_ldloc of uint16
      | I_ldloca of uint16
      | I_starg of uint16
      | I_stind of ILAlignment * ILVolatility * ILBasicType
      | I_stloc of uint16
      | I_br of ILCodeLabel
      | I_jmp of ILMethodSpec
      | I_brcmp of ILComparisonInstr * ILCodeLabel
      | I_switch of ILCodeLabel list
      | I_ret
      | I_call of ILTailcall * ILMethodSpec * ILVarArgs
      | I_callvirt of ILTailcall * ILMethodSpec * ILVarArgs
      | I_callconstraint of ILTailcall * ILType * ILMethodSpec * ILVarArgs
      | I_calli of ILTailcall * ILCallingSignature * ILVarArgs
      | I_ldftn of ILMethodSpec
      | I_newobj of ILMethodSpec * ILVarArgs
      | I_throw
      | I_endfinally
      | I_endfilter
      | I_leave of ILCodeLabel
      | I_rethrow
      | I_ldsfld of ILVolatility * ILFieldSpec
      | I_ldfld of ILAlignment * ILVolatility * ILFieldSpec
      | I_ldsflda of ILFieldSpec
      | I_ldflda of ILFieldSpec
      | I_stsfld of ILVolatility * ILFieldSpec
      | I_stfld of ILAlignment * ILVolatility * ILFieldSpec
      | I_ldstr of string
      | I_isinst of ILType
      | I_castclass of ILType
      | I_ldtoken of ILToken
      | I_ldvirtftn of ILMethodSpec
      | I_cpobj of ILType
      | I_initobj of ILType
      | I_ldobj of ILAlignment * ILVolatility * ILType
      | I_stobj of ILAlignment * ILVolatility * ILType
      | I_box of ILType
      | I_unbox of ILType
      | I_unbox_any of ILType
      | I_sizeof of ILType
      | I_ldelem of ILBasicType
      | I_stelem of ILBasicType
      | I_ldelema of ILReadonly * bool * ILArrayShape * ILType
      | I_ldelem_any of ILArrayShape * ILType
      | I_stelem_any of ILArrayShape * ILType
      | I_newarr of ILArrayShape * ILType
      | I_ldlen
      | I_mkrefany of ILType
      | I_refanytype
      | I_refanyval of ILType
      | I_break
      | I_seqpoint of ILSourceMarker
      | I_arglist
      | I_localloc
      | I_cpblk of ILAlignment * ILVolatility
      | I_initblk of ILAlignment * ILVolatility
      | EI_ilzero of ILType
      | EI_ldlen_multi of int32 * int32
    [<RequireQualifiedAccessAttribute ()>]
    type ILExceptionClause =
      | Finally of (ILCodeLabel * ILCodeLabel)
      | Fault of (ILCodeLabel * ILCodeLabel)
      | FilterCatch of
        filterRange: ILCodeLabel * ILCodeLabel *
        handlerRange: ILCodeLabel * ILCodeLabel
      | TypeCatch of ILType * (ILCodeLabel * ILCodeLabel)
    [<RequireQualifiedAccessAttribute (); NoEqualityAttribute ();
      NoComparisonAttribute ()>]
    type ILExceptionSpec =
      { Range: ILCodeLabel * ILCodeLabel
        Clause: ILExceptionClause }
    [<RequireQualifiedAccessAttribute (); NoEqualityAttribute ();
      NoComparisonAttribute ()>]
    type ILLocalDebugMapping =
      { LocalIndex: int
        LocalName: string }
    [<RequireQualifiedAccessAttribute (); NoEqualityAttribute ();
      NoComparisonAttribute ()>]
    type ILLocalDebugInfo =
      { Range: ILCodeLabel * ILCodeLabel
        DebugMappings: ILLocalDebugMapping list }
    [<RequireQualifiedAccessAttribute (); NoEqualityAttribute ();
      NoComparisonAttribute ()>]
    type ILCode =
      { Labels: System.Collections.Generic.Dictionary<ILCodeLabel,int>
        Instrs: ILInstr []
        Exceptions: ILExceptionSpec list
        Locals: ILLocalDebugInfo list }
    [<RequireQualifiedAccessAttribute (); NoComparisonAttribute ();
      NoEqualityAttribute ()>]
    type ILLocal =
      { Type: ILType
        IsPinned: bool
        DebugInfo: (string * int * int) option }
    type ILLocals = ILLocal list
    [<RequireQualifiedAccessAttribute (); NoComparisonAttribute ();
      NoEqualityAttribute ()>]
    type ILMethodBody =
      { IsZeroInit: bool
        MaxStack: int32
        NoInlining: bool
        AggressiveInlining: bool
        Locals: ILLocals
        Code: ILCode
        SourceMarker: ILSourceMarker option }
    [<RequireQualifiedAccessAttribute ()>]
    type ILMemberAccess =
      | Assembly
      | CompilerControlled
      | FamilyAndAssembly
      | FamilyOrAssembly
      | Family
      | Private
      | Public
    [<RequireQualifiedAccessAttribute (); StructuralEqualityAttribute ();
      StructuralComparisonAttribute ()>]
    type ILFieldInit =
      | String of string
      | Bool of bool
      | Char of uint16
      | Int8 of int8
      | Int16 of int16
      | Int32 of int32
      | Int64 of int64
      | UInt8 of uint8
      | UInt16 of uint16
      | UInt32 of uint32
      | UInt64 of uint64
      | Single of single
      | Double of double
      | Null
      with
        member AsObject : unit -> obj
      end
    [<RequireQualifiedAccessAttribute (); StructuralEqualityAttribute ();
      StructuralComparisonAttribute ()>]
    type ILNativeType =
      | Empty
      | Custom of
        ILGuid * nativeTypeName: string * custMarshallerName: string *
        cookieString: byte []
      | FixedSysString of int32
      | FixedArray of int32
      | Currency
      | LPSTR
      | LPWSTR
      | LPTSTR
      | LPUTF8STR
      | ByValStr
      | TBSTR
      | LPSTRUCT
      | Struct
      | Void
      | Bool
      | Int8
      | Int16
      | Int32
      | Int64
      | Single
      | Double
      | Byte
      | UInt16
      | UInt32
      | UInt64
      | Array of ILNativeType option * (int32 * int32 option) option
      | Int
      | UInt
      | Method
      | AsAny
      | BSTR
      | IUnknown
      | IDispatch
      | Interface
      | Error
      | SafeArray of ILNativeVariant * string option
      | ANSIBSTR
      | VariantBool
    [<RequireQualifiedAccessAttribute (); StructuralEqualityAttribute ();
      StructuralComparisonAttribute ()>]
    and ILNativeVariant =
      | Empty
      | Null
      | Variant
      | Currency
      | Decimal
      | Date
      | BSTR
      | LPSTR
      | LPWSTR
      | IUnknown
      | IDispatch
      | SafeArray
      | Error
      | HRESULT
      | CArray
      | UserDefined
      | Record
      | FileTime
      | Blob
      | Stream
      | Storage
      | StreamedObject
      | StoredObject
      | BlobObject
      | CF
      | CLSID
      | Void
      | Bool
      | Int8
      | Int16
      | Int32
      | Int64
      | Single
      | Double
      | UInt8
      | UInt16
      | UInt32
      | UInt64
      | PTR
      | Array of ILNativeVariant
      | Vector of ILNativeVariant
      | Byref of ILNativeVariant
      | Int
      | UInt
    [<RequireQualifiedAccessAttribute (); StructuralEqualityAttribute ();
      StructuralComparisonAttribute ()>]
    type ILSecurityAction =
      | Request
      | Demand
      | Assert
      | Deny
      | PermitOnly
      | LinkCheck
      | InheritCheck
      | ReqMin
      | ReqOpt
      | ReqRefuse
      | PreJitGrant
      | PreJitDeny
      | NonCasDemand
      | NonCasLinkDemand
      | NonCasInheritance
      | LinkDemandChoice
      | InheritanceDemandChoice
      | DemandChoice
    [<RequireQualifiedAccessAttribute (); StructuralEqualityAttribute ();
      StructuralComparisonAttribute ()>]
    type ILSecurityDecl = | ILSecurityDecl of ILSecurityAction * byte []
    [<NoComparisonAttribute (); NoEqualityAttribute (); StructAttribute ()>]
    type ILSecurityDecls =
      struct
        new : array:ILSecurityDecl [] -> ILSecurityDecls
        member AsArray : ILSecurityDecl []
        member AsList : ILSecurityDecl list
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type ILSecurityDeclsStored =
      | Reader of (int32 -> ILSecurityDecl [])
      | Given of ILSecurityDecls
      with
        member GetSecurityDecls : metadataIndex:int32 -> ILSecurityDecls
      end
    val emptyILSecurityDecls : ILSecurityDecls
    val emptyILSecurityDeclsStored : ILSecurityDeclsStored
    val mkILSecurityDecls : ILSecurityDecl list -> ILSecurityDecls
    val storeILSecurityDecls : ILSecurityDecls -> ILSecurityDeclsStored
    val mkILSecurityDeclsReader :
      (int32 -> ILSecurityDecl []) -> ILSecurityDeclsStored
    [<RequireQualifiedAccessAttribute ()>]
    type PInvokeCharBestFit =
      | UseAssembly
      | Enabled
      | Disabled
    [<RequireQualifiedAccessAttribute ()>]
    type PInvokeThrowOnUnmappableChar =
      | UseAssembly
      | Enabled
      | Disabled
    [<RequireQualifiedAccessAttribute ()>]
    type PInvokeCallingConvention =
      | None
      | Cdecl
      | Stdcall
      | Thiscall
      | Fastcall
      | WinApi
    [<RequireQualifiedAccessAttribute ()>]
    type PInvokeCharEncoding =
      | None
      | Ansi
      | Unicode
      | Auto
    [<RequireQualifiedAccessAttribute (); NoComparisonAttribute ();
      NoEqualityAttribute ()>]
    type PInvokeMethod =
      { Where: ILModuleRef
        Name: string
        CallingConv: PInvokeCallingConvention
        CharEncoding: PInvokeCharEncoding
        NoMangle: bool
        LastError: bool
        ThrowOnUnmappableChar: PInvokeThrowOnUnmappableChar
        CharBestFit: PInvokeCharBestFit }
    [<RequireQualifiedAccessAttribute (); NoEqualityAttribute ();
      NoComparisonAttribute ()>]
    type ILParameter =
      { Name: string option
        Type: ILType
        Default: ILFieldInit option
        Marshal: ILNativeType option
        IsIn: bool
        IsOut: bool
        IsOptional: bool
        CustomAttrsStored: ILAttributesStored
        MetadataIndex: int32 }
      with
        member CustomAttrs : ILAttributes
      end
    type ILParameters = ILParameter list
    [<RequireQualifiedAccessAttribute (); NoEqualityAttribute ();
      NoComparisonAttribute ()>]
    type ILReturn =
      { Marshal: ILNativeType option
        Type: ILType
        CustomAttrsStored: ILAttributesStored
        MetadataIndex: int32 }
      with
        member WithCustomAttrs : customAttrs:ILAttributes -> ILReturn
        member CustomAttrs : ILAttributes
      end
    type ILOverridesSpec =
      | OverridesSpec of ILMethodRef * ILType
      with
        member DeclaringType : ILType
        member MethodRef : ILMethodRef
      end
    type ILMethodVirtualInfo =
      { IsFinal: bool
        IsNewSlot: bool
        IsCheckAccessOnOverride: bool
        IsAbstract: bool }
    [<RequireQualifiedAccessAttribute ()>]
    type MethodKind =
      | Static
      | Cctor
      | Ctor
      | NonVirtual
      | Virtual of ILMethodVirtualInfo
    [<RequireQualifiedAccessAttribute ()>]
    type MethodBody =
      | IL of ILMethodBody
      | PInvoke of PInvokeMethod
      | Abstract
      | Native
      | NotAvailable
    [<NoComparisonAttribute (); NoEqualityAttribute (); SealedAttribute ()>]
    type ILLazyMethodBody =
      | ILLazyMethodBody of System.Lazy<MethodBody>
      with
        member Contents : MethodBody
      end
    [<RequireQualifiedAccessAttribute ()>]
    type MethodCodeKind =
      | IL
      | Native
      | Runtime
    val mkMethBodyAux : MethodBody -> ILLazyMethodBody
    val mkMethBodyLazyAux : System.Lazy<MethodBody> -> ILLazyMethodBody
    val typesOfILParams : ILParameters -> ILTypes
    [<StructuralEqualityAttribute (); StructuralComparisonAttribute ()>]
    type ILGenericVariance =
      | NonVariant
      | CoVariant
      | ContraVariant
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    type ILGenericParameterDef =
      { Name: string
        Constraints: ILTypes
        Variance: ILGenericVariance
        HasReferenceTypeConstraint: bool
        HasNotNullableValueTypeConstraint: bool
        HasDefaultConstructorConstraint: bool
        CustomAttrsStored: ILAttributesStored
        MetadataIndex: int32 }
      with
        override ToString : unit -> string
        member CustomAttrs : ILAttributes
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    type ILGenericParameterDefs = ILGenericParameterDef list
    val memberAccessOfFlags : flags:int -> ILMemberAccess
    val convertMemberAccess :
      ilMemberAccess:ILMemberAccess -> System.Reflection.MethodAttributes
    val inline conditionalAdd :
      condition:bool -> flagToAdd: ^a -> source: ^a ->  ^a
        when  ^a : (static member ( ~~~ ) :  ^a ->  ^a) and
              ^a : (static member ( ||| ) :  ^a *  ^a ->  ^a) and
              ^a : (static member ( &&& ) :  ^a *  ^a ->  ^a)
    val NoMetadataIdx : int
    [<NoComparisonAttribute (); NoEqualityAttribute ()>]
    type ILMethodDef =
      class
        new : name:string * attributes:System.Reflection.MethodAttributes *
              implAttributes:System.Reflection.MethodImplAttributes *
              callingConv:ILCallingConv * parameters:ILParameters * ret:ILReturn *
              body:ILLazyMethodBody * isEntryPoint:bool *
              genericParams:ILGenericParameterDefs *
              securityDecls:ILSecurityDecls * customAttrs:ILAttributes ->
                ILMethodDef
        new : name:string * attributes:System.Reflection.MethodAttributes *
              implAttributes:System.Reflection.MethodImplAttributes *
              callingConv:ILCallingConv * parameters:ILParameters * ret:ILReturn *
              body:ILLazyMethodBody * isEntryPoint:bool *
              genericParams:ILGenericParameterDefs *
              securityDeclsStored:ILSecurityDeclsStored *
              customAttrsStored:ILAttributesStored * metadataIndex:int32 ->
                ILMethodDef
        member
          With : ?name:string * ?attributes:System.Reflection.MethodAttributes *
                 ?implAttributes:System.Reflection.MethodImplAttributes *
                 ?callingConv:ILCallingConv * ?parameters:ILParameters *
                 ?ret:ILReturn * ?body:ILLazyMethodBody *
                 ?securityDecls:ILSecurityDecls * ?isEntryPoint:bool *
                 ?genericParams:ILGenericParameterDefs *
                 ?customAttrs:ILAttributes -> ILMethodDef
        member WithAbstract : bool -> ILMethodDef
        member WithAccess : ILMemberAccess -> ILMethodDef
        member WithAggressiveInlining : bool -> ILMethodDef
        member WithFinal : bool -> ILMethodDef
        member WithHideBySig : unit -> ILMethodDef
        member WithHideBySig : bool -> ILMethodDef
        member WithNoInlining : bool -> ILMethodDef
        member WithPInvoke : bool -> ILMethodDef
        member WithPreserveSig : bool -> ILMethodDef
        member WithRuntime : bool -> ILMethodDef
        member WithSecurity : bool -> ILMethodDef
        member WithSynchronized : bool -> ILMethodDef
        member Access : ILMemberAccess
        member Attributes : System.Reflection.MethodAttributes
        member Body : ILLazyMethodBody
        member CallingConv : ILCallingConv
        member CallingSignature : ILCallingSignature
        member Code : ILCode option
        member CustomAttrs : ILAttributes
        member CustomAttrsStored : ILAttributesStored
        member GenericParams : ILGenericParameterDefs
        member HasSecurity : bool
        member ImplAttributes : System.Reflection.MethodImplAttributes
        member IsAbstract : bool
        member IsAggressiveInline : bool
        member IsCheckAccessOnOverride : bool
        member IsClassInitializer : bool
        member IsConstructor : bool
        member IsEntryPoint : bool
        member IsFinal : bool
        member IsForwardRef : bool
        member IsHideBySig : bool
        member IsIL : bool
        member IsInternalCall : bool
        member IsManaged : bool
        member IsMustRun : bool
        member IsNewSlot : bool
        member IsNoInline : bool
        member IsNonVirtualInstance : bool
        member IsPreserveSig : bool
        member IsReqSecObj : bool
        member IsSpecialName : bool
        member IsStatic : bool
        member IsSynchronized : bool
        member IsUnmanagedExport : bool
        member IsVirtual : bool
        member IsZeroInit : bool
        member Locals : ILLocals
        member MaxStack : int32
        member MetadataIndex : int32
        member MethodBody : ILMethodBody
        member Name : string
        member ParameterTypes : ILTypes
        member Parameters : ILParameters
        member Return : ILReturn
        member SecurityDecls : ILSecurityDecls
        member SecurityDeclsStored : ILSecurityDeclsStored
        member SourceMarker : ILSourceMarker option
        member WithNewSlot : ILMethodDef
        member WithSpecialName : ILMethodDef
      end
    type MethodDefMap = Map<string,ILMethodDef list>
    [<NoEqualityAttribute (); NoComparisonAttribute (); SealedAttribute ()>]
    type ILMethodDefs =
      class
        interface System.Collections.Generic.IEnumerable<ILMethodDef>
        interface System.Collections.IEnumerable
        new : f:(unit -> ILMethodDef []) -> ILMethodDefs
        member FindByName : string -> ILMethodDef list
        member FindByNameAndArity : nm:string * arity:int -> ILMethodDef list
        member
          TryFindInstanceByNameAndCallingSignature : string * ILCallingSignature ->
                                                       ILMethodDef option
        member AsArray : ILMethodDef []
        member AsList : ILMethodDef list
      end
    [<NoComparisonAttribute (); NoEqualityAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    type ILEventDef =
      class
        new : eventType:ILType option * name:string *
              attributes:System.Reflection.EventAttributes *
              addMethod:ILMethodRef * removeMethod:ILMethodRef *
              fireMethod:ILMethodRef option * otherMethods:ILMethodRef list *
              customAttrs:ILAttributes -> ILEventDef
        new : eventType:ILType option * name:string *
              attributes:System.Reflection.EventAttributes *
              addMethod:ILMethodRef * removeMethod:ILMethodRef *
              fireMethod:ILMethodRef option * otherMethods:ILMethodRef list *
              customAttrsStored:ILAttributesStored * metadataIndex:int32 ->
                ILEventDef
        override ToString : unit -> string
        member
          With : ?eventType:ILType option * ?name:string *
                 ?attributes:System.Reflection.EventAttributes *
                 ?addMethod:ILMethodRef * ?removeMethod:ILMethodRef *
                 ?fireMethod:ILMethodRef option * ?otherMethods:ILMethodRef list *
                 ?customAttrs:ILAttributes -> ILEventDef
        member AddMethod : ILMethodRef
        member Attributes : System.Reflection.EventAttributes
        member CustomAttrs : ILAttributes
        member CustomAttrsStored : ILAttributesStored
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member EventType : ILType option
        member FireMethod : ILMethodRef option
        member IsRTSpecialName : bool
        member IsSpecialName : bool
        member MetadataIndex : int32
        member Name : string
        member OtherMethods : ILMethodRef list
        member RemoveMethod : ILMethodRef
      end
    [<NoEqualityAttribute (); NoComparisonAttribute (); SealedAttribute ()>]
    type ILEventDefs =
      | ILEvents of LazyOrderedMultiMap<string,ILEventDef>
      with
        member LookupByName : string -> ILEventDef list
        member AsList : ILEventDef list
      end
    [<NoComparisonAttribute (); NoEqualityAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    type ILPropertyDef =
      class
        new : name:string * attributes:System.Reflection.PropertyAttributes *
              setMethod:ILMethodRef option * getMethod:ILMethodRef option *
              callingConv:ILThisConvention * propertyType:ILType *
              init:ILFieldInit option * args:ILTypes * customAttrs:ILAttributes ->
                ILPropertyDef
        new : name:string * attributes:System.Reflection.PropertyAttributes *
              setMethod:ILMethodRef option * getMethod:ILMethodRef option *
              callingConv:ILThisConvention * propertyType:ILType *
              init:ILFieldInit option * args:ILTypes *
              customAttrsStored:ILAttributesStored * metadataIndex:int32 ->
                ILPropertyDef
        override ToString : unit -> string
        member
          With : ?name:string * ?attributes:System.Reflection.PropertyAttributes *
                 ?setMethod:ILMethodRef option * ?getMethod:ILMethodRef option *
                 ?callingConv:ILThisConvention * ?propertyType:ILType *
                 ?init:ILFieldInit option * ?args:ILTypes *
                 ?customAttrs:ILAttributes -> ILPropertyDef
        member Args : ILTypes
        member Attributes : System.Reflection.PropertyAttributes
        member CallingConv : ILThisConvention
        member CustomAttrs : ILAttributes
        member CustomAttrsStored : ILAttributesStored
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member GetMethod : ILMethodRef option
        member Init : ILFieldInit option
        member IsRTSpecialName : bool
        member IsSpecialName : bool
        member MetadataIndex : int32
        member Name : string
        member PropertyType : ILType
        member SetMethod : ILMethodRef option
      end
    [<NoEqualityAttribute (); NoComparisonAttribute (); SealedAttribute ()>]
    type ILPropertyDefs =
      | ILProperties of LazyOrderedMultiMap<string,ILPropertyDef>
      with
        member LookupByName : string -> ILPropertyDef list
        member AsList : ILPropertyDef list
      end
    val convertFieldAccess :
      ilMemberAccess:ILMemberAccess -> System.Reflection.FieldAttributes
    [<NoComparisonAttribute (); NoEqualityAttribute ()>]
    type ILFieldDef =
      class
        new : name:string * fieldType:ILType *
              attributes:System.Reflection.FieldAttributes * data:byte [] option *
              literalValue:ILFieldInit option * offset:int32 option *
              marshal:ILNativeType option * customAttrs:ILAttributes ->
                ILFieldDef
        new : name:string * fieldType:ILType *
              attributes:System.Reflection.FieldAttributes * data:byte [] option *
              literalValue:ILFieldInit option * offset:int32 option *
              marshal:ILNativeType option * customAttrsStored:ILAttributesStored *
              metadataIndex:int32 -> ILFieldDef
        member
          With : ?name:string * ?fieldType:ILType *
                 ?attributes:System.Reflection.FieldAttributes *
                 ?data:byte [] option * ?literalValue:ILFieldInit option *
                 ?offset:int32 option * ?marshal:ILNativeType option *
                 ?customAttrs:ILAttributes -> ILFieldDef
        member WithAccess : ILMemberAccess -> ILFieldDef
        member WithFieldMarshal : ILNativeType option -> ILFieldDef
        member WithInitOnly : bool -> ILFieldDef
        member WithLiteralDefaultValue : ILFieldInit option -> ILFieldDef
        member WithNotSerialized : bool -> ILFieldDef
        member WithSpecialName : bool -> ILFieldDef
        member WithStatic : bool -> ILFieldDef
        member Access : ILMemberAccess
        member Attributes : System.Reflection.FieldAttributes
        member CustomAttrs : ILAttributes
        member CustomAttrsStored : ILAttributesStored
        member Data : byte [] option
        member FieldType : ILType
        member IsInitOnly : bool
        member IsLiteral : bool
        member IsSpecialName : bool
        member IsStatic : bool
        member LiteralValue : ILFieldInit option
        member Marshal : ILNativeType option
        member MetadataIndex : int32
        member Name : string
        member NotSerialized : bool
        member Offset : int32 option
      end
    [<NoEqualityAttribute (); NoComparisonAttribute (); SealedAttribute ()>]
    type ILFieldDefs =
      | ILFields of LazyOrderedMultiMap<string,ILFieldDef>
      with
        member LookupByName : string -> ILFieldDef list
        member AsList : ILFieldDef list
      end
    type ILMethodImplDef =
      { Overrides: ILOverridesSpec
        OverrideBy: ILMethodSpec }
    [<NoEqualityAttribute (); NoComparisonAttribute (); SealedAttribute ()>]
    type ILMethodImplDefs =
      | ILMethodImpls of System.Lazy<MethodImplsMap>
      with
        member AsList : ILMethodImplDef list
      end
    and MethodImplsMap = Map<(string * int),ILMethodImplDef list>
    [<RequireQualifiedAccessAttribute ()>]
    type ILTypeDefLayout =
      | Auto
      | Sequential of ILTypeDefLayoutInfo
      | Explicit of ILTypeDefLayoutInfo
    and ILTypeDefLayoutInfo =
      { Size: int32 option
        Pack: uint16 option }
    [<RequireQualifiedAccessAttribute ()>]
    type ILTypeInit =
      | BeforeField
      | OnAny
    [<RequireQualifiedAccessAttribute ()>]
    type ILDefaultPInvokeEncoding =
      | Ansi
      | Auto
      | Unicode
    [<RequireQualifiedAccessAttribute ()>]
    type ILTypeDefAccess =
      | Public
      | Private
      | Nested of ILMemberAccess
    val typeAccessOfFlags : flags:int -> ILTypeDefAccess
    val typeEncodingOfFlags : flags:int -> ILDefaultPInvokeEncoding
    [<RequireQualifiedAccessAttribute ()>]
    type ILTypeDefKind =
      | Class
      | ValueType
      | Interface
      | Enum
      | Delegate
    val typeKindOfFlags :
      nm:string -> super:ILType option -> flags:int -> ILTypeDefKind
    val convertTypeAccessFlags :
      access:ILTypeDefAccess -> System.Reflection.TypeAttributes
    val convertTypeKind : kind:ILTypeDefKind -> System.Reflection.TypeAttributes
    val convertLayout :
      layout:ILTypeDefLayout -> System.Reflection.TypeAttributes
    val convertEncoding :
      encoding:ILDefaultPInvokeEncoding -> System.Reflection.TypeAttributes
    val convertToNestedTypeAccess :
      ilMemberAccess:ILMemberAccess -> System.Reflection.TypeAttributes
    val convertInitSemantics :
      init:ILTypeInit -> System.Reflection.TypeAttributes
    [<NoComparisonAttribute (); NoEqualityAttribute ()>]
    type ILTypeDef =
      class
        new : name:string * attributes:System.Reflection.TypeAttributes *
              layout:ILTypeDefLayout * implements:ILTypes *
              genericParams:ILGenericParameterDefs * extends:ILType option *
              methods:ILMethodDefs * nestedTypes:ILTypeDefs * fields:ILFieldDefs *
              methodImpls:ILMethodImplDefs * events:ILEventDefs *
              properties:ILPropertyDefs * securityDecls:ILSecurityDecls *
              customAttrs:ILAttributes -> ILTypeDef
        new : name:string * attributes:System.Reflection.TypeAttributes *
              layout:ILTypeDefLayout * implements:ILTypes *
              genericParams:ILGenericParameterDefs * extends:ILType option *
              methods:ILMethodDefs * nestedTypes:ILTypeDefs * fields:ILFieldDefs *
              methodImpls:ILMethodImplDefs * events:ILEventDefs *
              properties:ILPropertyDefs *
              securityDeclsStored:ILSecurityDeclsStored *
              customAttrsStored:ILAttributesStored * metadataIndex:int32 ->
                ILTypeDef
        member
          With : ?name:string * ?attributes:System.Reflection.TypeAttributes *
                 ?layout:ILTypeDefLayout * ?implements:ILTypes *
                 ?genericParams:ILGenericParameterDefs * ?extends:ILType option *
                 ?methods:ILMethodDefs * ?nestedTypes:ILTypeDefs *
                 ?fields:ILFieldDefs * ?methodImpls:ILMethodImplDefs *
                 ?events:ILEventDefs * ?properties:ILPropertyDefs *
                 ?customAttrs:ILAttributes * ?securityDecls:ILSecurityDecls ->
                   ILTypeDef
        member WithAbstract : bool -> ILTypeDef
        member WithAccess : ILTypeDefAccess -> ILTypeDef
        member WithEncoding : ILDefaultPInvokeEncoding -> ILTypeDef
        member WithHasSecurity : bool -> ILTypeDef
        member WithImport : bool -> ILTypeDef
        member WithInitSemantics : ILTypeInit -> ILTypeDef
        member WithKind : ILTypeDefKind -> ILTypeDef
        member WithLayout : ILTypeDefLayout -> ILTypeDef
        member WithNestedAccess : ILMemberAccess -> ILTypeDef
        member WithSealed : bool -> ILTypeDef
        member WithSerializable : bool -> ILTypeDef
        member WithSpecialName : bool -> ILTypeDef
        member Access : ILTypeDefAccess
        member Attributes : System.Reflection.TypeAttributes
        member CustomAttrs : ILAttributes
        member CustomAttrsStored : ILAttributesStored
        member Encoding : ILDefaultPInvokeEncoding
        member Events : ILEventDefs
        member Extends : ILType option
        member Fields : ILFieldDefs
        member GenericParams : ILGenericParameterDefs
        member HasSecurity : bool
        member Implements : ILTypes
        member IsAbstract : bool
        member IsClass : bool
        member IsComInterop : bool
        member IsDelegate : bool
        member IsEnum : bool
        member IsInterface : bool
        member IsSealed : bool
        member IsSerializable : bool
        member IsSpecialName : bool
        member IsStruct : bool
        member IsStructOrEnum : bool
        member Layout : ILTypeDefLayout
        member MetadataIndex : int32
        member MethodImpls : ILMethodImplDefs
        member Methods : ILMethodDefs
        member Name : string
        member NestedTypes : ILTypeDefs
        member Properties : ILPropertyDefs
        member SecurityDecls : ILSecurityDecls
        member SecurityDeclsStored : ILSecurityDeclsStored
      end
    [<NoEqualityAttribute (); NoComparisonAttribute (); SealedAttribute ()>]
    and ILTypeDefs =
      class
        interface System.Collections.Generic.IEnumerable<ILTypeDef>
        interface System.Collections.IEnumerable
        new : f:(unit -> ILPreTypeDef []) -> ILTypeDefs
        member FindByName : string -> ILTypeDef
        member AsArray : ILTypeDef []
        member AsArrayOfPreTypeDefs : ILPreTypeDef []
        member AsList : ILTypeDef list
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and ILPreTypeDef =
      interface
        abstract member GetTypeDef : unit -> ILTypeDef
        abstract member Name : string
        abstract member Namespace : string list
      end
    [<NoEqualityAttribute (); NoComparisonAttribute (); SealedAttribute ()>]
    and ILPreTypeDefImpl =
      class
        interface ILPreTypeDef
        new : nameSpace:string list * name:string * metadataIndex:int32 *
              storage:ILTypeDefStored -> ILPreTypeDefImpl
      end
    [<SealedAttribute ()>]
    and ILTypeDefStored =
      | Given of ILTypeDef
      | Reader of (int32 -> ILTypeDef)
      | Computed of (unit -> ILTypeDef)
    val mkILTypeDefReader : (int32 -> ILTypeDef) -> ILTypeDefStored
    type ILNestedExportedType =
      { Name: string
        Access: ILMemberAccess
        Nested: ILNestedExportedTypes
        CustomAttrsStored: ILAttributesStored
        MetadataIndex: int32 }
      with
        member CustomAttrs : ILAttributes
      end
    [<NoEqualityAttribute (); NoComparisonAttribute (); SealedAttribute ()>]
    and ILNestedExportedTypes =
      | ILNestedExportedTypes of System.Lazy<Map<string,ILNestedExportedType>>
      with
        member AsList : ILNestedExportedType list
      end
    [<NoComparisonAttribute (); NoEqualityAttribute ()>]
    and ILExportedTypeOrForwarder =
      { ScopeRef: ILScopeRef
        Name: string
        Attributes: System.Reflection.TypeAttributes
        Nested: ILNestedExportedTypes
        CustomAttrsStored: ILAttributesStored
        MetadataIndex: int32 }
      with
        member Access : ILTypeDefAccess
        member CustomAttrs : ILAttributes
        member IsForwarder : bool
      end
    [<NoEqualityAttribute (); NoComparisonAttribute (); SealedAttribute ()>]
    and ILExportedTypesAndForwarders =
      | ILExportedTypesAndForwarders of
        System.Lazy<Map<string,ILExportedTypeOrForwarder>>
      with
        member TryFindByName : string -> ILExportedTypeOrForwarder option
        member AsList : ILExportedTypeOrForwarder list
      end
    [<RequireQualifiedAccessAttribute ()>]
    type ILResourceAccess =
      | Public
      | Private
    [<RequireQualifiedAccessAttribute (); NoEqualityAttribute ();
      NoComparisonAttribute ()>]
    type ILResourceLocation =
      | Local of Internal.ByteStorage
      | File of ILModuleRef * int32
      | Assembly of ILAssemblyRef
    type ILResource =
      { Name: string
        Location: ILResourceLocation
        Access: ILResourceAccess
        CustomAttrsStored: ILAttributesStored
        MetadataIndex: int32 }
      with
        member GetBytes : unit -> Internal.ReadOnlyByteMemory
        member CustomAttrs : ILAttributes
      end
    [<NoEqualityAttribute (); NoComparisonAttribute (); SealedAttribute ()>]
    type ILResources =
      | ILResources of ILResource list
      with
        member AsList : ILResource list
      end
    [<RequireQualifiedAccessAttribute ()>]
    type ILAssemblyLongevity =
      | Unspecified
      | Library
      | PlatformAppDomain
      | PlatformProcess
      | PlatformSystem
    type ILAssemblyManifest =
      { Name: string
        AuxModuleHashAlgorithm: int32
        SecurityDeclsStored: ILSecurityDeclsStored
        PublicKey: byte [] option
        Version: ILVersionInfo option
        Locale: Locale option
        CustomAttrsStored: ILAttributesStored
        AssemblyLongevity: ILAssemblyLongevity
        DisableJitOptimizations: bool
        JitTracking: bool
        IgnoreSymbolStoreSequencePoints: bool
        Retargetable: bool
        ExportedTypes: ILExportedTypesAndForwarders
        EntrypointElsewhere: ILModuleRef option
        MetadataIndex: int32 }
      with
        member CustomAttrs : ILAttributes
        member SecurityDecls : ILSecurityDecls
      end
    [<RequireQualifiedAccessAttribute ()>]
    type ILNativeResource =
      | In of
        fileName: string * linkedResourceBase: int * linkedResourceStart: int *
        linkedResourceLength: int
      | Out of unlinkedResource: byte []
    type ILModuleDef =
      { Manifest: ILAssemblyManifest option
        Name: string
        TypeDefs: ILTypeDefs
        SubsystemVersion: int * int
        UseHighEntropyVA: bool
        SubSystemFlags: int32
        IsDLL: bool
        IsILOnly: bool
        Platform: ILPlatform option
        StackReserveSize: int32 option
        Is32Bit: bool
        Is32BitPreferred: bool
        Is64Bit: bool
        VirtualAlignment: int32
        PhysicalAlignment: int32
        ImageBase: int32
        MetadataVersion: string
        Resources: ILResources
        NativeResources: ILNativeResource list
        CustomAttrsStored: ILAttributesStored
        MetadataIndex: int32 }
      with
        member CustomAttrs : ILAttributes
        member HasManifest : bool
        member ManifestOfAssembly : ILAssemblyManifest
      end
    val mkILEmptyGenericParams : ILGenericParameterDefs
    val emptyILGenericArgsList : ILType list
    val mkILNestedTyRef : ILScopeRef * string list * string -> ILTypeRef
    val mkILTyRef : ILScopeRef * string -> ILTypeRef
    type ILGenericArgsList = ILType list
    val mkILTySpec : ILTypeRef * ILGenericArgs -> ILTypeSpec
    val mkILNonGenericTySpec : ILTypeRef -> ILTypeSpec
    val mkILTyRefInTyRef : ILTypeRef * string -> ILTypeRef
    val mkILTy : ILBoxity -> ILTypeSpec -> ILType
    val mkILNamedTy : ILBoxity -> ILTypeRef -> ILGenericArgs -> ILType
    val mkILValueTy : ILTypeRef -> ILGenericArgs -> ILType
    val mkILBoxedTy : ILTypeRef -> ILGenericArgs -> ILType
    val mkILNonGenericValueTy : ILTypeRef -> ILType
    val mkILNonGenericBoxedTy : ILTypeRef -> ILType
    val mkSimpleAssemblyRef : string -> ILAssemblyRef
    val mkSimpleModRef : string -> ILModuleRef
    val typeNameForGlobalFunctions : string
    val mkILTypeForGlobalFunctions : ILScopeRef -> ILType
    val isTypeNameForGlobalFunctions : string -> bool
    val mkILMethRef :
      ILTypeRef * ILCallingConv * string * int * ILTypes * ILType -> ILMethodRef
    val mkILMethSpecForMethRefInTy :
      ILMethodRef * ILType * ILGenericArgs -> ILMethodSpec
    val mkILMethSpec :
      ILMethodRef * ILBoxity * ILGenericArgs * ILGenericArgs -> ILMethodSpec
    val mkILMethSpecInTypeRef :
      tref:ILTypeRef * vc:ILBoxity * cc:ILCallingConv * nm:string * args:ILTypes *
      rty:ILType * tinst:ILGenericArgs * minst:ILType list -> ILMethodSpec
    val mkILMethSpecInTy :
      ILType * ILCallingConv * string * ILTypes * ILType * ILGenericArgs ->
        ILMethodSpec
    val mkILNonGenericMethSpecInTy :
      ILType * ILCallingConv * string * ILTypes * ILType -> ILMethodSpec
    val mkILInstanceMethSpecInTy :
      ILType * string * ILTypes * ILType * ILGenericArgs -> ILMethodSpec
    val mkILNonGenericInstanceMethSpecInTy :
      ILType * string * ILTypes * ILType -> ILMethodSpec
    val mkILStaticMethSpecInTy :
      ILType * string * ILTypes * ILType * ILGenericArgs -> ILMethodSpec
    val mkILNonGenericStaticMethSpecInTy :
      ILType * string * ILTypes * ILType -> ILMethodSpec
    val mkILCtorMethSpec :
      tref:ILTypeRef * args:ILTypes * cinst:ILGenericArgs -> ILMethodSpec
    val mkILCtorMethSpecForTy : ILType * ILTypes -> ILMethodSpec
    val mkILNonGenericCtorMethSpec :
      tref:ILTypeRef * args:ILTypes -> ILMethodSpec
    val mkILFieldRef : ILTypeRef * string * ILType -> ILFieldRef
    val mkILFieldSpec : ILFieldRef * ILType -> ILFieldSpec
    val mkILFieldSpecInTy : ILType * string * ILType -> ILFieldSpec
    val andTailness : ILTailcall -> bool -> ILTailcall
    val formatCodeLabel : int -> string
    val codeLabelCount : int ref
    val generateCodeLabel : unit -> int
    val instrIsRet : i:ILInstr -> bool
    val nonBranchingInstrsToCode : ILInstr list -> ILCode
    val mkILTyvarTy : uint16 -> ILType
    val mkILSimpleTypar : string -> ILGenericParameterDef
    val gparam_of_gactual : _ga:ILType -> ILGenericParameterDef
    val mkILFormalTypars : ILGenericArgsList -> ILGenericParameterDef list
    val mkILFormalGenericArgs : int -> ILGenericParameterDefs -> ILType list
    val mkILFormalBoxedTy : ILTypeRef -> ILGenericParameterDefs -> ILType
    val mkILFormalNamedTy :
      ILBoxity -> ILTypeRef -> ILGenericParameterDefs -> ILType
    val mkRefForNestedILTypeDef :
      ILScopeRef -> ILTypeDef list * ILTypeDef -> ILTypeRef
    val mkILPreTypeDef : ILTypeDef -> ILPreTypeDef
    val mkILPreTypeDefComputed :
      string list * string * (unit -> ILTypeDef) -> ILPreTypeDef
    val mkILPreTypeDefRead :
      string list * string * int32 * ILTypeDefStored -> ILPreTypeDef
    val addILTypeDef : ILTypeDef -> ILTypeDefs -> ILTypeDefs
    val mkILTypeDefsFromArray : ILTypeDef [] -> ILTypeDefs
    val mkILTypeDefs : ILTypeDef list -> ILTypeDefs
    val mkILTypeDefsComputed : (unit -> ILPreTypeDef []) -> ILTypeDefs
    val emptyILTypeDefs : ILTypeDefs
    val mkILMethodsFromArray : ILMethodDef [] -> ILMethodDefs
    val mkILMethods : ILMethodDef list -> ILMethodDefs
    val mkILMethodsComputed : (unit -> ILMethodDef []) -> ILMethodDefs
    val emptyILMethods : ILMethodDefs
    val filterILMethodDefs :
      f:(ILMethodDef -> bool) -> mdefs:ILMethodDefs -> ILMethodDefs
    val defaultSubSystem : int
    val defaultPhysAlignment : int
    val defaultVirtAlignment : int
    val defaultImageBase : int
    val mkILArrTy : ILType * ILArrayShape -> ILType
    val mkILArr1DTy : ILType -> ILType
    val isILArrTy : ILType -> bool
    val destILArrTy : ILType -> ILArrayShape * ILType
    [<LiteralAttribute ()>]
    val tname_Object : string = "System.Object"
    [<LiteralAttribute ()>]
    val tname_String : string = "System.String"
    [<LiteralAttribute ()>]
    val tname_Array : string = "System.Array"
    [<LiteralAttribute ()>]
    val tname_Type : string = "System.Type"
    [<LiteralAttribute ()>]
    val tname_Int64 : string = "System.Int64"
    [<LiteralAttribute ()>]
    val tname_UInt64 : string = "System.UInt64"
    [<LiteralAttribute ()>]
    val tname_Int32 : string = "System.Int32"
    [<LiteralAttribute ()>]
    val tname_UInt32 : string = "System.UInt32"
    [<LiteralAttribute ()>]
    val tname_Int16 : string = "System.Int16"
    [<LiteralAttribute ()>]
    val tname_UInt16 : string = "System.UInt16"
    [<LiteralAttribute ()>]
    val tname_SByte : string = "System.SByte"
    [<LiteralAttribute ()>]
    val tname_Byte : string = "System.Byte"
    [<LiteralAttribute ()>]
    val tname_Single : string = "System.Single"
    [<LiteralAttribute ()>]
    val tname_Double : string = "System.Double"
    [<LiteralAttribute ()>]
    val tname_Bool : string = "System.Boolean"
    [<LiteralAttribute ()>]
    val tname_Char : string = "System.Char"
    [<LiteralAttribute ()>]
    val tname_IntPtr : string = "System.IntPtr"
    [<LiteralAttribute ()>]
    val tname_UIntPtr : string = "System.UIntPtr"
    [<LiteralAttribute ()>]
    val tname_TypedReference : string = "System.TypedReference"
    [<NoEqualityAttribute (); NoComparisonAttribute (); ClassAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    type ILGlobals =
      class
        new : primaryScopeRef:ILScopeRef *
              assembliesThatForwardToPrimaryAssembly:ILAssemblyRef list ->
                ILGlobals
        member IsPossiblePrimaryAssemblyRef : ILAssemblyRef -> bool
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member primaryAssemblyName : string
        member primaryAssemblyRef : ILAssemblyRef
        member primaryAssemblyScopeRef : ILScopeRef
        member typ_Array : ILType
        member typ_Bool : ILType
        member typ_Byte : ILType
        member typ_Char : ILType
        member typ_Double : ILType
        member typ_Int16 : ILType
        member typ_Int32 : ILType
        member typ_Int64 : ILType
        member typ_IntPtr : ILType
        member typ_Object : ILType
        member typ_SByte : ILType
        member typ_Single : ILType
        member typ_String : ILType
        member typ_Type : ILType
        member typ_TypedReference : ILType
        member typ_UInt16 : ILType
        member typ_UInt32 : ILType
        member typ_UInt64 : ILType
        member typ_UIntPtr : ILType
      end
    val mkILGlobals :
      primaryScopeRef:ILScopeRef *
      assembliesThatForwardToPrimaryAssembly:ILAssemblyRef list -> ILGlobals
    val mkNormalCall : ILMethodSpec -> ILInstr
    val mkNormalCallvirt : ILMethodSpec -> ILInstr
    val mkNormalCallconstraint : ILType * ILMethodSpec -> ILInstr
    val mkNormalNewobj : ILMethodSpec -> ILInstr
    val ldargs : ILInstr []
    val mkLdarg : uint16 -> ILInstr
    val mkLdarg0 : ILInstr
    val ldlocs : ILInstr []
    val mkLdloc : uint16 -> ILInstr
    val stlocs : ILInstr []
    val mkStloc : uint16 -> ILInstr
    val ldi32s : ILInstr []
    val mkLdcInt32 : int -> ILInstr
    val tname_CompilerGeneratedAttribute : string
    val tname_DebuggableAttribute : string
    val ecmaPublicKey : PublicKey
    val isILBoxedTy : _arg1:ILType -> bool
    val isILValueTy : _arg1:ILType -> bool
    val isBuiltInTySpec : ilg:ILGlobals -> tspec:ILTypeSpec -> n:string -> bool
    val isILBoxedBuiltInTy : ilg:ILGlobals -> ty:ILType -> n:string -> bool
    val isILValueBuiltInTy : ilg:ILGlobals -> ty:ILType -> n:string -> bool
    val isILObjectTy : ILGlobals -> ILType -> bool
    val isILStringTy : ILGlobals -> ILType -> bool
    val isILTypedReferenceTy : ILGlobals -> ILType -> bool
    val isILSByteTy : ILGlobals -> ILType -> bool
    val isILByteTy : ILGlobals -> ILType -> bool
    val isILInt16Ty : ILGlobals -> ILType -> bool
    val isILUInt16Ty : ILGlobals -> ILType -> bool
    val isILInt32Ty : ILGlobals -> ILType -> bool
    val isILUInt32Ty : ILGlobals -> ILType -> bool
    val isILInt64Ty : ILGlobals -> ILType -> bool
    val isILUInt64Ty : ILGlobals -> ILType -> bool
    val isILIntPtrTy : ILGlobals -> ILType -> bool
    val isILUIntPtrTy : ILGlobals -> ILType -> bool
    val isILBoolTy : ILGlobals -> ILType -> bool
    val isILCharTy : ILGlobals -> ILType -> bool
    val isILSingleTy : ILGlobals -> ILType -> bool
    val isILDoubleTy : ILGlobals -> ILType -> bool
    val rescopeILScopeRef : ILScopeRef -> ILScopeRef -> ILScopeRef
    val rescopeILTypeRef : scoref:ILScopeRef -> tref1:ILTypeRef -> ILTypeRef
    val rescopeILTypeSpec : ILScopeRef -> ILTypeSpec -> ILTypeSpec
    val rescopeILType : ILScopeRef -> ILType -> ILType
    val rescopeILTypes : scoref:ILScopeRef -> i:ILGenericArgs -> ILGenericArgs
    val rescopeILCallSig :
      scoref:ILScopeRef -> csig:ILCallingSignature -> ILCallingSignature
    val rescopeILMethodRef : ILScopeRef -> ILMethodRef -> ILMethodRef
    val rescopeILFieldRef : ILScopeRef -> ILFieldRef -> ILFieldRef
    val instILTypeSpecAux :
      numFree:int -> inst:ILGenericArgs -> tspec:ILTypeSpec -> ILTypeSpec
    val instILTypeAux : int -> ILGenericArgs -> ILType -> ILType
    val instILGenericArgsAux :
      numFree:int -> inst:ILGenericArgs -> i:ILGenericArgs -> ILGenericArgs
    val instILCallSigAux :
      numFree:int ->
        inst:ILGenericArgs -> csig:ILCallingSignature -> ILCallingSignature
    val instILType : ILGenericArgs -> ILType -> ILType
    val mkILParam : string option * ILType -> ILParameter
    val mkILParamNamed : string * ILType -> ILParameter
    val mkILParamAnon : ILType -> ILParameter
    val mkILReturn : ILType -> ILReturn
    val mkILLocal : ILType -> (string * int * int) option -> ILLocal
    val mkILMethodBody :
      initlocals:bool * ILLocals * int32 * ILCode * ILSourceMarker option ->
        ILMethodBody
    val mkMethodBody :
      bool * ILLocals * int32 * ILCode * ILSourceMarker option -> MethodBody
    val mkILVoidReturn : ILReturn
    val methBodyNotAvailable : ILLazyMethodBody
    val methBodyAbstract : ILLazyMethodBody
    val methBodyNative : ILLazyMethodBody
    val mkILCtor : ILMemberAccess * ILParameters * MethodBody -> ILMethodDef
    val mkCallBaseConstructor : ILType * ILType list -> ILInstr list
    val mkNormalStfld : ILFieldSpec -> ILInstr
    val mkNormalStsfld : ILFieldSpec -> ILInstr
    val mkNormalLdsfld : ILFieldSpec -> ILInstr
    val mkNormalLdfld : ILFieldSpec -> ILInstr
    val mkNormalLdflda : ILFieldSpec -> ILInstr
    val mkNormalLdobj : ILType -> ILInstr
    val mkNormalStobj : ILType -> ILInstr
    val mkILNonGenericEmptyCtor : ILSourceMarker option -> ILType -> ILMethodDef
    val mkILStaticMethod :
      ILGenericParameterDefs * string * ILMemberAccess * ILParameters * ILReturn *
      MethodBody -> ILMethodDef
    val mkILNonGenericStaticMethod :
      string * ILMemberAccess * ILParameters * ILReturn * MethodBody ->
        ILMethodDef
    val mkILClassCtor : MethodBody -> ILMethodDef
    val mk_ospec :
      ty:ILType * callconv:ILCallingConv * nm:string * genparams:int *
      formal_args:ILTypes * formal_ret:ILType -> ILOverridesSpec
    val mkILGenericVirtualMethod :
      string * ILMemberAccess * ILGenericParameterDefs * ILParameters * ILReturn *
      MethodBody -> ILMethodDef
    val mkILNonGenericVirtualMethod :
      string * ILMemberAccess * ILParameters * ILReturn * MethodBody ->
        ILMethodDef
    val mkILGenericNonVirtualMethod :
      string * ILMemberAccess * ILGenericParameterDefs * ILParameters * ILReturn *
      MethodBody -> ILMethodDef
    val mkILNonGenericInstanceMethod :
      string * ILMemberAccess * ILParameters * ILReturn * MethodBody ->
        ILMethodDef
    val ilmbody_code2code :
      f:(ILCode -> ILCode) -> il:ILMethodBody -> ILMethodBody
    val mdef_code2code : f:(ILCode -> ILCode) -> md:ILMethodDef -> ILMethodDef
    val prependInstrsToCode : ILInstr list -> ILCode -> ILCode
    val prependInstrsToMethod : ILInstr list -> ILMethodDef -> ILMethodDef
    val cdef_cctorCode2CodeOrCreate :
      tag:ILSourceMarker option ->
        f:(ILMethodDef -> ILMethodDef) -> cd:ILTypeDef -> ILTypeDef
    val code_of_mdef : md:ILMethodDef -> ILCode
    val mkRefToILMethod : ILTypeRef * ILMethodDef -> ILMethodRef
    val mkRefToILField : ILTypeRef * ILFieldDef -> ILFieldRef
    val mkRefForILMethod :
      ILScopeRef -> ILTypeDef list * ILTypeDef -> ILMethodDef -> ILMethodRef
    val mkRefForILField :
      ILScopeRef -> ILTypeDef list * ILTypeDef -> ILFieldDef -> ILFieldRef
    val prependInstrsToClassCtor :
      ILInstr list -> ILSourceMarker option -> ILTypeDef -> ILTypeDef
    val mkILField :
      isStatic:bool * nm:string * ty:ILType * init:ILFieldInit option *
      at:byte [] option * access:ILMemberAccess * isLiteral:bool -> ILFieldDef
    val mkILInstanceField :
      string * ILType * ILFieldInit option * ILMemberAccess -> ILFieldDef
    val mkILStaticField :
      string * ILType * ILFieldInit option * byte [] option * ILMemberAccess ->
        ILFieldDef
    val mkILLiteralField :
      string * ILType * ILFieldInit * byte [] option * ILMemberAccess ->
        ILFieldDef
    type ILLocalsAllocator =
      class
        new : preAlloc:int -> ILLocalsAllocator
        member AllocLocal : ILLocal -> uint16
        member Close : unit -> ILLocal list
      end
    val mkILFieldsLazy : System.Lazy<ILFieldDef list> -> ILFieldDefs
    val mkILFields : ILFieldDef list -> ILFieldDefs
    val emptyILFields : ILFieldDefs
    val mkILEventsLazy : System.Lazy<ILEventDef list> -> ILEventDefs
    val mkILEvents : ILEventDef list -> ILEventDefs
    val emptyILEvents : ILEventDefs
    val mkILPropertiesLazy : System.Lazy<ILPropertyDef list> -> ILPropertyDefs
    val mkILProperties : ILPropertyDef list -> ILPropertyDefs
    val emptyILProperties : ILPropertyDefs
    val addExportedTypeToTable :
      y:ILExportedTypeOrForwarder ->
        tab:Map<string,ILExportedTypeOrForwarder> ->
          Map<string,ILExportedTypeOrForwarder>
    val mkILExportedTypes :
      ILExportedTypeOrForwarder list -> ILExportedTypesAndForwarders
    val mkILExportedTypesLazy :
      System.Lazy<ILExportedTypeOrForwarder list> ->
        ILExportedTypesAndForwarders
    val addNestedExportedTypeToTable :
      y:ILNestedExportedType ->
        tab:Map<string,ILNestedExportedType> -> Map<string,ILNestedExportedType>
    val mkTypeForwarder :
      ILScopeRef ->
        string ->
          ILNestedExportedTypes ->
            ILAttributes -> ILTypeDefAccess -> ILExportedTypeOrForwarder
    val mkILNestedExportedTypes :
      ILNestedExportedType list -> ILNestedExportedTypes
    val mkILNestedExportedTypesLazy :
      System.Lazy<ILNestedExportedType list> -> ILNestedExportedTypes
    val mkILResources : ILResource list -> ILResources
    val addMethodImplToTable :
      y:ILMethodImplDef ->
        tab:Map<(string * int),ILMethodImplDef list> ->
          Map<(string * int),ILMethodImplDef list>
    val mkILMethodImpls : ILMethodImplDef list -> ILMethodImplDefs
    val mkILMethodImplsLazy :
      System.Lazy<ILMethodImplDef list> -> ILMethodImplDefs
    val emptyILMethodImpls : ILMethodImplDefs
    val mkILStorageCtorWithParamNames :
      tag:ILSourceMarker option * preblock:ILInstr list * ty:ILType *
      extraParams:ILParameter list * flds:(string * string * ILType) list *
      access:ILMemberAccess -> ILMethodDef
    val mkILSimpleStorageCtorWithParamNames :
      ILSourceMarker option * ILTypeSpec option * ILType * ILParameter list *
      (string * string * ILType) list * ILMemberAccess -> ILMethodDef
    val addParamNames : flds:('a * 'b) list -> ('a * 'a * 'b) list
    val mkILSimpleStorageCtor :
      ILSourceMarker option * ILTypeSpec option * ILType * ILParameter list *
      (string * ILType) list * ILMemberAccess -> ILMethodDef
    val mkILStorageCtor :
      ILSourceMarker option * ILInstr list * ILType * (string * ILType) list *
      ILMemberAccess -> ILMethodDef
    val mkILGenericClass :
      string * ILTypeDefAccess * ILGenericParameterDefs * ILType * ILTypes *
      ILMethodDefs * ILFieldDefs * ILTypeDefs * ILPropertyDefs * ILEventDefs *
      ILAttributes * ILTypeInit -> ILTypeDef
    val mkRawDataValueTypeDef :
      ILType -> string * size:int32 * pack:uint16 -> ILTypeDef
    val mkILSimpleClass :
      ILGlobals ->
        string * ILTypeDefAccess * ILMethodDefs * ILFieldDefs * ILTypeDefs *
        ILPropertyDefs * ILEventDefs * ILAttributes * ILTypeInit -> ILTypeDef
    val mkILTypeDefForGlobalFunctions :
      ILGlobals -> ILMethodDefs * ILFieldDefs -> ILTypeDef
    val destTypeDefsWithGlobalFunctionsFirst :
      ILGlobals -> ILTypeDefs -> ILTypeDef list
    val mkILSimpleModule :
      assemblyName:string ->
        moduleName:string ->
          dll:bool ->
            subsystemVersion:(int * int) ->
              useHighEntropyVA:bool ->
                ILTypeDefs ->
                  int32 option ->
                    Locale option ->
                      int ->
                        ILExportedTypesAndForwarders -> string -> ILModuleDef
    val buildILCode :
      string ->
        lab2pc:System.Collections.Generic.Dictionary<ILCodeLabel,int> ->
          instrs:ILInstr [] ->
            ILExceptionSpec list -> ILLocalDebugInfo list -> ILCode
    val mkILDelegateMethods :
      ILMemberAccess ->
        ILGlobals ->
          ILType * ILType -> ILParameters * ILReturn -> ILMethodDef list
    val mkCtorMethSpecForDelegate : ILGlobals -> ILType * bool -> ILMethodSpec
    type ILEnumInfo =
      { enumValues: (string * ILFieldInit) list
        enumType: ILType }
    val getTyOfILEnumInfo : ILEnumInfo -> ILType
    val computeILEnumInfo : string * ILFieldDefs -> ILEnumInfo
    val sigptr_get_byte : bytes:byte [] -> sigptr:int -> int * int
    val sigptr_get_bool : bytes:byte [] -> sigptr:int -> bool * int
    val sigptr_get_u8 : bytes:byte [] -> sigptr:int -> byte * int
    val sigptr_get_i8 : bytes:byte [] -> sigptr:int -> sbyte * int
    val sigptr_get_u16 : bytes:byte [] -> sigptr:int -> uint16 * int
    val sigptr_get_i16 : bytes:byte [] -> sigptr:int -> int16 * int
    val sigptr_get_i32 : bytes:byte [] -> sigptr:int -> int * int
    val sigptr_get_u32 : bytes:byte [] -> sigptr:int -> uint32 * int
    val sigptr_get_i64 : bytes:byte [] -> sigptr:int -> int64 * int
    val sigptr_get_u64 : bytes:byte [] -> sigptr:int -> uint64 * int
    val float32_of_bits : x:int32 -> float32
    val float_of_bits : x:int64 -> float
    val sigptr_get_ieee32 : bytes:byte [] -> sigptr:int -> float32 * int
    val sigptr_get_ieee64 : bytes:byte [] -> sigptr:int -> float * int
    val sigptr_get_intarray :
      n:int -> bytes:byte [] -> sigptr:int -> byte [] * int
    val sigptr_get_string : n:int -> bytes:byte [] -> sigptr:int -> string * int
    val sigptr_get_z_i32 : bytes:byte [] -> sigptr:int -> int * int
    val sigptr_get_serstring : bytes:byte [] -> sigptr:int -> string * int
    val sigptr_get_serstring_possibly_null :
      bytes:byte [] -> sigptr:int -> string option * int
    val mkRefToILAssembly : ILAssemblyManifest -> ILAssemblyRef
    val z_unsigned_int_size : n:int -> int
    val z_unsigned_int : n:int -> byte []
    val string_as_utf8_bytes : s:string -> byte []
    val dw7 : n:int64 -> byte
    val dw6 : n:int64 -> byte
    val dw5 : n:int64 -> byte
    val dw4 : n:int64 -> byte
    val dw3 : n:int64 -> byte
    val dw2 : n:int64 -> byte
    val dw1 : n:int64 -> byte
    val dw0 : n:int64 -> byte
    val u8AsBytes : i:byte -> byte []
    val u16AsBytes : x:uint16 -> byte []
    val i32AsBytes : i:int -> byte []
    val i64AsBytes : i:int64 -> byte []
    val i8AsBytes : i:sbyte -> byte []
    val i16AsBytes : i:int16 -> byte []
    val u32AsBytes : i:uint32 -> byte []
    val u64AsBytes : i:uint64 -> byte []
    val bits_of_float32 : x:float32 -> int
    val bits_of_float : x:float -> int64
    val ieee32AsBytes : i:float32 -> byte []
    val ieee64AsBytes : i:float -> byte []
    val et_END : byte
    val et_VOID : byte
    val et_BOOLEAN : byte
    val et_CHAR : byte
    val et_I1 : byte
    val et_U1 : byte
    val et_I2 : byte
    val et_U2 : byte
    val et_I4 : byte
    val et_U4 : byte
    val et_I8 : byte
    val et_U8 : byte
    val et_R4 : byte
    val et_R8 : byte
    val et_STRING : byte
    val et_PTR : byte
    val et_BYREF : byte
    val et_VALUETYPE : byte
    val et_CLASS : byte
    val et_VAR : byte
    val et_ARRAY : byte
    val et_WITH : byte
    val et_TYPEDBYREF : byte
    val et_I : byte
    val et_U : byte
    val et_FNPTR : byte
    val et_OBJECT : byte
    val et_SZARRAY : byte
    val et_MVAR : byte
    val et_CMOD_REQD : byte
    val et_CMOD_OPT : byte
    val formatILVersion : ILVersionInfo -> string
    val encodeCustomAttrString : s:string -> byte []
    val encodeCustomAttrElemType : x:ILType -> byte []
    val encodeCustomAttrElemTypeForObject : x:ILAttribElem -> byte []
    val decodeCustomAttrElemType :
      ilg:ILGlobals -> bytes:byte [] -> sigptr:int -> x:byte -> ILType * int
    val encodeCustomAttrPrimValue : ilg:'a -> c:ILAttribElem -> byte []
    val encodeCustomAttrValue : ilg:'a -> ty:ILType -> c:ILAttribElem -> byte []
    val encodeCustomAttrNamedArg :
      ilg:'a -> nm:string * ty:ILType * prop:bool * elem:ILAttribElem -> byte []
    val encodeCustomAttrArgs :
      ilg:ILGlobals ->
        mspec:ILMethodSpec ->
          fixedArgs:ILAttribElem list ->
            namedArgs:(string * ILType * bool * ILAttribElem) list -> byte []
    val encodeCustomAttr :
      ilg:ILGlobals ->
        mspec:ILMethodSpec * fixedArgs:ILAttribElem list *
        namedArgs:(string * ILType * bool * ILAttribElem) list -> ILAttribute
    val mkILCustomAttribMethRef :
      ILGlobals ->
        ILMethodSpec * ILAttribElem list *
        (string * ILType * bool * ILAttribElem) list -> ILAttribute
    val mkILCustomAttribute :
      ILGlobals ->
        ILTypeRef * ILTypes * ILAttribElem list *
        (string * ILType * bool * ILAttribElem) list -> ILAttribute
    val getCustomAttrData : ILGlobals -> ILAttribute -> byte []
    val MscorlibScopeRef : ILScopeRef
    val EcmaMscorlibILGlobals : ILGlobals
    val PrimaryAssemblyILGlobals : ILGlobals
    val mkPermissionSet :
      ILGlobals ->
        ILSecurityAction *
        (ILTypeRef * (string * ILType * ILAttribElem) list) list ->
          ILSecurityDecl
    type ILTypeSigParser =
      class
        new : tstring:string -> ILTypeSigParser
        member private ParseType : unit -> ILType
        member ParseTypeSpec : unit -> ILAttribElem
      end
    val decodeILAttribData :
      ILGlobals -> ILAttribute -> ILAttribElem list * ILAttributeNamedArg list
    type ILReferences =
      { AssemblyReferences: ILAssemblyRef list
        ModuleReferences: ILModuleRef list }
    type ILReferencesAccumulator =
      { ilg: ILGlobals
        refsA: System.Collections.Generic.HashSet<ILAssemblyRef>
        refsM: System.Collections.Generic.HashSet<ILModuleRef> }
    val emptyILRefs : ILReferences
    val refs_of_assemblyRef :
      s:ILReferencesAccumulator -> x:ILAssemblyRef -> unit
    val refs_of_modref : s:ILReferencesAccumulator -> x:ILModuleRef -> unit
    val refs_of_scoref : s:ILReferencesAccumulator -> x:ILScopeRef -> unit
    val refs_of_tref : s:ILReferencesAccumulator -> x:ILTypeRef -> unit
    val refs_of_typ : s:ILReferencesAccumulator -> x:ILType -> unit
    val refs_of_inst : s:ILReferencesAccumulator -> i:ILGenericArgs -> unit
    val refs_of_tspec : s:ILReferencesAccumulator -> x:ILTypeSpec -> unit
    val refs_of_callsig :
      s:ILReferencesAccumulator -> csig:ILCallingSignature -> unit
    val refs_of_genparam :
      s:ILReferencesAccumulator -> x:ILGenericParameterDef -> unit
    val refs_of_genparams :
      s:ILReferencesAccumulator -> b:ILGenericParameterDef list -> unit
    val refs_of_dloc : s:ILReferencesAccumulator -> ts:ILTypeRef -> unit
    val refs_of_mref : s:ILReferencesAccumulator -> x:ILMethodRef -> unit
    val refs_of_fref : s:ILReferencesAccumulator -> x:ILFieldRef -> unit
    val refs_of_ospec : s:ILReferencesAccumulator -> ILOverridesSpec -> unit
    val refs_of_mspec : s:ILReferencesAccumulator -> x:ILMethodSpec -> unit
    val refs_of_fspec : s:ILReferencesAccumulator -> x:ILFieldSpec -> unit
    val refs_of_tys : s:ILReferencesAccumulator -> l:ILGenericArgs -> unit
    val refs_of_token : s:ILReferencesAccumulator -> x:ILToken -> unit
    val refs_of_custom_attr :
      s:ILReferencesAccumulator -> cattr:ILAttribute -> unit
    val refs_of_custom_attrs :
      s:ILReferencesAccumulator -> cas:ILAttributes -> unit
    val refs_of_varargs :
      s:ILReferencesAccumulator -> tyso:ILGenericArgs option -> unit
    val refs_of_instr : s:ILReferencesAccumulator -> x:ILInstr -> unit
    val refs_of_il_code : s:ILReferencesAccumulator -> c:ILCode -> unit
    val refs_of_ilmbody : s:ILReferencesAccumulator -> il:ILMethodBody -> unit
    val refs_of_local : s:ILReferencesAccumulator -> loc:ILLocal -> unit
    val refs_of_mbody : s:ILReferencesAccumulator -> x:MethodBody -> unit
    val refs_of_mdef : s:ILReferencesAccumulator -> md:ILMethodDef -> unit
    val refs_of_param : s:ILReferencesAccumulator -> p:ILParameter -> unit
    val refs_of_return : s:ILReferencesAccumulator -> rt:ILReturn -> unit
    val refs_of_mdefs : s:ILReferencesAccumulator -> x:seq<#ILMethodDef> -> unit
    val refs_of_event_def : s:ILReferencesAccumulator -> ed:ILEventDef -> unit
    val refs_of_events : s:ILReferencesAccumulator -> x:ILEventDefs -> unit
    val refs_of_property_def :
      s:ILReferencesAccumulator -> pd:ILPropertyDef -> unit
    val refs_of_properties :
      s:ILReferencesAccumulator -> x:ILPropertyDefs -> unit
    val refs_of_fdef : s:ILReferencesAccumulator -> fd:ILFieldDef -> unit
    val refs_of_fields :
      s:ILReferencesAccumulator -> fields:#ILFieldDef list -> unit
    val refs_of_method_impls :
      s:ILReferencesAccumulator -> mimpls:ILMethodImplDef list -> unit
    val refs_of_method_impl :
      s:ILReferencesAccumulator -> m:ILMethodImplDef -> unit
    val refs_of_tdef_kind : _s:'c -> _k:'d -> unit
    val refs_of_tdef : s:ILReferencesAccumulator -> td:ILTypeDef -> unit
    val refs_of_string : _s:'e -> 'f -> unit
    val refs_of_types : s:ILReferencesAccumulator -> types:ILTypeDefs -> unit
    val refs_of_exported_type :
      s:ILReferencesAccumulator -> c:ILExportedTypeOrForwarder -> unit
    val refs_of_exported_types :
      s:ILReferencesAccumulator -> tab:ILExportedTypesAndForwarders -> unit
    val refs_of_resource_where :
      s:ILReferencesAccumulator -> x:ILResourceLocation -> unit
    val refs_of_resource : s:ILReferencesAccumulator -> x:ILResource -> unit
    val refs_of_resources : s:ILReferencesAccumulator -> tab:ILResources -> unit
    val refs_of_modul : s:ILReferencesAccumulator -> m:ILModuleDef -> unit
    val refs_of_manifest :
      s:ILReferencesAccumulator -> m:ILAssemblyManifest -> unit
    val computeILRefs : ILGlobals -> ILModuleDef -> ILReferences
    val tspan : System.TimeSpan
    val parseILVersion : string -> ILVersionInfo
    val compareILVersions : ILVersionInfo -> ILVersionInfo -> int
    val unscopeILTypeRef : x:ILTypeRef -> ILTypeRef
    val unscopeILTypeSpec : tspec:ILTypeSpec -> ILTypeSpec
    val unscopeILType : ILType -> ILType
    val unscopeILTypes : i:ILGenericArgs -> ILGenericArgs
    val unscopeILCallSig : csig:ILCallingSignature -> ILCallingSignature
    val resolveILMethodRefWithRescope :
      (ILType -> ILType) -> ILTypeDef -> ILMethodRef -> ILMethodDef
    val resolveILMethodRef : ILTypeDef -> ILMethodRef -> ILMethodDef
    val mkRefToILModule : ILModuleDef -> ILModuleRef
    [<SealedAttribute ()>]
    type ILEventRef =
      { erA: ILTypeRef
        erB: string }
      with
        static member Create : ILTypeRef * string -> ILEventRef
        member DeclaringTypeRef : ILTypeRef
        member Name : string
      end
    [<SealedAttribute ()>]
    type ILPropertyRef =
      { prA: ILTypeRef
        prB: string }
      with
        static member Create : ILTypeRef * string -> ILPropertyRef
        member DeclaringTypeRef : ILTypeRef
        member Name : string
      end
  end

namespace FSharp.Compiler.AbstractIL.Extensions.ILX
  module internal Types = begin
    val mkLowerName : nm:string -> string
    [<SealedAttribute ()>]
    type IlxUnionField =
      class
        new : IL.ILFieldDef -> IlxUnionField
        member ILField : IL.ILFieldDef
        member LowerName : string
        member Name : string
        member Type : IL.ILType
      end
    type IlxUnionAlternative =
      { altName: string
        altFields: IlxUnionField []
        altCustomAttrs: IL.ILAttributes }
      with
        member FieldDef : int -> IlxUnionField
        member FieldDefs : IlxUnionField []
        member FieldTypes : IL.ILType []
        member IsNullary : bool
        member Name : string
      end
    type IlxUnionHasHelpers =
      | NoHelpers
      | AllHelpers
      | SpecialFSharpListHelpers
      | SpecialFSharpOptionHelpers
    type IlxUnionRef =
      | IlxUnionRef of
        boxity: IL.ILBoxity * IL.ILTypeRef * IlxUnionAlternative [] * bool *
        IlxUnionHasHelpers
    type IlxUnionSpec =
      | IlxUnionSpec of IlxUnionRef * IL.ILGenericArgs
      with
        member Alternative : int -> IlxUnionAlternative
        member FieldDef : int -> int -> IlxUnionField
        member Alternatives : IlxUnionAlternative list
        member AlternativesArray : IlxUnionAlternative []
        member Boxity : IL.ILBoxity
        member DeclaringType : IL.ILType
        member GenericArgs : IL.ILGenericArgs
        member HasHelpers : IlxUnionHasHelpers
        member IsNullPermitted : bool
        member TypeRef : IL.ILTypeRef
      end
    type IlxClosureLambdas =
      | Lambdas_forall of IL.ILGenericParameterDef * IlxClosureLambdas
      | Lambdas_lambda of IL.ILParameter * IlxClosureLambdas
      | Lambdas_return of IL.ILType
    type IlxClosureApps =
      | Apps_tyapp of IL.ILType * IlxClosureApps
      | Apps_app of IL.ILType * IlxClosureApps
      | Apps_done of IL.ILType
    val instAppsAux :
      int -> IL.ILGenericArgs -> IlxClosureApps -> IlxClosureApps
    val instLambdasAux :
      n:int ->
        inst:IL.ILGenericArgs -> _arg1:IlxClosureLambdas -> IlxClosureLambdas
    val instLambdas :
      i:IL.ILGenericArgs -> t:IlxClosureLambdas -> IlxClosureLambdas
    type IlxClosureFreeVar =
      { fvName: string
        fvCompilerGenerated: bool
        fvType: IL.ILType }
    val mkILFreeVar : string * bool * IL.ILType -> IlxClosureFreeVar
    type IlxClosureRef =
      | IlxClosureRef of IL.ILTypeRef * IlxClosureLambdas * IlxClosureFreeVar []
    type IlxClosureSpec =
      | IlxClosureSpec of
        IlxClosureRef * IL.ILGenericArgs * IL.ILType * useStaticField: bool
      with
        static member
          Create : IlxClosureRef * IL.ILGenericArgs * useStaticField:bool ->
                     IlxClosureSpec
        member GetStaticFieldSpec : unit -> IL.ILFieldSpec
        member ClosureRef : IlxClosureRef
        member Constructor : IL.ILMethodSpec
        member FormalFreeVars : IlxClosureFreeVar []
        member FormalLambdas : IlxClosureLambdas
        member GenericArgs : IL.ILGenericArgs
        member ILType : IL.ILType
        member TypeRef : IL.ILTypeRef
        member UseStaticField : bool
      end
    type IlxClosureInfo =
      { cloStructure: IlxClosureLambdas
        cloFreeVars: IlxClosureFreeVar []
        cloCode: Lazy<IL.ILMethodBody>
        cloUseStaticField: bool }
    type IlxUnionInfo =
      { cudReprAccess: IL.ILMemberAccess
        cudHelpersAccess: IL.ILMemberAccess
        cudHasHelpers: IlxUnionHasHelpers
        cudDebugProxies: bool
        cudDebugDisplayAttributes: IL.ILAttribute list
        cudAlternatives: IlxUnionAlternative []
        cudNullPermitted: bool
        cudWhere: IL.ILSourceMarker option }
    val destTyFuncApp : IlxClosureApps -> IL.ILType * IlxClosureApps
    val mkILFormalCloRef :
      IL.ILGenericParameterDefs ->
        IlxClosureRef -> useStaticField:bool -> IlxClosureSpec
    val actualTypOfIlxUnionField : IlxUnionSpec -> int -> int -> IL.ILType
  end

namespace FSharp.Compiler.AbstractIL.Internal
  module internal AsciiConstants = begin
    val noArgInstrs : Lazy<(string list * IL.ILInstr) list>
    val wordsOfNoArgInstr : (IL.ILInstr -> string list)
    val isNoArgInstr : (IL.ILInstr -> bool)
    val mk_stind : nm:'a * dt:IL.ILBasicType -> 'a * (unit -> IL.ILInstr)
    val mk_ldind : nm:'a * dt:IL.ILBasicType -> 'a * (unit -> IL.ILInstr)
    type NoArgInstr = unit -> IL.ILInstr
    type Int32Instr = int32 -> IL.ILInstr
    type Int32Int32Instr = int32 * int32 -> IL.ILInstr
    type Int64Instr = int64 -> IL.ILInstr
    type DoubleInstr = IL.ILConst -> IL.ILInstr
    type MethodSpecInstr = IL.ILMethodSpec * IL.ILVarArgs -> IL.ILInstr
    type TypeInstr = IL.ILType -> IL.ILInstr
    type IntTypeInstr = int * IL.ILType -> IL.ILInstr
    type ValueTypeInstr = IL.ILType -> IL.ILInstr
    type StringInstr = string -> IL.ILInstr
    type TokenInstr = IL.ILToken -> IL.ILInstr
    type SwitchInstr = IL.ILCodeLabel list * IL.ILCodeLabel -> IL.ILInstr
    type InstrTable<'T> = (string list * 'T) list
    type LazyInstrTable<'T> = Lazy<InstrTable<'T>>
    val NoArgInstrs : Lazy<InstrTable<NoArgInstr>>
    val Int64Instrs : Lazy<InstrTable<Int64Instr>>
    val Int32Instrs : Lazy<InstrTable<Int32Instr>>
    val Int32Int32Instrs : Lazy<InstrTable<Int32Int32Instr>>
    val DoubleInstrs : Lazy<InstrTable<DoubleInstr>>
    val StringInstrs : Lazy<InstrTable<StringInstr>>
    val TokenInstrs : Lazy<InstrTable<TokenInstr>>
    val TypeInstrs : Lazy<InstrTable<TypeInstr>>
    val IntTypeInstrs : Lazy<InstrTable<IntTypeInstr>>
    val ValueTypeInstrs : Lazy<InstrTable<ValueTypeInstr>>
  end

namespace FSharp.Compiler.AbstractIL
  module internal ILAsciiWriter = begin
    val pretty : unit -> bool
    val tyvar_generator : (string -> string)
    type ppenv =
      { ilGlobals: IL.ILGlobals
        ppenvClassFormals: int
        ppenvMethodFormals: int }
    val ppenv_enter_method : mgparams:int -> env:ppenv -> ppenv
    val ppenv_enter_tdef : gparams:'a list -> env:ppenv -> ppenv
    val mk_ppenv : ilg:IL.ILGlobals -> ppenv
    val debug_ppenv : (IL.ILGlobals -> ppenv)
    val ppenv_enter_modul : env:ppenv -> ppenv
    val output_string : os:System.IO.TextWriter -> s:string -> unit
    val output_char : os:System.IO.TextWriter -> c:char -> unit
    val output_int : os:System.IO.TextWriter -> i:int -> unit
    val output_hex_digit : os:System.IO.TextWriter -> i:int -> unit
    val output_qstring : os:System.IO.TextWriter -> s:string -> unit
    val output_sqstring : os:System.IO.TextWriter -> s:string -> unit
    val output_seq :
      sep:string -> f:('a -> 'b -> unit) -> os:'a -> a:seq<'b> -> unit
        when 'a :> System.IO.TextWriter
    val output_array :
      sep:string -> f:('a -> 'b -> unit) -> os:'a -> a:'b [] -> unit
        when 'a :> System.IO.TextWriter
    val output_parens :
      f:('a -> 'b -> unit) -> os:'a -> a:'b -> unit
        when 'a :> System.IO.TextWriter
    val output_angled :
      f:('a -> 'b -> unit) -> os:'a -> a:'b -> unit
        when 'a :> System.IO.TextWriter
    val output_bracks :
      f:('a -> 'b -> unit) -> os:'a -> a:'b -> unit
        when 'a :> System.IO.TextWriter
    val output_id : os:System.IO.TextWriter -> n:string -> unit
    val output_label : os:System.IO.TextWriter -> n:string -> unit
    val output_lid : os:System.IO.TextWriter -> lid:seq<string> -> unit
    val string_of_type_name : 'a * n:'b -> 'b
    val output_byte : os:System.IO.TextWriter -> i:int -> unit
    val output_bytes : os:System.IO.TextWriter -> bytes:byte [] -> unit
    val bits_of_float32 : x:float32 -> int
    val bits_of_float : x:float -> int64
    val output_u8 : os:System.IO.TextWriter -> x:byte -> unit
    val output_i8 : os:System.IO.TextWriter -> x:sbyte -> unit
    val output_u16 : os:System.IO.TextWriter -> x:uint16 -> unit
    val output_i16 : os:System.IO.TextWriter -> x:int16 -> unit
    val output_u32 : os:System.IO.TextWriter -> x:uint32 -> unit
    val output_i32 : os:System.IO.TextWriter -> x:int32 -> unit
    val output_u64 : os:System.IO.TextWriter -> x:uint64 -> unit
    val output_i64 : os:System.IO.TextWriter -> x:int64 -> unit
    val output_ieee32 : os:System.IO.TextWriter -> x:float32 -> unit
    val output_ieee64 : os:System.IO.TextWriter -> x:float -> unit
    val goutput_scoref :
      env:ppenv -> os:System.IO.TextWriter -> _arg2:IL.ILScopeRef -> unit
    val goutput_type_name_ref :
      env:ppenv ->
        os:System.IO.TextWriter ->
          scoref:IL.ILScopeRef * enc:string list * n:string -> unit
    val goutput_tref :
      env:ppenv -> os:System.IO.TextWriter -> x:IL.ILTypeRef -> unit
    val goutput_typ :
      env:ppenv -> os:System.IO.TextWriter -> ty:IL.ILType -> unit
    val output_tyvar : os:System.IO.TextWriter -> d:uint16 -> unit
    val goutput_ldtoken_info :
      env:ppenv -> os:System.IO.TextWriter -> _arg3:IL.ILToken -> unit
    val goutput_typ_with_shortened_class_syntax :
      env:ppenv -> os:System.IO.TextWriter -> _arg4:IL.ILType -> unit
    val goutput_gactuals :
      env:ppenv -> os:System.IO.TextWriter -> inst:IL.ILGenericArgs -> unit
    val goutput_gactual :
      env:ppenv -> os:System.IO.TextWriter -> ty:IL.ILType -> unit
    val goutput_tspec :
      env:ppenv -> os:System.IO.TextWriter -> tspec:IL.ILTypeSpec -> unit
    val output_arr_bounds :
      os:System.IO.TextWriter -> _arg5:IL.ILArrayShape -> unit
    val goutput_permission :
      _env:'a -> os:System.IO.TextWriter -> p:IL.ILSecurityDecl -> unit
    val goutput_security_decls :
      env:'b -> os:System.IO.TextWriter -> ps:IL.ILSecurityDecls -> unit
    val goutput_gparam :
      env:ppenv ->
        os:System.IO.TextWriter -> gf:IL.ILGenericParameterDef -> unit
    val goutput_gparams :
      env:ppenv ->
        os:System.IO.TextWriter -> b:IL.ILGenericParameterDef list -> unit
    val output_bcc : os:System.IO.TextWriter -> bcc:IL.ILArgConvention -> unit
    val output_callconv : os:System.IO.TextWriter -> IL.ILCallingConv -> unit
    val goutput_dlocref :
      env:ppenv -> os:System.IO.TextWriter -> dref:IL.ILType -> unit
    val goutput_callsig :
      env:ppenv -> os:System.IO.TextWriter -> csig:IL.ILCallingSignature -> unit
    val goutput_mref :
      env:ppenv -> os:System.IO.TextWriter -> mref:IL.ILMethodRef -> unit
    val goutput_mspec :
      env:ppenv -> os:System.IO.TextWriter -> mspec:IL.ILMethodSpec -> unit
    val goutput_vararg_mspec :
      env:ppenv ->
        os:System.IO.TextWriter ->
          mspec:IL.ILMethodSpec * varargs:#seq<IL.ILType> option -> unit
    val goutput_vararg_sig :
      env:ppenv ->
        os:System.IO.TextWriter ->
          csig:IL.ILCallingSignature * varargs:IL.ILVarArgs -> unit
    val goutput_fspec :
      env:ppenv -> os:System.IO.TextWriter -> x:IL.ILFieldSpec -> unit
    val output_member_access :
      os:System.IO.TextWriter -> access:IL.ILMemberAccess -> unit
    val output_type_access :
      os:System.IO.TextWriter -> access:IL.ILTypeDefAccess -> unit
    val output_encoding :
      os:System.IO.TextWriter -> e:IL.ILDefaultPInvokeEncoding -> unit
    val output_field_init :
      os:System.IO.TextWriter -> _arg1:IL.ILFieldInit -> unit
    val output_at : os:System.IO.TextWriter -> b:byte [] -> unit
    val output_option : f:('a -> 'b -> unit) -> os:'a -> _arg1:'b option -> unit
    val goutput_alternative_ref :
      env:ppenv ->
        os:System.IO.TextWriter ->
          alt:Extensions.ILX.Types.IlxUnionAlternative -> unit
    val goutput_curef :
      env:ppenv ->
        os:System.IO.TextWriter -> Extensions.ILX.Types.IlxUnionRef -> unit
    val goutput_cuspec :
      env:ppenv ->
        os:System.IO.TextWriter -> Extensions.ILX.Types.IlxUnionSpec -> unit
    val output_basic_type : os:System.IO.TextWriter -> x:IL.ILBasicType -> unit
    val output_custom_attr_data :
      os:System.IO.TextWriter -> data:byte [] -> unit
    val goutput_custom_attr :
      env:ppenv -> os:System.IO.TextWriter -> attr:IL.ILAttribute -> unit
    val goutput_custom_attrs :
      env:ppenv -> os:System.IO.TextWriter -> attrs:IL.ILAttributes -> unit
    val goutput_fdef :
      _tref:'a ->
        env:ppenv -> os:System.IO.TextWriter -> fd:IL.ILFieldDef -> unit
    val output_alignment :
      os:System.IO.TextWriter -> _arg1:IL.ILAlignment -> unit
    val output_volatility :
      os:System.IO.TextWriter -> _arg1:IL.ILVolatility -> unit
    val output_tailness : os:System.IO.TextWriter -> _arg1:IL.ILTailcall -> unit
    val output_after_tailcall :
      os:System.IO.TextWriter -> _arg1:IL.ILTailcall -> unit
    val goutput_apps :
      env:ppenv ->
        os:System.IO.TextWriter ->
          _arg1:Extensions.ILX.Types.IlxClosureApps -> unit
    val output_short_u16 : os:System.IO.TextWriter -> x:uint16 -> unit
    val output_short_i32 : os:System.IO.TextWriter -> i32:int -> unit
    val output_code_label :
      os:System.IO.TextWriter -> lab:IL.ILCodeLabel -> unit
    val goutput_local :
      env:ppenv -> os:System.IO.TextWriter -> l:IL.ILLocal -> unit
    val goutput_param :
      env:ppenv -> os:System.IO.TextWriter -> l:IL.ILParameter -> unit
    val goutput_params :
      env:ppenv -> os:System.IO.TextWriter -> ps:seq<IL.ILParameter> -> unit
    val goutput_freevar :
      env:ppenv ->
        os:System.IO.TextWriter ->
          l:Extensions.ILX.Types.IlxClosureFreeVar -> unit
    val goutput_freevars :
      env:ppenv ->
        os:System.IO.TextWriter ->
          ps:seq<Extensions.ILX.Types.IlxClosureFreeVar> -> unit
    val output_source : os:System.IO.TextWriter -> s:IL.ILSourceMarker -> unit
    val goutput_instr :
      env:ppenv -> os:System.IO.TextWriter -> inst:IL.ILInstr -> unit
    val goutput_ilmbody :
      env:ppenv -> os:System.IO.TextWriter -> il:IL.ILMethodBody -> unit
    val goutput_mbody :
      is_entrypoint:bool ->
        env:ppenv -> os:System.IO.TextWriter -> md:IL.ILMethodDef -> unit
    val goutput_mdef :
      env:ppenv -> os:System.IO.TextWriter -> md:IL.ILMethodDef -> unit
    val goutput_pdef :
      env:ppenv -> os:System.IO.TextWriter -> pd:IL.ILPropertyDef -> unit
    val goutput_superclass :
      env:ppenv -> os:System.IO.TextWriter -> _arg1:IL.ILType option -> unit
    val goutput_superinterfaces :
      env:ppenv -> os:System.IO.TextWriter -> imp:IL.ILType list -> unit
    val goutput_implements :
      env:ppenv -> os:System.IO.TextWriter -> imp:IL.ILTypes -> unit
    val the : _arg1:'a option -> 'a
    val output_type_layout_info :
      os:System.IO.TextWriter -> info:IL.ILTypeDefLayoutInfo -> unit
    val splitTypeLayout :
      _arg1:IL.ILTypeDefLayout ->
        string * (#System.IO.TextWriter -> unit -> unit)
    val goutput_fdefs :
      tref:'a ->
        env:ppenv -> os:System.IO.TextWriter -> fdefs:IL.ILFieldDefs -> unit
    val goutput_mdefs :
      env:ppenv -> os:System.IO.TextWriter -> mdefs:IL.ILMethodDefs -> unit
    val goutput_pdefs :
      env:ppenv -> os:System.IO.TextWriter -> pdefs:IL.ILPropertyDefs -> unit
    val goutput_tdef :
      enc:string list ->
        env:ppenv ->
          contents:bool -> os:System.IO.TextWriter -> cd:IL.ILTypeDef -> unit
    val output_init_semantics :
      os:System.IO.TextWriter -> f:System.Reflection.TypeAttributes -> unit
    val goutput_lambdas :
      env:ppenv ->
        os:System.IO.TextWriter ->
          lambdas:Extensions.ILX.Types.IlxClosureLambdas -> unit
    val goutput_tdefs :
      contents:bool ->
        enc:string list ->
          env:ppenv -> os:System.IO.TextWriter -> td:IL.ILTypeDefs -> unit
    val output_ver : os:System.IO.TextWriter -> version:IL.ILVersionInfo -> unit
    val output_locale : os:System.IO.TextWriter -> s:string -> unit
    val output_hash : os:System.IO.TextWriter -> x:byte [] -> unit
    val output_publickeytoken : os:System.IO.TextWriter -> x:byte [] -> unit
    val output_publickey : os:System.IO.TextWriter -> x:byte [] -> unit
    val output_publickeyinfo :
      os:System.IO.TextWriter -> _arg1:IL.PublicKey -> unit
    val output_assemblyRef :
      os:System.IO.TextWriter -> aref:IL.ILAssemblyRef -> unit
    val output_modref : os:System.IO.TextWriter -> modref:IL.ILModuleRef -> unit
    val goutput_resource :
      env:ppenv -> os:System.IO.TextWriter -> r:IL.ILResource -> unit
    val goutput_manifest :
      env:ppenv -> os:System.IO.TextWriter -> m:IL.ILAssemblyManifest -> unit
    val output_module_fragment_aux :
      _refs:'a ->
        os:System.IO.TextWriter ->
          ilg:IL.ILGlobals -> modul:IL.ILModuleDef -> unit
    val output_module_fragment :
      os:System.IO.TextWriter ->
        ilg:IL.ILGlobals -> modul:IL.ILModuleDef -> IL.ILReferences
    val output_module_refs :
      os:System.IO.TextWriter -> refs:IL.ILReferences -> unit
    val goutput_module_manifest :
      env:ppenv -> os:System.IO.TextWriter -> modul:IL.ILModuleDef -> unit
    val output_module :
      System.IO.TextWriter -> ilg:IL.ILGlobals -> IL.ILModuleDef -> unit
  end

namespace FSharp.Compiler.AbstractIL
  module internal Morphs = begin
    val mutable morphCustomAttributeData : bool
    val enableMorphCustomAttributeData : unit -> unit
    val disableMorphCustomAttributeData : unit -> unit
    val code_instr2instr :
      f:(IL.ILInstr -> IL.ILInstr) -> code:IL.ILCode -> IL.ILCode
    val code_instr2instrs :
      f:(IL.ILInstr -> IL.ILInstr list) -> code:IL.ILCode -> IL.ILCode
    val code_instr2instr_ty2ty :
      finstr:(IL.ILInstr -> IL.ILInstr) * fty:(IL.ILType -> IL.ILType) ->
        c:IL.ILCode -> IL.ILCode
    val ty_tref2tref :
      f:(IL.ILTypeRef -> IL.ILTypeRef) -> x:IL.ILType -> IL.ILType
    val tspec_tref2tref :
      f:(IL.ILTypeRef -> IL.ILTypeRef) -> x:IL.ILTypeSpec -> IL.ILTypeSpec
    val ty_scoref2scoref_tyvar2ty :
      (IL.ILScopeRef -> IL.ILScopeRef) * (uint16 -> IL.ILType) ->
        x:IL.ILType -> IL.ILType
    val tspec_scoref2scoref_tyvar2ty :
      (IL.ILScopeRef -> IL.ILScopeRef) * (uint16 -> IL.ILType) ->
        x:IL.ILTypeSpec -> IL.ILTypeSpec
    val callsig_scoref2scoref_tyvar2ty :
      (IL.ILScopeRef -> IL.ILScopeRef) * (uint16 -> IL.ILType) ->
        x:IL.ILCallingSignature -> IL.ILCallingSignature
    val tys_scoref2scoref_tyvar2ty :
      (IL.ILScopeRef -> IL.ILScopeRef) * (uint16 -> IL.ILType) ->
        i:IL.ILGenericArgs -> IL.ILGenericArgs
    val gparams_scoref2scoref_tyvar2ty : f:'a -> i:'b list -> 'b list
    val gparam_scoref2scoref_tyvar2ty : _f:'a -> i:'b -> 'b
    val morphILScopeRefsInILTypeRef :
      (IL.ILScopeRef -> IL.ILScopeRef) -> IL.ILTypeRef -> IL.ILTypeRef
    val callsig_ty2ty :
      f:(IL.ILType -> IL.ILType) ->
        x:IL.ILCallingSignature -> IL.ILCallingSignature
    val gparam_ty2ty :
      f:(IL.ILType -> IL.ILType) ->
        gf:IL.ILGenericParameterDef -> IL.ILGenericParameterDef
    val gparams_ty2ty :
      f:(IL.ILType -> IL.ILType) ->
        gfs:IL.ILGenericParameterDef list -> IL.ILGenericParameterDef list
    val tys_ty2ty :
      f:(IL.ILType -> IL.ILType) -> x:IL.ILType list -> IL.ILType list
    val mref_ty2ty :
      f:(IL.ILType -> IL.ILType) -> x:IL.ILMethodRef -> IL.ILMethodRef
    type formal_scopeCtxt = Choice<IL.ILMethodSpec,IL.ILFieldSpec>
    val mspec_ty2ty :
      (IL.ILType -> IL.ILType) * (formal_scopeCtxt -> IL.ILType -> IL.ILType) ->
        x:IL.ILMethodSpec -> IL.ILMethodSpec
    val fref_ty2ty :
      f:(IL.ILType -> IL.ILType) -> x:IL.ILFieldRef -> IL.ILFieldRef
    val fspec_ty2ty :
      (IL.ILType -> IL.ILType) * (formal_scopeCtxt -> IL.ILType -> IL.ILType) ->
        x:IL.ILFieldSpec -> IL.ILFieldSpec
    val celem_ty2ty :
      f:(IL.ILType -> IL.ILType) -> celem:IL.ILAttribElem -> IL.ILAttribElem
    val cnamedarg_ty2ty :
      f:(IL.ILType -> IL.ILType) ->
        string * IL.ILType * bool * IL.ILAttribElem ->
          string * IL.ILType * bool * IL.ILAttribElem
    val cattr_ty2ty :
      ilg:IL.ILGlobals ->
        f:(IL.ILType -> IL.ILType) -> c:IL.ILAttribute -> IL.ILAttribute
    val cattrs_ty2ty :
      ilg:IL.ILGlobals ->
        f:(IL.ILType -> IL.ILType) -> cs:IL.ILAttributes -> IL.ILAttributes
    val fdef_ty2ty :
      ilg:IL.ILGlobals ->
        ftye:(IL.ILType -> IL.ILType) -> fd:IL.ILFieldDef -> IL.ILFieldDef
    val local_ty2ty : f:(IL.ILType -> IL.ILType) -> l:IL.ILLocal -> IL.ILLocal
    val varargs_ty2ty :
      f:(IL.ILType -> 'a) -> varargs:IL.ILVarArgs -> 'a list option
    val morphILTypesInILInstr :
      (IL.ILInstr option -> IL.ILType -> IL.ILType) *
      (IL.ILInstr option -> formal_scopeCtxt -> IL.ILType -> IL.ILType) ->
        i:IL.ILInstr -> IL.ILInstr
    val return_ty2ty :
      ilg:IL.ILGlobals ->
        f:(IL.ILType -> IL.ILType) -> r:IL.ILReturn -> IL.ILReturn
    val param_ty2ty :
      ilg:IL.ILGlobals ->
        f:(IL.ILType -> IL.ILType) -> p:IL.ILParameter -> IL.ILParameter
    val morphILMethodDefs :
      f:(IL.ILMethodDef -> IL.ILMethodDef) ->
        m:IL.ILMethodDefs -> IL.ILMethodDefs
    val fdefs_fdef2fdef :
      f:(IL.ILFieldDef -> IL.ILFieldDef) -> m:IL.ILFieldDefs -> IL.ILFieldDefs
    val morphILTypeDefs :
      f:(IL.ILTypeDef -> IL.ILTypeDef) -> m:IL.ILTypeDefs -> IL.ILTypeDefs
    val locals_ty2ty :
      f:(IL.ILType -> IL.ILType) -> ls:IL.ILLocal list -> IL.ILLocal list
    val ilmbody_instr2instr_ty2ty :
      (IL.ILInstr -> IL.ILInstr) * (IL.ILType -> IL.ILType) ->
        il:IL.ILMethodBody -> IL.ILMethodBody
    val morphILMethodBody :
      filmbody:(IL.ILMethodBody -> IL.ILMethodBody) ->
        x:IL.ILLazyMethodBody -> IL.ILLazyMethodBody
    val ospec_ty2ty :
      f:(IL.ILType -> IL.ILType) -> IL.ILOverridesSpec -> IL.ILOverridesSpec
    val mdef_ty2ty_ilmbody2ilmbody :
      ilg:IL.ILGlobals ->
        (IL.ILMethodDef option -> IL.ILType -> IL.ILType) *
        (IL.ILMethodDef option -> IL.ILMethodBody -> IL.ILMethodBody) ->
          md:IL.ILMethodDef -> IL.ILMethodDef
    val fdefs_ty2ty :
      ilg:IL.ILGlobals ->
        f:(IL.ILType -> IL.ILType) -> x:IL.ILFieldDefs -> IL.ILFieldDefs
    val mdefs_ty2ty_ilmbody2ilmbody :
      ilg:IL.ILGlobals ->
        (IL.ILMethodDef option -> IL.ILType -> IL.ILType) *
        (IL.ILMethodDef option -> IL.ILMethodBody -> IL.ILMethodBody) ->
          x:IL.ILMethodDefs -> IL.ILMethodDefs
    val mimpl_ty2ty :
      f:(IL.ILType -> IL.ILType) -> e:IL.ILMethodImplDef -> IL.ILMethodImplDef
    val edef_ty2ty :
      ilg:IL.ILGlobals ->
        f:(IL.ILType -> IL.ILType) -> e:IL.ILEventDef -> IL.ILEventDef
    val pdef_ty2ty :
      ilg:IL.ILGlobals ->
        f:(IL.ILType -> IL.ILType) -> p:IL.ILPropertyDef -> IL.ILPropertyDef
    val pdefs_ty2ty :
      ilg:IL.ILGlobals ->
        f:(IL.ILType -> IL.ILType) ->
          pdefs:IL.ILPropertyDefs -> IL.ILPropertyDefs
    val edefs_ty2ty :
      ilg:IL.ILGlobals ->
        f:(IL.ILType -> IL.ILType) -> edefs:IL.ILEventDefs -> IL.ILEventDefs
    val mimpls_ty2ty :
      f:(IL.ILType -> IL.ILType) ->
        mimpls:IL.ILMethodImplDefs -> IL.ILMethodImplDefs
    val tdef_ty2ty_ilmbody2ilmbody_mdefs2mdefs :
      ilg:IL.ILGlobals ->
        enc:IL.ILTypeDef list ->
          ((IL.ILTypeDef list * IL.ILTypeDef) option -> 'a option ->
             IL.ILType -> IL.ILType) *
          (IL.ILTypeDef list * IL.ILTypeDef -> IL.ILMethodDefs ->
             IL.ILMethodDefs) -> td:IL.ILTypeDef -> IL.ILTypeDef
    val tdefs_ty2ty_ilmbody2ilmbody_mdefs2mdefs :
      ilg:IL.ILGlobals ->
        enc:IL.ILTypeDef list ->
          ((IL.ILTypeDef list * IL.ILTypeDef) option -> 'a option ->
             IL.ILType -> IL.ILType) *
          (IL.ILTypeDef list * IL.ILTypeDef -> IL.ILMethodDefs ->
             IL.ILMethodDefs) -> tdefs:IL.ILTypeDefs -> IL.ILTypeDefs
    val manifest_ty2ty :
      ilg:IL.ILGlobals ->
        f:(IL.ILType -> IL.ILType) ->
          m:IL.ILAssemblyManifest -> IL.ILAssemblyManifest
    val morphILTypeInILModule_ilmbody2ilmbody_mdefs2mdefs :
      ilg:IL.ILGlobals ->
        ftye:(IL.ILModuleDef -> (IL.ILTypeDef list * IL.ILTypeDef) option ->
                IL.ILMethodDef option -> IL.ILType -> IL.ILType) *
        fmdefs:(IL.ILModuleDef -> IL.ILTypeDef list * IL.ILTypeDef ->
                  IL.ILMethodDefs -> IL.ILMethodDefs) ->
          m:IL.ILModuleDef -> IL.ILModuleDef
    val module_instr2instr_ty2ty :
      ilg:IL.ILGlobals ->
        (IL.ILModuleDef -> IL.ILTypeDef list * IL.ILTypeDef ->
           IL.ILMethodDef option -> IL.ILInstr -> IL.ILInstr) *
        (IL.ILModuleDef -> (IL.ILTypeDef list * IL.ILTypeDef) option ->
           IL.ILMethodDef option -> IL.ILType -> IL.ILType) ->
          x:IL.ILModuleDef -> IL.ILModuleDef
    val morphILInstrsAndILTypesInILModule :
      ilg:IL.ILGlobals ->
        f1:(IL.ILModuleDef -> IL.ILTypeDef list * IL.ILTypeDef ->
              IL.ILMethodDef option -> IL.ILInstr -> IL.ILInstr) *
        f2:(IL.ILModuleDef -> (IL.ILTypeDef list * IL.ILTypeDef) option ->
              IL.ILMethodDef option -> IL.ILType -> IL.ILType) ->
          x:IL.ILModuleDef -> IL.ILModuleDef
    val morphILInstrsInILCode :
      (IL.ILInstr -> IL.ILInstr list) -> IL.ILCode -> IL.ILCode
    val morphILTypeInILModule :
      ilg:IL.ILGlobals ->
        ftye:(IL.ILModuleDef -> (IL.ILTypeDef list * IL.ILTypeDef) option ->
                IL.ILMethodDef option -> IL.ILType -> IL.ILType) ->
          y:IL.ILModuleDef -> IL.ILModuleDef
    val morphILTypeRefsInILModuleMemoized :
      IL.ILGlobals ->
        (IL.ILTypeRef -> IL.ILTypeRef) -> IL.ILModuleDef -> IL.ILModuleDef
    val morphILScopeRefsInILModuleMemoized :
      IL.ILGlobals ->
        (IL.ILScopeRef -> IL.ILScopeRef) -> IL.ILModuleDef -> IL.ILModuleDef
  end

namespace FSharp.Compiler.AbstractIL.Internal
  module internal StrongNameSign = begin
    type KeyType =
      | Public
      | KeyPair
    val ALG_TYPE_RSA : int
    val ALG_CLASS_KEY_EXCHANGE : int
    val ALG_CLASS_SIGNATURE : int
    val CALG_RSA_KEYX : int
    val CALG_RSA_SIGN : int
    val ALG_CLASS_HASH : int
    val ALG_TYPE_ANY : int
    val CALG_SHA1 : int
    val CALG_SHA_256 : int
    val CALG_SHA_384 : int
    val CALG_SHA_512 : int
    val PUBLICKEYBLOB : int
    val PRIVATEKEYBLOB : int
    val BLOBHEADER_CURRENT_BVERSION : int
    val BLOBHEADER_LENGTH : int
    val RSA_PUB_MAGIC : int
    val RSA_PRIV_MAGIC : int
    val getResourceString : 'a * str:'b -> 'b
    val check : _action:'a -> hresult:int -> unit
    [<StructAttribute ()>]
    type ByteArrayUnion =
      struct
        new : immutableArray:System.Collections.Immutable.ImmutableArray<byte> ->
                ByteArrayUnion
        val UnderlyingArray: byte []
        val ImmutableArray: System.Collections.Immutable.ImmutableArray<byte>
      end
    val getUnderlyingArray :
      array:System.Collections.Immutable.ImmutableArray<byte> -> byte []
    val hashAssembly :
      peReader:System.Reflection.PortableExecutable.PEReader ->
        hashAlgorithm:System.Security.Cryptography.IncrementalHash -> byte []
    type BlobReader =
      class
        new : blob:byte [] -> BlobReader
        member ReadBigInteger : length:int -> byte []
        member ReadInt32 : int
      end
    val RSAParamatersFromBlob :
      blob:byte [] ->
        keyType:KeyType -> System.Security.Cryptography.RSAParameters
    val toCLRKeyBlob :
      rsaParameters:System.Security.Cryptography.RSAParameters ->
        algId:int -> byte []
    val createSignature :
      hash:byte [] -> keyBlob:byte [] -> keyType:KeyType -> byte []
    val patchSignature :
      stream:System.IO.Stream ->
        peReader:System.Reflection.PortableExecutable.PEReader ->
          signature:byte [] -> unit
    val signStream : stream:System.IO.Stream -> keyBlob:byte [] -> unit
    val signFile : filename:string -> keyBlob:byte [] -> unit
    val signatureSize : pk:byte [] -> int
    val getPublicKeyForKeyPair : keyBlob:byte [] -> byte []
    type keyContainerName = string
    type keyPair = byte []
    type pubkey = byte []
    type pubkeyOptions = byte [] * bool
    val signerOpenPublicKeyFile : filePath:string -> byte []
    val signerOpenKeyPairFile : filePath:string -> byte []
    val signerGetPublicKeyForKeyPair : kp:keyPair -> pubkey
    val signerGetPublicKeyForKeyContainer : _kcName:keyContainerName -> pubkey
    val signerCloseKeyContainer : _kc:keyContainerName -> unit
    val signerSignatureSize : pk:pubkey -> int
    val signerSignFileWithKeyPair : fileName:string -> kp:keyPair -> unit
    val signerSignFileWithKeyContainer :
      _fileName:string -> _kcName:keyContainerName -> unit
    [<SealedAttribute ()>]
    type ILStrongNameSigner =
      | PublicKeySigner of pubkey
      | PublicKeyOptionsSigner of pubkeyOptions
      | KeyPair of keyPair
      | KeyContainer of keyContainerName
      with
        static member OpenKeyContainer : keyContainerName -> ILStrongNameSigner
        static member OpenKeyPairFile : string -> ILStrongNameSigner
        static member OpenPublicKey : pubkey -> ILStrongNameSigner
        static member
          OpenPublicKeyOptions : string -> bool -> ILStrongNameSigner
        member Close : unit -> unit
        member SignFile : string -> unit
        member IsFullySigned : bool
        member PublicKey : pubkey
        member SignatureSize : int
      end
  end

namespace FSharp.Compiler.AbstractIL.Internal
  module internal NativeRes = begin
    type BYTE = byte
    type DWORD = uint32
    type WCHAR = System.Char
    type WORD = uint16
    val inline WORD :
      s: ^a -> uint16 when  ^a : (static member op_Explicit :  ^a -> uint16)
    val inline DWORD :
      s: ^a -> uint32 when  ^a : (static member op_Explicit :  ^a -> uint32)
    val inline WCHAR :
      s: ^a -> char when  ^a : (static member op_Explicit :  ^a -> char)
    val inline BYTE :
      s: ^a -> byte when  ^a : (static member op_Explicit :  ^a -> byte)
    type ResourceException =
      class
        inherit System.Exception
        new : name:string * ?inner:System.Exception -> ResourceException
      end
    [<ClassAttribute ()>]
    type RESOURCE_STRING =
      class
        new : unit -> RESOURCE_STRING
        member Ordinal : WORD
        member theString : string
      end
    [<ClassAttribute ()>]
    type RESOURCE =
      class
        new : unit -> RESOURCE
        member Characteristics : DWORD
        member DataSize : DWORD
        member DataVersion : DWORD
        member HeaderSize : DWORD
        member LanguageId : WORD
        member MemoryFlags : WORD
        member Version : DWORD
        member data : byte []
        member pstringName : RESOURCE_STRING
        member pstringType : RESOURCE_STRING
      end
    [<ClassAttribute ()>]
    type CvtResFile =
      class
        new : unit -> CvtResFile
        static member
          ReadResFile : stream:System.IO.Stream ->
                          System.Collections.Generic.List<RESOURCE>
        static member
          private ReadStringOrID : fhIn:System.IO.BinaryReader ->
                                     RESOURCE_STRING
        static member private RT_DLGINCLUDE : int
      end
    [<System.Flags ()>]
    type SectionCharacteristics =
      | TypeReg = 0u
      | TypeDSect = 1u
      | TypeNoLoad = 2u
      | TypeGroup = 4u
      | TypeNoPad = 8u
      | TypeCopy = 16u
      | ContainsCode = 32u
      | ContainsInitializedData = 64u
      | ContainsUninitializedData = 128u
      | LinkerOther = 256u
      | LinkerInfo = 512u
      | TypeOver = 1024u
      | LinkerRemove = 2048u
      | LinkerComdat = 4096u
      | MemProtected = 16384u
      | NoDeferSpecExc = 16384u
      | GPRel = 32768u
      | MemFardata = 32768u
      | MemSysheap = 65536u
      | MemPurgeable = 131072u
      | Mem16Bit = 131072u
      | MemLocked = 262144u
      | MemPreload = 524288u
      | Align1Bytes = 1048576u
      | Align2Bytes = 2097152u
      | Align4Bytes = 3145728u
      | Align8Bytes = 4194304u
      | Align16Bytes = 5242880u
      | Align32Bytes = 6291456u
      | Align64Bytes = 7340032u
      | Align128Bytes = 8388608u
      | Align256Bytes = 9437184u
      | Align512Bytes = 10485760u
      | Align1024Bytes = 11534336u
      | Align2048Bytes = 12582912u
      | Align4096Bytes = 13631488u
      | Align8192Bytes = 14680064u
      | AlignMask = 15728640u
      | LinkerNRelocOvfl = 16777216u
      | MemDiscardable = 33554432u
      | MemNotCached = 67108864u
      | MemNotPaged = 134217728u
      | MemShared = 268435456u
      | MemExecute = 536870912u
      | MemRead = 1073741824u
      | MemWrite = 2147483648u
    type ResourceSection =
      class
        new : sectionBytes:byte [] * relocations:uint32 [] -> ResourceSection
        new : unit -> ResourceSection
        member Relocations : uint32 []
        member SectionBytes : byte []
      end
    [<System.Runtime.CompilerServices.Extension ()>]
    type StreamExtensions =
      class
        new : unit -> StreamExtensions
        [<System.Runtime.CompilerServices.Extension ()>]
        static member
          TryReadAll : stream:System.IO.Stream * buffer:byte [] * offset:int *
                       count:int -> int
      end
    type COFFResourceReader =
      class
        new : unit -> COFFResourceReader
        static member
          private ConfirmSectionValues : hdr:System.Reflection.PortableExecutable.SectionHeader *
                                         fileSize:int64 -> unit
        static member
          ReadWin32ResourcesFromCOFF : stream:System.IO.Stream ->
                                         ResourceSection
      end
    [<StructAttribute ()>]
    type ICONDIRENTRY =
      struct
        val mutable bWidth: BYTE
        val mutable bHeight: BYTE
        val mutable bColorCount: BYTE
        val mutable bReserved: BYTE
        val mutable wPlanes: WORD
        val mutable wBitCount: WORD
        val mutable dwBytesInRes: DWORD
        val mutable dwImageOffset: DWORD
      end
    type VersionHelper =
      class
        new : unit -> VersionHelper
        static member
          GenerateVersionFromPatternAndCurrentTime : time:System.DateTime *
                                                     pattern:System.Version ->
                                                       System.Version
        static member
          private TryGetValue : s:string * value:byref<uint16> -> bool
        static member
          TryParse : s:string * version:byref<System.Version> -> bool
        static member
          private TryParse : s:string * allowWildcard:bool * maxValue:uint16 *
                             allowPartialParse:bool *
                             version:byref<System.Version> -> bool
        static member
          TryParseAssemblyVersion : s:string * allowWildcard:bool *
                                    version:byref<System.Version> -> bool
        static member private NullVersion : System.Version
      end
    type VersionResourceSerializer =
      class
        new : isDll:bool * comments:string * companyName:string *
              fileDescription:string * fileVersion:string * internalName:string *
              legalCopyright:string * legalTrademark:string *
              originalFileName:string * productName:string *
              productVersion:string * assemblyVersion:System.Version ->
                VersionResourceSerializer
        new : unit -> VersionResourceSerializer
        static member private KEYBYTES : sz:string -> int
        static member private KEYSIZE : sz:string -> int
        static member private PadKeyLen : cb:int -> int
        static member private PadToDword : cb:int -> int
        static member
          private SizeofVerString : lpszKey:string * lpszValue:string -> int
        static member
          private WriteVersionString : keyValuePair:System.Collections.Generic.KeyValuePair<string,
                                                                                            string> *
                                       writer:System.IO.BinaryWriter -> unit
        member GetDataSize : unit -> int
        member private GetStringsSize : unit -> int
        member
          private GetVerStrings : unit ->
                                    seq<System.Collections.Generic.KeyValuePair<string,
                                                                                string>>
        member
          private WriteVSFixedFileInfo : writer:System.IO.BinaryWriter -> unit
        member WriteVerResource : writer:System.IO.BinaryWriter -> unit
        member private FileType : uint32
        member private _assemblyVersionContents : System.Version
        member private _commentsContents : string
        member private _companyNameContents : string
        member private _fileDescriptionContents : string
        member private _fileVersionContents : string
        member private _internalNameContents : string
        member private _isDll : bool
        member private _langIdAndCodePageKey : string
        member private _legalCopyrightContents : string
        member private _legalTrademarksContents : string
        member private _originalFileNameContents : string
        member private _productNameContents : string
        member private _productVersionContents : string
        static member private CP_WINUNICODE : uint32
        static member private HDRSIZE : int
        static member private VFT_APP : uint32
        static member private VFT_DLL : uint32
        static member private sizeVS_FIXEDFILEINFO : uint16
        static member private stringFileInfoKey : string
        static member private translationKey : string
        static member private varFileInfoKey : string
        static member private vsVersionInfoKey : string
      end
    [<ClassAttribute ()>]
    type Win32ResourceConversions =
      class
        new : unit -> Win32ResourceConversions
        static member
          AppendIconToResourceStream : resStream:System.IO.Stream *
                                       iconStream:System.IO.Stream -> unit
        static member
          AppendManifestToResourceStream : resStream:System.IO.Stream *
                                           manifestStream:System.IO.Stream *
                                           isDll:bool -> unit
        static member
          AppendVersionToResourceStream : resStream:System.IO.Stream *
                                          isDll:bool * fileVersion:string *
                                          originalFileName:string *
                                          internalName:string *
                                          productVersion:string *
                                          assemblyVersion:System.Version *
                                          ?fileDescription:string *
                                          ?legalCopyright:string *
                                          ?legalTrademarks:string *
                                          ?productName:string * ?comments:string *
                                          ?companyName:string -> unit
      end
    type Win32Resource =
      class
        new : data:byte [] * codePage:DWORD * languageId:DWORD * id:int *
              name:string * typeId:int * typeName:string -> Win32Resource
        member CodePage : DWORD
        member Data : byte []
        member Id : int
        member LanguageId : DWORD
        member Name : string
        member TypeId : int
        member TypeName : string
      end
    type Directory =
      class
        new : name:string * id:int -> Directory
        member Entries : System.Collections.Generic.List<obj>
        member ID : int
        member Name : string
        member NumberOfIdEntries : uint16
        member NumberOfNamedEntries : uint16
      end
    [<ClassAttribute ()>]
    type NativeResourceWriter =
      class
        new : unit -> NativeResourceWriter
        static member
          private CompareResourceIdentifiers : xOrdinal:int * xString:string *
                                               yOrdinal:int * yString:string ->
                                                 int
        static member
          private CompareResources : left:Win32Resource ->
                                       right:Win32Resource -> int
        static member
          SerializeWin32Resources : builder:System.Reflection.Metadata.BlobBuilder *
                                    theResources:System.Collections.Generic.IEnumerable<Win32Resource> *
                                    resourcesRva:int -> unit
        static member private SizeOfDirectory : directory:Directory -> uint32
        static member
          SortResources : resources:System.Collections.Generic.IEnumerable<Win32Resource> ->
                            System.Collections.Generic.IEnumerable<Win32Resource>
        static member
          private WriteDirectory : directory:Directory *
                                   writer:System.Reflection.Metadata.BlobBuilder *
                                   offset:uint32 * level:uint32 *
                                   sizeOfDirectoryTree:uint32 *
                                   virtualAddressBase:int *
                                   dataWriter:System.Reflection.Metadata.BlobBuilder ->
                                     unit
      end
  end

namespace FSharp.Compiler.AbstractIL.Internal
  module internal Support = begin
    val DateTime1970Jan01 : System.DateTime
    val absilWriteGetTimeStamp : unit -> int
    val inline ignore : _x:'a -> unit
    type IStream = System.Runtime.InteropServices.ComTypes.IStream
    val check : _action:'a -> hresult:int -> unit
    val MAX_PATH : int
    val E_FAIL : int
    val bytesToWord : b0:byte * b1:byte -> int16
    val bytesToDWord : b0:byte * b1:byte * b2:byte * b3:byte -> int
    val bytesToQWord :
      b0:byte * b1:byte * b2:byte * b3:byte * b4:byte * b5:byte * b6:byte *
      b7:byte -> int64
    val dwToBytes : n:int -> byte [] * int
    val wToBytes : n:int16 -> byte [] * int
    type IMAGE_FILE_HEADER =
      class
        new : m:int16 * secs:int16 * tds:int32 * ptst:int32 * nos:int32 *
              soh:int16 * c:int16 -> IMAGE_FILE_HEADER
        member toBytes : unit -> byte []
        member Characteristics : int16
        member Machine : int16
        member NumberOfSections : int16
        member NumberOfSymbols : int32
        member PointerToSymbolTable : int32
        member SizeOfOptionalHeader : int16
        member TimeDateStamp : int32
        static member Width : int
      end
    val bytesToIFH : buffer:byte [] -> offset:int -> IMAGE_FILE_HEADER
    type IMAGE_SECTION_HEADER =
      class
        new : n:int64 * ai:int32 * va:int32 * srd:int32 * prd:int32 * pr:int32 *
              pln:int32 * nr:int16 * nl:int16 * c:int32 -> IMAGE_SECTION_HEADER
        member toBytes : unit -> byte []
        member Characteristics : int32
        member Name : int64
        member NumberOfLineNumbers : int16
        member NumberOfRelocations : int16
        member PhysicalAddress : int32
        member PointerToLineNumbers : int32
        member PointerToRawData : int32
        member PointerToRelocations : int32
        member SizeOfRawData : int32
        member VirtualAddress : int32
        member VirtualSize : int32
        static member Width : int
      end
    val bytesToISH : buffer:byte [] -> offset:int -> IMAGE_SECTION_HEADER
    type IMAGE_SYMBOL =
      class
        new : n:int64 * v:int32 * sn:int16 * t:int16 * sc:byte * nas:byte ->
                IMAGE_SYMBOL
        member toBytes : unit -> byte []
        member Name : int64
        member NumberOfAuxSymbols : byte
        member SectionNumber : int16
        member StorageClass : byte
        member Type : int16
        member Value : int32
        static member Width : int
      end
    val bytesToIS : buffer:byte [] -> offset:int -> IMAGE_SYMBOL
    type IMAGE_RELOCATION =
      class
        new : va:int32 * sti:int32 * t:int16 -> IMAGE_RELOCATION
        member toBytes : unit -> byte []
        member RelocCount : int32
        member SymbolTableIndex : int32
        member Type : int16
        member VirtualAddress : int32
        static member Width : int
      end
    val bytesToIR : buffer:byte [] -> offset:int -> IMAGE_RELOCATION
    type IMAGE_RESOURCE_DIRECTORY =
      class
        new : c:int32 * tds:int32 * mjv:int16 * mnv:int16 * nne:int16 *
              nie:int16 -> IMAGE_RESOURCE_DIRECTORY
        member toBytes : unit -> byte []
        member Characteristics : int32
        member MajorVersion : int16
        member MinorVersion : int16
        member NumberOfIdEntries : int16
        member NumberOfNamedEntries : int16
        member TimeDateStamp : int32
        static member Width : int
      end
    val bytesToIRD : buffer:byte [] -> offset:int -> IMAGE_RESOURCE_DIRECTORY
    type IMAGE_RESOURCE_DIRECTORY_ENTRY =
      class
        new : n:int32 * o:int32 -> IMAGE_RESOURCE_DIRECTORY_ENTRY
        member toBytes : unit -> byte []
        member DataIsDirectory : bool
        member Name : int32
        member OffsetToData : int32
        member OffsetToDirectory : int32
        static member Width : int
      end
    val bytesToIRDE :
      buffer:byte [] -> offset:int -> IMAGE_RESOURCE_DIRECTORY_ENTRY
    type IMAGE_RESOURCE_DATA_ENTRY =
      class
        new : o:int32 * s:int32 * c:int32 * r:int32 -> IMAGE_RESOURCE_DATA_ENTRY
        member toBytes : unit -> unit
        member CodePage : int32
        member OffsetToData : int32
        member Reserved : int32
        member Size : int32
        static member Width : int
      end
    val bytesToIRDataE :
      buffer:byte [] -> offset:int -> IMAGE_RESOURCE_DATA_ENTRY
    type ResFormatHeader =
      class
        new : unit -> ResFormatHeader
        member toBytes : unit -> byte []
        member Characteristics : int
        member DataSize : int
        member DataVersion : int
        member HeaderSize : int
        member LangID : int16
        member MemFlags : int16
        member NameID : int
        member TypeID : int
        member Version : int
        static member Width : int
      end
    type ResFormatNode =
      class
        new : tid:int32 * nid:int32 * lid:int32 * dataOffset:int32 *
              pbLinkedResource:byte [] -> ResFormatNode
        member
          Save : ulLinkedResourceBaseRVA:int32 * pbLinkedResource:byte [] *
                 pUnlinkedResource:byte [] * offset:int -> int
        member DataEntry : IMAGE_RESOURCE_DATA_ENTRY
        member Name : byte []
        member ResHdr : ResFormatHeader
        member Type : byte []
      end
    val linkNativeResources :
      unlinkedResources:byte [] list -> rva:int32 -> byte []
    val unlinkResource : int32 -> byte [] -> byte []
  end

namespace FSharp.Compiler.AbstractIL.Internal
  module internal AsciiParser = begin
    val pfailwith : s:string -> 'a
    type ResolvedAtMethodSpecScope<'T> =
      | ResolvedAtMethodSpecScope of (IL.ILGenericParameterDefs -> 'T)
    val noMethodSpecScope : x:'a -> ResolvedAtMethodSpecScope<'a>
    val resolveMethodSpecScope :
      ResolvedAtMethodSpecScope<'a> -> x:IL.ILGenericParameterDefs -> 'a
    val resolveMethodSpecScopeThen :
      ResolvedAtMethodSpecScope<'a> ->
        g:('a -> ResolvedAtMethodSpecScope<'b>) -> ResolvedAtMethodSpecScope<'b>
    val resolveCurrentMethodSpecScope : obj:ResolvedAtMethodSpecScope<'a> -> 'a
    type token =
      | VOID
      | VARARG
      | VALUETYPE
      | VALUE
      | UNSIGNED
      | UNMANAGED
      | UINT8
      | UINT64
      | UINT32
      | UINT16
      | UINT
      | STRING
      | STAR
      | SLASH
      | RPAREN
      | RBRACK
      | PLUS
      | OBJECT
      | NATIVE
      | METHOD
      | LPAREN
      | LESS
      | LBRACK
      | INT8
      | INT64
      | INT32
      | INT16
      | INT
      | INSTANCE
      | GREATER
      | FLOAT64
      | FLOAT32
      | FIELD
      | EXPLICIT
      | EOF
      | ELIPSES
      | DOT
      | DEFAULT
      | DCOLON
      | COMMA
      | CLASS
      | CHAR
      | BYTEARRAY
      | BOOL
      | BANG
      | AMP
      | VAL_SQSTRING of string
      | VAL_QSTRING of string
      | VAL_DOTTEDNAME of string
      | VAL_ID of string
      | VAL_HEXBYTE of int
      | INSTR_VALUETYPE of AsciiConstants.ValueTypeInstr
      | INSTR_INT_TYPE of AsciiConstants.IntTypeInstr
      | INSTR_TYPE of AsciiConstants.TypeInstr
      | INSTR_TOK of AsciiConstants.TokenInstr
      | INSTR_STRING of AsciiConstants.StringInstr
      | INSTR_NONE of AsciiConstants.NoArgInstr
      | INSTR_R of AsciiConstants.DoubleInstr
      | INSTR_I8 of AsciiConstants.Int64Instr
      | INSTR_I32_I32 of AsciiConstants.Int32Int32Instr
      | INSTR_I of AsciiConstants.Int32Instr
      | VAL_FLOAT64 of double
      | VAL_INT32_ELIPSES of int32
      | VAL_INT64 of int64
    type tokenId =
      | TOKEN_VOID
      | TOKEN_VARARG
      | TOKEN_VALUETYPE
      | TOKEN_VALUE
      | TOKEN_UNSIGNED
      | TOKEN_UNMANAGED
      | TOKEN_UINT8
      | TOKEN_UINT64
      | TOKEN_UINT32
      | TOKEN_UINT16
      | TOKEN_UINT
      | TOKEN_STRING
      | TOKEN_STAR
      | TOKEN_SLASH
      | TOKEN_RPAREN
      | TOKEN_RBRACK
      | TOKEN_PLUS
      | TOKEN_OBJECT
      | TOKEN_NATIVE
      | TOKEN_METHOD
      | TOKEN_LPAREN
      | TOKEN_LESS
      | TOKEN_LBRACK
      | TOKEN_INT8
      | TOKEN_INT64
      | TOKEN_INT32
      | TOKEN_INT16
      | TOKEN_INT
      | TOKEN_INSTANCE
      | TOKEN_GREATER
      | TOKEN_FLOAT64
      | TOKEN_FLOAT32
      | TOKEN_FIELD
      | TOKEN_EXPLICIT
      | TOKEN_EOF
      | TOKEN_ELIPSES
      | TOKEN_DOT
      | TOKEN_DEFAULT
      | TOKEN_DCOLON
      | TOKEN_COMMA
      | TOKEN_CLASS
      | TOKEN_CHAR
      | TOKEN_BYTEARRAY
      | TOKEN_BOOL
      | TOKEN_BANG
      | TOKEN_AMP
      | TOKEN_VAL_SQSTRING
      | TOKEN_VAL_QSTRING
      | TOKEN_VAL_DOTTEDNAME
      | TOKEN_VAL_ID
      | TOKEN_VAL_HEXBYTE
      | TOKEN_INSTR_VALUETYPE
      | TOKEN_INSTR_INT_TYPE
      | TOKEN_INSTR_TYPE
      | TOKEN_INSTR_TOK
      | TOKEN_INSTR_STRING
      | TOKEN_INSTR_NONE
      | TOKEN_INSTR_R
      | TOKEN_INSTR_I8
      | TOKEN_INSTR_I32_I32
      | TOKEN_INSTR_I
      | TOKEN_VAL_FLOAT64
      | TOKEN_VAL_INT32_ELIPSES
      | TOKEN_VAL_INT64
      | TOKEN_end_of_input
      | TOKEN_error
    type nonTerminalId =
      | NONTERM__startilInstrs
      | NONTERM__startilType
      | NONTERM_ilType
      | NONTERM_ilInstrs
      | NONTERM_compQstring
      | NONTERM_methodName
      | NONTERM_instrs2
      | NONTERM_instr
      | NONTERM_name1
      | NONTERM_className
      | NONTERM_slashedName
      | NONTERM_typeNameInst
      | NONTERM_typeName
      | NONTERM_typSpec
      | NONTERM_callConv
      | NONTERM_callKind
      | NONTERM_typ
      | NONTERM_bounds1
      | NONTERM_bound
      | NONTERM_id
      | NONTERM_int32
      | NONTERM_int64
      | NONTERM_float64
      | NONTERM_opt_actual_tyargs
      | NONTERM_actual_tyargs
      | NONTERM_actualTypSpecs
    val tagOfToken : t:token -> int
    val tokenTagToTokenId : tokenIdx:int -> tokenId
    val prodIdxToNonTerminal : prodIdx:int -> nonTerminalId
    val _fsyacc_endOfInputTag : int
    val _fsyacc_tagOfErrorTerminal : int
    val token_to_string : t:token -> string
    val _fsyacc_dataOfToken : t:token -> System.Object
    val _fsyacc_gotos : uint16 []
    val _fsyacc_sparseGotoTableRowOffsets : uint16 []
    val _fsyacc_stateToProdIdxsTableElements : uint16 []
    val _fsyacc_stateToProdIdxsTableRowOffsets : uint16 []
    val _fsyacc_action_rows : int
    val _fsyacc_actionTableElements : uint16 []
    val _fsyacc_actionTableRowOffsets : uint16 []
    val _fsyacc_reductionSymbolCounts : uint16 []
    val _fsyacc_productionToNonTerminalTable : uint16 []
    val _fsyacc_immediateActions : uint16 []
    val _fsyacc_reductions :
      unit -> (Internal.Utilities.Text.Parsing.IParseState -> obj) []
    val tables : unit -> Internal.Utilities.Text.Parsing.Tables<token>
    val engine :
      lexer:(Internal.Utilities.Text.Lexing.LexBuffer<char> -> token) ->
        lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
          startState:int -> obj
    val ilInstrs :
      lexer:(Internal.Utilities.Text.Lexing.LexBuffer<char> -> token) ->
        lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
          IL.ILInstr array
    val ilType :
      lexer:(Internal.Utilities.Text.Lexing.LexBuffer<char> -> token) ->
        lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> -> IL.ILType
  end

namespace FSharp.Compiler.AbstractIL.Internal
  module internal AsciiLexer = begin
    val lexeme : lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> -> string
    val lexemeChar :
      lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> -> n:int -> char
    val unexpectedChar : _lexbuf:'a -> 'b
    val keywords : Lazy<(string * AsciiParser.token) list>
    val kwdInstrTable :
      Lazy<Internal.Utilities.Collections.HashMultiMap<string,AsciiParser.token>>
    val kwdOrInstr : s:string -> AsciiParser.token
    val evalDigit : ch:char -> int
    val kwdOrInstrOrId : s:string -> AsciiParser.token
    val trans : uint16 [] array
    val actions : uint16 []
    val _fslex_tables : Internal.Utilities.Text.Lexing.UnicodeTables
    val _fslex_dummy : unit -> 'a
    val token :
      lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> -> AsciiParser.token
  end

namespace FSharp.Compiler.AbstractIL.Internal
  module internal BinaryConstants = begin
    [<StructAttribute ()>]
    type TableName =
      struct
        new : idx:int -> TableName
        static member FromIndex : int -> TableName
        member Index : int
      end
    module TableNames = begin
      val Module : TableName
      val TypeRef : TableName
      val TypeDef : TableName
      val FieldPtr : TableName
      val Field : TableName
      val MethodPtr : TableName
      val Method : TableName
      val ParamPtr : TableName
      val Param : TableName
      val InterfaceImpl : TableName
      val MemberRef : TableName
      val Constant : TableName
      val CustomAttribute : TableName
      val FieldMarshal : TableName
      val Permission : TableName
      val ClassLayout : TableName
      val FieldLayout : TableName
      val StandAloneSig : TableName
      val EventMap : TableName
      val EventPtr : TableName
      val Event : TableName
      val PropertyMap : TableName
      val PropertyPtr : TableName
      val Property : TableName
      val MethodSemantics : TableName
      val MethodImpl : TableName
      val ModuleRef : TableName
      val TypeSpec : TableName
      val ImplMap : TableName
      val FieldRVA : TableName
      val ENCLog : TableName
      val ENCMap : TableName
      val Assembly : TableName
      val AssemblyProcessor : TableName
      val AssemblyOS : TableName
      val AssemblyRef : TableName
      val AssemblyRefProcessor : TableName
      val AssemblyRefOS : TableName
      val File : TableName
      val ExportedType : TableName
      val ManifestResource : TableName
      val Nested : TableName
      val GenericParam : TableName
      val MethodSpec : TableName
      val GenericParamConstraint : TableName
      val UserStrings : TableName
    end
    val sortedTableInfo : (TableName * int) list
    [<StructAttribute ()>]
    type TypeDefOrRefTag =
      struct
        new : tag:int32 -> TypeDefOrRefTag
        member Tag : int32
      end
    val tdor_TypeDef : TypeDefOrRefTag
    val tdor_TypeRef : TypeDefOrRefTag
    val tdor_TypeSpec : TypeDefOrRefTag
    val mkTypeDefOrRefOrSpecTag : int -> TypeDefOrRefTag
    [<StructAttribute ()>]
    type HasConstantTag =
      struct
        new : tag:int32 -> HasConstantTag
        member Tag : int32
      end
    val hc_FieldDef : HasConstantTag
    val hc_ParamDef : HasConstantTag
    val hc_Property : HasConstantTag
    val mkHasConstantTag : int -> HasConstantTag
    [<StructAttribute ()>]
    type HasCustomAttributeTag =
      struct
        new : tag:int32 -> HasCustomAttributeTag
        member Tag : int32
      end
    val hca_MethodDef : HasCustomAttributeTag
    val hca_FieldDef : HasCustomAttributeTag
    val hca_TypeRef : HasCustomAttributeTag
    val hca_TypeDef : HasCustomAttributeTag
    val hca_ParamDef : HasCustomAttributeTag
    val hca_InterfaceImpl : HasCustomAttributeTag
    val hca_MemberRef : HasCustomAttributeTag
    val hca_Module : HasCustomAttributeTag
    val hca_Permission : HasCustomAttributeTag
    val hca_Property : HasCustomAttributeTag
    val hca_Event : HasCustomAttributeTag
    val hca_StandAloneSig : HasCustomAttributeTag
    val hca_ModuleRef : HasCustomAttributeTag
    val hca_TypeSpec : HasCustomAttributeTag
    val hca_Assembly : HasCustomAttributeTag
    val hca_AssemblyRef : HasCustomAttributeTag
    val hca_File : HasCustomAttributeTag
    val hca_ExportedType : HasCustomAttributeTag
    val hca_ManifestResource : HasCustomAttributeTag
    val hca_GenericParam : HasCustomAttributeTag
    val hca_GenericParamConstraint : HasCustomAttributeTag
    val hca_MethodSpec : HasCustomAttributeTag
    val mkHasCustomAttributeTag : int -> HasCustomAttributeTag
    [<StructAttribute ()>]
    type HasFieldMarshalTag =
      struct
        new : tag:int32 -> HasFieldMarshalTag
        member Tag : int32
      end
    val hfm_FieldDef : HasFieldMarshalTag
    val hfm_ParamDef : HasFieldMarshalTag
    val mkHasFieldMarshalTag : int -> HasFieldMarshalTag
    [<StructAttribute ()>]
    type HasDeclSecurityTag =
      struct
        new : tag:int32 -> HasDeclSecurityTag
        member Tag : int32
      end
    val hds_TypeDef : HasDeclSecurityTag
    val hds_MethodDef : HasDeclSecurityTag
    val hds_Assembly : HasDeclSecurityTag
    val mkHasDeclSecurityTag : int -> HasDeclSecurityTag
    [<StructAttribute ()>]
    type MemberRefParentTag =
      struct
        new : tag:int32 -> MemberRefParentTag
        member Tag : int32
      end
    val mrp_TypeRef : MemberRefParentTag
    val mrp_ModuleRef : MemberRefParentTag
    val mrp_MethodDef : MemberRefParentTag
    val mrp_TypeSpec : MemberRefParentTag
    val mkMemberRefParentTag : int -> MemberRefParentTag
    [<StructAttribute ()>]
    type HasSemanticsTag =
      struct
        new : tag:int32 -> HasSemanticsTag
        member Tag : int32
      end
    val hs_Event : HasSemanticsTag
    val hs_Property : HasSemanticsTag
    val mkHasSemanticsTag : int -> HasSemanticsTag
    [<StructAttribute ()>]
    type MethodDefOrRefTag =
      struct
        new : tag:int32 -> MethodDefOrRefTag
        member Tag : int32
      end
    val mdor_MethodDef : MethodDefOrRefTag
    val mdor_MemberRef : MethodDefOrRefTag
    val mdor_MethodSpec : MethodDefOrRefTag
    val mkMethodDefOrRefTag : int -> MethodDefOrRefTag
    [<StructAttribute ()>]
    type MemberForwardedTag =
      struct
        new : tag:int32 -> MemberForwardedTag
        member Tag : int32
      end
    val mf_FieldDef : MemberForwardedTag
    val mf_MethodDef : MemberForwardedTag
    val mkMemberForwardedTag : int -> MemberForwardedTag
    [<StructAttribute ()>]
    type ImplementationTag =
      struct
        new : tag:int32 -> ImplementationTag
        member Tag : int32
      end
    val i_File : ImplementationTag
    val i_AssemblyRef : ImplementationTag
    val i_ExportedType : ImplementationTag
    val mkImplementationTag : int -> ImplementationTag
    [<StructAttribute ()>]
    type CustomAttributeTypeTag =
      struct
        new : tag:int32 -> CustomAttributeTypeTag
        member Tag : int32
      end
    val cat_MethodDef : CustomAttributeTypeTag
    val cat_MemberRef : CustomAttributeTypeTag
    val mkILCustomAttributeTypeTag : int -> CustomAttributeTypeTag
    [<StructAttribute ()>]
    type ResolutionScopeTag =
      struct
        new : tag:int32 -> ResolutionScopeTag
        member Tag : int32
      end
    val rs_Module : ResolutionScopeTag
    val rs_ModuleRef : ResolutionScopeTag
    val rs_AssemblyRef : ResolutionScopeTag
    val rs_TypeRef : ResolutionScopeTag
    val mkResolutionScopeTag : int -> ResolutionScopeTag
    [<StructAttribute ()>]
    type TypeOrMethodDefTag =
      struct
        new : tag:int32 -> TypeOrMethodDefTag
        member Tag : int32
      end
    val tomd_TypeDef : TypeOrMethodDefTag
    val tomd_MethodDef : TypeOrMethodDefTag
    val mkTypeOrMethodDefTag : int -> TypeOrMethodDefTag
    val et_END : byte
    val et_VOID : byte
    val et_BOOLEAN : byte
    val et_CHAR : byte
    val et_I1 : byte
    val et_U1 : byte
    val et_I2 : byte
    val et_U2 : byte
    val et_I4 : byte
    val et_U4 : byte
    val et_I8 : byte
    val et_U8 : byte
    val et_R4 : byte
    val et_R8 : byte
    val et_STRING : byte
    val et_PTR : byte
    val et_BYREF : byte
    val et_VALUETYPE : byte
    val et_CLASS : byte
    val et_VAR : byte
    val et_ARRAY : byte
    val et_WITH : byte
    val et_TYPEDBYREF : byte
    val et_I : byte
    val et_U : byte
    val et_FNPTR : byte
    val et_OBJECT : byte
    val et_SZARRAY : byte
    val et_MVAR : byte
    val et_CMOD_REQD : byte
    val et_CMOD_OPT : byte
    val et_SENTINEL : byte
    val et_PINNED : byte
    val i_nop : int
    val i_break : int
    val i_ldarg_0 : int
    val i_ldarg_1 : int
    val i_ldarg_2 : int
    val i_ldarg_3 : int
    val i_ldloc_0 : int
    val i_ldloc_1 : int
    val i_ldloc_2 : int
    val i_ldloc_3 : int
    val i_stloc_0 : int
    val i_stloc_1 : int
    val i_stloc_2 : int
    val i_stloc_3 : int
    val i_ldarg_s : int
    val i_ldarga_s : int
    val i_starg_s : int
    val i_ldloc_s : int
    val i_ldloca_s : int
    val i_stloc_s : int
    val i_ldnull : int
    val i_ldc_i4_m1 : int
    val i_ldc_i4_0 : int
    val i_ldc_i4_1 : int
    val i_ldc_i4_2 : int
    val i_ldc_i4_3 : int
    val i_ldc_i4_4 : int
    val i_ldc_i4_5 : int
    val i_ldc_i4_6 : int
    val i_ldc_i4_7 : int
    val i_ldc_i4_8 : int
    val i_ldc_i4_s : int
    val i_ldc_i4 : int
    val i_ldc_i8 : int
    val i_ldc_r4 : int
    val i_ldc_r8 : int
    val i_dup : int
    val i_pop : int
    val i_jmp : int
    val i_call : int
    val i_calli : int
    val i_ret : int
    val i_br_s : int
    val i_brfalse_s : int
    val i_brtrue_s : int
    val i_beq_s : int
    val i_bge_s : int
    val i_bgt_s : int
    val i_ble_s : int
    val i_blt_s : int
    val i_bne_un_s : int
    val i_bge_un_s : int
    val i_bgt_un_s : int
    val i_ble_un_s : int
    val i_blt_un_s : int
    val i_br : int
    val i_brfalse : int
    val i_brtrue : int
    val i_beq : int
    val i_bge : int
    val i_bgt : int
    val i_ble : int
    val i_blt : int
    val i_bne_un : int
    val i_bge_un : int
    val i_bgt_un : int
    val i_ble_un : int
    val i_blt_un : int
    val i_switch : int
    val i_ldind_i1 : int
    val i_ldind_u1 : int
    val i_ldind_i2 : int
    val i_ldind_u2 : int
    val i_ldind_i4 : int
    val i_ldind_u4 : int
    val i_ldind_i8 : int
    val i_ldind_i : int
    val i_ldind_r4 : int
    val i_ldind_r8 : int
    val i_ldind_ref : int
    val i_stind_ref : int
    val i_stind_i1 : int
    val i_stind_i2 : int
    val i_stind_i4 : int
    val i_stind_i8 : int
    val i_stind_r4 : int
    val i_stind_r8 : int
    val i_add : int
    val i_sub : int
    val i_mul : int
    val i_div : int
    val i_div_un : int
    val i_rem : int
    val i_rem_un : int
    val i_and : int
    val i_or : int
    val i_xor : int
    val i_shl : int
    val i_shr : int
    val i_shr_un : int
    val i_neg : int
    val i_not : int
    val i_conv_i1 : int
    val i_conv_i2 : int
    val i_conv_i4 : int
    val i_conv_i8 : int
    val i_conv_r4 : int
    val i_conv_r8 : int
    val i_conv_u4 : int
    val i_conv_u8 : int
    val i_callvirt : int
    val i_cpobj : int
    val i_ldobj : int
    val i_ldstr : int
    val i_newobj : int
    val i_castclass : int
    val i_isinst : int
    val i_conv_r_un : int
    val i_unbox : int
    val i_throw : int
    val i_ldfld : int
    val i_ldflda : int
    val i_stfld : int
    val i_ldsfld : int
    val i_ldsflda : int
    val i_stsfld : int
    val i_stobj : int
    val i_conv_ovf_i1_un : int
    val i_conv_ovf_i2_un : int
    val i_conv_ovf_i4_un : int
    val i_conv_ovf_i8_un : int
    val i_conv_ovf_u1_un : int
    val i_conv_ovf_u2_un : int
    val i_conv_ovf_u4_un : int
    val i_conv_ovf_u8_un : int
    val i_conv_ovf_i_un : int
    val i_conv_ovf_u_un : int
    val i_box : int
    val i_newarr : int
    val i_ldlen : int
    val i_ldelema : int
    val i_ldelem_i1 : int
    val i_ldelem_u1 : int
    val i_ldelem_i2 : int
    val i_ldelem_u2 : int
    val i_ldelem_i4 : int
    val i_ldelem_u4 : int
    val i_ldelem_i8 : int
    val i_ldelem_i : int
    val i_ldelem_r4 : int
    val i_ldelem_r8 : int
    val i_ldelem_ref : int
    val i_stelem_i : int
    val i_stelem_i1 : int
    val i_stelem_i2 : int
    val i_stelem_i4 : int
    val i_stelem_i8 : int
    val i_stelem_r4 : int
    val i_stelem_r8 : int
    val i_stelem_ref : int
    val i_conv_ovf_i1 : int
    val i_conv_ovf_u1 : int
    val i_conv_ovf_i2 : int
    val i_conv_ovf_u2 : int
    val i_conv_ovf_i4 : int
    val i_conv_ovf_u4 : int
    val i_conv_ovf_i8 : int
    val i_conv_ovf_u8 : int
    val i_refanyval : int
    val i_ckfinite : int
    val i_mkrefany : int
    val i_ldtoken : int
    val i_conv_u2 : int
    val i_conv_u1 : int
    val i_conv_i : int
    val i_conv_ovf_i : int
    val i_conv_ovf_u : int
    val i_add_ovf : int
    val i_add_ovf_un : int
    val i_mul_ovf : int
    val i_mul_ovf_un : int
    val i_sub_ovf : int
    val i_sub_ovf_un : int
    val i_endfinally : int
    val i_leave : int
    val i_leave_s : int
    val i_stind_i : int
    val i_conv_u : int
    val i_arglist : int
    val i_ceq : int
    val i_cgt : int
    val i_cgt_un : int
    val i_clt : int
    val i_clt_un : int
    val i_ldftn : int
    val i_ldvirtftn : int
    val i_ldarg : int
    val i_ldarga : int
    val i_starg : int
    val i_ldloc : int
    val i_ldloca : int
    val i_stloc : int
    val i_localloc : int
    val i_endfilter : int
    val i_unaligned : int
    val i_volatile : int
    val i_constrained : int
    val i_readonly : int
    val i_tail : int
    val i_initobj : int
    val i_cpblk : int
    val i_initblk : int
    val i_rethrow : int
    val i_sizeof : int
    val i_refanytype : int
    val i_ldelem_any : int
    val i_stelem_any : int
    val i_unbox_any : int
    val mk_ldc : i:int32 -> IL.ILInstr
    val noArgInstrs : Lazy<(int * IL.ILInstr) list>
    val isNoArgInstr : IL.ILInstr -> bool
    val ILCmpInstrMap :
      Lazy<System.Collections.Generic.Dictionary<IL.ILComparisonInstr,int>>
    val ILCmpInstrRevMap :
      Lazy<System.Collections.Generic.Dictionary<IL.ILComparisonInstr,int>>
    val nt_VOID : byte
    val nt_BOOLEAN : byte
    val nt_I1 : byte
    val nt_U1 : byte
    val nt_I2 : byte
    val nt_U2 : byte
    val nt_I4 : byte
    val nt_U4 : byte
    val nt_I8 : byte
    val nt_U8 : byte
    val nt_R4 : byte
    val nt_R8 : byte
    val nt_SYSCHAR : byte
    val nt_VARIANT : byte
    val nt_CURRENCY : byte
    val nt_PTR : byte
    val nt_DECIMAL : byte
    val nt_DATE : byte
    val nt_BSTR : byte
    val nt_LPSTR : byte
    val nt_LPWSTR : byte
    val nt_LPTSTR : byte
    val nt_FIXEDSYSSTRING : byte
    val nt_OBJECTREF : byte
    val nt_IUNKNOWN : byte
    val nt_IDISPATCH : byte
    val nt_STRUCT : byte
    val nt_INTF : byte
    val nt_SAFEARRAY : byte
    val nt_FIXEDARRAY : byte
    val nt_INT : byte
    val nt_UINT : byte
    val nt_NESTEDSTRUCT : byte
    val nt_BYVALSTR : byte
    val nt_ANSIBSTR : byte
    val nt_TBSTR : byte
    val nt_VARIANTBOOL : byte
    val nt_FUNC : byte
    val nt_ASANY : byte
    val nt_ARRAY : byte
    val nt_LPSTRUCT : byte
    val nt_CUSTOMMARSHALER : byte
    val nt_ERROR : byte
    val nt_LPUTF8STR : byte
    val nt_MAX : byte
    val vt_EMPTY : int
    val vt_NULL : int
    val vt_I2 : int
    val vt_I4 : int
    val vt_R4 : int
    val vt_R8 : int
    val vt_CY : int
    val vt_DATE : int
    val vt_BSTR : int
    val vt_DISPATCH : int
    val vt_ERROR : int
    val vt_BOOL : int
    val vt_VARIANT : int
    val vt_UNKNOWN : int
    val vt_DECIMAL : int
    val vt_I1 : int
    val vt_UI1 : int
    val vt_UI2 : int
    val vt_UI4 : int
    val vt_I8 : int
    val vt_UI8 : int
    val vt_INT : int
    val vt_UINT : int
    val vt_VOID : int
    val vt_HRESULT : int
    val vt_PTR : int
    val vt_SAFEARRAY : int
    val vt_CARRAY : int
    val vt_USERDEFINED : int
    val vt_LPSTR : int
    val vt_LPWSTR : int
    val vt_RECORD : int
    val vt_FILETIME : int
    val vt_BLOB : int
    val vt_STREAM : int
    val vt_STORAGE : int
    val vt_STREAMED_OBJECT : int
    val vt_STORED_OBJECT : int
    val vt_BLOB_OBJECT : int
    val vt_CF : int
    val vt_CLSID : int
    val vt_VECTOR : int
    val vt_ARRAY : int
    val vt_BYREF : int
    val ILNativeTypeMap : Lazy<(byte * IL.ILNativeType) list>
    val ILNativeTypeRevMap : Lazy<(IL.ILNativeType * byte) list>
    val ILVariantTypeMap : Lazy<(IL.ILNativeVariant * int) list>
    val ILVariantTypeRevMap : Lazy<(int * IL.ILNativeVariant) list>
    val ILSecurityActionMap : Lazy<(IL.ILSecurityAction * int) list>
    val ILSecurityActionRevMap : Lazy<(int * IL.ILSecurityAction) list>
    val e_CorILMethod_TinyFormat : byte
    val e_CorILMethod_FatFormat : byte
    val e_CorILMethod_FormatMask : byte
    val e_CorILMethod_MoreSects : byte
    val e_CorILMethod_InitLocals : byte
    val e_CorILMethod_Sect_EHTable : byte
    val e_CorILMethod_Sect_FatFormat : byte
    val e_CorILMethod_Sect_MoreSects : byte
    val e_COR_ILEXCEPTION_CLAUSE_EXCEPTION : int
    val e_COR_ILEXCEPTION_CLAUSE_FILTER : int
    val e_COR_ILEXCEPTION_CLAUSE_FINALLY : int
    val e_COR_ILEXCEPTION_CLAUSE_FAULT : int
    val e_IMAGE_CEE_CS_CALLCONV_FASTCALL : byte
    val e_IMAGE_CEE_CS_CALLCONV_STDCALL : byte
    val e_IMAGE_CEE_CS_CALLCONV_THISCALL : byte
    val e_IMAGE_CEE_CS_CALLCONV_CDECL : byte
    val e_IMAGE_CEE_CS_CALLCONV_VARARG : byte
    val e_IMAGE_CEE_CS_CALLCONV_FIELD : byte
    val e_IMAGE_CEE_CS_CALLCONV_LOCAL_SIG : byte
    val e_IMAGE_CEE_CS_CALLCONV_PROPERTY : byte
    val e_IMAGE_CEE_CS_CALLCONV_GENERICINST : byte
    val e_IMAGE_CEE_CS_CALLCONV_GENERIC : byte
    val e_IMAGE_CEE_CS_CALLCONV_INSTANCE : byte
    val e_IMAGE_CEE_CS_CALLCONV_INSTANCE_EXPLICIT : byte
  end

namespace FSharp.Compiler.AbstractIL
  module ILBinaryReader = begin
    val checking : bool
    val logging : bool
    val noStableFileHeuristic : bool
    val alwaysMemoryMapFSC : bool
    val stronglyHeldReaderCacheSizeDefault : int
    val stronglyHeldReaderCacheSize : int
    val singleOfBits : x:int32 -> float32
    val doubleOfBits : x:int64 -> float
    val align : alignment:int -> n:int -> int
    val uncodedToken : tab:Internal.BinaryConstants.TableName -> idx:int -> int
    val i32ToUncodedToken : tok:int -> Internal.BinaryConstants.TableName * int
    [<StructAttribute ()>]
    type TaggedIndex<'T> =
      struct
        new : tag:'T * index:int32 -> TaggedIndex<'T>
        val tag: 'T
        val index: int32
      end
    val uncodedTokenToTypeDefOrRefOrSpec :
      tab:Internal.BinaryConstants.TableName * tok:int32 ->
        TaggedIndex<Internal.BinaryConstants.TypeDefOrRefTag>
    val uncodedTokenToMethodDefOrRef :
      tab:Internal.BinaryConstants.TableName * tok:int32 ->
        TaggedIndex<Internal.BinaryConstants.MethodDefOrRefTag>
    val ( |TaggedIndex| ) : x:TaggedIndex<'T> -> 'T * int32
    val inline tokToTaggedIdx :
      f:(int -> 'a) -> nbits:int -> tok:int -> TaggedIndex<'a>
    type Statistics =
      { mutable rawMemoryFileCount: int
        mutable memoryMapFileOpenedCount: int
        mutable memoryMapFileClosedCount: int
        mutable weakByteFileCount: int
        mutable byteFileCount: int }
    val stats : Statistics
    val GetStatistics : unit -> Statistics
    type private BinaryView = Internal.ReadOnlyByteMemory
    type BinaryFile =
      interface
        abstract member GetView : unit -> BinaryView
      end
    type RawMemoryFile =
      class
        interface BinaryFile
        new : fileName:string * obj:obj * addr:nativeint * length:int ->
                RawMemoryFile
        member HoldObj : unit -> obj
        member FileName : string
      end
    [<System.Diagnostics.DebuggerDisplay ("{FileName}")>]
    type ByteFile =
      class
        interface BinaryFile
        new : fileName:string * bytes:byte [] -> ByteFile
        member FileName : string
      end
    [<System.Diagnostics.DebuggerDisplay ("{FileName}")>]
    type WeakByteFile =
      class
        interface BinaryFile
        new : fileName:string * chunk:(int * int) option -> WeakByteFile
        member FileName : string
      end
    val seekReadByte : mdv:BinaryView -> addr:int -> byte
    val seekReadBytes : mdv:BinaryView -> addr:int -> len:int -> byte []
    val seekReadInt32 : mdv:BinaryView -> addr:int -> int
    val seekReadUInt16 : mdv:BinaryView -> addr:int -> uint16
    val seekReadByteAsInt32 : mdv:BinaryView -> addr:int -> int32
    val seekReadInt64 : mdv:BinaryView -> addr:int -> int64
    val seekReadUInt16AsInt32 : mdv:BinaryView -> addr:int -> int32
    val seekReadCompressedUInt32 :
      mdv:BinaryView -> addr:int -> struct (int * int)
    val seekReadSByte : mdv:BinaryView -> addr:int -> sbyte
    val seekReadSingle : mdv:BinaryView -> addr:int -> float32
    val seekReadDouble : mdv:BinaryView -> addr:int -> float
    val seekCountUtf8String : mdv:BinaryView -> addr:int -> n:int -> int
    val seekReadUTF8String : mdv:BinaryView -> addr:int -> string
    val seekReadBlob : mdv:BinaryView -> addr:int -> byte []
    val seekReadUserString : mdv:BinaryView -> addr:int -> string
    val seekReadGuid : mdv:BinaryView -> addr:int -> byte []
    val seekReadUncodedToken :
      mdv:BinaryView -> addr:int -> Internal.BinaryConstants.TableName * int
    val sigptrCheck : bytes:byte [] -> sigptr:int -> unit
    val sigptrGetByte : bytes:byte [] -> sigptr:int -> byte * int
    val sigptrGetBool : bytes:byte [] -> sigptr:int -> bool * int
    val sigptrGetSByte : bytes:byte [] -> sigptr:int -> sbyte * int
    val sigptrGetUInt16 : bytes:byte [] -> sigptr:int -> uint16 * int
    val sigptrGetInt16 : bytes:byte [] -> sigptr:int -> int16 * int
    val sigptrGetInt32 : bytes:byte [] -> sigptr:int -> int * int
    val sigptrGetUInt32 : bytes:byte [] -> sigptr:int -> uint32 * int
    val sigptrGetUInt64 : bytes:byte [] -> sigptr:int -> uint64 * int
    val sigptrGetInt64 : bytes:byte [] -> sigptr:int -> int64 * int
    val sigptrGetSingle : bytes:byte [] -> sigptr:int -> float32 * int
    val sigptrGetDouble : bytes:byte [] -> sigptr:int -> float * int
    val sigptrGetZInt32 : bytes:byte [] -> sigptr:int -> struct (int * int)
    val sigptrFoldAcc :
      f:(byte [] -> int -> 'a * int) ->
        n:int ->
          bytes:byte [] -> sigptr:int -> i:int -> acc:'a list -> 'a list * int
    val sigptrFold :
      f:(byte [] -> int -> 'a * int) ->
        n:int -> bytes:byte [] -> sigptr:int -> 'a list * int
    val sigptrFoldStruct :
      f:(byte [] -> int -> struct ('a * int)) ->
        n:int -> bytes:byte [] -> sigptr:int -> struct ('a list * int)
    val sigptrGetBytes : n:int -> bytes:byte [] -> sigptr:int -> byte [] * int
    val sigptrGetString : n:int -> bytes:byte [] -> sigptr:int -> string * int
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type ILInstrPrefixesRegister =
      { mutable al: IL.ILAlignment
        mutable tl: IL.ILTailcall
        mutable vol: IL.ILVolatility
        mutable ro: IL.ILReadonly
        mutable constrained: IL.ILType option }
    val noPrefixes : mk:'a -> prefixes:ILInstrPrefixesRegister -> 'a
    val volatileOrUnalignedPrefix :
      mk:(IL.ILAlignment * IL.ILVolatility -> 'a) ->
        prefixes:ILInstrPrefixesRegister -> 'a
    val volatilePrefix :
      mk:(IL.ILVolatility -> 'a) -> prefixes:ILInstrPrefixesRegister -> 'a
    val tailPrefix :
      mk:(IL.ILTailcall -> 'a) -> prefixes:ILInstrPrefixesRegister -> 'a
    val constraintOrTailPrefix :
      mk:(IL.ILType option * IL.ILTailcall -> 'a) ->
        prefixes:ILInstrPrefixesRegister -> 'a
    val readonlyPrefix :
      mk:(IL.ILReadonly -> 'a) -> prefixes:ILInstrPrefixesRegister -> 'a
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type ILInstrDecoder =
      | I_u16_u8_instr of (ILInstrPrefixesRegister -> uint16 -> IL.ILInstr)
      | I_u16_u16_instr of (ILInstrPrefixesRegister -> uint16 -> IL.ILInstr)
      | I_none_instr of (ILInstrPrefixesRegister -> IL.ILInstr)
      | I_i64_instr of (ILInstrPrefixesRegister -> int64 -> IL.ILInstr)
      | I_i32_i32_instr of (ILInstrPrefixesRegister -> int32 -> IL.ILInstr)
      | I_i32_i8_instr of (ILInstrPrefixesRegister -> int32 -> IL.ILInstr)
      | I_r4_instr of (ILInstrPrefixesRegister -> single -> IL.ILInstr)
      | I_r8_instr of (ILInstrPrefixesRegister -> double -> IL.ILInstr)
      | I_field_instr of
        (ILInstrPrefixesRegister -> IL.ILFieldSpec -> IL.ILInstr)
      | I_method_instr of
        (ILInstrPrefixesRegister -> IL.ILMethodSpec * IL.ILVarArgs -> IL.ILInstr)
      | I_unconditional_i32_instr of
        (ILInstrPrefixesRegister -> IL.ILCodeLabel -> IL.ILInstr)
      | I_unconditional_i8_instr of
        (ILInstrPrefixesRegister -> IL.ILCodeLabel -> IL.ILInstr)
      | I_conditional_i32_instr of
        (ILInstrPrefixesRegister -> IL.ILCodeLabel -> IL.ILInstr)
      | I_conditional_i8_instr of
        (ILInstrPrefixesRegister -> IL.ILCodeLabel -> IL.ILInstr)
      | I_string_instr of (ILInstrPrefixesRegister -> string -> IL.ILInstr)
      | I_switch_instr of
        (ILInstrPrefixesRegister -> IL.ILCodeLabel list -> IL.ILInstr)
      | I_tok_instr of (ILInstrPrefixesRegister -> IL.ILToken -> IL.ILInstr)
      | I_sig_instr of
        (ILInstrPrefixesRegister -> IL.ILCallingSignature * IL.ILVarArgs ->
           IL.ILInstr)
      | I_type_instr of (ILInstrPrefixesRegister -> IL.ILType -> IL.ILInstr)
      | I_invalid_instr
    val mkStind : dt:IL.ILBasicType -> (ILInstrPrefixesRegister -> IL.ILInstr)
    val mkLdind : dt:IL.ILBasicType -> (ILInstrPrefixesRegister -> IL.ILInstr)
    val instrs : unit -> (int * ILInstrDecoder) list
    val oneByteInstrs : ILInstrDecoder [] option ref
    val twoByteInstrs : ILInstrDecoder [] option ref
    val fillInstrs : unit -> unit
    val getOneByteInstr : i:int -> ILInstrDecoder
    val getTwoByteInstr : i:int -> ILInstrDecoder
    type ImageChunk =
      { size: int32
        addr: int32 }
    val chunk : sz:int32 -> next:int32 -> ImageChunk * int32
    val nochunk : next:'a -> ImageChunk * 'a
    type RowElementKind =
      | UShort
      | ULong
      | Byte
      | Data
      | GGuid
      | Blob
      | SString
      | SimpleIndex of Internal.BinaryConstants.TableName
      | TypeDefOrRefOrSpec
      | TypeOrMethodDef
      | HasConstant
      | HasCustomAttribute
      | HasFieldMarshal
      | HasDeclSecurity
      | MemberRefParent
      | HasSemantics
      | MethodDefOrRef
      | MemberForwarded
      | Implementation
      | CustomAttributeType
      | ResolutionScope
    type RowKind = | RowKind of RowElementKind list
    val kindAssemblyRef : RowKind
    val kindModuleRef : RowKind
    val kindFileRef : RowKind
    val kindTypeRef : RowKind
    val kindTypeSpec : RowKind
    val kindTypeDef : RowKind
    val kindPropertyMap : RowKind
    val kindEventMap : RowKind
    val kindInterfaceImpl : RowKind
    val kindNested : RowKind
    val kindCustomAttribute : RowKind
    val kindDeclSecurity : RowKind
    val kindMemberRef : RowKind
    val kindStandAloneSig : RowKind
    val kindFieldDef : RowKind
    val kindFieldRVA : RowKind
    val kindFieldMarshal : RowKind
    val kindConstant : RowKind
    val kindFieldLayout : RowKind
    val kindParam : RowKind
    val kindMethodDef : RowKind
    val kindMethodImpl : RowKind
    val kindImplMap : RowKind
    val kindMethodSemantics : RowKind
    val kindProperty : RowKind
    val kindEvent : RowKind
    val kindManifestResource : RowKind
    val kindClassLayout : RowKind
    val kindExportedType : RowKind
    val kindAssembly : RowKind
    val kindGenericParam_v1_1 : RowKind
    val kindGenericParam_v2_0 : RowKind
    val kindMethodSpec : RowKind
    val kindGenericParamConstraint : RowKind
    val kindModule : RowKind
    val kindIllegal : RowKind
    val hcCompare :
      TaggedIndex<Internal.BinaryConstants.HasConstantTag> ->
        TaggedIndex<Internal.BinaryConstants.HasConstantTag> -> int
    val hsCompare :
      TaggedIndex<Internal.BinaryConstants.HasSemanticsTag> ->
        TaggedIndex<Internal.BinaryConstants.HasSemanticsTag> -> int
    val hcaCompare :
      TaggedIndex<Internal.BinaryConstants.HasCustomAttributeTag> ->
        TaggedIndex<Internal.BinaryConstants.HasCustomAttributeTag> -> int
    val mfCompare :
      TaggedIndex<Internal.BinaryConstants.MemberForwardedTag> ->
        TaggedIndex<Internal.BinaryConstants.MemberForwardedTag> -> int
    val hdsCompare :
      TaggedIndex<Internal.BinaryConstants.HasDeclSecurityTag> ->
        TaggedIndex<Internal.BinaryConstants.HasDeclSecurityTag> -> int
    val hfmCompare :
      TaggedIndex<Internal.BinaryConstants.HasFieldMarshalTag> ->
        TaggedIndex<Internal.BinaryConstants.HasFieldMarshalTag> -> int
    val tomdCompare :
      TaggedIndex<Internal.BinaryConstants.TypeOrMethodDefTag> ->
        TaggedIndex<Internal.BinaryConstants.TypeOrMethodDefTag> -> int
    val simpleIndexCompare : idx1:int -> idx2:int -> int
    type TypeDefAsTypIdx =
      | TypeDefAsTypIdx of IL.ILBoxity * IL.ILGenericArgs * int
    type TypeRefAsTypIdx =
      | TypeRefAsTypIdx of IL.ILBoxity * IL.ILGenericArgs * int
    type BlobAsMethodSigIdx =
      | BlobAsMethodSigIdx of numtypars: int * blobIdx: int32
    type BlobAsFieldSigIdx =
      | BlobAsFieldSigIdx of numtypars: int * blobIdx: int32
    type BlobAsPropSigIdx =
      | BlobAsPropSigIdx of numtypars: int * blobIdx: int32
    type BlobAsLocalSigIdx =
      | BlobAsLocalSigIdx of numtypars: int * blobIdx: int32
    type MemberRefAsMspecIdx =
      | MemberRefAsMspecIdx of numtypars: int * idx: int
    type MethodSpecAsMspecIdx =
      | MethodSpecAsMspecIdx of numtypars: int * idx: int
    type MemberRefAsFspecIdx =
      | MemberRefAsFspecIdx of numtypars: int * idx: int
    type CustomAttrIdx =
      | CustomAttrIdx of
        Internal.BinaryConstants.CustomAttributeTypeTag * idx: int *
        valIdx: int32
    type GenericParamsIdx =
      | GenericParamsIdx of
        numtypars: int * Internal.BinaryConstants.TypeOrMethodDefTag * idx: int
    val mkCacheInt32 :
      lowMem:bool ->
        _inbase:'a -> _nm:'b -> _sz:'c -> ((int32 -> 'd) -> int32 -> 'd)
    val mkCacheGeneric :
      lowMem:bool -> _inbase:'a -> _nm:'b -> _sz:'c -> (('T -> 'd) -> 'T -> 'd)
    val seekFindRow : numRows:int -> rowChooser:(int -> bool) -> int
    val seekReadIndexedRows :
      numRows:int * rowReader:(int -> 'a) * keyFunc:('a -> 'b) *
      keyComparer:('b -> int) * binaryChop:bool * rowConverter:('a -> 'c) ->
        'c list
    val seekReadOptionalIndexedRow :
      int * (int -> 'a) * ('a -> 'b) * ('b -> int) * bool * ('a -> 'c) ->
        'c option
    val seekReadIndexedRow :
      int * (int -> 'a) * ('a -> 'b) * ('b -> int) * bool * ('a -> 'c) -> 'c
    type MethodData =
      | MethodData of
        enclTy: IL.ILType * IL.ILCallingConv * name: string * argtys: IL.ILTypes *
        retty: IL.ILType * minst: IL.ILTypes
    type VarArgMethodData =
      | VarArgMethodData of
        enclTy: IL.ILType * IL.ILCallingConv * name: string * argtys: IL.ILTypes *
        IL.ILVarArgs * retty: IL.ILType * minst: IL.ILTypes
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    type PEReader =
      { fileName: string
        pdb: obj option
        entryPointToken: Internal.BinaryConstants.TableName * int
        pefile: BinaryFile
        textSegmentPhysicalLoc: int32
        textSegmentPhysicalSize: int32
        dataSegmentPhysicalLoc: int32
        dataSegmentPhysicalSize: int32
        anyV2P: string * int32 -> int32
        metadataAddr: int32
        sectionHeaders: (int32 * int32 * int32) list
        nativeResourcesAddr: int32
        nativeResourcesSize: int32
        resourcesAddr: int32
        strongnameAddr: int32
        vtableFixupsAddr: int32
        noFileOnDisk: bool }
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    type ILMetadataReader =
      { sorted: int64
        mdfile: BinaryFile
        pectxtCaptured: PEReader option
        entryPointToken: Internal.BinaryConstants.TableName * int
        dataEndPoints: System.Lazy<int32 list>
        fileName: string
        getNumRows: Internal.BinaryConstants.TableName -> int
        userStringsStreamPhysicalLoc: int32
        stringsStreamPhysicalLoc: int32
        blobsStreamPhysicalLoc: int32
        blobsStreamSize: int32
        readUserStringHeap: int32 -> string
        memoizeString: string -> string
        readStringHeap: int32 -> string
        readBlobHeap: int32 -> byte []
        guidsStreamPhysicalLoc: int32
        rowAddr: Internal.BinaryConstants.TableName -> int -> int32
        tableBigness: bool []
        rsBigness: bool
        tdorBigness: bool
        tomdBigness: bool
        hcBigness: bool
        hcaBigness: bool
        hfmBigness: bool
        hdsBigness: bool
        mrpBigness: bool
        hsBigness: bool
        mdorBigness: bool
        mfBigness: bool
        iBigness: bool
        catBigness: bool
        stringsBigness: bool
        guidsBigness: bool
        blobsBigness: bool
        seekReadNestedRow: int -> int * int
        seekReadConstantRow:
          int ->
            uint16 * TaggedIndex<Internal.BinaryConstants.HasConstantTag> *
            int32
        seekReadMethodSemanticsRow:
          int ->
            int32 * int * TaggedIndex<Internal.BinaryConstants.HasSemanticsTag>
        seekReadTypeDefRow:
          int ->
            int32 * int32 * int32 *
            TaggedIndex<Internal.BinaryConstants.TypeDefOrRefTag> * int * int
        seekReadAssemblyRef: int -> IL.ILAssemblyRef
        seekReadMethodSpecAsMethodData: MethodSpecAsMspecIdx -> VarArgMethodData
        seekReadMemberRefAsMethodData: MemberRefAsMspecIdx -> VarArgMethodData
        seekReadMemberRefAsFieldSpec: MemberRefAsFspecIdx -> IL.ILFieldSpec
        seekReadCustomAttr: CustomAttrIdx -> IL.ILAttribute
        seekReadTypeRef: int -> IL.ILTypeRef
        seekReadTypeRefAsType: TypeRefAsTypIdx -> IL.ILType
        readBlobHeapAsPropertySig:
          BlobAsPropSigIdx -> IL.ILThisConvention * IL.ILType * IL.ILTypes
        readBlobHeapAsFieldSig: BlobAsFieldSigIdx -> IL.ILType
        readBlobHeapAsMethodSig:
          BlobAsMethodSigIdx ->
            bool * int32 * IL.ILCallingConv * IL.ILType * IL.ILTypes *
            IL.ILVarArgs
        readBlobHeapAsLocalsSig: BlobAsLocalSigIdx -> IL.ILLocal list
        seekReadTypeDefAsType: TypeDefAsTypIdx -> IL.ILType
        seekReadMethodDefAsMethodData: int -> MethodData
        seekReadGenericParams: GenericParamsIdx -> IL.ILGenericParameterDef list
        seekReadFieldDefAsFieldSpec: int -> IL.ILFieldSpec
        customAttrsReader_Module: IL.ILAttributesStored
        customAttrsReader_Assembly: IL.ILAttributesStored
        customAttrsReader_TypeDef: IL.ILAttributesStored
        customAttrsReader_GenericParam: IL.ILAttributesStored
        customAttrsReader_FieldDef: IL.ILAttributesStored
        customAttrsReader_MethodDef: IL.ILAttributesStored
        customAttrsReader_ParamDef: IL.ILAttributesStored
        customAttrsReader_Event: IL.ILAttributesStored
        customAttrsReader_Property: IL.ILAttributesStored
        customAttrsReader_ManifestResource: IL.ILAttributesStored
        customAttrsReader_ExportedType: IL.ILAttributesStored
        securityDeclsReader_TypeDef: IL.ILSecurityDeclsStored
        securityDeclsReader_MethodDef: IL.ILSecurityDeclsStored
        securityDeclsReader_Assembly: IL.ILSecurityDeclsStored
        typeDefReader: IL.ILTypeDefStored }
    type ISeekReadIndexedRowReader<'RowT,'KeyT,'T when 'RowT : struct> =
      interface
        abstract member CompareKey : 'KeyT -> int
        abstract member ConvertRow : byref<'RowT> -> 'T
        abstract member GetKey : byref<'RowT> -> 'KeyT
        abstract member GetRow : int * byref<'RowT> -> unit
      end
    val seekReadIndexedRowsByInterface :
      numRows:int ->
        binaryChop:bool ->
          reader:ISeekReadIndexedRowReader<'RowT,'a,'b> -> 'b []
        when 'RowT : struct
    [<StructAttribute ()>]
    type CustomAttributeRow =
      struct
        val mutable parentIndex:
              TaggedIndex<Internal.BinaryConstants.HasCustomAttributeTag>
        val mutable typeIndex:
              TaggedIndex<Internal.BinaryConstants.CustomAttributeTypeTag>
        val mutable valueIndex: int
      end
    val seekReadUInt16Adv : mdv:BinaryView -> addr:byref<int> -> uint16
    val seekReadInt32Adv : mdv:BinaryView -> addr:byref<int> -> int
    val seekReadUInt16AsInt32Adv : mdv:BinaryView -> addr:byref<int> -> int32
    val inline seekReadTaggedIdx :
      f:(int -> 'a) ->
        nbits:int ->
          big:bool -> mdv:BinaryView -> addr:byref<int> -> TaggedIndex<'a>
    val seekReadIdx : big:bool -> mdv:BinaryView -> addr:byref<int> -> int
    val seekReadUntaggedIdx :
      tab:Internal.BinaryConstants.TableName ->
        ctxt:ILMetadataReader -> mdv:BinaryView -> addr:byref<int> -> int
    val seekReadResolutionScopeIdx :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          addr:byref<int> ->
            TaggedIndex<Internal.BinaryConstants.ResolutionScopeTag>
    val seekReadTypeDefOrRefOrSpecIdx :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          addr:byref<int> ->
            TaggedIndex<Internal.BinaryConstants.TypeDefOrRefTag>
    val seekReadTypeOrMethodDefIdx :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          addr:byref<int> ->
            TaggedIndex<Internal.BinaryConstants.TypeOrMethodDefTag>
    val seekReadHasConstantIdx :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          addr:byref<int> ->
            TaggedIndex<Internal.BinaryConstants.HasConstantTag>
    val seekReadHasCustomAttributeIdx :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          addr:byref<int> ->
            TaggedIndex<Internal.BinaryConstants.HasCustomAttributeTag>
    val seekReadHasFieldMarshalIdx :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          addr:byref<int> ->
            TaggedIndex<Internal.BinaryConstants.HasFieldMarshalTag>
    val seekReadHasDeclSecurityIdx :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          addr:byref<int> ->
            TaggedIndex<Internal.BinaryConstants.HasDeclSecurityTag>
    val seekReadMemberRefParentIdx :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          addr:byref<int> ->
            TaggedIndex<Internal.BinaryConstants.MemberRefParentTag>
    val seekReadHasSemanticsIdx :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          addr:byref<int> ->
            TaggedIndex<Internal.BinaryConstants.HasSemanticsTag>
    val seekReadMethodDefOrRefIdx :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          addr:byref<int> ->
            TaggedIndex<Internal.BinaryConstants.MethodDefOrRefTag>
    val seekReadMemberForwardedIdx :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          addr:byref<int> ->
            TaggedIndex<Internal.BinaryConstants.MemberForwardedTag>
    val seekReadImplementationIdx :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          addr:byref<int> ->
            TaggedIndex<Internal.BinaryConstants.ImplementationTag>
    val seekReadCustomAttributeTypeIdx :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          addr:byref<int> ->
            TaggedIndex<Internal.BinaryConstants.CustomAttributeTypeTag>
    val seekReadStringIdx :
      ctxt:ILMetadataReader -> mdv:BinaryView -> addr:byref<int> -> int
    val seekReadGuidIdx :
      ctxt:ILMetadataReader -> mdv:BinaryView -> addr:byref<int> -> int
    val seekReadBlobIdx :
      ctxt:ILMetadataReader -> mdv:BinaryView -> addr:byref<int> -> int
    val seekReadModuleRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView -> idx:int -> uint16 * int * int * int * int
    val seekReadTypeRefRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          idx:int ->
            TaggedIndex<Internal.BinaryConstants.ResolutionScopeTag> * int * int
    val seekReadTypeDefRow :
      ctxt:ILMetadataReader ->
        idx:int ->
          int32 * int32 * int32 *
          TaggedIndex<Internal.BinaryConstants.TypeDefOrRefTag> * int * int
    val seekReadTypeDefRowUncached :
      ctxtH:ILMetadataReader option ref ->
        idx:int ->
          int * int * int *
          TaggedIndex<Internal.BinaryConstants.TypeDefOrRefTag> * int * int
    val seekReadFieldRow :
      ctxt:ILMetadataReader -> mdv:BinaryView -> idx:int -> int32 * int * int
    val seekReadMethodRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView -> idx:int -> int * int32 * int32 * int * int * int
    val seekReadParamRow :
      ctxt:ILMetadataReader -> mdv:BinaryView -> idx:int -> int32 * int32 * int
    val seekReadInterfaceImplRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          idx:int -> int * TaggedIndex<Internal.BinaryConstants.TypeDefOrRefTag>
    val seekReadMemberRefRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          idx:int ->
            TaggedIndex<Internal.BinaryConstants.MemberRefParentTag> * int * int
    val seekReadConstantRow :
      ctxt:ILMetadataReader ->
        idx:int ->
          uint16 * TaggedIndex<Internal.BinaryConstants.HasConstantTag> * int32
    val seekReadConstantRowUncached :
      ctxtH:ILMetadataReader option ref ->
        idx:int ->
          uint16 * TaggedIndex<Internal.BinaryConstants.HasConstantTag> * int
    val seekReadCustomAttributeRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView -> idx:int -> attrRow:byref<CustomAttributeRow> -> unit
    val seekReadFieldMarshalRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          idx:int ->
            TaggedIndex<Internal.BinaryConstants.HasFieldMarshalTag> * int
    val seekReadPermissionRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          idx:int ->
            uint16 * TaggedIndex<Internal.BinaryConstants.HasDeclSecurityTag> *
            int
    val seekReadClassLayoutRow :
      ctxt:ILMetadataReader -> mdv:BinaryView -> idx:int -> uint16 * int * int
    val seekReadFieldLayoutRow :
      ctxt:ILMetadataReader -> mdv:BinaryView -> idx:int -> int * int
    val seekReadStandAloneSigRow :
      ctxt:ILMetadataReader -> mdv:BinaryView -> idx:int -> int
    val seekReadEventMapRow :
      ctxt:ILMetadataReader -> mdv:BinaryView -> idx:int -> int * int
    val seekReadEventRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          idx:int ->
            int32 * int * TaggedIndex<Internal.BinaryConstants.TypeDefOrRefTag>
    val seekReadPropertyMapRow :
      ctxt:ILMetadataReader -> mdv:BinaryView -> idx:int -> int * int
    val seekReadPropertyRow :
      ctxt:ILMetadataReader -> mdv:BinaryView -> idx:int -> int32 * int * int
    val seekReadMethodSemanticsRow :
      ctxt:ILMetadataReader ->
        idx:int ->
          int32 * int * TaggedIndex<Internal.BinaryConstants.HasSemanticsTag>
    val seekReadMethodSemanticsRowUncached :
      ctxtH:ILMetadataReader option ref ->
        idx:int ->
          int32 * int * TaggedIndex<Internal.BinaryConstants.HasSemanticsTag>
    val seekReadMethodImplRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          idx:int ->
            int * TaggedIndex<Internal.BinaryConstants.MethodDefOrRefTag> *
            TaggedIndex<Internal.BinaryConstants.MethodDefOrRefTag>
    val seekReadModuleRefRow :
      ctxt:ILMetadataReader -> mdv:BinaryView -> idx:int -> int
    val seekReadTypeSpecRow :
      ctxt:ILMetadataReader -> mdv:BinaryView -> idx:int -> int
    val seekReadImplMapRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          idx:int ->
            int32 * TaggedIndex<Internal.BinaryConstants.MemberForwardedTag> *
            int * int
    val seekReadFieldRVARow :
      ctxt:ILMetadataReader -> mdv:BinaryView -> idx:int -> int * int
    val seekReadAssemblyRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          idx:int ->
            int * uint16 * uint16 * uint16 * uint16 * int * int * int * int
    val seekReadAssemblyRefRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          idx:int ->
            uint16 * uint16 * uint16 * uint16 * int * int * int * int * int
    val seekReadFileRow :
      ctxt:ILMetadataReader -> mdv:BinaryView -> idx:int -> int * int * int
    val seekReadExportedTypeRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          idx:int ->
            int * int * int * int *
            TaggedIndex<Internal.BinaryConstants.ImplementationTag>
    val seekReadManifestResourceRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          idx:int ->
            int * int * int *
            TaggedIndex<Internal.BinaryConstants.ImplementationTag>
    val seekReadNestedRow : ctxt:ILMetadataReader -> idx:int -> int * int
    val seekReadNestedRowUncached :
      ctxtH:ILMetadataReader option ref -> idx:int -> int * int
    val seekReadGenericParamRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          idx:int ->
            int * uint16 * uint16 *
            TaggedIndex<Internal.BinaryConstants.TypeOrMethodDefTag> * int
    val seekReadGenericParamConstraintRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          idx:int -> int * TaggedIndex<Internal.BinaryConstants.TypeDefOrRefTag>
    val seekReadMethodSpecRow :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          idx:int ->
            TaggedIndex<Internal.BinaryConstants.MethodDefOrRefTag> * int
    val readUserStringHeapUncached :
      ctxtH:ILMetadataReader option ref -> idx:int32 -> string
    val readUserStringHeap : ctxt:ILMetadataReader -> idx:int32 -> string
    val readStringHeapUncached :
      ctxtH:ILMetadataReader option ref -> idx:int32 -> string
    val readStringHeap : ctxt:ILMetadataReader -> idx:int32 -> string
    val readStringHeapOption : ctxt:ILMetadataReader -> idx:int -> string option
    val emptyByteArray : byte []
    val readBlobHeapUncached :
      ctxtH:ILMetadataReader option ref -> idx:int -> byte []
    val readBlobHeap : ctxt:ILMetadataReader -> idx:int32 -> byte []
    val readBlobHeapOption : ctxt:ILMetadataReader -> idx:int -> byte [] option
    val readBlobHeapAsBool : ctxt:ILMetadataReader -> vidx:int32 -> bool
    val readBlobHeapAsSByte : ctxt:ILMetadataReader -> vidx:int32 -> sbyte
    val readBlobHeapAsInt16 : ctxt:ILMetadataReader -> vidx:int32 -> int16
    val readBlobHeapAsInt32 : ctxt:ILMetadataReader -> vidx:int32 -> int
    val readBlobHeapAsInt64 : ctxt:ILMetadataReader -> vidx:int32 -> int64
    val readBlobHeapAsByte : ctxt:ILMetadataReader -> vidx:int32 -> byte
    val readBlobHeapAsUInt16 : ctxt:ILMetadataReader -> vidx:int32 -> uint16
    val readBlobHeapAsUInt32 : ctxt:ILMetadataReader -> vidx:int32 -> uint32
    val readBlobHeapAsUInt64 : ctxt:ILMetadataReader -> vidx:int32 -> uint64
    val readBlobHeapAsSingle : ctxt:ILMetadataReader -> vidx:int32 -> float32
    val readBlobHeapAsDouble : ctxt:ILMetadataReader -> vidx:int32 -> float
    val readNativeResources : pectxt:PEReader -> IL.ILNativeResource list
    val getDataEndPointsDelayed :
      pectxt:PEReader -> ctxtH:ILMetadataReader option ref -> Lazy<int32 list>
    val rvaToData :
      ctxt:ILMetadataReader ->
        pectxt:PEReader -> nm:string -> rva:int -> byte []
    val isSorted :
      ctxt:ILMetadataReader -> tab:Internal.BinaryConstants.TableName -> bool
    val seekReadModule :
      ctxt:ILMetadataReader ->
        canReduceMemory:bool ->
          pectxtEager:PEReader ->
            pevEager:BinaryView ->
              uint16 * (int * int) * bool * bool * bool * bool * bool *
              IL.ILPlatform option * bool * int32 * int32 * int32 ->
                ilMetadataVersion:string -> idx:int -> IL.ILModuleDef
    val seekReadAssemblyManifest :
      ctxt:ILMetadataReader ->
        pectxt:PEReader -> idx:int -> IL.ILAssemblyManifest
    val seekReadAssemblyRef :
      ctxt:ILMetadataReader -> idx:int -> IL.ILAssemblyRef
    val seekReadAssemblyRefUncached :
      ctxtH:ILMetadataReader option ref -> idx:int -> IL.ILAssemblyRef
    val seekReadModuleRef :
      ctxt:ILMetadataReader -> mdv:BinaryView -> idx:int -> IL.ILModuleRef
    val seekReadFile :
      ctxt:ILMetadataReader -> mdv:BinaryView -> idx:int -> IL.ILModuleRef
    val seekReadClassLayout :
      ctxt:ILMetadataReader ->
        mdv:BinaryView -> idx:int -> IL.ILTypeDefLayoutInfo
    val typeAccessOfFlags : flags:int -> IL.ILTypeDefAccess
    val typeLayoutOfFlags :
      ctxt:ILMetadataReader ->
        mdv:BinaryView -> flags:int -> tidx:int -> IL.ILTypeDefLayout
    val isTopTypeDef : flags:int -> bool
    val seekIsTopTypeDefOfIdx : ctxt:ILMetadataReader -> idx:int -> bool
    val readBlobHeapAsSplitTypeName :
      ctxt:ILMetadataReader ->
        nameIdx:int32 * namespaceIdx:int -> string list * string
    val readBlobHeapAsTypeName :
      ctxt:ILMetadataReader -> nameIdx:int32 * namespaceIdx:int -> string
    val seekReadTypeDefRowExtents :
      ctxt:ILMetadataReader -> _info:'a -> idx:int -> struct (int * int)
    val seekReadTypeDefRowWithExtents :
      ctxt:ILMetadataReader ->
        idx:int ->
          (int32 * int32 * int32 *
           TaggedIndex<Internal.BinaryConstants.TypeDefOrRefTag> * int * int) *
          struct (int * int)
    val seekReadPreTypeDef :
      ctxt:ILMetadataReader -> toponly:bool -> idx:int -> IL.ILPreTypeDef option
    val typeDefReader : ctxtH:ILMetadataReader option ref -> IL.ILTypeDefStored
    val seekReadTopTypeDefs : ctxt:ILMetadataReader -> IL.ILPreTypeDef []
    val seekReadNestedTypeDefs :
      ctxt:ILMetadataReader -> tidx:int32 -> IL.ILTypeDefs
    val seekReadInterfaceImpls :
      ctxt:ILMetadataReader ->
        mdv:BinaryView -> numtypars:int -> tidx:int32 -> IL.ILTypes
    val seekReadGenericParams :
      ctxt:ILMetadataReader ->
        numtypars:int ->
          a:Internal.BinaryConstants.TypeOrMethodDefTag * b:int32 ->
            IL.ILGenericParameterDefs
    val seekReadGenericParamsUncached :
      ctxtH:ILMetadataReader option ref ->
        GenericParamsIdx -> IL.ILGenericParameterDef list
    val seekReadGenericParamConstraints :
      ctxt:ILMetadataReader ->
        mdv:BinaryView -> numtypars:int -> gpidx:int -> IL.ILTypes
    val seekReadTypeDefAsType :
      ctxt:ILMetadataReader ->
        boxity:IL.ILBoxity -> ginst:IL.ILTypes -> idx:int -> IL.ILType
    val seekReadTypeDefAsTypeUncached :
      ctxtH:ILMetadataReader option ref -> TypeDefAsTypIdx -> IL.ILType
    val seekReadTypeDefAsTypeRef :
      ctxt:ILMetadataReader -> idx:int -> IL.ILTypeRef
    val seekReadTypeRef : ctxt:ILMetadataReader -> idx:int -> IL.ILTypeRef
    val seekReadTypeRefUncached :
      ctxtH:ILMetadataReader option ref -> idx:int -> IL.ILTypeRef
    val seekReadTypeRefAsType :
      ctxt:ILMetadataReader ->
        boxity:IL.ILBoxity -> ginst:IL.ILGenericArgs -> idx:int -> IL.ILType
    val seekReadTypeRefAsTypeUncached :
      ctxtH:ILMetadataReader option ref -> TypeRefAsTypIdx -> IL.ILType
    val seekReadTypeDefOrRef :
      ctxt:ILMetadataReader ->
        numtypars:int ->
          boxity:IL.ILBoxity ->
            ginst:IL.ILTypes ->
              TaggedIndex<Internal.BinaryConstants.TypeDefOrRefTag> -> IL.ILType
    val seekReadTypeDefOrRefAsTypeRef :
      ctxt:ILMetadataReader ->
        TaggedIndex<Internal.BinaryConstants.TypeDefOrRefTag> -> IL.ILTypeRef
    val seekReadMethodRefParent :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          numtypars:int ->
            TaggedIndex<Internal.BinaryConstants.MemberRefParentTag> ->
              IL.ILType
    val seekReadMethodDefOrRef :
      ctxt:ILMetadataReader ->
        numtypars:int ->
          TaggedIndex<Internal.BinaryConstants.MethodDefOrRefTag> ->
            VarArgMethodData
    val seekReadMethodDefOrRefNoVarargs :
      ctxt:ILMetadataReader ->
        numtypars:int ->
          x:TaggedIndex<Internal.BinaryConstants.MethodDefOrRefTag> ->
            MethodData
    val seekReadCustomAttrType :
      ctxt:ILMetadataReader ->
        TaggedIndex<Internal.BinaryConstants.CustomAttributeTypeTag> ->
          IL.ILMethodSpec
    val seekReadImplAsScopeRef :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          TaggedIndex<Internal.BinaryConstants.ImplementationTag> ->
            IL.ILScopeRef
    val seekReadTypeRefScope :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          TaggedIndex<Internal.BinaryConstants.ResolutionScopeTag> ->
            IL.ILScopeRef * string list
    val seekReadOptionalTypeDefOrRef :
      ctxt:ILMetadataReader ->
        numtypars:int ->
          boxity:IL.ILBoxity ->
            idx:TaggedIndex<Internal.BinaryConstants.TypeDefOrRefTag> ->
              IL.ILType option
    val seekReadField :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          numtypars:int * hasLayout:bool -> idx:int -> IL.ILFieldDef
    val seekReadFields :
      ctxt:ILMetadataReader ->
        numtypars:int * hasLayout:bool ->
          fidx1:int -> fidx2:int -> IL.ILFieldDefs
    val seekReadMethods :
      ctxt:ILMetadataReader ->
        numtypars:int -> midx1:int -> midx2:int -> IL.ILMethodDefs
    val sigptrGetTypeDefOrRefOrSpecIdx :
      bytes:byte [] ->
        sigptr:int ->
          TaggedIndex<Internal.BinaryConstants.TypeDefOrRefTag> * int
    val sigptrGetTy :
      ctxt:ILMetadataReader ->
        numtypars:int -> bytes:byte [] -> sigptr:int -> IL.ILType * int
    val sigptrGetVarArgTys :
      ctxt:ILMetadataReader ->
        n:int ->
          numtypars:int -> bytes:byte [] -> sigptr:int -> IL.ILType list * int
    val sigptrGetArgTys :
      ctxt:ILMetadataReader ->
        n:int ->
          numtypars:int ->
            bytes:byte [] ->
              sigptr:int ->
                acc:IL.ILType list ->
                  (IL.ILType list * IL.ILType list option) * int
    val sigptrGetLocal :
      ctxt:ILMetadataReader ->
        numtypars:int -> bytes:byte [] -> sigptr:int -> IL.ILLocal * int
    val readBlobHeapAsMethodSig :
      ctxt:ILMetadataReader ->
        numtypars:int ->
          blobIdx:int32 ->
            bool * int32 * IL.ILCallingConv * IL.ILType * IL.ILTypes *
            IL.ILVarArgs
    val readBlobHeapAsMethodSigUncached :
      ctxtH:ILMetadataReader option ref ->
        BlobAsMethodSigIdx ->
          bool * int * IL.ILCallingConv * IL.ILType * IL.ILType list *
          IL.ILType list option
    val readBlobHeapAsType :
      ctxt:ILMetadataReader -> numtypars:int -> blobIdx:int -> IL.ILType
    val readBlobHeapAsFieldSig :
      ctxt:ILMetadataReader -> numtypars:int -> blobIdx:int -> IL.ILType
    val readBlobHeapAsFieldSigUncached :
      ctxtH:ILMetadataReader option ref -> BlobAsFieldSigIdx -> IL.ILType
    val readBlobHeapAsPropertySig :
      ctxt:ILMetadataReader ->
        numtypars:int ->
          blobIdx:int32 -> IL.ILThisConvention * IL.ILType * IL.ILTypes
    val readBlobHeapAsPropertySigUncached :
      ctxtH:ILMetadataReader option ref ->
        BlobAsPropSigIdx -> IL.ILThisConvention * IL.ILType * IL.ILType list
    val readBlobHeapAsLocalsSig :
      ctxt:ILMetadataReader -> numtypars:int -> blobIdx:int32 -> IL.ILLocal list
    val readBlobHeapAsLocalsSigUncached :
      ctxtH:ILMetadataReader option ref -> BlobAsLocalSigIdx -> IL.ILLocal list
    val byteAsHasThis : b:byte -> IL.ILThisConvention
    val byteAsCallConv : b:byte -> bool * IL.ILCallingConv
    val seekReadMemberRefAsMethodData :
      ctxt:ILMetadataReader -> numtypars:int -> idx:int32 -> VarArgMethodData
    val seekReadMemberRefAsMethodDataUncached :
      ctxtH:ILMetadataReader option ref ->
        MemberRefAsMspecIdx -> VarArgMethodData
    val seekReadMemberRefAsMethDataNoVarArgs :
      ctxt:ILMetadataReader -> numtypars:int -> idx:int32 -> MethodData
    val seekReadMethodSpecAsMethodData :
      ctxt:ILMetadataReader -> numtypars:int -> idx:int -> VarArgMethodData
    val seekReadMethodSpecAsMethodDataUncached :
      ctxtH:ILMetadataReader option ref ->
        MethodSpecAsMspecIdx -> VarArgMethodData
    val seekReadMemberRefAsFieldSpec :
      ctxt:ILMetadataReader -> numtypars:int -> idx:int -> IL.ILFieldSpec
    val seekReadMemberRefAsFieldSpecUncached :
      ctxtH:ILMetadataReader option ref -> MemberRefAsFspecIdx -> IL.ILFieldSpec
    val seekReadMethodDefAsMethodData :
      ctxt:ILMetadataReader -> idx:int32 -> MethodData
    val seekReadMethodDefAsMethodDataUncached :
      ctxtH:ILMetadataReader option ref -> idx:int -> MethodData
    val seekReadFieldDefAsFieldSpec :
      ctxt:ILMetadataReader -> idx:int -> IL.ILFieldSpec
    val seekReadFieldDefAsFieldSpecUncached :
      ctxtH:ILMetadataReader option ref -> idx:int -> IL.ILFieldSpec
    val seekReadMethod :
      ctxt:ILMetadataReader ->
        mdv:BinaryView -> numtypars:int -> idx:int -> IL.ILMethodDef
    val seekReadParams :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          retty:IL.ILType * argtys:IL.ILTypes ->
            pidx1:int -> pidx2:int -> IL.ILReturn * IL.ILParameters
    val seekReadParamExtras :
      ctxt:ILMetadataReader ->
        mdv:BinaryView ->
          retRes:IL.ILReturn ref * paramsRes:IL.ILParameter [] ->
            idx:int -> unit
    val seekReadMethodImpls :
      ctxt:ILMetadataReader ->
        numtypars:int -> tidx:int32 -> IL.ILMethodImplDefs
    val seekReadMultipleMethodSemantics :
      ctxt:ILMetadataReader ->
        flags:int32 * id:TaggedIndex<Internal.BinaryConstants.HasSemanticsTag> ->
          IL.ILMethodRef list
    val seekReadoptional_MethodSemantics :
      ctxt:ILMetadataReader ->
        int32 * TaggedIndex<Internal.BinaryConstants.HasSemanticsTag> ->
          IL.ILMethodRef option
    val seekReadMethodSemantics :
      ctxt:ILMetadataReader ->
        int32 * TaggedIndex<Internal.BinaryConstants.HasSemanticsTag> ->
          IL.ILMethodRef
    val seekReadEvent :
      ctxt:ILMetadataReader ->
        mdv:BinaryView -> numtypars:int -> idx:int -> IL.ILEventDef
    val seekReadEvents :
      ctxt:ILMetadataReader -> numtypars:int -> tidx:int32 -> IL.ILEventDefs
    val seekReadProperty :
      ctxt:ILMetadataReader ->
        mdv:BinaryView -> numtypars:int -> idx:int -> IL.ILPropertyDef
    val seekReadProperties :
      ctxt:ILMetadataReader -> numtypars:int -> tidx:int32 -> IL.ILPropertyDefs
    val customAttrsReader :
      ctxtH:ILMetadataReader option ref ->
        tag:Internal.BinaryConstants.HasCustomAttributeTag ->
          IL.ILAttributesStored
    val seekReadCustomAttr :
      ctxt:ILMetadataReader ->
        TaggedIndex<Internal.BinaryConstants.CustomAttributeTypeTag> * b:int ->
          IL.ILAttribute
    val seekReadCustomAttrUncached :
      ctxtH:ILMetadataReader option ref -> CustomAttrIdx -> IL.ILAttribute
    val securityDeclsReader :
      ctxtH:ILMetadataReader option ref ->
        tag:Internal.BinaryConstants.HasDeclSecurityTag ->
          IL.ILSecurityDeclsStored
    val seekReadSecurityDecl :
      ctxt:ILMetadataReader -> act:uint16 * ty:int -> IL.ILSecurityDecl
    val seekReadConstant :
      ctxt:ILMetadataReader ->
        idx:TaggedIndex<Internal.BinaryConstants.HasConstantTag> ->
          IL.ILFieldInit
    val seekReadImplMap :
      ctxt:ILMetadataReader -> nm:string -> midx:int -> IL.ILLazyMethodBody
    val seekReadTopCode :
      ctxt:ILMetadataReader ->
        pev:BinaryView ->
          mdv:BinaryView ->
            numtypars:int ->
              sz:int ->
                start:int ->
                  seqpoints:(int * IL.ILSourceMarker) list ->
                    IL.ILInstr [] * (int -> IL.ILCodeLabel) *
                    System.Collections.Generic.Dictionary<IL.ILCodeLabel,int> *
                    (int -> IL.ILCodeLabel)
    val seekReadMethodRVA :
      pectxt:PEReader ->
        ctxt:ILMetadataReader ->
          _idx:int * nm:string * _internalcall:bool * noinline:bool *
          aggressiveinline:bool * numtypars:int ->
            rva:int -> IL.ILLazyMethodBody
    val int32AsILVariantType :
      ctxt:ILMetadataReader -> n:int32 -> IL.ILNativeVariant
    val readBlobHeapAsNativeType :
      ctxt:ILMetadataReader -> blobIdx:int -> IL.ILNativeType
    val sigptrGetILNativeType :
      ctxt:ILMetadataReader ->
        bytes:byte [] -> sigptr:int -> IL.ILNativeType * int
    val seekReadManifestResources :
      ctxt:ILMetadataReader ->
        canReduceMemory:bool ->
          mdv:BinaryView ->
            pectxtEager:PEReader -> pevEager:BinaryView -> IL.ILResources
    val seekReadNestedExportedTypes :
      ctxt:ILMetadataReader ->
        exported:(int * 'b * int32 * int * 'c) [] ->
          nested:System.Lazy<int32 list []> ->
            parentIdx:int32 -> IL.ILNestedExportedTypes
    val seekReadTopExportedTypes :
      ctxt:ILMetadataReader -> IL.ILExportedTypesAndForwarders
    val openMetadataReader :
      fileName:string * mdfile:BinaryFile * metadataPhysLoc:int *
      peinfo:(uint16 * (int * int) * bool * bool * bool * bool * bool *
              IL.ILPlatform option * bool * int32 * int32 * int32) *
      pectxtEager:PEReader * pevEager:BinaryView *
      pectxtCaptured:PEReader option * reduceMemoryUsage:bool ->
        IL.ILModuleDef * Lazy<IL.ILAssemblyRef list>
    val openPEFileReader :
      fileName:string * pefile:BinaryFile * pdbDirPath:'a * noFileOnDisk:bool ->
        int * int *
        (uint16 * (int32 * int32) * bool * bool * bool * bool * bool *
         IL.ILPlatform option * bool * int * int * int) * PEReader * BinaryView *
        obj option
    val openPE :
      fileName:string * pefile:BinaryFile * pdbDirPath:'a *
      reduceMemoryUsage:bool * noFileOnDisk:bool ->
        IL.ILModuleDef * Lazy<IL.ILAssemblyRef list> * obj option
    val openPEMetadataOnly :
      fileName:string *
      peinfo:(uint16 * (int * int) * bool * bool * bool * bool * bool *
              IL.ILPlatform option * bool * int32 * int32 * int32) *
      pectxtEager:PEReader * pevEager:BinaryView * mdfile:BinaryFile *
      reduceMemoryUsage:bool -> IL.ILModuleDef * Lazy<IL.ILAssemblyRef list>
    val ClosePdbReader : pdb:'a -> unit
    type ILReaderMetadataSnapshot = obj * nativeint * int
    type ILReaderTryGetMetadataSnapshot =
      string * System.DateTime -> ILReaderMetadataSnapshot option
    [<RequireQualifiedAccessAttribute ()>]
    type MetadataOnlyFlag =
      | Yes
      | No
    [<RequireQualifiedAccessAttribute ()>]
    type ReduceMemoryFlag =
      | Yes
      | No
    type ILReaderOptions =
      { pdbDirPath: string option
        reduceMemoryUsage: ReduceMemoryFlag
        metadataOnly: MetadataOnlyFlag
        tryGetMetadataSnapshot: ILReaderTryGetMetadataSnapshot }
    type ILModuleReader =
      interface
        inherit System.IDisposable
        abstract member ILAssemblyRefs : IL.ILAssemblyRef list
        abstract member ILModuleDef : IL.ILModuleDef
      end
    [<SealedAttribute ()>]
    type ILModuleReaderImpl =
      class
        interface ILModuleReader
        new : ilModule:IL.ILModuleDef *
              ilAssemblyRefs:System.Lazy<IL.ILAssemblyRef list> *
              dispose:(unit -> unit) -> ILModuleReaderImpl
      end
    type ILModuleReaderCacheKey =
      | ILModuleReaderCacheKey of
        string * System.DateTime * bool * ReduceMemoryFlag * MetadataOnlyFlag
    type ILModuleReaderCache1LockToken =
      class
        interface Internal.Library.LockToken
        new : unit -> ILModuleReaderCache1LockToken
      end
    val ilModuleReaderCache1 :
      Internal.Utilities.Collections.AgedLookup<ILModuleReaderCache1LockToken,
                                                ILModuleReaderCacheKey,
                                                ILModuleReader>
    val ilModuleReaderCache1Lock :
      Internal.Library.Lock<ILModuleReaderCache1LockToken>
    val ilModuleReaderCache2 :
      System.Collections.Concurrent.ConcurrentDictionary<ILModuleReaderCacheKey,
                                                         System.WeakReference<ILModuleReader>>
    val stableFileHeuristicApplies : fileName:string -> bool
    val createByteFileChunk :
      opts:ILReaderOptions ->
        fileName:string -> chunk:(int * int) option -> BinaryFile
    val createMemoryMapFile : fileName:string -> System.IDisposable * BinaryFile
    val OpenILModuleReaderFromBytes :
      fileName:string ->
        assemblyContents:byte [] -> options:ILReaderOptions -> ILModuleReader
    val ClearAllILModuleReaderCache : unit -> unit
    val OpenILModuleReader : string -> ILReaderOptions -> ILModuleReader
    module Shim = begin
      type IAssemblyReader =
        interface
          abstract member
            GetILModuleReader : filename:string * readerOptions:ILReaderOptions ->
                                  ILModuleReader
        end
      [<SealedAttribute ()>]
      type DefaultAssemblyReader =
        class
          interface IAssemblyReader
          new : unit -> DefaultAssemblyReader
        end
      val mutable AssemblyReader : IAssemblyReader
    end
  end

namespace FSharp.Compiler.AbstractIL
  module internal ILPdbWriter = begin
    type BlobBuildingStream =
      class
        inherit System.IO.Stream
        new : unit -> BlobBuildingStream
        override Dispose : _disposing:bool -> unit
        override Flush : unit -> unit
        override Read : _buffer:byte [] * _offset:int * _count:int -> int
        override Seek : _offset:int64 * _origin:System.IO.SeekOrigin -> int64
        override SetLength : _value:int64 -> unit
        member
          ToImmutableArray : unit ->
                               System.Collections.Immutable.ImmutableArray<byte>
        member TryWriteBytes : stream:System.IO.Stream * length:int -> int
        override Write : buffer:byte [] * offset:int * count:int -> unit
        override WriteByte : value:byte -> unit
        member WriteInt32 : value:int -> unit
        override CanRead : bool
        override CanSeek : bool
        override CanWrite : bool
        override Length : int64
        override Position : int64
      end
    type PdbDocumentData = IL.ILSourceDocument
    type PdbLocalVar =
      { Name: string
        Signature: byte []
        Index: int32 }
    type PdbMethodScope =
      { Children: PdbMethodScope array
        StartOffset: int
        EndOffset: int
        Locals: PdbLocalVar array }
    type PdbSourceLoc =
      { Document: int
        Line: int
        Column: int }
    type PdbSequencePoint =
      { Document: int
        Offset: int
        Line: int
        Column: int
        EndLine: int
        EndColumn: int }
      with
        override ToString : unit -> string
      end
    type PdbMethodData =
      { MethToken: int32
        MethName: string
        LocalSignatureToken: int32
        Params: PdbLocalVar array
        RootScope: PdbMethodScope option
        Range: (PdbSourceLoc * PdbSourceLoc) option
        SequencePoints: PdbSequencePoint array }
    module SequencePoint = begin
      val orderBySource : sp1:PdbSequencePoint -> sp2:PdbSequencePoint -> int
      val orderByOffset : sp1:PdbSequencePoint -> sp2:PdbSequencePoint -> int
    end
    val sizeof_IMAGE_DEBUG_DIRECTORY : int
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type PdbData =
      { EntryPoint: int32 option
        Timestamp: int32
        ModuleID: byte []
        Documents: PdbDocumentData []
        Methods: PdbMethodData []
        TableRowCounts: int [] }
    type BinaryChunk =
      { size: int32
        addr: int32 }
    type idd =
      { iddCharacteristics: int32
        iddMajorVersion: int32
        iddMinorVersion: int32
        iddType: int32
        iddTimestamp: int32
        iddData: byte []
        iddChunk: BinaryChunk }
    type HashAlgorithm =
      | Sha1
      | Sha256
    val guidSha1 : System.Guid
    val guidSha2 : System.Guid
    val checkSum :
      url:string ->
        checksumAlgorithm:HashAlgorithm -> (System.Guid * byte []) option
    val cvMagicNumber : int64
    val pdbGetCvDebugInfo :
      mvid:byte [] ->
        timestamp:int32 -> filepath:string -> cvChunk:BinaryChunk -> idd
    val pdbMagicNumber : int64
    val pdbGetEmbeddedPdbDebugInfo :
      embeddedPdbChunk:BinaryChunk ->
        uncompressedLength:int64 -> stream:System.IO.MemoryStream -> idd
    val pdbChecksumDebugInfo :
      timestamp:int32 ->
        checksumPdbChunk:BinaryChunk ->
          algorithmName:string -> checksum:byte [] -> idd
    val pdbGetPdbDebugDeterministicInfo :
      deterministicPdbChunk:BinaryChunk -> idd
    val pdbGetDebugInfo :
      contentId:byte [] ->
        timestamp:int32 ->
          filepath:string ->
            cvChunk:BinaryChunk ->
              embeddedPdbChunk:BinaryChunk option ->
                deterministicPdbChunk:BinaryChunk ->
                  checksumPdbChunk:BinaryChunk ->
                    algorithmName:string ->
                      checksum:byte [] ->
                        uncompressedLength:int64 ->
                          stream:System.IO.MemoryStream option ->
                            embeddedPdb:bool -> deterministic:bool -> idd []
    val getDebugFileName : string -> bool -> string
    val sortMethods : showTimes:bool -> info:PdbData -> unit
    val getRowCounts :
      tableRowCounts:int [] -> System.Collections.Immutable.ImmutableArray<int>
    val generatePortablePdb :
      embedAllSource:bool ->
        embedSourceList:string list ->
          sourceLink:string ->
            checksumAlgorithm:HashAlgorithm ->
              showTimes:bool ->
                info:PdbData ->
                  pathMap:Internal.Utilities.PathMap ->
                    int64 * System.Reflection.Metadata.BlobContentId *
                    System.IO.MemoryStream * string * byte []
    val compressPortablePdbStream :
      uncompressedLength:int64 ->
        contentId:System.Reflection.Metadata.BlobContentId ->
          stream:System.IO.MemoryStream ->
            int64 * System.Reflection.Metadata.BlobContentId *
            System.IO.MemoryStream
    val writePortablePdbInfo :
      contentId:System.Reflection.Metadata.BlobContentId ->
        stream:System.IO.MemoryStream ->
          showTimes:bool ->
            fpdb:string ->
              pathMap:Internal.Utilities.PathMap ->
                cvChunk:BinaryChunk ->
                  deterministicPdbChunk:BinaryChunk ->
                    checksumPdbChunk:BinaryChunk ->
                      algorithmName:string ->
                        checksum:byte [] ->
                          embeddedPdb:bool -> deterministic:bool -> idd []
    val embedPortablePdbInfo :
      uncompressedLength:int64 ->
        contentId:System.Reflection.Metadata.BlobContentId ->
          stream:System.IO.MemoryStream ->
            showTimes:bool ->
              fpdb:string ->
                cvChunk:BinaryChunk ->
                  pdbChunk:BinaryChunk ->
                    deterministicPdbChunk:BinaryChunk ->
                      checksumPdbChunk:BinaryChunk ->
                        algorithmName:string ->
                          checksum:byte [] ->
                            embeddedPdb:bool -> deterministic:bool -> idd []
    val ( ? ) : this:'a -> memb:string -> args:'Args -> 'R
    val monoCompilerSvc : System.Reflection.AssemblyName
    val ctor :
      asmName:System.Reflection.AssemblyName ->
        clsName:string -> args:obj [] -> obj
    val createSourceMethodImpl :
      name:string -> token:int -> namespaceID:int -> obj
    val createWriter : f:string -> obj
    val writeMdbInfo : string -> string -> PdbData -> 'a
    val logDebugInfo : string -> PdbData -> unit
  end

namespace FSharp.Compiler.AbstractIL
  module internal ILBinaryWriter = begin
    val showEntryLookups : bool
    val b0 : n:int -> byte
    val b1 : n:int -> byte
    val b2 : n:int -> byte
    val b3 : n:int -> byte
    val dw7 : n:int64 -> byte
    val dw6 : n:int64 -> byte
    val dw5 : n:int64 -> byte
    val dw4 : n:int64 -> byte
    val dw3 : n:int64 -> byte
    val dw2 : n:int64 -> byte
    val dw1 : n:int64 -> byte
    val dw0 : n:int64 -> byte
    val bitsOfSingle : x:float32 -> int
    val bitsOfDouble : x:float -> int64
    val emitBytesViaBuffer : f:(Internal.ByteBuffer -> unit) -> byte []
    val align : alignment:int -> n:int -> int
    type ByteBuffer with
      static member Z32Size : n:int -> int
    type ByteBuffer with
      member EmitZ32 : n:int -> unit
    type ByteBuffer with
      member EmitPadding : n:int -> unit
    type ByteBuffer with
      member EmitZUntaggedIndex : big:bool -> idx:int32 -> unit
    type ByteBuffer with
      member
        EmitZTaggedIndex : tag:int32 ->
                             nbits:int32 -> big:bool -> idx:int32 -> unit
    val getUncodedToken :
      tab:Internal.BinaryConstants.TableName -> idx:int -> int
    val markerForUnicodeBytes : b:byte [] -> int
    val checkFixup32 : data:byte [] -> offset:int -> exp:int -> unit
    val applyFixup32 : data:byte [] -> offset:int -> v:int -> unit
    module RowElementTags = begin
      [<LiteralAttribute ()>]
      val UShort : int = 0
      [<LiteralAttribute ()>]
      val ULong : int = 1
      [<LiteralAttribute ()>]
      val Data : int = 2
      [<LiteralAttribute ()>]
      val DataResources : int = 3
      [<LiteralAttribute ()>]
      val Guid : int = 4
      [<LiteralAttribute ()>]
      val Blob : int = 5
      [<LiteralAttribute ()>]
      val String : int = 6
      [<LiteralAttribute ()>]
      val SimpleIndexMin : int = 7
      val SimpleIndex : t:Internal.BinaryConstants.TableName -> int
      [<LiteralAttribute ()>]
      val SimpleIndexMax : int = 119
      [<LiteralAttribute ()>]
      val TypeDefOrRefOrSpecMin : int = 120
      val TypeDefOrRefOrSpec : t:Internal.BinaryConstants.TypeDefOrRefTag -> int
      [<LiteralAttribute ()>]
      val TypeDefOrRefOrSpecMax : int = 122
      [<LiteralAttribute ()>]
      val TypeOrMethodDefMin : int = 123
      val TypeOrMethodDef : t:Internal.BinaryConstants.TypeOrMethodDefTag -> int
      [<LiteralAttribute ()>]
      val TypeOrMethodDefMax : int = 124
      [<LiteralAttribute ()>]
      val HasConstantMin : int = 125
      val HasConstant : t:Internal.BinaryConstants.HasConstantTag -> int
      [<LiteralAttribute ()>]
      val HasConstantMax : int = 127
      [<LiteralAttribute ()>]
      val HasCustomAttributeMin : int = 128
      val HasCustomAttribute :
        t:Internal.BinaryConstants.HasCustomAttributeTag -> int
      [<LiteralAttribute ()>]
      val HasCustomAttributeMax : int = 149
      [<LiteralAttribute ()>]
      val HasFieldMarshalMin : int = 150
      val HasFieldMarshal : t:Internal.BinaryConstants.HasFieldMarshalTag -> int
      [<LiteralAttribute ()>]
      val HasFieldMarshalMax : int = 151
      [<LiteralAttribute ()>]
      val HasDeclSecurityMin : int = 152
      val HasDeclSecurity : t:Internal.BinaryConstants.HasDeclSecurityTag -> int
      [<LiteralAttribute ()>]
      val HasDeclSecurityMax : int = 154
      [<LiteralAttribute ()>]
      val MemberRefParentMin : int = 155
      val MemberRefParent : t:Internal.BinaryConstants.MemberRefParentTag -> int
      [<LiteralAttribute ()>]
      val MemberRefParentMax : int = 159
      [<LiteralAttribute ()>]
      val HasSemanticsMin : int = 160
      val HasSemantics : t:Internal.BinaryConstants.HasSemanticsTag -> int
      [<LiteralAttribute ()>]
      val HasSemanticsMax : int = 161
      [<LiteralAttribute ()>]
      val MethodDefOrRefMin : int = 162
      val MethodDefOrRef : t:Internal.BinaryConstants.MethodDefOrRefTag -> int
      [<LiteralAttribute ()>]
      val MethodDefOrRefMax : int = 164
      [<LiteralAttribute ()>]
      val MemberForwardedMin : int = 165
      val MemberForwarded : t:Internal.BinaryConstants.MemberForwardedTag -> int
      [<LiteralAttribute ()>]
      val MemberForwardedMax : int = 166
      [<LiteralAttribute ()>]
      val ImplementationMin : int = 167
      val Implementation : t:Internal.BinaryConstants.ImplementationTag -> int
      [<LiteralAttribute ()>]
      val ImplementationMax : int = 169
      [<LiteralAttribute ()>]
      val CustomAttributeTypeMin : int = 170
      val CustomAttributeType :
        t:Internal.BinaryConstants.CustomAttributeTypeTag -> int
      [<LiteralAttribute ()>]
      val CustomAttributeTypeMax : int = 173
      [<LiteralAttribute ()>]
      val ResolutionScopeMin : int = 174
      val ResolutionScope : t:Internal.BinaryConstants.ResolutionScopeTag -> int
      [<LiteralAttribute ()>]
      val ResolutionScopeMax : int = 178
    end
    [<StructAttribute ()>]
    type RowElement =
      struct
        new : tag:int32 * idx:int32 -> RowElement
        member Tag : int32
        member Val : int32
      end
    val UShort : x:uint16 -> RowElement
    val ULong : x:int32 -> RowElement
    val Data : x:int * k:bool -> RowElement
    val Guid : x:int -> RowElement
    val Blob : x:int -> RowElement
    val StringE : x:int -> RowElement
    val SimpleIndex : t:Internal.BinaryConstants.TableName * x:int -> RowElement
    val TypeDefOrRefOrSpec :
      t:Internal.BinaryConstants.TypeDefOrRefTag * x:int -> RowElement
    val TypeOrMethodDef :
      t:Internal.BinaryConstants.TypeOrMethodDefTag * x:int -> RowElement
    val HasConstant :
      t:Internal.BinaryConstants.HasConstantTag * x:int -> RowElement
    val HasCustomAttribute :
      t:Internal.BinaryConstants.HasCustomAttributeTag * x:int -> RowElement
    val HasFieldMarshal :
      t:Internal.BinaryConstants.HasFieldMarshalTag * x:int -> RowElement
    val HasDeclSecurity :
      t:Internal.BinaryConstants.HasDeclSecurityTag * x:int -> RowElement
    val MemberRefParent :
      t:Internal.BinaryConstants.MemberRefParentTag * x:int -> RowElement
    val HasSemantics :
      t:Internal.BinaryConstants.HasSemanticsTag * x:int -> RowElement
    val MethodDefOrRef :
      t:Internal.BinaryConstants.MethodDefOrRefTag * x:int -> RowElement
    val MemberForwarded :
      t:Internal.BinaryConstants.MemberForwardedTag * x:int -> RowElement
    val Implementation :
      t:Internal.BinaryConstants.ImplementationTag * x:int -> RowElement
    val CustomAttributeType :
      t:Internal.BinaryConstants.CustomAttributeTypeTag * x:int -> RowElement
    val ResolutionScope :
      t:Internal.BinaryConstants.ResolutionScopeTag * x:int -> RowElement
    type BlobIndex = int
    type StringIndex = int
    val BlobIndex : x:BlobIndex -> int
    val StringIndex : x:StringIndex -> int
    val inline combineHash : x2:int -> acc:int -> int
    val hashRow : elems:RowElement [] -> int
    val equalRows : elems:RowElement [] -> elems2:RowElement [] -> bool
    type GenericRow = RowElement []
    [<StructAttribute (); CustomEqualityAttribute (); NoComparisonAttribute ()>]
    type SharedRow =
      struct
        new : elems:RowElement [] * hashCode:int -> SharedRow
        override Equals : obj:obj -> bool
        override GetHashCode : unit -> int
        member GenericRow : RowElement []
      end
    val SharedRow : elems:RowElement [] -> SharedRow
    val AssemblyRefRow :
      s1:uint16 * s2:uint16 * s3:uint16 * s4:uint16 * l1:int32 * b1:int *
      nameIdx:int * str2:int * b2:int -> SharedRow
    val MemberRefRow :
      mrp:RowElement * nmIdx:StringIndex * blobIdx:BlobIndex -> SharedRow
    [<StructAttribute (); CustomEqualityAttribute (); NoComparisonAttribute ()>]
    type UnsharedRow =
      struct
        new : elems:RowElement [] -> UnsharedRow
        override Equals : obj:obj -> bool
        override GetHashCode : unit -> int
        member GenericRow : RowElement []
      end
    type ILTypeWriterEnv =
      { EnclosingTyparCount: int }
    val envForTypeDef : td:IL.ILTypeDef -> ILTypeWriterEnv
    val envForMethodRef : env:ILTypeWriterEnv -> ty:IL.ILType -> ILTypeWriterEnv
    val envForNonGenericMethodRef : _mref:'a -> ILTypeWriterEnv
    val envForFieldSpec : fspec:IL.ILFieldSpec -> ILTypeWriterEnv
    val envForOverrideSpec : ospec:IL.ILOverridesSpec -> ILTypeWriterEnv
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type MetadataTable<'T> =
      { name: string
        dict: System.Collections.Generic.Dictionary<'T,int>
        mutable lookups: int
        mutable rows: ResizeArray<'T> }
      with
        static member
          New : nm:string *
                hashEq:System.Collections.Generic.IEqualityComparer<'a> ->
                  MetadataTable<'a>
        member AddSharedEntry : x:'T -> int
        member
          AddUniqueEntry : nm:string -> getter:('T -> string) -> x:'T -> int
        member AddUnsharedEntry : x:'T -> int
        member FindOrAddSharedEntry : x:'T -> int
        member GetTableEntry : x:'T -> int
        member SetRowsOfTable : t:'T [] -> unit
        member Count : int
        member Entries : 'T list
        member EntriesAsArray : 'T []
      end
    type MethodDefKey =
      class
        new : ilg:IL.ILGlobals * tidx:int * garity:int * nm:string *
              rty:IL.ILType * argtys:IL.ILTypes * isStatic:bool -> MethodDefKey
        override Equals : obj:obj -> bool
        override GetHashCode : unit -> int
        member ArgTypes : IL.ILTypes
        member GenericArity : int
        member IsStatic : bool
        member Name : string
        member ReturnType : IL.ILType
        member TypeIdx : int
      end
    type FieldDefKey =
      class
        new : tidx:int * nm:string * ty:IL.ILType -> FieldDefKey
        override Equals : obj:obj -> bool
        override GetHashCode : unit -> int
        member Name : string
        member Type : IL.ILType
        member TypeIdx : int
      end
    type PropertyTableKey = | PropKey of int * string * IL.ILType * IL.ILTypes
    type EventTableKey = | EventKey of int * string
    type TypeDefTableKey = | TdKey of string list * string
    [<NoComparisonAttribute (); NoEqualityAttribute ();
      RequireQualifiedAccessAttribute ()>]
    type MetadataTable =
      | Shared of MetadataTable<SharedRow>
      | Unshared of MetadataTable<UnsharedRow>
      with
        member AddSharedEntry : x:SharedRow -> int
        member AddUnsharedEntry : x:UnsharedRow -> int
        member FindOrAddSharedEntry : x:SharedRow -> int
        member SetRowsOfSharedTable : rows:RowElement [] [] -> unit
        member Count : int
        member GenericRowsOfTable : RowElement [] []
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type cenv =
      { ilg: IL.ILGlobals
        emitTailcalls: bool
        deterministic: bool
        showTimes: bool
        desiredMetadataVersion: IL.ILVersionInfo
        requiredDataFixups: (int32 * (int * bool)) list ref
        mutable requiredStringFixups: (int32 * (int * int) list) list
        codeChunks: Internal.ByteBuffer
        mutable nextCodeAddr: int32
        mutable moduleGuid: byte []
        generatePdb: bool
        pdbinfo: ResizeArray<ILPdbWriter.PdbMethodData>
        documents: MetadataTable<ILPdbWriter.PdbDocumentData>
        data: Internal.ByteBuffer
        resources: Internal.ByteBuffer
        mutable entrypoint: (bool * int) option
        trefCache: System.Collections.Generic.Dictionary<IL.ILTypeRef,int>
        tables: MetadataTable []
        AssemblyRefs: MetadataTable<SharedRow>
        fieldDefs: MetadataTable<FieldDefKey>
        methodDefIdxsByKey: MetadataTable<MethodDefKey>
        methodDefIdxs: System.Collections.Generic.Dictionary<IL.ILMethodDef,int>
        propertyDefs: MetadataTable<PropertyTableKey>
        eventDefs: MetadataTable<EventTableKey>
        typeDefs: MetadataTable<TypeDefTableKey>
        guids: MetadataTable<byte []>
        blobs: MetadataTable<byte []>
        strings: MetadataTable<string>
        userStrings: MetadataTable<string>
        normalizeAssemblyRefs: IL.ILAssemblyRef -> IL.ILAssemblyRef }
      with
        member AddCode : (int32 * (int * int) list) * code:byte [] -> unit
        member GetCode : unit -> byte []
        member
          GetTable : tab:Internal.BinaryConstants.TableName -> MetadataTable
        override ToString : unit -> string
      end
    val FindOrAddSharedRow :
      cenv:cenv -> tbl:Internal.BinaryConstants.TableName -> x:SharedRow -> int
    val AddSharedRow :
      cenv:cenv -> tbl:Internal.BinaryConstants.TableName -> x:SharedRow -> int
    val AddUnsharedRow :
      cenv:cenv ->
        tbl:Internal.BinaryConstants.TableName -> x:UnsharedRow -> int
    val metadataSchemaVersionSupportedByCLRVersion :
      v:IL.ILVersionInfo -> int * int
    val headerVersionSupportedByCLRVersion : v:IL.ILVersionInfo -> int * int
    val peOptionalHeaderByteByCLRVersion : v:IL.ILVersionInfo -> int
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type ILTokenMappings =
      { TypeDefTokenMap: IL.ILTypeDef list * IL.ILTypeDef -> int32
        FieldDefTokenMap:
          IL.ILTypeDef list * IL.ILTypeDef -> IL.ILFieldDef -> int32
        MethodDefTokenMap:
          IL.ILTypeDef list * IL.ILTypeDef -> IL.ILMethodDef -> int32
        PropertyTokenMap:
          IL.ILTypeDef list * IL.ILTypeDef -> IL.ILPropertyDef -> int32
        EventTokenMap:
          IL.ILTypeDef list * IL.ILTypeDef -> IL.ILEventDef -> int32 }
    val recordRequiredDataFixup :
      requiredDataFixups:('a * 'b) list ref ->
        buf:Internal.ByteBuffer -> pos:'a -> lab:'b -> unit
    val GetUserStringHeapIdx : cenv:cenv -> s:string -> int
    val GetBytesAsBlobIdx : cenv:cenv -> bytes:byte [] -> int
    val GetStringHeapIdx : cenv:cenv -> s:string -> int
    val GetGuidIdx : cenv:cenv -> info:byte [] -> int
    val GetStringHeapIdxOption : cenv:cenv -> sopt:string option -> int
    val GetTypeNameAsElemPair : cenv:cenv -> n:string -> RowElement * RowElement
    val GenTypeDefPass1 :
      enc:string list -> cenv:cenv -> td:IL.ILTypeDef -> unit
    val GenTypeDefsPass1 :
      enc:string list -> cenv:cenv -> tds:IL.ILTypeDef list -> unit
    val GetIdxForTypeDef : cenv:cenv -> key:TypeDefTableKey -> int
    val GetAssemblyRefAsRow : cenv:cenv -> aref:IL.ILAssemblyRef -> SharedRow
    val GetAssemblyRefAsIdx : cenv:cenv -> aref:IL.ILAssemblyRef -> int
    val GetModuleRefAsRow : cenv:cenv -> mref:IL.ILModuleRef -> SharedRow
    val GetModuleRefAsFileRow : cenv:cenv -> mref:IL.ILModuleRef -> SharedRow
    val GetModuleRefAsIdx : cenv:cenv -> mref:IL.ILModuleRef -> int
    val GetModuleRefAsFileIdx : cenv:cenv -> mref:IL.ILModuleRef -> int
    val isScopeRefLocal : scoref:IL.ILScopeRef -> bool
    val isTypeRefLocal : tref:IL.ILTypeRef -> bool
    val isTypeLocal : ty:IL.ILType -> bool
    val GetScopeRefAsImplementationElem :
      cenv:cenv ->
        scoref:IL.ILScopeRef -> Internal.BinaryConstants.ImplementationTag * int
    val GetTypeRefAsTypeRefRow : cenv:cenv -> tref:IL.ILTypeRef -> SharedRow
    val GetTypeRefAsTypeRefIdx : cenv:cenv -> tref:IL.ILTypeRef -> int
    val GetTypeDescAsTypeRefIdx :
      cenv:cenv -> scoref:IL.ILScopeRef * enc:string list * n:string -> int
    val GetResolutionScopeAsElem :
      cenv:cenv ->
        scoref:IL.ILScopeRef * enc:string list ->
          Internal.BinaryConstants.ResolutionScopeTag * int
    val emitTypeInfoAsTypeDefOrRefEncoded :
      cenv:cenv ->
        bb:Internal.ByteBuffer ->
          scoref:IL.ILScopeRef * enc:string list * nm:string -> unit
    val getTypeDefOrRefAsUncodedToken :
      tag:Internal.BinaryConstants.TypeDefOrRefTag * idx:int -> int
    val EmitArrayShape : bb:Internal.ByteBuffer -> IL.ILArrayShape -> unit
    val hasthisToByte : hasthis:IL.ILThisConvention -> byte
    val callconvToByte : ntypars:int -> IL.ILCallingConv -> byte
    val EmitTypeSpec :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          bb:Internal.ByteBuffer -> et:byte * tspec:IL.ILTypeSpec -> unit
    val GetTypeAsTypeDefOrRef :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          ty:IL.ILType -> Internal.BinaryConstants.TypeDefOrRefTag * int
    val GetTypeAsBytes :
      cenv:cenv -> env:ILTypeWriterEnv -> ty:IL.ILType -> byte []
    val GetTypeOfLocalAsBytes :
      cenv:cenv -> env:ILTypeWriterEnv -> l:IL.ILLocal -> byte []
    val GetTypeAsBlobIdx :
      cenv:cenv -> env:ILTypeWriterEnv -> ty:IL.ILType -> int
    val GetTypeAsTypeSpecRow :
      cenv:cenv -> env:ILTypeWriterEnv -> ty:IL.ILType -> SharedRow
    val GetTypeAsTypeSpecIdx :
      cenv:cenv -> env:ILTypeWriterEnv -> ty:IL.ILType -> int
    val EmitType :
      cenv:cenv ->
        env:ILTypeWriterEnv -> bb:Internal.ByteBuffer -> ty:IL.ILType -> unit
    val EmitLocalInfo :
      cenv:cenv ->
        env:ILTypeWriterEnv -> bb:Internal.ByteBuffer -> l:IL.ILLocal -> unit
    val EmitCallsig :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          bb:Internal.ByteBuffer ->
            callconv:IL.ILCallingConv * args:IL.ILTypes * ret:IL.ILType *
            varargs:IL.ILVarArgs * genarity:int -> unit
    val GetCallsigAsBytes :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          IL.ILCallingConv * IL.ILTypes * IL.ILType * IL.ILVarArgs * int ->
            byte []
    val EmitTypes :
      cenv:cenv ->
        env:ILTypeWriterEnv -> bb:Internal.ByteBuffer -> inst:IL.ILTypes -> unit
    val GetTypeAsMemberRefParent :
      cenv:cenv -> env:ILTypeWriterEnv -> ty:IL.ILType -> RowElement
    val GetVariantTypeAsInt32 : ty:IL.ILNativeVariant -> int32
    val GetNativeTypeAsBlobIdx : cenv:cenv -> ty:IL.ILNativeType -> int
    val GetNativeTypeAsBytes : ty:IL.ILNativeType -> byte []
    val EmitNativeType : bb:Internal.ByteBuffer -> ty:IL.ILNativeType -> unit
    val GetFieldInitAsBlobIdx : cenv:cenv -> x:IL.ILFieldInit -> int
    val GetFieldInit : bb:Internal.ByteBuffer -> x:IL.ILFieldInit -> unit
    val GetFieldInitFlags : i:IL.ILFieldInit -> RowElement
    val GetMemberAccessFlags : access:IL.ILMemberAccess -> int
    val GetTypeAccessFlags : access:IL.ILTypeDefAccess -> int
    val GetTypeDefAsRow :
      cenv:cenv ->
        env:ILTypeWriterEnv -> _enc:'a -> td:IL.ILTypeDef -> UnsharedRow
    val GetTypeOptionAsTypeDefOrRef :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          tyOpt:IL.ILType option ->
            Internal.BinaryConstants.TypeDefOrRefTag * int
    val GetTypeDefAsPropertyMapRow : cenv:cenv -> tidx:int -> UnsharedRow
    val GetTypeDefAsEventMapRow : cenv:cenv -> tidx:int -> UnsharedRow
    val GetKeyForFieldDef : tidx:int -> fd:IL.ILFieldDef -> FieldDefKey
    val GenFieldDefPass2 : cenv:cenv -> tidx:int -> fd:IL.ILFieldDef -> unit
    val GetKeyForMethodDef :
      cenv:cenv -> tidx:int -> md:IL.ILMethodDef -> MethodDefKey
    val GenMethodDefPass2 : cenv:cenv -> tidx:int -> md:IL.ILMethodDef -> unit
    val GetKeyForPropertyDef :
      tidx:int -> x:IL.ILPropertyDef -> PropertyTableKey
    val GenPropertyDefPass2 :
      cenv:cenv -> tidx:int -> x:IL.ILPropertyDef -> unit
    val GetTypeAsImplementsRow :
      cenv:cenv ->
        env:ILTypeWriterEnv -> tidx:int -> ty:IL.ILType -> UnsharedRow
    val GenImplementsPass2 :
      cenv:cenv -> env:ILTypeWriterEnv -> tidx:int -> ty:IL.ILType -> unit
    val GetKeyForEvent : tidx:int -> x:IL.ILEventDef -> EventTableKey
    val GenEventDefPass2 : cenv:cenv -> tidx:int -> x:IL.ILEventDef -> unit
    val GenTypeDefPass2 :
      pidx:int -> enc:string list -> cenv:cenv -> td:IL.ILTypeDef -> unit
    val GenTypeDefsPass2 :
      pidx:int -> enc:string list -> cenv:cenv -> tds:IL.ILTypeDef list -> unit
    exception MethodDefNotFound
    val FindMethodDefIdx : cenv:cenv -> mdkey:MethodDefKey -> int
    val GetMethodDefIdx : cenv:cenv -> md:IL.ILMethodDef -> int
    val FindFieldDefIdx : cenv:cenv -> fdkey:FieldDefKey -> int
    val GetFieldDefAsFieldDefIdx :
      cenv:cenv -> tidx:int -> fd:IL.ILFieldDef -> int
    val GetMethodRefAsMethodDefIdx : cenv:cenv -> mref:IL.ILMethodRef -> int
    val MethodRefInfoAsMemberRefRow :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          fenv:ILTypeWriterEnv ->
            nm:string * ty:IL.ILType * callconv:IL.ILCallingConv *
            args:IL.ILTypes * ret:IL.ILType * varargs:IL.ILVarArgs *
            genarity:int -> SharedRow
    val GetMethodRefInfoAsBlobIdx :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          IL.ILCallingConv * IL.ILTypes * IL.ILType * IL.ILVarArgs * int ->
            BlobIndex
    val GetMethodRefInfoAsMemberRefIdx :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          string * IL.ILType * IL.ILCallingConv * IL.ILTypes * IL.ILType *
          IL.ILVarArgs * int -> int
    val GetMethodRefInfoAsMethodRefOrDef :
      isAlwaysMethodDef:bool ->
        cenv:cenv ->
          env:ILTypeWriterEnv ->
            string * IL.ILType * IL.ILCallingConv * IL.ILType list * IL.ILType *
            IL.ILTypes option * int ->
              Internal.BinaryConstants.MethodDefOrRefTag * int
    val GetMethodSpecInfoAsMethodSpecIdx :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          nm:string * ty:IL.ILType * cc:IL.ILCallingConv * args:IL.ILType list *
          ret:IL.ILType * varargs:IL.ILTypes option * minst:IL.ILGenericArgs ->
            int
    val GetMethodDefOrRefAsUncodedToken :
      tag:Internal.BinaryConstants.MethodDefOrRefTag * idx:int -> int
    val GetMethodSpecInfoAsUncodedToken :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          string * IL.ILType * IL.ILCallingConv * IL.ILType list * IL.ILType *
          IL.ILTypes option * IL.ILGenericArgs -> int
    val GetMethodSpecAsUncodedToken :
      cenv:cenv ->
        env:ILTypeWriterEnv -> IL.ILMethodSpec * IL.ILTypes option -> int
    val GetMethodRefInfoOfMethodSpecInfo :
      nm:string * ty:IL.ILType * cc:IL.ILCallingConv * args:IL.ILType list *
      ret:IL.ILType * varargs:IL.ILTypes option * minst:IL.ILGenericArgs ->
        string * IL.ILType * IL.ILCallingConv * IL.ILType list * IL.ILType *
        IL.ILTypes option * int
    val GetMethodSpecAsMethodDefOrRef :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          mspec:IL.ILMethodSpec * varargs:IL.ILTypes option ->
            Internal.BinaryConstants.MethodDefOrRefTag * int
    val GetMethodSpecAsMethodDef :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          mspec:IL.ILMethodSpec * varargs:IL.ILTypes option ->
            Internal.BinaryConstants.MethodDefOrRefTag * int
    val InfoOfMethodSpec :
      mspec:IL.ILMethodSpec * varargs:IL.ILTypes option ->
        string * IL.ILType * IL.ILCallingConv * IL.ILType list * IL.ILType *
        IL.ILTypes option * IL.ILGenericArgs
    val GetOverridesSpecAsMemberRefIdx :
      cenv:cenv -> env:ILTypeWriterEnv -> ospec:IL.ILOverridesSpec -> int
    val GetOverridesSpecAsMethodDefOrRef :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          ospec:IL.ILOverridesSpec ->
            Internal.BinaryConstants.MethodDefOrRefTag * int
    val GetMethodRefAsMemberRefIdx :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          fenv:ILTypeWriterEnv -> mref:IL.ILMethodRef -> int
    val GetMethodRefAsCustomAttribType :
      cenv:cenv ->
        mref:IL.ILMethodRef ->
          Internal.BinaryConstants.CustomAttributeTypeTag * int
    val GetCustomAttrDataAsBlobIdx : cenv:cenv -> data:byte [] -> int
    val GetCustomAttrRow :
      cenv:cenv ->
        Internal.BinaryConstants.HasCustomAttributeTag * int ->
          attr:IL.ILAttribute -> UnsharedRow
    val GenCustomAttrPass3Or4 :
      cenv:cenv ->
        Internal.BinaryConstants.HasCustomAttributeTag * int ->
          attr:IL.ILAttribute -> unit
    val GenCustomAttrsPass3Or4 :
      cenv:cenv ->
        Internal.BinaryConstants.HasCustomAttributeTag * int ->
          attrs:IL.ILAttributes -> unit
    val GetSecurityDeclRow :
      cenv:cenv ->
        Internal.BinaryConstants.HasDeclSecurityTag * int ->
          IL.ILSecurityDecl -> UnsharedRow
    val GenSecurityDeclPass3 :
      cenv:cenv ->
        Internal.BinaryConstants.HasDeclSecurityTag * int ->
          attr:IL.ILSecurityDecl -> unit
    val GenSecurityDeclsPass3 :
      cenv:cenv ->
        Internal.BinaryConstants.HasDeclSecurityTag * int ->
          attrs:IL.ILSecurityDecl list -> unit
    val GetFieldSpecAsMemberRefRow :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          fenv:ILTypeWriterEnv -> fspec:IL.ILFieldSpec -> SharedRow
    val GetFieldSpecAsMemberRefIdx :
      cenv:cenv -> env:ILTypeWriterEnv -> fspec:IL.ILFieldSpec -> int
    val EmitFieldSpecSig :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          bb:Internal.ByteBuffer -> fspec:IL.ILFieldSpec -> unit
    val GetFieldSpecSigAsBytes :
      cenv:cenv -> env:ILTypeWriterEnv -> x:IL.ILFieldSpec -> byte []
    val GetFieldSpecSigAsBlobIdx :
      cenv:cenv -> env:ILTypeWriterEnv -> x:IL.ILFieldSpec -> BlobIndex
    val GetFieldSpecAsFieldDefOrRef :
      cenv:cenv -> env:ILTypeWriterEnv -> fspec:IL.ILFieldSpec -> bool * int
    val GetFieldDefOrRefAsUncodedToken : tag:bool * idx:int -> int
    val GetCallsigAsBlobIdx :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          callsig:IL.ILCallingSignature * varargs:IL.ILVarArgs -> int
    val GetCallsigAsStandAloneSigRow :
      cenv:cenv ->
        env:ILTypeWriterEnv -> IL.ILCallingSignature * IL.ILVarArgs -> SharedRow
    val GetCallsigAsStandAloneSigIdx :
      cenv:cenv ->
        env:ILTypeWriterEnv -> IL.ILCallingSignature * IL.ILVarArgs -> int
    val EmitLocalSig :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          bb:Internal.ByteBuffer -> locals:IL.ILLocals -> unit
    val GetLocalSigAsBlobHeapIdx :
      cenv:cenv -> env:ILTypeWriterEnv -> locals:IL.ILLocals -> int
    val GetLocalSigAsStandAloneSigIdx :
      cenv:cenv -> env:ILTypeWriterEnv -> locals:IL.ILLocals -> SharedRow
    type ExceptionClauseKind =
      | FinallyClause
      | FaultClause
      | TypeFilterClause of int32
      | FilterClause of int
    type ExceptionClauseSpec = int * int * int * int * ExceptionClauseKind
    type CodeBuffer =
      { code: Internal.ByteBuffer
        mutable reqdBrFixups:
          ((int * int option) * int * IL.ILCodeLabel list) list
        availBrFixups: System.Collections.Generic.Dictionary<IL.ILCodeLabel,int>
        mutable reqdStringFixupsInMethod: (int * int) list
        mutable seh: ExceptionClauseSpec list
        seqpoints: ResizeArray<ILPdbWriter.PdbSequencePoint> }
      with
        static member Create : _nm:'a -> CodeBuffer
        member EmitByte : x:int -> unit
        member EmitExceptionClause : seh:ExceptionClauseSpec -> unit
        member EmitInt32 : x:int32 -> unit
        member EmitInt64 : x:int64 -> unit
        member EmitSeqPoint : cenv:cenv -> m:IL.ILSourceMarker -> unit
        member EmitUInt16 : x:uint16 -> unit
        member EmitUncodedToken : u:int32 -> unit
        member RecordAvailBrFixup : tg:IL.ILCodeLabel -> unit
        member
          RecordReqdBrFixup : i:(int * int option) -> tg:IL.ILCodeLabel -> unit
        member
          RecordReqdBrFixups : i:(int * int option) ->
                                 tgs:IL.ILCodeLabel list -> unit
        member RecordReqdStringFixup : stringIdx:int -> unit
      end
    module Codebuf = begin
      val binaryChop : p:('T -> int) -> arr:'T [] -> int
      val applyBrFixups :
        origCode:byte [] ->
          origExnClauses:(int * int * int * int * ExceptionClauseKind) list ->
            origReqdStringFixups:(int * 'a) list ->
              origAvailBrFixups:System.Collections.Generic.Dictionary<IL.ILCodeLabel,
                                                                      int> ->
                origReqdBrFixups:((int * int option) * int * IL.ILCodeLabel list) list ->
                  origSeqPoints:ILPdbWriter.PdbSequencePoint [] ->
                    origScopes:ILPdbWriter.PdbMethodScope list ->
                      byte [] * (int * 'a) list *
                      (int * int * int * int * ExceptionClauseKind) list *
                      ILPdbWriter.PdbSequencePoint [] *
                      ILPdbWriter.PdbMethodScope list
      type SEHTree = | Node of ExceptionClauseSpec option * SEHTree list
      val encodingsForNoArgInstrs :
        System.Collections.Generic.Dictionary<IL.ILInstr,int>
      val encodingsOfNoArgInstr : si:IL.ILInstr -> int
      val emitInstrCode : codebuf:CodeBuffer -> i:int -> unit
      val emitTypeInstr :
        cenv:cenv ->
          codebuf:CodeBuffer ->
            env:ILTypeWriterEnv -> i:int -> ty:IL.ILType -> unit
      val emitMethodSpecInfoInstr :
        cenv:cenv ->
          codebuf:CodeBuffer ->
            env:ILTypeWriterEnv ->
              i:int ->
                string * IL.ILType * IL.ILCallingConv * IL.ILType list *
                IL.ILType * IL.ILTypes option * IL.ILGenericArgs -> unit
      val emitMethodSpecInstr :
        cenv:cenv ->
          codebuf:CodeBuffer ->
            env:ILTypeWriterEnv ->
              i:int -> IL.ILMethodSpec * IL.ILTypes option -> unit
      val emitFieldSpecInstr :
        cenv:cenv ->
          codebuf:CodeBuffer ->
            env:ILTypeWriterEnv -> i:int -> fspec:IL.ILFieldSpec -> unit
      val emitShortUInt16Instr :
        codebuf:CodeBuffer -> i_short:int * i:int -> x:uint16 -> unit
      val emitShortInt32Instr :
        codebuf:CodeBuffer -> i_short:int * i:int -> x:int -> unit
      val emitTailness :
        cenv:cenv -> codebuf:CodeBuffer -> tl:IL.ILTailcall -> unit
      val emitVolatility : codebuf:CodeBuffer -> tl:IL.ILVolatility -> unit
      val emitConstrained :
        cenv:cenv ->
          codebuf:CodeBuffer -> env:ILTypeWriterEnv -> ty:IL.ILType -> unit
      val emitAlignment : codebuf:CodeBuffer -> tl:IL.ILAlignment -> unit
      val emitInstr :
        cenv:cenv ->
          codebuf:CodeBuffer -> env:ILTypeWriterEnv -> instr:IL.ILInstr -> unit
      val mkScopeNode :
        cenv:cenv ->
          localSigs:byte [] [] ->
            startOffset:int * endOffset:int * ls:IL.ILLocalDebugMapping list *
            childScopes:ILPdbWriter.PdbMethodScope list ->
              ILPdbWriter.PdbMethodScope list
      val rangeInsideRange :
        start_pc1:int * end_pc1:int -> start_pc2:int * end_pc2:int -> bool
      val lranges_of_clause :
        cl:IL.ILExceptionClause -> (IL.ILCodeLabel * IL.ILCodeLabel) list
      val labelsToRange :
        lab2pc:System.Collections.Generic.Dictionary<IL.ILCodeLabel,int> ->
          IL.ILCodeLabel * IL.ILCodeLabel -> int * int
      val labelRangeInsideLabelRange :
        lab2pc:System.Collections.Generic.Dictionary<IL.ILCodeLabel,int> ->
          IL.ILCodeLabel * IL.ILCodeLabel ->
            IL.ILCodeLabel * IL.ILCodeLabel -> bool
      val findRoots :
        contains:('a -> 'a -> bool) -> vs:'a list -> ('a * 'a list) list
      val makeSEHTree :
        cenv:cenv ->
          env:ILTypeWriterEnv ->
            pc2pos:int [] ->
              lab2pc:System.Collections.Generic.Dictionary<IL.ILCodeLabel,int> ->
                exs:IL.ILExceptionSpec list -> SEHTree list
      val makeLocalsTree :
        cenv:cenv ->
          localSigs:byte [] [] ->
            pc2pos:int [] ->
              lab2pc:System.Collections.Generic.Dictionary<IL.ILCodeLabel,int> ->
                exs:IL.ILLocalDebugInfo list -> ILPdbWriter.PdbMethodScope list
      val emitExceptionHandlerTree : codebuf:CodeBuffer -> SEHTree -> unit
      val emitCode :
        cenv:cenv ->
          localSigs:byte [] [] ->
            codebuf:CodeBuffer ->
              env:ILTypeWriterEnv ->
                code:IL.ILCode -> ILPdbWriter.PdbMethodScope list
      val EmitTopCode :
        cenv:cenv ->
          localSigs:byte [] [] ->
            env:ILTypeWriterEnv ->
              nm:'a ->
                code:IL.ILCode ->
                  (int * int) list *
                  (int * int * int * int * ExceptionClauseKind) list * byte [] *
                  ILPdbWriter.PdbSequencePoint [] * ILPdbWriter.PdbMethodScope
    end
    val GetFieldDefTypeAsBlobIdx :
      cenv:cenv -> env:ILTypeWriterEnv -> ty:IL.ILType -> int
    val GenILMethodBody :
      mname:'a ->
        cenv:cenv ->
          env:ILTypeWriterEnv ->
            il:IL.ILMethodBody ->
              int * ((int * (int * int) list) * byte []) *
              ILPdbWriter.PdbSequencePoint [] * ILPdbWriter.PdbMethodScope
    val GetFieldDefAsFieldDefRow :
      cenv:cenv -> env:ILTypeWriterEnv -> fd:IL.ILFieldDef -> UnsharedRow
    val GetFieldDefSigAsBlobIdx :
      cenv:cenv -> env:ILTypeWriterEnv -> fd:IL.ILFieldDef -> int
    val GenFieldDefPass3 :
      cenv:cenv -> env:ILTypeWriterEnv -> fd:IL.ILFieldDef -> unit
    val GetGenericParamAsGenericParamRow :
      cenv:cenv ->
        _env:'a ->
          idx:int ->
            Internal.BinaryConstants.TypeOrMethodDefTag * int ->
              gp:IL.ILGenericParameterDef -> SharedRow
    val GenTypeAsGenericParamConstraintRow :
      cenv:cenv ->
        env:ILTypeWriterEnv -> gpidx:int -> ty:IL.ILType -> UnsharedRow
    val GenGenericParamConstraintPass4 :
      cenv:cenv -> env:ILTypeWriterEnv -> gpidx:int -> ty:IL.ILType -> unit
    val GenGenericParamPass3 :
      cenv:cenv ->
        env:'a ->
          idx:int ->
            Internal.BinaryConstants.TypeOrMethodDefTag * int ->
              gp:IL.ILGenericParameterDef -> unit
    val GenGenericParamPass4 :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          idx:int ->
            Internal.BinaryConstants.TypeOrMethodDefTag * int ->
              gp:IL.ILGenericParameterDef -> unit
    val GetParamAsParamRow :
      cenv:cenv -> _env:'a -> seq:int -> param:IL.ILParameter -> UnsharedRow
    val GenParamPass3 :
      cenv:cenv -> env:'a -> seq:int -> param:IL.ILParameter -> unit
    val GenReturnAsParamRow : returnv:IL.ILReturn -> UnsharedRow
    val GenReturnPass3 : cenv:cenv -> returnv:IL.ILReturn -> unit
    val GetMethodDefSigAsBytes :
      cenv:cenv -> env:ILTypeWriterEnv -> mdef:IL.ILMethodDef -> byte []
    val GenMethodDefSigAsBlobIdx :
      cenv:cenv -> env:ILTypeWriterEnv -> mdef:IL.ILMethodDef -> int
    val GenMethodDefAsRow :
      cenv:cenv ->
        env:ILTypeWriterEnv -> midx:int -> md:IL.ILMethodDef -> UnsharedRow
    val GenMethodImplPass3 :
      cenv:cenv ->
        env:ILTypeWriterEnv ->
          _tgparams:'a -> tidx:int -> mimpl:IL.ILMethodImplDef -> unit
    val GenMethodDefPass3 :
      cenv:cenv -> env:ILTypeWriterEnv -> md:IL.ILMethodDef -> unit
    val GenMethodDefPass4 :
      cenv:cenv -> env:ILTypeWriterEnv -> md:IL.ILMethodDef -> unit
    val GenPropertyMethodSemanticsPass3 :
      cenv:cenv -> pidx:int -> kind:int -> mref:IL.ILMethodRef -> unit
    val GetPropertySigAsBlobIdx :
      cenv:cenv -> env:ILTypeWriterEnv -> prop:IL.ILPropertyDef -> int
    val GetPropertySigAsBytes :
      cenv:cenv -> env:ILTypeWriterEnv -> prop:IL.ILPropertyDef -> byte []
    val GetPropertyAsPropertyRow :
      cenv:cenv -> env:ILTypeWriterEnv -> prop:IL.ILPropertyDef -> UnsharedRow
    val GenPropertyPass3 :
      cenv:cenv -> env:ILTypeWriterEnv -> prop:IL.ILPropertyDef -> unit
    val GenEventMethodSemanticsPass3 :
      cenv:cenv -> eidx:int -> kind:int -> mref:IL.ILMethodRef -> unit
    val GenEventAsEventRow :
      cenv:cenv -> env:ILTypeWriterEnv -> md:IL.ILEventDef -> UnsharedRow
    val GenEventPass3 :
      cenv:cenv -> env:ILTypeWriterEnv -> md:IL.ILEventDef -> unit
    val GetResourceAsManifestResourceRow :
      cenv:cenv -> r:IL.ILResource -> UnsharedRow
    val GenResourcePass3 : cenv:cenv -> r:IL.ILResource -> unit
    val GenTypeDefPass3 :
      enc:string list -> cenv:cenv -> td:IL.ILTypeDef -> unit
    val GenTypeDefsPass3 :
      enc:string list -> cenv:cenv -> tds:IL.ILTypeDef list -> unit
    val GenTypeDefPass4 :
      enc:string list -> cenv:cenv -> td:IL.ILTypeDef -> unit
    val GenTypeDefsPass4 :
      enc:string list -> cenv:cenv -> tds:IL.ILTypeDef list -> unit
    val timestamp : int32
    val GenNestedExportedTypePass3 :
      cenv:cenv -> cidx:int -> ce:IL.ILNestedExportedType -> unit
    val GenNestedExportedTypesPass3 :
      cenv:cenv -> nidx:int -> nce:IL.ILNestedExportedTypes -> unit
    val GenExportedTypePass3 :
      cenv:cenv -> ce:IL.ILExportedTypeOrForwarder -> unit
    val GenExportedTypesPass3 :
      cenv:cenv -> ce:IL.ILExportedTypesAndForwarders -> unit
    val GetManifestAsAssemblyRow :
      cenv:cenv -> m:IL.ILAssemblyManifest -> UnsharedRow
    val GenManifestPass3 : cenv:cenv -> m:IL.ILAssemblyManifest -> unit
    val newGuid : modul:IL.ILModuleDef -> byte []
    val deterministicGuid : modul:IL.ILModuleDef -> byte []
    val GetModuleAsRow : cenv:cenv -> modul:IL.ILModuleDef -> UnsharedRow
    val rowElemCompare : e1:RowElement -> e2:RowElement -> int
    val TableRequiresSorting : tab:Internal.BinaryConstants.TableName -> bool
    val SortTableRows :
      tab:Internal.BinaryConstants.TableName ->
        rows:GenericRow [] -> GenericRow []
    val GenModule : cenv:cenv -> modul:IL.ILModuleDef -> unit
    val generateIL :
      requiredDataFixups:(int32 * (int * bool)) list ref ->
        desiredMetadataVersion:IL.ILVersionInfo * generatePdb:bool *
        ilg:IL.ILGlobals * emitTailcalls:bool * deterministic:bool *
        showTimes:bool ->
          m:IL.ILModuleDef ->
            cilStartAddress:int32 ->
              normalizeAssemblyRefs:(IL.ILAssemblyRef -> IL.ILAssemblyRef) ->
                byte [] [] * byte [] [] * byte [] [] * byte [] [] *
                MetadataTable [] * int * byte [] *
                (int32 * (int * int) list) list * byte [] * byte [] *
                ILPdbWriter.PdbData * ILTokenMappings
    val chunk : sz:int32 -> next:int32 -> ILPdbWriter.BinaryChunk * int32
    val emptychunk : next:int32 -> ILPdbWriter.BinaryChunk * int32
    val nochunk : next:'a -> ILPdbWriter.BinaryChunk * 'a
    val count : f:('a -> int) -> arr:'a [] -> int
    module FileSystemUtilities = begin
      val progress : bool
      val setExecutablePermission : filename:string -> unit
    end
    val writeILMetadataAndCode :
      generatePdb:bool * desiredMetadataVersion:IL.ILVersionInfo *
      ilg:IL.ILGlobals * emitTailcalls:bool * deterministic:bool *
      showTimes:bool ->
        modul:IL.ILModuleDef ->
          cilStartAddress:int32 ->
            normalizeAssemblyRefs:(IL.ILAssemblyRef -> IL.ILAssemblyRef) ->
              int * byte [] * byte [] * byte [] * byte [] * byte [] *
              (int32 * (int * bool)) list * ILPdbWriter.PdbData *
              ILTokenMappings * int
    val msdosHeader : byte []
    val writeInt64 : os:System.IO.BinaryWriter -> x:int64 -> unit
    val writeInt32 : os:System.IO.BinaryWriter -> x:int -> unit
    val writeInt32AsUInt16 : os:System.IO.BinaryWriter -> x:int -> unit
    val writeDirectory :
      os:System.IO.BinaryWriter -> dict:ILPdbWriter.BinaryChunk -> unit
    val writeBytes : os:System.IO.BinaryWriter -> chunk:byte [] -> unit
    val writeBinaryAndReportMappings :
      outfile:string * ilg:IL.ILGlobals * pdbfile:string option *
      signer:Internal.StrongNameSign.ILStrongNameSigner option *
      portablePDB:bool * embeddedPDB:bool * embedAllSource:bool *
      embedSourceList:string list * sourceLink:string *
      checksumAlgorithm:ILPdbWriter.HashAlgorithm * emitTailcalls:bool *
      deterministic:bool * showTimes:bool * dumpDebugInfo:bool *
      pathMap:Internal.Utilities.PathMap ->
        modul:IL.ILModuleDef ->
          normalizeAssemblyRefs:(IL.ILAssemblyRef -> IL.ILAssemblyRef) ->
            ILTokenMappings
    type options =
      { ilg: IL.ILGlobals
        pdbfile: string option
        portablePDB: bool
        embeddedPDB: bool
        embedAllSource: bool
        embedSourceList: string list
        sourceLink: string
        checksumAlgorithm: ILPdbWriter.HashAlgorithm
        signer: Internal.StrongNameSign.ILStrongNameSigner option
        emitTailcalls: bool
        deterministic: bool
        showTimes: bool
        dumpDebugInfo: bool
        pathMap: Internal.Utilities.PathMap }
    val WriteILBinary :
      filename:string * options:options * inputModule:IL.ILModuleDef *
      (IL.ILAssemblyRef -> IL.ILAssemblyRef) -> unit
  end

namespace FSharp.Compiler.AbstractIL
  module internal ILRuntimeWriter = begin
    val codeLabelOrder : System.Collections.Generic.IComparer<IL.ILCodeLabel>
    val wrapCustomAttr :
      setCustomAttr:('a * 'b -> 'c) -> cinfo:'a * bytes:'b -> 'c
    val logRefEmitCalls : bool
    type AssemblyBuilder with
      member
        DefineDynamicModuleAndLog : a:string * b:'a * c:'b ->
                                      System.Reflection.Emit.ModuleBuilder
    type AssemblyBuilder with
      member
        SetCustomAttributeAndLog : cinfo:System.Reflection.ConstructorInfo *
                                   bytes:byte [] -> unit
    type AssemblyBuilder with
      member
        SetCustomAttributeAndLog : cab:System.Reflection.Emit.CustomAttributeBuilder ->
                                     unit
    type ModuleBuilder with
      member
        GetArrayMethodAndLog : aty:System.Type * nm:string *
                               flags:System.Reflection.CallingConventions *
                               rty:System.Type * tys:System.Type [] ->
                                 System.Reflection.MethodInfo
    type ModuleBuilder with
      member
        GetTypeAndLog : nameInModule:string * flag1:bool * flag2:bool ->
                          System.Type
    type ModuleBuilder with
      member
        DefineTypeAndLog : name:string * attrs:System.Reflection.TypeAttributes ->
                             System.Reflection.Emit.TypeBuilder
    type ModuleBuilder with
      member
        SetCustomAttributeAndLog : cinfo:System.Reflection.ConstructorInfo *
                                   bytes:byte [] -> unit
    type ConstructorBuilder with
      member
        SetImplementationFlagsAndLog : attrs:System.Reflection.MethodImplAttributes ->
                                         unit
    type ConstructorBuilder with
      member
        DefineParameterAndLog : n:int *
                                attr:System.Reflection.ParameterAttributes *
                                nm:string ->
                                  System.Reflection.Emit.ParameterBuilder
    type ConstructorBuilder with
      member GetILGeneratorAndLog : unit -> System.Reflection.Emit.ILGenerator
    type MethodBuilder with
      member
        SetImplementationFlagsAndLog : attrs:System.Reflection.MethodImplAttributes ->
                                         unit
    type MethodBuilder with
      member
        SetSignatureAndLog : returnType:System.Type *
                             returnTypeRequiredCustomModifiers:System.Type [] *
                             returnTypeOptionalCustomModifiers:System.Type [] *
                             parameterTypes:System.Type [] *
                             parameterTypeRequiredCustomModifiers:System.Type [] [] *
                             parameterTypeOptionalCustomModifiers:System.Type [] [] ->
                               unit
    type MethodBuilder with
      member
        DefineParameterAndLog : n:int *
                                attr:System.Reflection.ParameterAttributes *
                                nm:string ->
                                  System.Reflection.Emit.ParameterBuilder
    type MethodBuilder with
      member
        DefineGenericParametersAndLog : gps:string [] ->
                                          System.Reflection.Emit.GenericTypeParameterBuilder []
    type MethodBuilder with
      member GetILGeneratorAndLog : unit -> System.Reflection.Emit.ILGenerator
    type MethodBuilder with
      member
        SetCustomAttributeAndLog : cinfo:System.Reflection.ConstructorInfo *
                                   bytes:byte [] -> unit
    type TypeBuilder with
      member CreateTypeAndLog : unit -> System.Type
    type TypeBuilder with
      member
        DefineNestedTypeAndLog : name:string *
                                 attrs:System.Reflection.TypeAttributes ->
                                   System.Reflection.Emit.TypeBuilder
    type TypeBuilder with
      member
        DefineMethodAndLog : name:string *
                             attrs:System.Reflection.MethodAttributes *
                             cconv:System.Reflection.CallingConventions ->
                               System.Reflection.Emit.MethodBuilder
    type TypeBuilder with
      member
        DefineGenericParametersAndLog : gps:string [] ->
                                          System.Reflection.Emit.GenericTypeParameterBuilder []
    type TypeBuilder with
      member
        DefineConstructorAndLog : attrs:System.Reflection.MethodAttributes *
                                  cconv:System.Reflection.CallingConventions *
                                  parms:System.Type [] ->
                                    System.Reflection.Emit.ConstructorBuilder
    type TypeBuilder with
      member
        DefineFieldAndLog : nm:string * ty:System.Type *
                            attrs:System.Reflection.FieldAttributes ->
                              System.Reflection.Emit.FieldBuilder
    type TypeBuilder with
      member
        DefinePropertyAndLog : nm:string *
                               attrs:System.Reflection.PropertyAttributes *
                               ty:System.Type * args:System.Type [] ->
                                 System.Reflection.Emit.PropertyBuilder
    type TypeBuilder with
      member
        DefineEventAndLog : nm:string * attrs:System.Reflection.EventAttributes *
                            ty:System.Type ->
                              System.Reflection.Emit.EventBuilder
    type TypeBuilder with
      member SetParentAndLog : ty:System.Type -> unit
    type TypeBuilder with
      member AddInterfaceImplementationAndLog : ty:System.Type -> unit
    type TypeBuilder with
      member InvokeMemberAndLog : nm:string * _flags:'a * args:obj [] -> obj
    type TypeBuilder with
      member
        SetCustomAttributeAndLog : cinfo:System.Reflection.ConstructorInfo *
                                   bytes:byte [] -> unit
    type OpCode with
      member RefEmitName : string
    type ILGenerator with
      member
        DeclareLocalAndLog : ty:System.Type * isPinned:bool ->
                               System.Reflection.Emit.LocalBuilder
    type ILGenerator with
      member MarkLabelAndLog : lab:System.Reflection.Emit.Label -> unit
    type ILGenerator with
      member BeginExceptionBlockAndLog : unit -> System.Reflection.Emit.Label
    type ILGenerator with
      member EndExceptionBlockAndLog : unit -> unit
    type ILGenerator with
      member BeginFinallyBlockAndLog : unit -> unit
    type ILGenerator with
      member BeginCatchBlockAndLog : ty:System.Type -> unit
    type ILGenerator with
      member BeginExceptFilterBlockAndLog : unit -> unit
    type ILGenerator with
      member BeginFaultBlockAndLog : unit -> unit
    type ILGenerator with
      member DefineLabelAndLog : unit -> System.Reflection.Emit.Label
    type ILGenerator with
      member EmitAndLog : op:System.Reflection.Emit.OpCode -> unit
    type ILGenerator with
      member
        EmitAndLog : op:System.Reflection.Emit.OpCode *
                     v:System.Reflection.Emit.Label -> unit
    type ILGenerator with
      member EmitAndLog : op:System.Reflection.Emit.OpCode * v:int16 -> unit
    type ILGenerator with
      member EmitAndLog : op:System.Reflection.Emit.OpCode * v:int32 -> unit
    type ILGenerator with
      member
        EmitAndLog : op:System.Reflection.Emit.OpCode *
                     v:System.Reflection.MethodInfo -> unit
    type ILGenerator with
      member EmitAndLog : op:System.Reflection.Emit.OpCode * v:string -> unit
    type ILGenerator with
      member
        EmitAndLog : op:System.Reflection.Emit.OpCode * v:System.Type -> unit
    type ILGenerator with
      member
        EmitAndLog : op:System.Reflection.Emit.OpCode *
                     v:System.Reflection.FieldInfo -> unit
    type ILGenerator with
      member
        EmitAndLog : op:System.Reflection.Emit.OpCode *
                     v:System.Reflection.ConstructorInfo -> unit
    val inline flagsIf : b:bool -> x: ^a ->  ^a when  ^a : enum<int32>
    module Zmap = begin
      val force : x:'a -> m:Internal.Zmap<'a,'b> -> str:string -> 'b
    end
    val equalTypes : s:System.Type -> t:System.Type -> bool
    val equalTypeLists : ss:#System.Type list -> tt:#System.Type list -> bool
    val equalTypeArrays : ss:#System.Type [] -> tt:#System.Type [] -> bool
    val getGenericArgumentsOfType : typT:System.Type -> System.Type []
    val getGenericArgumentsOfMethod :
      methI:System.Reflection.MethodInfo -> System.Type []
    val getTypeConstructor : ty:System.Type -> System.Type
    val convAssemblyRef :
      aref:IL.ILAssemblyRef -> System.Reflection.AssemblyName
    type cenv =
      { ilg: IL.ILGlobals
        tryFindSysILTypeRef: string -> IL.ILTypeRef option
        generatePdb: bool
        resolveAssemblyRef:
          IL.ILAssemblyRef -> Choice<string,System.Reflection.Assembly> option }
      with
        override ToString : unit -> string
      end
    val convResolveAssemblyRef :
      cenv:cenv ->
        asmref:IL.ILAssemblyRef -> qualifiedName:string -> System.Type
    val convTypeRefAux : cenv:cenv -> tref:IL.ILTypeRef -> System.Type
    type emEnv =
      { emTypMap:
          Internal.Zmap<IL.ILTypeRef,
                        (System.Type * System.Reflection.Emit.TypeBuilder *
                         IL.ILTypeDef * System.Type option)>
        emConsMap:
          Internal.Zmap<IL.ILMethodRef,System.Reflection.Emit.ConstructorBuilder>
        emMethMap:
          Internal.Zmap<IL.ILMethodRef,System.Reflection.Emit.MethodBuilder>
        emFieldMap:
          Internal.Zmap<IL.ILFieldRef,System.Reflection.Emit.FieldBuilder>
        emPropMap:
          Internal.Zmap<IL.ILPropertyRef,System.Reflection.Emit.PropertyBuilder>
        emLocals: System.Reflection.Emit.LocalBuilder []
        emLabels: Internal.Zmap<IL.ILCodeLabel,System.Reflection.Emit.Label>
        emTyvars: System.Type [] list
        emEntryPts: (System.Reflection.Emit.TypeBuilder * string) list
        delayedFieldInits: (unit -> unit) list }
    val orderILTypeRef : System.Collections.Generic.IComparer<IL.ILTypeRef>
    val orderILMethodRef : System.Collections.Generic.IComparer<IL.ILMethodRef>
    val orderILFieldRef : System.Collections.Generic.IComparer<IL.ILFieldRef>
    val orderILPropertyRef :
      System.Collections.Generic.IComparer<IL.ILPropertyRef>
    val emEnv0 : emEnv
    val envBindTypeRef :
      emEnv:emEnv ->
        tref:IL.ILTypeRef ->
          typT:System.Type * typB:System.Reflection.Emit.TypeBuilder *
          typeDef:IL.ILTypeDef -> emEnv
    val envUpdateCreatedTypeRef : emEnv:emEnv -> tref:IL.ILTypeRef -> emEnv
    val convTypeRef :
      cenv:cenv ->
        emEnv:emEnv -> preferCreated:bool -> tref:IL.ILTypeRef -> System.Type
    val envBindConsRef :
      emEnv:emEnv ->
        mref:IL.ILMethodRef ->
          consB:System.Reflection.Emit.ConstructorBuilder -> emEnv
    val envGetConsB :
      emEnv:emEnv ->
        mref:IL.ILMethodRef -> System.Reflection.Emit.ConstructorBuilder
    val envBindMethodRef :
      emEnv:emEnv ->
        mref:IL.ILMethodRef ->
          methB:System.Reflection.Emit.MethodBuilder -> emEnv
    val envGetMethB :
      emEnv:emEnv -> mref:IL.ILMethodRef -> System.Reflection.Emit.MethodBuilder
    val envBindFieldRef :
      emEnv:emEnv ->
        fref:IL.ILFieldRef ->
          fieldB:System.Reflection.Emit.FieldBuilder -> emEnv
    val envGetFieldB :
      emEnv:emEnv -> fref:IL.ILFieldRef -> System.Reflection.Emit.FieldBuilder
    val envBindPropRef :
      emEnv:emEnv ->
        pref:IL.ILPropertyRef ->
          propB:System.Reflection.Emit.PropertyBuilder -> emEnv
    val envGetPropB :
      emEnv:emEnv ->
        pref:IL.ILPropertyRef -> System.Reflection.Emit.PropertyBuilder
    val envGetTypB :
      emEnv:emEnv -> tref:IL.ILTypeRef -> System.Reflection.Emit.TypeBuilder
    val envGetTypeDef : emEnv:emEnv -> tref:IL.ILTypeRef -> IL.ILTypeDef
    val envSetLocals :
      emEnv:emEnv -> locs:System.Reflection.Emit.LocalBuilder [] -> emEnv
    val envGetLocal :
      emEnv:emEnv -> i:int -> System.Reflection.Emit.LocalBuilder
    val envSetLabel :
      emEnv:emEnv ->
        name:IL.ILCodeLabel -> lab:System.Reflection.Emit.Label -> emEnv
    val envGetLabel :
      emEnv:emEnv -> name:IL.ILCodeLabel -> System.Reflection.Emit.Label
    val envPushTyvars : emEnv:emEnv -> tys:System.Type [] -> emEnv
    val envPopTyvars : emEnv:emEnv -> emEnv
    val envGetTyvar : emEnv:emEnv -> u16:uint16 -> System.Type
    val isEmittedTypeRef : emEnv:emEnv -> tref:IL.ILTypeRef -> bool
    val envAddEntryPt :
      emEnv:emEnv -> System.Reflection.Emit.TypeBuilder * string -> emEnv
    val envPopEntryPts :
      emEnv:emEnv -> emEnv * (System.Reflection.Emit.TypeBuilder * string) list
    val convCallConv : IL.ILCallingConv -> System.Reflection.CallingConventions
    val convTypeSpec :
      cenv:cenv ->
        emEnv:emEnv -> preferCreated:bool -> tspec:IL.ILTypeSpec -> System.Type
    val convTypeAux :
      cenv:cenv ->
        emEnv:emEnv -> preferCreated:bool -> ty:IL.ILType -> System.Type
    val convType : cenv:cenv -> emEnv:emEnv -> ty:IL.ILType -> System.Type
    val convTypeOrTypeDef :
      cenv:cenv -> emEnv:emEnv -> ty:IL.ILType -> System.Type
    val convTypes :
      cenv:cenv -> emEnv:emEnv -> tys:IL.ILTypes -> System.Type list
    val convTypesToArray :
      cenv:cenv -> emEnv:emEnv -> tys:IL.ILTypes -> System.Type []
    val convCreatedType :
      cenv:cenv -> emEnv:emEnv -> ty:IL.ILType -> System.Type
    val convCreatedTypeRef :
      cenv:cenv -> emEnv:emEnv -> ty:IL.ILTypeRef -> System.Type
    val convParamModifiersOfType :
      cenv:cenv -> emEnv:emEnv -> pty:IL.ILType -> (bool * System.Type) []
    val splitModifiers : mods:(bool * 'a) [] -> 'a [] * 'a []
    val convParamModifiers :
      cenv:cenv ->
        emEnv:emEnv -> p:IL.ILParameter -> System.Type [] * System.Type []
    val convReturnModifiers :
      cenv:cenv ->
        emEnv:emEnv -> p:IL.ILReturn -> System.Type [] * System.Type []
    val TypeBuilderInstantiationT : System.Type
    val typeIsNotQueryable : ty:System.Type -> bool
    val queryableTypeGetField :
      _emEnv:'a ->
        parentT:System.Type -> fref:IL.ILFieldRef -> System.Reflection.FieldInfo
    val nonQueryableTypeGetField :
      parentTI:System.Type ->
        fieldInfo:System.Reflection.FieldInfo -> System.Reflection.FieldInfo
    val convFieldSpec :
      cenv:cenv ->
        emEnv:emEnv -> fspec:IL.ILFieldSpec -> System.Reflection.FieldInfo
    val queryableTypeGetMethodBySearch :
      cenv:cenv ->
        emEnv:emEnv ->
          parentT:System.Type ->
            mref:IL.ILMethodRef -> System.Reflection.MethodInfo
    val queryableTypeGetMethod :
      cenv:cenv ->
        emEnv:emEnv ->
          parentT:System.Type ->
            mref:IL.ILMethodRef -> System.Reflection.MethodInfo
    val nonQueryableTypeGetMethod :
      parentTI:System.Type ->
        methInfo:System.Reflection.MethodInfo -> System.Reflection.MethodInfo
    val convMethodRef :
      cenv:cenv ->
        emEnv:emEnv ->
          parentTI:System.Type ->
            mref:IL.ILMethodRef -> System.Reflection.MethodInfo
    val convMethodSpec :
      cenv:cenv ->
        emEnv:emEnv -> mspec:IL.ILMethodSpec -> System.Reflection.MethodInfo
    val queryableTypeGetConstructor :
      cenv:cenv ->
        emEnv:emEnv ->
          parentT:System.Type ->
            mref:IL.ILMethodRef -> System.Reflection.ConstructorInfo
    val nonQueryableTypeGetConstructor :
      parentTI:System.Type ->
        consInfo:System.Reflection.ConstructorInfo ->
          System.Reflection.ConstructorInfo
    val convConstructorSpec :
      cenv:cenv ->
        emEnv:emEnv ->
          mspec:IL.ILMethodSpec -> System.Reflection.ConstructorInfo
    val emitLabelMark :
      emEnv:emEnv ->
        ilG:System.Reflection.Emit.ILGenerator -> label:IL.ILCodeLabel -> unit
    val emitInstrCompare :
      emEnv:emEnv ->
        ilG:System.Reflection.Emit.ILGenerator ->
          comp:IL.ILComparisonInstr -> targ:IL.ILCodeLabel -> unit
    val emitInstrVolatile :
      ilG:System.Reflection.Emit.ILGenerator -> _arg1:IL.ILVolatility -> unit
    val emitInstrAlign :
      ilG:System.Reflection.Emit.ILGenerator -> _arg1:IL.ILAlignment -> unit
    val emitInstrTail :
      ilG:System.Reflection.Emit.ILGenerator ->
        tail:IL.ILTailcall -> emitTheCall:(unit -> unit) -> unit
    val emitInstrNewobj :
      cenv:cenv ->
        emEnv:emEnv ->
          ilG:System.Reflection.Emit.ILGenerator ->
            mspec:IL.ILMethodSpec -> varargs:'a option -> unit
    val emitSilverlightCheck : ilG:System.Reflection.Emit.ILGenerator -> unit
    val emitInstrCall :
      cenv:cenv ->
        emEnv:emEnv ->
          ilG:System.Reflection.Emit.ILGenerator ->
            opCall:System.Reflection.Emit.OpCode ->
              tail:IL.ILTailcall ->
                mspec:IL.ILMethodSpec -> varargs:IL.ILTypes option -> unit
    val getGenericMethodDefinition :
      q:Quotations.Expr -> ty:System.Type -> System.Reflection.MethodInfo
    val getArrayMethInfo :
      n:int -> ty:System.Type -> System.Reflection.MethodInfo
    val setArrayMethInfo :
      n:int -> ty:System.Type -> System.Reflection.MethodInfo
    val emitInstr :
      cenv:cenv ->
        modB:System.Reflection.Emit.ModuleBuilder ->
          emEnv:emEnv ->
            ilG:System.Reflection.Emit.ILGenerator -> instr:IL.ILInstr -> unit
    val emitCode :
      cenv:cenv ->
        modB:System.Reflection.Emit.ModuleBuilder ->
          emEnv:emEnv ->
            ilG:System.Reflection.Emit.ILGenerator -> code:IL.ILCode -> unit
    val emitLocal :
      cenv:cenv ->
        emEnv:emEnv ->
          ilG:System.Reflection.Emit.ILGenerator ->
            local:IL.ILLocal -> System.Reflection.Emit.LocalBuilder
    val emitILMethodBody :
      cenv:cenv ->
        modB:System.Reflection.Emit.ModuleBuilder ->
          emEnv:emEnv ->
            ilG:System.Reflection.Emit.ILGenerator ->
              ilmbody:IL.ILMethodBody -> unit
    val emitMethodBody :
      cenv:cenv ->
        modB:System.Reflection.Emit.ModuleBuilder ->
          emEnv:emEnv ->
            ilG:(unit -> #System.Reflection.Emit.ILGenerator) ->
              _name:'b -> mbody:IL.ILLazyMethodBody -> unit
    val convCustomAttr :
      cenv:cenv ->
        emEnv:emEnv ->
          cattr:IL.ILAttribute -> System.Reflection.ConstructorInfo * byte []
    val emitCustomAttr :
      cenv:cenv ->
        emEnv:emEnv ->
          add:(System.Reflection.ConstructorInfo * byte [] -> 'a) ->
            cattr:IL.ILAttribute -> 'a
    val emitCustomAttrs :
      cenv:cenv ->
        emEnv:emEnv ->
          add:(System.Reflection.ConstructorInfo * byte [] -> unit) ->
            cattrs:IL.ILAttributes -> unit
    val buildGenParamsPass1 :
      _emEnv:'a ->
        defineGenericParameters:(string [] -> 'b) ->
          gps:IL.ILGenericParameterDefs -> unit
    val buildGenParamsPass1b :
      cenv:cenv ->
        emEnv:emEnv ->
          genArgs:System.Type array -> gps:IL.ILGenericParameterDefs -> unit
    val emitParameter :
      cenv:cenv ->
        emEnv:emEnv ->
          defineParameter:(int * System.Reflection.ParameterAttributes * string ->
                             System.Reflection.Emit.ParameterBuilder) ->
            i:int -> param:IL.ILParameter -> unit
    val definePInvokeMethod : System.Reflection.MethodInfo
    val enablePInvoke : bool
    val buildMethodPass2 :
      cenv:cenv ->
        tref:IL.ILTypeRef ->
          typB:System.Reflection.Emit.TypeBuilder ->
            emEnv:emEnv -> mdef:IL.ILMethodDef -> emEnv
    val buildMethodPass3 :
      cenv:cenv ->
        tref:IL.ILTypeRef ->
          modB:System.Reflection.Emit.ModuleBuilder ->
            typB:System.Reflection.Emit.TypeBuilder ->
              emEnv:emEnv -> mdef:IL.ILMethodDef -> unit
    val buildFieldPass2 :
      cenv:cenv ->
        tref:IL.ILTypeRef ->
          typB:System.Reflection.Emit.TypeBuilder ->
            emEnv:emEnv -> fdef:IL.ILFieldDef -> emEnv
    val buildFieldPass3 :
      cenv:cenv ->
        tref:IL.ILTypeRef ->
          _typB:System.Reflection.Emit.TypeBuilder ->
            emEnv:emEnv -> fdef:IL.ILFieldDef -> unit
    val buildPropertyPass2 :
      cenv:cenv ->
        tref:IL.ILTypeRef ->
          typB:System.Reflection.Emit.TypeBuilder ->
            emEnv:emEnv -> prop:IL.ILPropertyDef -> emEnv
    val buildPropertyPass3 :
      cenv:cenv ->
        tref:IL.ILTypeRef ->
          _typB:System.Reflection.Emit.TypeBuilder ->
            emEnv:emEnv -> prop:IL.ILPropertyDef -> unit
    val buildEventPass3 :
      cenv:cenv ->
        typB:System.Reflection.Emit.TypeBuilder ->
          emEnv:emEnv -> eventDef:IL.ILEventDef -> unit
    val buildMethodImplsPass3 :
      cenv:cenv ->
        _tref:'a ->
          typB:System.Reflection.Emit.TypeBuilder ->
            emEnv:emEnv -> mimpl:IL.ILMethodImplDef -> emEnv
    val typeAttributesOfTypeDefKind :
      x:IL.ILTypeDefKind -> System.Reflection.TypeAttributes
    val typeAttributesOfTypeAccess :
      x:IL.ILTypeDefAccess -> System.Reflection.TypeAttributes
    val typeAttributesOfTypeEncoding :
      x:IL.ILDefaultPInvokeEncoding -> System.Reflection.TypeAttributes
    val typeAttributesOfTypeLayout :
      cenv:cenv ->
        emEnv:emEnv ->
          x:IL.ILTypeDefLayout ->
            (System.Reflection.ConstructorInfo * byte []) option
    val buildTypeDefPass1 :
      cenv:cenv ->
        emEnv:emEnv ->
          modB:System.Reflection.Emit.ModuleBuilder ->
            rootTypeBuilder:(string * System.Reflection.TypeAttributes ->
                               System.Reflection.Emit.TypeBuilder) ->
              nesting:IL.ILTypeDef list -> tdef:IL.ILTypeDef -> emEnv
    val buildTypeTypeDef :
      cenv:cenv ->
        emEnv:emEnv ->
          modB:System.Reflection.Emit.ModuleBuilder ->
            typB:System.Reflection.Emit.TypeBuilder ->
              nesting:IL.ILTypeDef list -> tdef:IL.ILTypeDef -> emEnv
    val buildTypeDefPass1b :
      cenv:cenv ->
        nesting:IL.ILTypeDef list -> emEnv:emEnv -> tdef:IL.ILTypeDef -> unit
    val buildTypeDefPass2 :
      cenv:cenv ->
        nesting:IL.ILTypeDef list -> emEnv:emEnv -> tdef:IL.ILTypeDef -> emEnv
    val buildTypeDefPass3 :
      cenv:cenv ->
        nesting:IL.ILTypeDef list ->
          modB:System.Reflection.Emit.ModuleBuilder ->
            emEnv:emEnv -> tdef:IL.ILTypeDef -> emEnv
    val getEnclosingTypeRefs : tref:IL.ILTypeRef -> IL.ILTypeRef list
    [<RequireQualifiedAccessAttribute ()>]
    type CollectTypes =
      | ValueTypesOnly
      | All
    val getTypeRefsInType :
      allTypes:CollectTypes ->
        ty:IL.ILType -> acc:IL.ILTypeRef list -> IL.ILTypeRef list
    val verbose2 : bool
    val createTypeRef :
      visited:System.Collections.Generic.Dictionary<IL.ILTypeRef,bool> *
      created:System.Collections.Generic.Dictionary<IL.ILTypeRef,bool> ->
        emEnv:emEnv -> tref:IL.ILTypeRef -> unit
    val buildTypeDefPass4 :
      visited:System.Collections.Generic.Dictionary<IL.ILTypeRef,bool> *
      created:System.Collections.Generic.Dictionary<IL.ILTypeRef,bool> ->
        nesting:IL.ILTypeDef list -> emEnv:emEnv -> tdef:IL.ILTypeDef -> unit
    val buildModuleTypePass1 :
      cenv:cenv ->
        modB:System.Reflection.Emit.ModuleBuilder ->
          emEnv:emEnv -> tdef:IL.ILTypeDef -> emEnv
    val buildModuleTypePass1b :
      cenv:cenv -> emEnv:emEnv -> tdef:IL.ILTypeDef -> unit
    val buildModuleTypePass2 :
      cenv:cenv -> emEnv:emEnv -> tdef:IL.ILTypeDef -> emEnv
    val buildModuleTypePass3 :
      cenv:cenv ->
        modB:System.Reflection.Emit.ModuleBuilder ->
          emEnv:emEnv -> tdef:IL.ILTypeDef -> emEnv
    val buildModuleTypePass4 :
      System.Collections.Generic.Dictionary<IL.ILTypeRef,bool> *
      System.Collections.Generic.Dictionary<IL.ILTypeRef,bool> ->
        emEnv:emEnv -> tdef:IL.ILTypeDef -> unit
    val buildModuleFragment :
      cenv:cenv ->
        emEnv:emEnv ->
          asmB:System.Reflection.Emit.AssemblyBuilder ->
            modB:System.Reflection.Emit.ModuleBuilder ->
              m:IL.ILModuleDef -> emEnv
    val defineDynamicAssemblyAndLog :
      asmName:System.Reflection.AssemblyName *
      flags:System.Reflection.Emit.AssemblyBuilderAccess * asmDir:string ->
        System.Reflection.Emit.AssemblyBuilder
    val mkDynamicAssemblyAndModule :
      assemblyName:string * optimize:bool * debugInfo:'a * collectible:bool ->
        System.Reflection.Emit.AssemblyBuilder *
        System.Reflection.Emit.ModuleBuilder
    val emitModuleFragment :
      ilg:IL.ILGlobals * emEnv:emEnv *
      asmB:System.Reflection.Emit.AssemblyBuilder *
      modB:System.Reflection.Emit.ModuleBuilder * modul:IL.ILModuleDef *
      debugInfo:bool *
      resolveAssemblyRef:(IL.ILAssemblyRef ->
                            Choice<string,System.Reflection.Assembly> option) *
      tryFindSysILTypeRef:(string -> IL.ILTypeRef option) ->
        emEnv * (unit -> exn option) list
    val LookupTypeRef :
      cenv:cenv -> emEnv:emEnv -> tref:IL.ILTypeRef -> System.Type
    val LookupType : cenv:cenv -> emEnv:emEnv -> ty:IL.ILType -> System.Type
    val LookupFieldRef :
      emEnv:emEnv -> fref:IL.ILFieldRef -> System.Reflection.FieldInfo option
    val LookupMethodRef :
      emEnv:emEnv -> mref:IL.ILMethodRef -> System.Reflection.MethodInfo option
  end

namespace FSharp.Compiler
  module ReferenceResolver = begin
    exception internal ResolutionFailure
    [<RequireQualifiedAccessAttribute ()>]
    type ResolutionEnvironment =
      | EditingOrCompilation of isEditing: bool
      | CompilationAndEvaluation
    type ResolvedFile =
      { itemSpec: string
        prepareToolTip: string * string -> string
        baggage: string }
      with
        override ToString : unit -> string
      end
    [<AllowNullLiteralAttribute ()>]
    type Resolver =
      interface
        abstract member HighestInstalledNetFrameworkVersion : unit -> string
        abstract member
          Resolve : resolutionEnvironment:ResolutionEnvironment *
                    references:(string * string) [] *
                    targetFrameworkVersion:string *
                    targetFrameworkDirectories:string list *
                    targetProcessorArchitecture:string * fsharpCoreDir:string *
                    explicitIncludeDirs:string list * implicitIncludeDir:string *
                    logMessage:(string -> unit) *
                    logDiagnostic:(bool -> string -> string -> unit) ->
                      ResolvedFile []
        abstract member DotNetFrameworkReferenceAssembliesRootDirectory : string
      end
  end

namespace FSharp.Compiler
  module internal SimulatedMSBuildReferenceResolver = begin
    [<LiteralAttribute ()>]
    val private Net45 : string = "v4.5"
    [<LiteralAttribute ()>]
    val private Net451 : string = "v4.5.1"
    [<LiteralAttribute ()>]
    val private Net452 : string = "v4.5.2"
    [<LiteralAttribute ()>]
    val private Net46 : string = "v4.6"
    [<LiteralAttribute ()>]
    val private Net461 : string = "v4.6.1"
    [<LiteralAttribute ()>]
    val private Net462 : string = "v4.6.2"
    [<LiteralAttribute ()>]
    val private Net47 : string = "v4.7"
    [<LiteralAttribute ()>]
    val private Net471 : string = "v4.7.1"
    [<LiteralAttribute ()>]
    val private Net472 : string = "v4.7.2"
    [<LiteralAttribute ()>]
    val private Net48 : string = "v4.8"
    val SupportedDesktopFrameworkVersions : string list
    val private SimulatedMSBuildResolver : ReferenceResolver.Resolver
    val getResolver : unit -> ReferenceResolver.Resolver
  end

namespace Internal.Utilities
  module internal FSharpEnvironment = begin
    val FSharpBannerVersion : string
    val FSharpProductName : string
    val versionOf<'t> : string
    val FSharpCoreLibRunningVersion : string option
    val FSharpBinaryMetadataFormatRevision : string
    val isRunningOnCoreClr : bool
    module Option = begin
      val ofString : s:string -> string option
    end
    val maxPath : int
    val maxDataLength : int
    val tryCurrentDomain : unit -> string option
    val tryAppConfig : _appConfigKey:string -> 'a option
    val BinFolderOfDefaultFSharpCompiler :
      probePoint:string option -> string option
    val toolingCompatibleTypeProviderProtocolMonikers : unit -> string list
    val toolingCompatibleVersions : string []
    val toolPaths : string []
    val toolingCompatiblePaths : unit -> string list
    val searchToolPaths :
      path:string option -> compilerToolPaths:seq<string> -> seq<string>
    val getTypeProviderAssembly :
      runTimeAssemblyFileName:string * designTimeAssemblyName:string *
      compilerToolPaths:string list *
      raiseError:(string option -> exn -> System.Reflection.Assembly option) ->
        System.Reflection.Assembly option
    val getCompilerToolsDesignTimeAssemblyPaths :
      compilerToolPaths:seq<string> -> seq<string>
  end

namespace FSharp.Compiler
  module PrettyNaming = begin
    [<LiteralAttribute ()>]
    val parenGet : string = ".()"
    [<LiteralAttribute ()>]
    val parenSet : string = ".()<-"
    [<LiteralAttribute ()>]
    val qmark : string = "?"
    [<LiteralAttribute ()>]
    val qmarkSet : string = "?<-"
    [<LiteralAttribute ()>]
    val opNamePrefix : string = "op_"
    val private opNameTable : (string * string) []
    val private opCharTranslateTable : (char * string) []
    val private opCharSet : System.Collections.Generic.HashSet<char>
    val IsOperatorOrBacktickedName : name:string -> bool
    val IsOperatorName : name:string -> bool
    val IsMangledOpName : n:string -> bool
    val private compileCustomOpName : (string -> string)
    val CompileOpName : (string -> string)
    val private decompileCustomOpName : (string -> string)
    val DecompileOpName : (string -> string)
    val DemangleOperatorName : nm:string -> string
    val DemangleOperatorNameAsLayout :
      nonOpTagged:(string -> #Internal.Utilities.StructuredFormat.TaggedText) ->
        nm:string -> Internal.Utilities.StructuredFormat.Layout
    val opNameCons : string
    val opNameNil : string
    val opNameEquals : string
    val opNameEqualsNullable : string
    val opNameNullableEquals : string
    val opNameNullableEqualsNullable : string
    val IsIdentifierFirstCharacter : c:char -> bool
    val IsIdentifierPartCharacter : c:char -> bool
    val IsLongIdentifierPartCharacter : c:char -> bool
    val isTildeOnlyString : s:string -> bool
    val IsValidPrefixOperatorUse : s:string -> bool
    val IsValidPrefixOperatorDefinitionName : s:string -> bool
    val IsPrefixOperator : s:string -> bool
    val IsPunctuation : s:string -> bool
    val IsTernaryOperator : s:string -> bool
    val IsInfixOperator : (string -> bool)
    val ( |Control|Equality|Relational|Indexer|FixedTypes|Other| ) :
      opName:string -> Choice<unit,unit,unit,unit,unit,unit>
    [<LiteralAttribute ()>]
    val private compilerGeneratedMarker : string = "@"
    [<LiteralAttribute ()>]
    val private compilerGeneratedMarkerChar : char = '@'
    val IsCompilerGeneratedName : nm:string -> bool
    val CompilerGeneratedName : nm:string -> string
    val GetBasicNameOfPossibleCompilerGeneratedName : name:string -> string
    val CompilerGeneratedNameSuffix :
      basicName:string -> suffix:string -> string
    [<LiteralAttribute ()>]
    val private mangledGenericTypeNameSym : char = '`'
    val TryDemangleGenericNameAndPos : n:string -> int voption
    type NameArityPair = | NameArityPair of string * int
    val DemangleGenericTypeNameWithPos : pos:int -> mangledName:string -> string
    val DecodeGenericTypeNameWithPos :
      pos:int -> mangledName:string -> NameArityPair
    val DemangleGenericTypeName : mangledName:string -> string
    val DecodeGenericTypeName : mangledName:string -> NameArityPair
    val private chopStringTo : s:string -> c:char -> string
    val TryChopPropertyName : s:string -> string option
    val ChopPropertyName : s:string -> string
    val SplitNamesForILPath : s:string -> string list
    val inline private isNotQuotedQuotation : text:string -> n:int -> bool
    val private splitAroundQuotation :
      text:string -> separator:char -> string []
    val private splitAroundQuotationWithCount :
      text:string -> separator:char -> count:int -> string []
    [<LiteralAttribute ()>]
    val FSharpModuleSuffix : string = "Module"
    [<LiteralAttribute ()>]
    val MangledGlobalName : string = "`global`"
    val IllegalCharactersInTypeAndNamespaceNames : char []
    val IsActivePatternName : name:string -> bool
    type ActivePatternInfo =
      | APInfo of bool * (string * Range.range) list * Range.range
      with
        member ActiveTags : string list
        member ActiveTagsWithRanges : (string * Range.range) list
        member IsTotal : bool
        member Range : Range.range
      end
    val ActivePatternInfoOfValName :
      nm:string -> m:Range.range -> ActivePatternInfo option
    val private mangleStaticStringArg : nm:string * v:string -> string
    val private tryDemangleStaticStringArg :
      mangledText:string -> (string * string) option
    exception InvalidMangledStaticArg of string
    val demangleProvidedTypeName :
      typeLogicalName:string -> string * (string * string) []
    val mangleProvidedTypeName :
      typeLogicalName:string * nonDefaultArgs:(string * string) [] -> string
    val computeMangledNameWithoutDefaultArgValues :
      nm:string * staticArgs:'a [] *
      defaultArgValues:(string * string option) [] -> string
    val outArgCompilerGeneratedName : string
    val ExtraWitnessMethodName : nm:string -> string
    val mkUnionCaseFieldName : (int -> int -> string)
    val mkExceptionFieldName : (int -> string)
    val FsiDynamicModulePrefix : string
    module FSharpLib = begin
      val Root : string
      val RootPath : string list
      val Core : string
      val CorePath : string list
    end
    module CustomOperations = begin
      [<LiteralAttribute ()>]
      val Into : string = "into"
    end
    val unassignedTyparName : string
    val FSharpOptimizationDataResourceName : string
    val FSharpSignatureDataResourceName : string
    val FSharpOptimizationDataResourceName2 : string
    val FSharpSignatureDataResourceName2 : string
  end

namespace FSharp.Compiler.AbstractIL.Extensions.ILX
  module internal IlxSettings = begin
    type IlxCallImplementation = | VirtEntriesVirtCode
    val mutable ilxCompilingFSharpCoreLib : bool
    val mutable ilxFsharpCoreLibAssemRef : IL.ILAssemblyRef option
    val ilxFsharpCoreLibScopeRef : unit -> IL.ILScopeRef
    val ilxNamespace : unit -> string
  end

namespace FSharp.Compiler.AbstractIL.Extensions.ILX
  module internal EraseClosures = begin
    val notlazy : v:'a -> System.Lazy<'a>
    val stripUpTo :
      n:int -> test:('a -> bool) -> dest:('a -> 'b * 'a) -> x:'a -> 'b list * 'a
    val destTyLambda :
      _arg1:Types.IlxClosureLambdas ->
        IL.ILGenericParameterDef * Types.IlxClosureLambdas
    val isTyLambda : _arg1:Types.IlxClosureLambdas -> bool
    val isTyApp : _arg1:Types.IlxClosureApps -> bool
    val stripTyLambdasUpTo :
      n:int ->
        lambdas:Types.IlxClosureLambdas ->
          IL.ILGenericParameterDef list * Types.IlxClosureLambdas
    val stripSupportedIndirectCall :
      apps:Types.IlxClosureApps ->
        IL.ILType list * IL.ILType list * Types.IlxClosureApps
    val stripSupportedAbstraction :
      lambdas:Types.IlxClosureLambdas ->
        IL.ILGenericParameterDef list * IL.ILParameter list *
        Types.IlxClosureLambdas
    val isSupportedDirectCall : apps:Types.IlxClosureApps -> bool
    val mkFuncTypeRef : n:int -> IL.ILTypeRef
    type cenv =
      { ilg: IL.ILGlobals
        tref_Func: IL.ILTypeRef []
        mkILTyFuncTy: IL.ILType
        addFieldGeneratedAttrs: IL.ILFieldDef -> IL.ILFieldDef
        addFieldNeverAttrs: IL.ILFieldDef -> IL.ILFieldDef
        addMethodGeneratedAttrs: IL.ILMethodDef -> IL.ILMethodDef }
      with
        override ToString : unit -> string
      end
    val addMethodGeneratedAttrsToTypeDef :
      cenv:cenv -> tdef:IL.ILTypeDef -> IL.ILTypeDef
    val newIlxPubCloEnv :
      IL.ILGlobals * addMethodGeneratedAttrs:(IL.ILMethodDef -> IL.ILMethodDef) *
      addFieldGeneratedAttrs:(IL.ILFieldDef -> IL.ILFieldDef) *
      addFieldNeverAttrs:(IL.ILFieldDef -> IL.ILFieldDef) -> cenv
    val mkILTyFuncTy : cenv -> IL.ILType
    val mkILFuncTy : cenv -> IL.ILType -> IL.ILType -> IL.ILType
    val mkILCurriedFuncTy :
      cenv:cenv -> dtys:IL.ILType list -> rty:IL.ILType -> IL.ILType
    val typ_Func :
      cenv:cenv -> dtys:IL.ILType list -> rty:IL.ILType -> IL.ILType
    val mkTyOfApps : cenv:cenv -> apps:Types.IlxClosureApps -> IL.ILType
    val mkTyOfLambdas : cenv -> Types.IlxClosureLambdas -> IL.ILType
    val mkMethSpecForMultiApp :
      cenv:cenv ->
        argtys':IL.ILType list * rty:IL.ILType -> bool * IL.ILMethodSpec
    val mkCallBlockForMultiValueApp :
      cenv:cenv ->
        doTailCall:IL.ILTailcall ->
          args':IL.ILType list * rty':IL.ILType -> IL.ILInstr list
    val mkMethSpecForClosureCall :
      cenv:cenv -> clospec:Types.IlxClosureSpec -> IL.ILMethodSpec
    val mkLdFreeVar :
      clospec:Types.IlxClosureSpec ->
        fv:Types.IlxClosureFreeVar -> IL.ILInstr list
    val mkCallFunc :
      cenv ->
        allocLocal:(IL.ILType -> uint16) ->
          numThisGenParams:int ->
            IL.ILTailcall -> Types.IlxClosureApps -> IL.ILInstr list
    val convReturnInstr : ty:IL.ILType -> instr:IL.ILInstr -> IL.ILInstr list
    val convILMethodBody :
      thisClo:'a option * boxReturnTy:IL.ILType option ->
        il:IL.ILMethodBody -> IL.ILMethodBody
    val convMethodBody :
      thisClo:'a option -> _arg1:IL.MethodBody -> IL.MethodBody
    val convMethodDef : thisClo:'a option -> md:IL.ILMethodDef -> IL.ILMethodDef
    val mkILFreeVarForParam : p:IL.ILParameter -> Types.IlxClosureFreeVar
    val mkILLocalForFreeVar : p:Types.IlxClosureFreeVar -> IL.ILLocal
    val mkILCloFldSpecs :
      _cenv:'a -> flds:Types.IlxClosureFreeVar [] -> (string * IL.ILType) list
    val mkILCloFldDefs :
      cenv:cenv -> flds:Types.IlxClosureFreeVar [] -> IL.ILFieldDef list
    val convIlxClosureDef :
      cenv ->
        encl:string list ->
          IL.ILTypeDef -> Types.IlxClosureInfo -> IL.ILTypeDef list
  end

namespace FSharp.Compiler.AbstractIL.Extensions.ILX
  module internal EraseUnions = begin
    [<LiteralAttribute ()>]
    val TagNil : int = 0
    [<LiteralAttribute ()>]
    val TagCons : int = 1
    [<LiteralAttribute ()>]
    val ALT_NAME_CONS : string = "Cons"
    type DiscriminationTechnique =
      | TailOrNull
      | RuntimeTypes
      | SingleCase
      | IntegerTag
    type UnionReprDecisions<'Union,'Alt,'Type> =
      class
        new : getAlternatives:('Union -> 'Alt []) *
              nullPermitted:('Union -> bool) * isNullary:('Alt -> bool) *
              isList:('Union -> bool) * isStruct:('Union -> bool) *
              nameOfAlt:('Alt -> string) * makeRootType:('Union -> 'Type) *
              makeNestedType:('Union * string -> 'Type) ->
                UnionReprDecisions<'Union,'Alt,'Type>
        member DiscriminationTechnique : cu:'Union -> DiscriminationTechnique
        member Flatten : cu:'Union -> bool
        member
          MaintainPossiblyUniqueConstantFieldForAlternative : cu:'Union *
                                                              alt:'Alt -> bool
        member OptimizeAlternativeToRootClass : cu:'Union * alt:'Alt -> bool
        member
          RepresentAllAlternativesAsConstantFieldsInRootClass : cu:'Union ->
                                                                  bool
        member
          RepresentAlternativeAsConstantFieldInTaggedRootClass : cu:'Union *
                                                                 alt:'Alt ->
                                                                   bool
        member
          RepresentAlternativeAsFreshInstancesOfRootClass : cu:'Union * alt:'Alt ->
                                                              bool
        member RepresentAlternativeAsNull : cu:'Union * alt:'Alt -> bool
        member RepresentAlternativeAsStructValue : cu:'Union -> bool
        member RepresentOneAlternativeAsNull : cu:'Union -> bool
        member
          RepresentSingleNonNullaryAlternativeAsInstancesOfRootClassAndAnyOtherAlternativesAsNull : cu:'Union *
                                                                                                    alt:'Alt ->
                                                                                                      bool
        member TypeForAlternative : cuspec:'Union * alt:'Alt -> 'Type
      end
    val baseTyOfUnionSpec : cuspec:Types.IlxUnionSpec -> IL.ILType
    val mkMakerName : cuspec:Types.IlxUnionSpec -> nm:string -> string
    val mkCasesTypeRef : cuspec:Types.IlxUnionSpec -> IL.ILTypeRef
    val cuspecRepr :
      UnionReprDecisions<Types.IlxUnionSpec,Types.IlxUnionAlternative,IL.ILType>
    type NoTypesGeneratedViaThisReprDecider =
      | NoTypesGeneratedViaThisReprDecider
    val cudefRepr :
      UnionReprDecisions<(IL.ILTypeDef * Types.IlxUnionInfo),
                         Types.IlxUnionAlternative,
                         NoTypesGeneratedViaThisReprDecider>
    val mkTesterName : nm:string -> string
    val tagPropertyName : string
    val mkUnionCaseFieldId : fdef:Types.IlxUnionField -> string * IL.ILType
    val refToFieldInTy :
      ty:IL.ILType -> nm:string * fldTy:IL.ILType -> IL.ILFieldSpec
    val formalTypeArgs : baseTy:IL.ILType -> IL.ILType list
    val constFieldName : nm:string -> string
    val constFormalFieldTy : baseTy:IL.ILType -> IL.ILType
    val mkConstFieldSpecFromId :
      baseTy:IL.ILType -> string * IL.ILType -> IL.ILFieldSpec
    val mkConstFieldSpec : nm:string -> baseTy:IL.ILType -> IL.ILFieldSpec
    val tyForAlt :
      cuspec:Types.IlxUnionSpec -> alt:Types.IlxUnionAlternative -> IL.ILType
    val GetILTypeForAlternative : Types.IlxUnionSpec -> int -> IL.ILType
    val mkTagFieldType : ilg:IL.ILGlobals -> _cuspec:'a -> IL.ILType
    val mkTagFieldFormalType : ilg:IL.ILGlobals -> _cuspec:'a -> IL.ILType
    val mkTagFieldId : ilg:IL.ILGlobals -> cuspec:'a -> string * IL.ILType
    val mkTailOrNullId : baseTy:IL.ILType -> string * IL.ILType
    val altOfUnionSpec :
      cuspec:Types.IlxUnionSpec -> cidx:int -> Types.IlxUnionAlternative
    val doesRuntimeTypeDiscriminateUseHelper :
      avoidHelpers:bool ->
        cuspec:Types.IlxUnionSpec -> alt:Types.IlxUnionAlternative -> bool
    val mkRuntimeTypeDiscriminate :
      ilg:IL.ILGlobals ->
        avoidHelpers:bool ->
          cuspec:Types.IlxUnionSpec ->
            alt:Types.IlxUnionAlternative ->
              altName:string -> altTy:IL.ILType -> IL.ILInstr list
    val mkRuntimeTypeDiscriminateThen :
      ilg:IL.ILGlobals ->
        avoidHelpers:bool ->
          cuspec:Types.IlxUnionSpec ->
            alt:Types.IlxUnionAlternative ->
              altName:string ->
                altTy:IL.ILType -> after:IL.ILInstr -> IL.ILInstr list
    val mkGetTagFromField :
      ilg:IL.ILGlobals -> cuspec:'a -> baseTy:IL.ILType -> IL.ILInstr list
    val adjustFieldName :
      hasHelpers:Types.IlxUnionHasHelpers -> nm:string -> string
    val mkLdData : bool * Types.IlxUnionSpec * int * int -> IL.ILInstr list
    val mkLdDataAddr : bool * Types.IlxUnionSpec * int * int -> IL.ILInstr list
    val mkGetTailOrNull :
      avoidHelpers:bool -> cuspec:Types.IlxUnionSpec -> IL.ILInstr list
    val mkGetTagFromHelpers :
      ilg:IL.ILGlobals -> cuspec:Types.IlxUnionSpec -> IL.ILInstr
    val mkGetTag :
      ilg:IL.ILGlobals -> cuspec:Types.IlxUnionSpec -> IL.ILInstr list
    val mkCeqThen : after:IL.ILInstr -> IL.ILInstr list
    val mkTagDiscriminate :
      ilg:IL.ILGlobals ->
        cuspec:Types.IlxUnionSpec -> _baseTy:'a -> cidx:int32 -> IL.ILInstr list
    val mkTagDiscriminateThen :
      ilg:IL.ILGlobals ->
        cuspec:Types.IlxUnionSpec ->
          cidx:int32 -> after:IL.ILInstr -> IL.ILInstr list
    val extraTysAndInstrsForStructCtor :
      ilg:IL.ILGlobals -> cidx:int -> IL.ILType list * IL.ILInstr list
    val takesExtraParams : alts:Types.IlxUnionAlternative [] -> bool
    val convNewDataInstrInternal :
      ilg:IL.ILGlobals ->
        cuspec:Types.IlxUnionSpec -> cidx:int -> IL.ILInstr list
    val mkStData : Types.IlxUnionSpec * int * int -> IL.ILInstr list
    val mkNewData : IL.ILGlobals -> Types.IlxUnionSpec * int -> IL.ILInstr list
    val mkIsData :
      IL.ILGlobals -> bool * Types.IlxUnionSpec * int -> IL.ILInstr list
    type ICodeGen<'Mark> =
      interface
        abstract member CodeLabel : 'Mark -> IL.ILCodeLabel
        abstract member EmitInstr : IL.ILInstr -> unit
        abstract member EmitInstrs : IL.ILInstr list -> unit
        abstract member GenLocal : IL.ILType -> uint16
        abstract member GenerateDelayMark : unit -> 'Mark
        abstract member MkInvalidCastExnNewobj : unit -> IL.ILInstr
        abstract member SetMarkToHere : 'Mark -> unit
      end
    val genWith : g:(ICodeGen<IL.ILCodeLabel> -> unit) -> IL.ILCode
    val mkBrIsData :
      IL.ILGlobals ->
        sense:bool ->
          avoidHelpers:bool * Types.IlxUnionSpec * int * IL.ILCodeLabel ->
            IL.ILInstr list
    val emitLdDataTagPrim :
      ilg:IL.ILGlobals ->
        ldOpt:IL.ILInstr option ->
          cg:ICodeGen<'Mark> ->
            avoidHelpers:bool * cuspec:Types.IlxUnionSpec -> unit
    val emitLdDataTag :
      IL.ILGlobals ->
        ICodeGen<'Mark> -> avoidHelpers:bool * Types.IlxUnionSpec -> unit
    val emitCastData :
      IL.ILGlobals ->
        ICodeGen<'Mark> ->
          canfail:bool * avoidHelpers:bool * Types.IlxUnionSpec * int -> unit
    val emitDataSwitch :
      IL.ILGlobals ->
        ICodeGen<'Mark> ->
          avoidHelpers:bool * Types.IlxUnionSpec * (int * IL.ILCodeLabel) list ->
            unit
    val mkMethodsAndPropertiesForFields :
      addMethodGeneratedAttrs:(IL.ILMethodDef -> 'a) *
      addPropertyGeneratedAttrs:(IL.ILPropertyDef -> 'b) ->
        access:IL.ILMemberAccess ->
          attr:IL.ILSourceMarker option ->
            hasHelpers:Types.IlxUnionHasHelpers ->
              ilTy:IL.ILType ->
                fields:Types.IlxUnionField [] -> 'b list * 'a list
    val convAlternativeDef :
      addMethodGeneratedAttrs:(IL.ILMethodDef -> IL.ILMethodDef) *
      addPropertyGeneratedAttrs:(IL.ILPropertyDef -> IL.ILPropertyDef) *
      addPropertyNeverAttrs:(IL.ILPropertyDef -> 'a) *
      addFieldGeneratedAttrs:('b -> IL.ILFieldDef) *
      addFieldNeverAttrs:(IL.ILFieldDef -> 'b) *
      mkDebuggerTypeProxyAttribute:(IL.ILType -> IL.ILAttribute) ->
        ilg:IL.ILGlobals ->
          num:int ->
            td:IL.ILTypeDef ->
              cud:Types.IlxUnionInfo ->
                IL.ILTypeDef * Types.IlxUnionInfo ->
                  cuspec:Types.IlxUnionSpec ->
                    baseTy:IL.ILType ->
                      alt:Types.IlxUnionAlternative ->
                        IL.ILMethodDef list * 'a list * IL.ILMethodDef list *
                        IL.ILTypeDef list * IL.ILTypeDef list *
                        ((IL.ILTypeDef * Types.IlxUnionInfo) *
                         Types.IlxUnionAlternative * IL.ILType * int *
                         IL.ILFieldDef * bool) list
    val mkClassUnionDef :
      addMethodGeneratedAttrs:(IL.ILMethodDef -> IL.ILMethodDef) *
      addPropertyGeneratedAttrs:(IL.ILPropertyDef -> IL.ILPropertyDef) *
      addPropertyNeverAttrs:(IL.ILPropertyDef -> IL.ILPropertyDef) *
      addFieldGeneratedAttrs:(IL.ILFieldDef -> IL.ILFieldDef) *
      addFieldNeverAttrs:(IL.ILFieldDef -> IL.ILFieldDef) *
      mkDebuggerTypeProxyAttribute:(IL.ILType -> IL.ILAttribute) ->
        ilg:IL.ILGlobals ->
          tref:IL.ILTypeRef ->
            td:IL.ILTypeDef -> cud:Types.IlxUnionInfo -> IL.ILTypeDef
  end

namespace FSharp.Compiler
  module internal UnicodeLexing = begin
    type Lexbuf = Internal.Utilities.Text.Lexing.LexBuffer<char>
    val StringAsLexbuf :
      (Features.LanguageFeature -> bool) * string ->
        Internal.Utilities.Text.Lexing.LexBuffer<char>
    val FunctionAsLexbuf :
      (Features.LanguageFeature -> bool) * (char [] * int * int -> int) ->
        Internal.Utilities.Text.Lexing.LexBuffer<char>
    val SourceTextAsLexbuf :
      (Features.LanguageFeature -> bool) * Text.ISourceText ->
        Internal.Utilities.Text.Lexing.LexBuffer<char>
    val StreamReaderAsLexbuf :
      (Features.LanguageFeature -> bool) * System.IO.StreamReader ->
        Internal.Utilities.Text.Lexing.LexBuffer<char>
  end

namespace FSharp.Compiler
  module Layout = begin
    type layout = Internal.Utilities.StructuredFormat.Layout
    type LayoutTag = Internal.Utilities.StructuredFormat.LayoutTag
    type TaggedText = Internal.Utilities.StructuredFormat.TaggedText
    type NavigableTaggedText =
      class
        interface TaggedText
        new : TaggedText * Range.range -> NavigableTaggedText
        member Range : Range.range
      end
    val mkNav : Range.range -> TaggedText -> TaggedText
    val spaces : n:int -> System.String
    val emptyL : Internal.Utilities.StructuredFormat.Layout
    val isEmptyL : Internal.Utilities.StructuredFormat.Layout -> bool
    val mkNode :
      l:Internal.Utilities.StructuredFormat.Layout ->
        r:Internal.Utilities.StructuredFormat.Layout ->
          joint:Internal.Utilities.StructuredFormat.Joint ->
            Internal.Utilities.StructuredFormat.Layout
    val wordL : TaggedText -> Internal.Utilities.StructuredFormat.Layout
    val sepL : TaggedText -> Internal.Utilities.StructuredFormat.Layout
    val rightL : TaggedText -> Internal.Utilities.StructuredFormat.Layout
    val leftL : TaggedText -> Internal.Utilities.StructuredFormat.Layout
    module TaggedTextOps = begin
      val tagActivePatternCase :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagActivePatternResult :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagAlias : (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagClass : (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagUnion : (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagUnionCase :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagDelegate :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagEnum : (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagEvent : (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagField : (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagInterface :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagKeyword :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagLineBreak :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagLocal : (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagRecord : (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagRecordField :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagMethod : (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagMember : (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagModule : (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagModuleBinding :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagFunction :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagNamespace :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagNumericLiteral :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagOperator :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagParameter :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagProperty :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagSpace : (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagStringLiteral :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagStruct : (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagTypeParameter :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagText : (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagPunctuation :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagUnknownEntity :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      val tagUnknownType :
        (string -> Internal.Utilities.StructuredFormat.TaggedText)
      module Literals = begin
        val lineBreak : Internal.Utilities.StructuredFormat.TaggedText
        val space : Internal.Utilities.StructuredFormat.TaggedText
        val comma : Internal.Utilities.StructuredFormat.TaggedText
        val semicolon : Internal.Utilities.StructuredFormat.TaggedText
        val leftParen : Internal.Utilities.StructuredFormat.TaggedText
        val rightParen : Internal.Utilities.StructuredFormat.TaggedText
        val leftBracket : Internal.Utilities.StructuredFormat.TaggedText
        val rightBracket : Internal.Utilities.StructuredFormat.TaggedText
        val leftBrace : Internal.Utilities.StructuredFormat.TaggedText
        val rightBrace : Internal.Utilities.StructuredFormat.TaggedText
        val leftBraceBar : Internal.Utilities.StructuredFormat.TaggedText
        val rightBraceBar : Internal.Utilities.StructuredFormat.TaggedText
        val equals : Internal.Utilities.StructuredFormat.TaggedText
        val arrow : Internal.Utilities.StructuredFormat.TaggedText
        val questionMark : Internal.Utilities.StructuredFormat.TaggedText
        val dot : Internal.Utilities.StructuredFormat.TaggedText
        val leftAngle : Internal.Utilities.StructuredFormat.TaggedText
        val rightAngle : Internal.Utilities.StructuredFormat.TaggedText
        val star : Internal.Utilities.StructuredFormat.TaggedText
        val colon : Internal.Utilities.StructuredFormat.TaggedText
        val minus : Internal.Utilities.StructuredFormat.TaggedText
        val keywordNew : Internal.Utilities.StructuredFormat.TaggedText
        val leftBracketAngle : Internal.Utilities.StructuredFormat.TaggedText
        val rightBracketAngle : Internal.Utilities.StructuredFormat.TaggedText
        val structUnit : Internal.Utilities.StructuredFormat.TaggedText
        val keywordStatic : Internal.Utilities.StructuredFormat.TaggedText
        val keywordMember : Internal.Utilities.StructuredFormat.TaggedText
        val keywordVal : Internal.Utilities.StructuredFormat.TaggedText
        val keywordEvent : Internal.Utilities.StructuredFormat.TaggedText
        val keywordWith : Internal.Utilities.StructuredFormat.TaggedText
        val keywordSet : Internal.Utilities.StructuredFormat.TaggedText
        val keywordGet : Internal.Utilities.StructuredFormat.TaggedText
        val keywordTrue : Internal.Utilities.StructuredFormat.TaggedText
        val keywordFalse : Internal.Utilities.StructuredFormat.TaggedText
        val bar : Internal.Utilities.StructuredFormat.TaggedText
        val keywordStruct : Internal.Utilities.StructuredFormat.TaggedText
        val keywordInherit : Internal.Utilities.StructuredFormat.TaggedText
        val keywordEnd : Internal.Utilities.StructuredFormat.TaggedText
        val keywordNested : Internal.Utilities.StructuredFormat.TaggedText
        val keywordType : Internal.Utilities.StructuredFormat.TaggedText
        val keywordDelegate : Internal.Utilities.StructuredFormat.TaggedText
        val keywordOf : Internal.Utilities.StructuredFormat.TaggedText
        val keywordInternal : Internal.Utilities.StructuredFormat.TaggedText
        val keywordPrivate : Internal.Utilities.StructuredFormat.TaggedText
        val keywordAbstract : Internal.Utilities.StructuredFormat.TaggedText
        val keywordOverride : Internal.Utilities.StructuredFormat.TaggedText
        val keywordEnum : Internal.Utilities.StructuredFormat.TaggedText
        val leftBracketBar : Internal.Utilities.StructuredFormat.TaggedText
        val rightBracketBar : Internal.Utilities.StructuredFormat.TaggedText
        val keywordTypeof : Internal.Utilities.StructuredFormat.TaggedText
        val keywordTypedefof : Internal.Utilities.StructuredFormat.TaggedText
      end
    end
    module SepL = begin
      val dot : Internal.Utilities.StructuredFormat.Layout
      val star : Internal.Utilities.StructuredFormat.Layout
      val colon : Internal.Utilities.StructuredFormat.Layout
      val questionMark : Internal.Utilities.StructuredFormat.Layout
      val leftParen : Internal.Utilities.StructuredFormat.Layout
      val comma : Internal.Utilities.StructuredFormat.Layout
      val space : Internal.Utilities.StructuredFormat.Layout
      val leftBracket : Internal.Utilities.StructuredFormat.Layout
      val leftAngle : Internal.Utilities.StructuredFormat.Layout
      val lineBreak : Internal.Utilities.StructuredFormat.Layout
      val rightParen : Internal.Utilities.StructuredFormat.Layout
    end
    module WordL = begin
      val arrow : Internal.Utilities.StructuredFormat.Layout
      val star : Internal.Utilities.StructuredFormat.Layout
      val colon : Internal.Utilities.StructuredFormat.Layout
      val equals : Internal.Utilities.StructuredFormat.Layout
      val keywordNew : Internal.Utilities.StructuredFormat.Layout
      val structUnit : Internal.Utilities.StructuredFormat.Layout
      val keywordStatic : Internal.Utilities.StructuredFormat.Layout
      val keywordMember : Internal.Utilities.StructuredFormat.Layout
      val keywordVal : Internal.Utilities.StructuredFormat.Layout
      val keywordEvent : Internal.Utilities.StructuredFormat.Layout
      val keywordWith : Internal.Utilities.StructuredFormat.Layout
      val keywordSet : Internal.Utilities.StructuredFormat.Layout
      val keywordGet : Internal.Utilities.StructuredFormat.Layout
      val keywordTrue : Internal.Utilities.StructuredFormat.Layout
      val keywordFalse : Internal.Utilities.StructuredFormat.Layout
      val bar : Internal.Utilities.StructuredFormat.Layout
      val keywordStruct : Internal.Utilities.StructuredFormat.Layout
      val keywordInherit : Internal.Utilities.StructuredFormat.Layout
      val keywordEnd : Internal.Utilities.StructuredFormat.Layout
      val keywordNested : Internal.Utilities.StructuredFormat.Layout
      val keywordType : Internal.Utilities.StructuredFormat.Layout
      val keywordDelegate : Internal.Utilities.StructuredFormat.Layout
      val keywordOf : Internal.Utilities.StructuredFormat.Layout
      val keywordInternal : Internal.Utilities.StructuredFormat.Layout
      val keywordPrivate : Internal.Utilities.StructuredFormat.Layout
      val keywordAbstract : Internal.Utilities.StructuredFormat.Layout
      val keywordOverride : Internal.Utilities.StructuredFormat.Layout
      val keywordEnum : Internal.Utilities.StructuredFormat.Layout
    end
    module LeftL = begin
      val leftParen : Internal.Utilities.StructuredFormat.Layout
      val questionMark : Internal.Utilities.StructuredFormat.Layout
      val colon : Internal.Utilities.StructuredFormat.Layout
      val leftBracketAngle : Internal.Utilities.StructuredFormat.Layout
      val leftBracketBar : Internal.Utilities.StructuredFormat.Layout
      val keywordTypeof : Internal.Utilities.StructuredFormat.Layout
      val keywordTypedefof : Internal.Utilities.StructuredFormat.Layout
    end
    module RightL = begin
      val comma : Internal.Utilities.StructuredFormat.Layout
      val rightParen : Internal.Utilities.StructuredFormat.Layout
      val colon : Internal.Utilities.StructuredFormat.Layout
      val rightBracket : Internal.Utilities.StructuredFormat.Layout
      val rightAngle : Internal.Utilities.StructuredFormat.Layout
      val rightBracketAngle : Internal.Utilities.StructuredFormat.Layout
      val rightBracketBar : Internal.Utilities.StructuredFormat.Layout
    end
    val aboveL :
      Internal.Utilities.StructuredFormat.Layout ->
        Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
    val tagAttrL :
      str:string ->
        attrs:(string * string) list ->
          ly:Internal.Utilities.StructuredFormat.Layout ->
            Internal.Utilities.StructuredFormat.Layout
    val apply2 :
      f:(Internal.Utilities.StructuredFormat.Layout ->
           Internal.Utilities.StructuredFormat.Layout ->
           Internal.Utilities.StructuredFormat.Layout) ->
        l:Internal.Utilities.StructuredFormat.Layout ->
          r:Internal.Utilities.StructuredFormat.Layout ->
            Internal.Utilities.StructuredFormat.Layout
    val ( ^^ ) :
      Internal.Utilities.StructuredFormat.Layout ->
        Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
    val ( ++ ) :
      Internal.Utilities.StructuredFormat.Layout ->
        Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
    val ( -- ) :
      Internal.Utilities.StructuredFormat.Layout ->
        Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
    val ( --- ) :
      Internal.Utilities.StructuredFormat.Layout ->
        Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
    val ( ---- ) :
      Internal.Utilities.StructuredFormat.Layout ->
        Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
    val ( ----- ) :
      Internal.Utilities.StructuredFormat.Layout ->
        Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
    val ( @@ ) :
      Internal.Utilities.StructuredFormat.Layout ->
        Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
    val ( @@- ) :
      Internal.Utilities.StructuredFormat.Layout ->
        Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
    val ( @@-- ) :
      Internal.Utilities.StructuredFormat.Layout ->
        Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
    val tagListL :
      tagger:(Internal.Utilities.StructuredFormat.Layout ->
                Internal.Utilities.StructuredFormat.Layout) ->
        _arg1:Internal.Utilities.StructuredFormat.Layout list ->
          Internal.Utilities.StructuredFormat.Layout
    val commaListL :
      Internal.Utilities.StructuredFormat.Layout list ->
        Internal.Utilities.StructuredFormat.Layout
    val semiListL :
      Internal.Utilities.StructuredFormat.Layout list ->
        Internal.Utilities.StructuredFormat.Layout
    val spaceListL :
      Internal.Utilities.StructuredFormat.Layout list ->
        Internal.Utilities.StructuredFormat.Layout
    val sepListL :
      Internal.Utilities.StructuredFormat.Layout ->
        Internal.Utilities.StructuredFormat.Layout list ->
          Internal.Utilities.StructuredFormat.Layout
    val bracketL :
      Internal.Utilities.StructuredFormat.Layout ->
        Internal.Utilities.StructuredFormat.Layout
    val tupleL :
      Internal.Utilities.StructuredFormat.Layout list ->
        Internal.Utilities.StructuredFormat.Layout
    val aboveListL :
      Internal.Utilities.StructuredFormat.Layout list ->
        Internal.Utilities.StructuredFormat.Layout
    val optionL :
      ('a -> Internal.Utilities.StructuredFormat.Layout) ->
        'a option -> Internal.Utilities.StructuredFormat.Layout
    val listL :
      ('a -> Internal.Utilities.StructuredFormat.Layout) ->
        'a list -> Internal.Utilities.StructuredFormat.Layout
    type LayoutRenderer<'a,'b> =
      interface
        abstract member AddBreak : 'b -> int -> 'b
        abstract member
          AddTag : 'b -> string * (string * string) list * bool -> 'b
        abstract member AddText : 'b -> TaggedText -> 'b
        abstract member Finish : 'b -> 'a
        abstract member Start : unit -> 'b
      end
    val renderL :
      LayoutRenderer<'b,'a> -> Internal.Utilities.StructuredFormat.Layout -> 'b
    val stringR : LayoutRenderer<string,string list>
    type NoState = | NoState
    type NoResult = | NoResult
    val taggedTextListR :
      collector:(TaggedText -> unit) -> LayoutRenderer<NoResult,NoState>
    val channelR : System.IO.TextWriter -> LayoutRenderer<NoResult,NoState>
    val bufferR : System.Text.StringBuilder -> LayoutRenderer<NoResult,NoState>
    val showL : Internal.Utilities.StructuredFormat.Layout -> string
    val outL :
      System.IO.TextWriter -> Internal.Utilities.StructuredFormat.Layout -> unit
    val bufferL :
      System.Text.StringBuilder ->
        Internal.Utilities.StructuredFormat.Layout -> unit
  end

namespace FSharp.Compiler
  module XmlDoc = begin
    [<ClassAttribute (); RequireQualifiedAccessAttribute ()>]
    type XmlDoc =
      class
        new : unprocessedLines:string [] * range:Range.range -> XmlDoc
        static member Merge : doc1:XmlDoc -> doc2:XmlDoc -> XmlDoc
        member Check : paramNamesOpt:string list option -> unit
        member GetElaboratedXmlLines : unit -> string []
        member GetXmlText : unit -> string
        member IsEmpty : bool
        member NonEmpty : bool
        member Range : Range.range
        member UnprocessedLines : string []
        static member Empty : XmlDoc
      end
    and XmlDocStatics =
      class
        new : unit -> XmlDocStatics
        static member Empty : XmlDoc
      end
    type XmlDocCollector =
      class
        new : unit -> XmlDocCollector
        member AddGrabPoint : pos:Range.pos -> unit
        member AddXmlDocLine : line:string * range:Range.range -> unit
        member LinesBefore : grabPointPos:Range.pos -> (string * Range.range) []
      end
    type PreXmlDoc =
      | PreXmlMerge of PreXmlDoc * PreXmlDoc
      | PreXmlDoc of Range.pos * XmlDocCollector
      | PreXmlDocEmpty
      with
        static member
          CreateFromGrabPoint : collector:XmlDocCollector *
                                grabPointPos:Range.pos -> PreXmlDoc
        static member Merge : a:PreXmlDoc -> b:PreXmlDoc -> PreXmlDoc
        member
          ToXmlDoc : check:bool * paramNamesOpt:string list option -> XmlDoc
        static member Empty : PreXmlDoc
      end
  end

namespace FSharp.Compiler
  module SyntaxTree = begin
    [<StructAttribute (); NoEqualityAttribute (); NoComparisonAttribute ();
      System.Diagnostics.DebuggerDisplay ("{idText}")>]
    type Ident =
      struct
        new : text:string * range:Range.range -> Ident
        override ToString : unit -> string
        member idRange : Range.range
        member idText : string
      end
    and LongIdent = Ident list
    and LongIdentWithDots =
      | LongIdentWithDots of id: LongIdent * dotms: Range.range list
      with
        member Lid : LongIdent
        member Range : Range.range
        member RangeSansAnyExtraDot : Range.range
        member ThereIsAnExtraDotAtTheEnd : bool
      end
    [<RequireQualifiedAccessAttribute ()>]
    and ParserDetail =
      | Ok
      | ErrorRecovery
    and TyparStaticReq =
      | NoStaticReq
      | HeadTypeStaticReq
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynTypar =
      | Typar of ident: Ident * staticReq: TyparStaticReq * isCompGen: bool
      with
        member Range : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynConst =
      | Unit
      | Bool of bool
      | SByte of sbyte
      | Byte of byte
      | Int16 of int16
      | UInt16 of uint16
      | Int32 of int32
      | UInt32 of uint32
      | Int64 of int64
      | UInt64 of uint64
      | IntPtr of int64
      | UIntPtr of uint64
      | Single of single
      | Double of double
      | Char of char
      | Decimal of System.Decimal
      | UserNum of value: string * suffix: string
      | String of text: string * range: Range.range
      | Bytes of bytes: byte [] * range: Range.range
      | UInt16s of uint16 []
      | Measure of constant: SynConst * SynMeasure
      with
        member Range : dflt:Range.range -> Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynMeasure =
      | Named of longId: LongIdent * range: Range.range
      | Product of SynMeasure * SynMeasure * range: Range.range
      | Seq of SynMeasure list * range: Range.range
      | Divide of SynMeasure * SynMeasure * range: Range.range
      | Power of SynMeasure * SynRationalConst * range: Range.range
      | One
      | Anon of range: Range.range
      | Var of SynTypar * range: Range.range
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynRationalConst =
      | Integer of int32
      | Rational of int32 * int32 * range: Range.range
      | Negate of SynRationalConst
    [<RequireQualifiedAccessAttribute ()>]
    and SynAccess =
      | Public
      | Internal
      | Private
      with
        override ToString : unit -> string
      end
    [<RequireQualifiedAccessAttribute ()>]
    and DebugPointForTarget =
      | Yes
      | No
    [<RequireQualifiedAccessAttribute ()>]
    and DebugPointAtSequential =
      | Both
      | StmtOnly
      | ExprOnly
    [<RequireQualifiedAccessAttribute ()>]
    and DebugPointAtTry =
      | Yes of range: Range.range
      | Body
      | No
    [<RequireQualifiedAccessAttribute ()>]
    and DebugPointAtWith =
      | Yes of range: Range.range
      | No
    [<RequireQualifiedAccessAttribute ()>]
    and DebugPointAtFinally =
      | Yes of range: Range.range
      | No
    [<RequireQualifiedAccessAttribute ()>]
    and DebugPointAtFor =
      | Yes of range: Range.range
      | No
    [<RequireQualifiedAccessAttribute ()>]
    and DebugPointAtWhile =
      | Yes of range: Range.range
      | No
    and DebugPointForBinding =
      | DebugPointAtBinding of range: Range.range
      | NoDebugPointAtDoBinding
      | NoDebugPointAtLetBinding
      | NoDebugPointAtStickyBinding
      | NoDebugPointAtInvisibleBinding
      with
        member Combine : y:DebugPointForBinding -> DebugPointForBinding
      end
    and SeqExprOnly = | SeqExprOnly of bool
    and BlockSeparator = Range.range * Range.pos option
    and RecordFieldName = LongIdentWithDots * bool
    and ExprAtomicFlag =
      | Atomic = 0
      | NonAtomic = 1
    and SynBindingKind =
      | StandaloneExpression
      | NormalBinding
      | DoBinding
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynTyparDecl = | TyparDecl of attributes: SynAttributes * SynTypar
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynTypeConstraint =
      | WhereTyparIsValueType of typar: SynTypar * range: Range.range
      | WhereTyparIsReferenceType of typar: SynTypar * range: Range.range
      | WhereTyparIsUnmanaged of typar: SynTypar * range: Range.range
      | WhereTyparSupportsNull of typar: SynTypar * range: Range.range
      | WhereTyparIsComparable of typar: SynTypar * range: Range.range
      | WhereTyparIsEquatable of typar: SynTypar * range: Range.range
      | WhereTyparDefaultsToType of
        typar: SynTypar * typeName: SynType * range: Range.range
      | WhereTyparSubtypeOfType of
        typar: SynTypar * typeName: SynType * range: Range.range
      | WhereTyparSupportsMember of
        typars: SynType list * memberSig: SynMemberSig * range: Range.range
      | WhereTyparIsEnum of
        typar: SynTypar * typeArgs: SynType list * range: Range.range
      | WhereTyparIsDelegate of
        typar: SynTypar * typeArgs: SynType list * range: Range.range
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynType =
      | LongIdent of longDotId: LongIdentWithDots
      | App of
        typeName: SynType * lessRange: Range.range option *
        typeArgs: SynType list * commaRanges: Range.range list *
        greaterRange: Range.range option * isPostfix: bool * range: Range.range
      | LongIdentApp of
        typeName: SynType * longDotId: LongIdentWithDots *
        lessRange: Range.range option * typeArgs: SynType list *
        commaRanges: Range.range list * greaterRange: Range.range option *
        range: Range.range
      | Tuple of
        isStruct: bool * elementTypes: (bool * SynType) list *
        range: Range.range
      | AnonRecd of
        isStruct: bool * fields: (Ident * SynType) list * range: Range.range
      | Array of rank: int * elementType: SynType * range: Range.range
      | Fun of argType: SynType * returnType: SynType * range: Range.range
      | Var of typar: SynTypar * range: Range.range
      | Anon of range: Range.range
      | WithGlobalConstraints of
        typeName: SynType * constraints: SynTypeConstraint list *
        range: Range.range
      | HashConstraint of innerType: SynType * range: Range.range
      | MeasureDivide of
        dividend: SynType * divisor: SynType * range: Range.range
      | MeasurePower of
        baseMeasure: SynType * exponent: SynRationalConst * range: Range.range
      | StaticConstant of constant: SynConst * range: Range.range
      | StaticConstantExpr of expr: SynExpr * range: Range.range
      | StaticConstantNamed of
        ident: SynType * value: SynType * range: Range.range
      | Paren of innerType: SynType * range: Range.range
      with
        member Range : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynExpr =
      | Paren of
        expr: SynExpr * leftParenRange: Range.range *
        rightParenRange: Range.range option * range: Range.range
      | Quote of
        operator: SynExpr * isRaw: bool * quotedExpr: SynExpr *
        isFromQueryExpression: bool * range: Range.range
      | Const of constant: SynConst * range: Range.range
      | Typed of expr: SynExpr * targetType: SynType * range: Range.range
      | Tuple of
        isStruct: bool * exprs: SynExpr list * commaRanges: Range.range list *
        range: Range.range
      | AnonRecd of
        isStruct: bool * copyInfo: (SynExpr * BlockSeparator) option *
        recordFields: (Ident * SynExpr) list * range: Range.range
      | ArrayOrList of isList: bool * exprs: SynExpr list * range: Range.range
      | Record of
        baseInfo:
          (SynType * SynExpr * Range.range * BlockSeparator option * Range.range) option *
        copyInfo: (SynExpr * BlockSeparator) option *
        recordFields:
          (RecordFieldName * SynExpr option * BlockSeparator option) list *
        range: Range.range
      | New of
        isProtected: bool * targetType: SynType * expr: SynExpr *
        range: Range.range
      | ObjExpr of
        objType: SynType * argOptions: (SynExpr * Ident option) option *
        bindings: SynBinding list * extraImpls: SynInterfaceImpl list *
        newExprRange: Range.range * range: Range.range
      | While of
        whileSeqPoint: DebugPointAtWhile * whileExpr: SynExpr * doExpr: SynExpr *
        range: Range.range
      | For of
        forSeqPoint: DebugPointAtFor * ident: Ident * identBody: SynExpr *
        direction: bool * toBody: SynExpr * doBody: SynExpr * range: Range.range
      | ForEach of
        forSeqPoint: DebugPointAtFor * seqExprOnly: SeqExprOnly *
        isFromSource: bool * pat: SynPat * enumExpr: SynExpr * bodyExpr: SynExpr *
        range: Range.range
      | ArrayOrListOfSeqExpr of
        isArray: bool * expr: SynExpr * range: Range.range
      | CompExpr of
        isArrayOrList: bool * isNotNakedRefCell: bool ref * expr: SynExpr *
        range: Range.range
      | Lambda of
        fromMethod: bool * inLambdaSeq: bool * args: SynSimplePats *
        body: SynExpr * parsedData: (SynPat list * SynExpr) option *
        range: Range.range
      | MatchLambda of
        isExnMatch: bool * keywordRange: Range.range *
        matchClauses: SynMatchClause list * matchSeqPoint: DebugPointForBinding *
        range: Range.range
      | Match of
        matchSeqPoint: DebugPointForBinding * expr: SynExpr *
        clauses: SynMatchClause list * range: Range.range
      | Do of expr: SynExpr * range: Range.range
      | Assert of expr: SynExpr * range: Range.range
      | App of
        flag: ExprAtomicFlag * isInfix: bool * funcExpr: SynExpr *
        argExpr: SynExpr * range: Range.range
      | TypeApp of
        expr: SynExpr * lessRange: Range.range * typeArgs: SynType list *
        commaRanges: Range.range list * greaterRange: Range.range option *
        typeArgsRange: Range.range * range: Range.range
      | LetOrUse of
        isRecursive: bool * isUse: bool * bindings: SynBinding list *
        body: SynExpr * range: Range.range
      | TryWith of
        tryExpr: SynExpr * tryRange: Range.range *
        withCases: SynMatchClause list * withRange: Range.range *
        range: Range.range * trySeqPoint: DebugPointAtTry *
        withSeqPoint: DebugPointAtWith
      | TryFinally of
        tryExpr: SynExpr * finallyExpr: SynExpr * range: Range.range *
        trySeqPoint: DebugPointAtTry * finallySeqPoint: DebugPointAtFinally
      | Lazy of expr: SynExpr * range: Range.range
      | Sequential of
        seqPoint: DebugPointAtSequential * isTrueSeq: bool * expr1: SynExpr *
        expr2: SynExpr * range: Range.range
      | IfThenElse of
        ifExpr: SynExpr * thenExpr: SynExpr * elseExpr: SynExpr option *
        spIfToThen: DebugPointForBinding * isFromErrorRecovery: bool *
        ifToThenRange: Range.range * range: Range.range
      | Ident of ident: Ident
      | LongIdent of
        isOptional: bool * longDotId: LongIdentWithDots *
        altNameRefCell: SynSimplePatAlternativeIdInfo ref option *
        range: Range.range
      | LongIdentSet of
        longDotId: LongIdentWithDots * expr: SynExpr * range: Range.range
      | DotGet of
        expr: SynExpr * rangeOfDot: Range.range * longDotId: LongIdentWithDots *
        range: Range.range
      | DotSet of
        targetExpr: SynExpr * longDotId: LongIdentWithDots * rhsExpr: SynExpr *
        range: Range.range
      | Set of targetExpr: SynExpr * rhsExpr: SynExpr * range: Range.range
      | DotIndexedGet of
        objectExpr: SynExpr * indexExprs: SynIndexerArg list *
        dotRange: Range.range * range: Range.range
      | DotIndexedSet of
        objectExpr: SynExpr * indexExprs: SynIndexerArg list *
        valueExpr: SynExpr * leftOfSetRange: Range.range * dotRange: Range.range *
        range: Range.range
      | NamedIndexedPropertySet of
        longDotId: LongIdentWithDots * expr1: SynExpr * expr2: SynExpr *
        range: Range.range
      | DotNamedIndexedPropertySet of
        targetExpr: SynExpr * longDotId: LongIdentWithDots * argExpr: SynExpr *
        rhsExpr: SynExpr * range: Range.range
      | TypeTest of expr: SynExpr * targetType: SynType * range: Range.range
      | Upcast of expr: SynExpr * targetType: SynType * range: Range.range
      | Downcast of expr: SynExpr * targetType: SynType * range: Range.range
      | InferredUpcast of expr: SynExpr * range: Range.range
      | InferredDowncast of expr: SynExpr * range: Range.range
      | Null of range: Range.range
      | AddressOf of
        isByref: bool * expr: SynExpr * opRange: Range.range *
        range: Range.range
      | TraitCall of
        supportTys: SynTypar list * traitSig: SynMemberSig * argExpr: SynExpr *
        range: Range.range
      | JoinIn of
        lhsExpr: SynExpr * lhsRange: Range.range * rhsExpr: SynExpr *
        range: Range.range
      | ImplicitZero of range: Range.range
      | SequentialOrImplicitYield of
        seqPoint: DebugPointAtSequential * expr1: SynExpr * expr2: SynExpr *
        ifNotStmt: SynExpr * range: Range.range
      | YieldOrReturn of flags: bool * bool * expr: SynExpr * range: Range.range
      | YieldOrReturnFrom of
        flags: bool * bool * expr: SynExpr * range: Range.range
      | LetOrUseBang of
        bindSeqPoint: DebugPointForBinding * isUse: bool * isFromSource: bool *
        pat: SynPat * rhs: SynExpr *
        andBangs:
          (DebugPointForBinding * bool * bool * SynPat * SynExpr * Range.range) list *
        body: SynExpr * range: Range.range
      | MatchBang of
        matchSeqPoint: DebugPointForBinding * expr: SynExpr *
        clauses: SynMatchClause list * range: Range.range
      | DoBang of expr: SynExpr * range: Range.range
      | LibraryOnlyILAssembly of
        ilCode: AbstractIL.IL.ILInstr array * typeArgs: SynType list *
        args: SynExpr list * retTy: SynType list * range: Range.range
      | LibraryOnlyStaticOptimization of
        constraints: SynStaticOptimizationConstraint list * expr: SynExpr *
        optimizedExpr: SynExpr * range: Range.range
      | LibraryOnlyUnionCaseFieldGet of
        expr: SynExpr * longId: LongIdent * fieldNum: int * range: Range.range
      | LibraryOnlyUnionCaseFieldSet of
        expr: SynExpr * longId: LongIdent * fieldNum: int * rhsExpr: SynExpr *
        range: Range.range
      | ArbitraryAfterError of debugStr: string * range: Range.range
      | FromParseError of expr: SynExpr * range: Range.range
      | DiscardAfterMissingQualificationAfterDot of
        expr: SynExpr * range: Range.range
      | Fixed of expr: SynExpr * range: Range.range
      | InterpolatedString of
        contents: SynInterpolatedStringPart list * range: Range.range
      with
        member IsArbExprAndThusAlreadyReportedError : bool
        member Range : Range.range
        member RangeOfFirstPortion : Range.range
        member RangeSansAnyExtraDot : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynInterpolatedStringPart =
      | String of string * Range.range
      | FillExpr of SynExpr * Ident option
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynIndexerArg =
      | Two of
        expr1: SynExpr * fromEnd1: bool * expr2: SynExpr * fromEnd2: bool *
        range1: Range.range * range2: Range.range
      | One of expr: SynExpr * fromEnd: bool * Range.range
      with
        member Exprs : SynExpr list
        member Range : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynSimplePat =
      | Id of
        ident: Ident * altNameRefCell: SynSimplePatAlternativeIdInfo ref option *
        isCompilerGenerated: bool * isThisVar: bool * isOptArg: bool *
        range: Range.range
      | Typed of pat: SynSimplePat * targetType: SynType * range: Range.range
      | Attrib of
        pat: SynSimplePat * attributes: SynAttributes * range: Range.range
    and SynSimplePatAlternativeIdInfo =
      | Undecided of Ident
      | Decided of Ident
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynStaticOptimizationConstraint =
      | WhenTyparTyconEqualsTycon of
        typar: SynTypar * rhsType: SynType * range: Range.range
      | WhenTyparIsStruct of typar: SynTypar * range: Range.range
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynSimplePats =
      | SimplePats of pats: SynSimplePat list * range: Range.range
      | Typed of pats: SynSimplePats * targetType: SynType * range: Range.range
    and SynArgPats =
      | Pats of pats: SynPat list
      | NamePatPairs of pats: (Ident * SynPat) list * range: Range.range
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynPat =
      | Const of constant: SynConst * range: Range.range
      | Wild of range: Range.range
      | Named of
        pat: SynPat * ident: Ident * isSelfIdentifier: bool *
        accessibility: SynAccess option * range: Range.range
      | Typed of pat: SynPat * targetType: SynType * range: Range.range
      | Attrib of pat: SynPat * attributes: SynAttributes * range: Range.range
      | Or of lhsPat: SynPat * rhsPat: SynPat * range: Range.range
      | Ands of pats: SynPat list * range: Range.range
      | LongIdent of
        longDotId: LongIdentWithDots * extraId: Ident option *
        typarDecls: SynValTyparDecls option * argPats: SynArgPats *
        accessibility: SynAccess option * range: Range.range
      | Tuple of isStruct: bool * elementPats: SynPat list * range: Range.range
      | Paren of pat: SynPat * range: Range.range
      | ArrayOrList of
        isArray: bool * elementPats: SynPat list * range: Range.range
      | Record of
        fieldPats: ((LongIdent * Ident) * SynPat) list * range: Range.range
      | Null of range: Range.range
      | OptionalVal of ident: Ident * range: Range.range
      | IsInst of pat: SynType * range: Range.range
      | QuoteExpr of expr: SynExpr * range: Range.range
      | DeprecatedCharRange of
        startChar: char * endChar: char * range: Range.range
      | InstanceMember of
        thisId: Ident * memberId: Ident * toolingId: Ident option *
        accessibility: SynAccess option * range: Range.range
      | FromParseError of pat: SynPat * range: Range.range
      with
        member Range : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynInterfaceImpl =
      | InterfaceImpl of SynType * SynBinding list * range: Range.range
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynMatchClause =
      | Clause of
        pat: SynPat * whenExpr: SynExpr option * resultExpr: SynExpr *
        range: Range.range * spInfo: DebugPointForTarget
      with
        member Range : Range.range
        member RangeOfGuardAndRhs : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynAttribute =
      { TypeName: LongIdentWithDots
        ArgExpr: SynExpr
        Target: Ident option
        AppliesToGetterAndSetter: bool
        Range: Range.range }
    and SynAttributeList =
      { Attributes: SynAttribute list
        Range: Range.range }
    and SynAttributes = SynAttributeList list
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynValData =
      | SynValData of MemberFlags option * SynValInfo * Ident option
      with
        member SynValInfo : SynValInfo
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynBinding =
      | Binding of
        accessibility: SynAccess option * kind: SynBindingKind *
        mustInline: bool * isMutable: bool * attributes: SynAttributes *
        xmlDoc: XmlDoc.PreXmlDoc * valData: SynValData * headPat: SynPat *
        returnInfo: SynBindingReturnInfo option * expr: SynExpr *
        range: Range.range * seqPoint: DebugPointForBinding
      with
        member RangeOfBindingAndRhs : Range.range
        member RangeOfBindingSansRhs : Range.range
        member RangeOfHeadPat : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynBindingReturnInfo =
      | SynBindingReturnInfo of
        typeName: SynType * range: Range.range * attributes: SynAttributes
    [<NoComparisonAttribute ()>]
    and MemberFlags =
      { IsInstance: bool
        IsDispatchSlot: bool
        IsOverrideOrExplicitImpl: bool
        IsFinal: bool
        MemberKind: MemberKind }
    [<StructuralEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and MemberKind =
      | ClassConstructor
      | Constructor
      | Member
      | PropertyGet
      | PropertySet
      | PropertyGetSet
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynMemberSig =
      | Member of memberSig: SynValSig * flags: MemberFlags * range: Range.range
      | Interface of interfaceType: SynType * range: Range.range
      | Inherit of inheritedType: SynType * range: Range.range
      | ValField of field: SynField * range: Range.range
      | NestedType of nestedType: SynTypeDefnSig * range: Range.range
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynTypeDefnKind =
      | TyconUnspecified
      | TyconClass
      | TyconInterface
      | TyconStruct
      | TyconRecord
      | TyconUnion
      | TyconAbbrev
      | TyconHiddenRepr
      | TyconAugmentation
      | TyconILAssemblyCode
      | TyconDelegate of SynType * SynValInfo
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynTypeDefnSimpleRepr =
      | Union of
        accessibility: SynAccess option * unionCases: SynUnionCase list *
        range: Range.range
      | Enum of cases: SynEnumCase list * range: Range.range
      | Record of
        accessibility: SynAccess option * recordFields: SynField list *
        range: Range.range
      | General of
        kind: SynTypeDefnKind *
        inherits: (SynType * Range.range * Ident option) list *
        slotsigs: (SynValSig * MemberFlags) list * fields: SynField list *
        isConcrete: bool * isIncrClass: bool *
        implicitCtorSynPats: SynSimplePats option * range: Range.range
      | LibraryOnlyILAssembly of
        ilType: AbstractIL.IL.ILType * range: Range.range
      | TypeAbbrev of
        detail: ParserDetail * rhsType: SynType * range: Range.range
      | None of range: Range.range
      | Exception of exnRepr: SynExceptionDefnRepr
      with
        member Range : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynEnumCase =
      | EnumCase of
        attributes: SynAttributes * ident: Ident * SynConst *
        xmldoc: XmlDoc.PreXmlDoc * range: Range.range
      with
        member Range : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynUnionCase =
      | UnionCase of
        attributes: SynAttributes * ident: Ident * caseType: SynUnionCaseType *
        xmlDoc: XmlDoc.PreXmlDoc * accessibility: SynAccess option *
        range: Range.range
      with
        member Range : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynUnionCaseType =
      | UnionCaseFields of cases: SynField list
      | UnionCaseFullType of SynType * SynValInfo
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynTypeDefnSigRepr =
      | ObjectModel of
        kind: SynTypeDefnKind * memberSigs: SynMemberSig list *
        range: Range.range
      | Simple of repr: SynTypeDefnSimpleRepr * range: Range.range
      | Exception of SynExceptionDefnRepr
      with
        member Range : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynTypeDefnSig =
      | TypeDefnSig of
        SynComponentInfo * SynTypeDefnSigRepr * SynMemberSig list *
        range: Range.range
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynField =
      | Field of
        attributes: SynAttributes * isStatic: bool * idOpt: Ident option *
        fieldType: SynType * isMutable: bool * xmlDoc: XmlDoc.PreXmlDoc *
        accessibility: SynAccess option * range: Range.range
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynComponentInfo =
      | ComponentInfo of
        attributes: SynAttributes * typeParams: SynTyparDecl list *
        constraints: SynTypeConstraint list * longId: LongIdent *
        xmlDoc: XmlDoc.PreXmlDoc * preferPostfix: bool *
        accessibility: SynAccess option * range: Range.range
      with
        member Range : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynValSig =
      | ValSpfn of
        attributes: SynAttributes * ident: Ident *
        explicitValDecls: SynValTyparDecls * synType: SynType *
        arity: SynValInfo * isInline: bool * isMutable: bool *
        xmlDoc: XmlDoc.PreXmlDoc * accessibility: SynAccess option *
        synExpr: SynExpr option * range: Range.range
      with
        member RangeOfId : Range.range
        member SynInfo : SynValInfo
        member SynType : SynType
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynValInfo =
      | SynValInfo of
        curriedArgInfos: SynArgInfo list list * returnInfo: SynArgInfo
      with
        member ArgNames : string list
        member CurriedArgInfos : SynArgInfo list list
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynArgInfo =
      | SynArgInfo of
        attributes: SynAttributes * optional: bool * ident: Ident option
      with
        member Ident : Ident option
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynValTyparDecls =
      | SynValTyparDecls of
        typars: SynTyparDecl list * canInfer: bool *
        constraints: SynTypeConstraint list
    and SynReturnInfo =
      | SynReturnInfo of returnType: SynType * SynArgInfo * range: Range.range
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynExceptionDefnRepr =
      | SynExceptionDefnRepr of
        attributes: SynAttributes * caseName: SynUnionCase *
        longId: LongIdent option * xmlDoc: XmlDoc.PreXmlDoc *
        accessibility: SynAccess option * range: Range.range
      with
        member Range : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynExceptionDefn =
      | SynExceptionDefn of
        exnRepr: SynExceptionDefnRepr * members: SynMemberDefns *
        range: Range.range
      with
        member Range : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynTypeDefnRepr =
      | ObjectModel of
        kind: SynTypeDefnKind * members: SynMemberDefns * range: Range.range
      | Simple of simpleRepr: SynTypeDefnSimpleRepr * range: Range.range
      | Exception of exnRepr: SynExceptionDefnRepr
      with
        member Range : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynTypeDefn =
      | TypeDefn of
        typeInfo: SynComponentInfo * typeRepr: SynTypeDefnRepr *
        members: SynMemberDefns * range: Range.range
      with
        member Range : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynMemberDefn =
      | Open of target: SynOpenDeclTarget * range: Range.range
      | Member of memberDefn: SynBinding * range: Range.range
      | ImplicitCtor of
        accessibility: SynAccess option * attributes: SynAttributes *
        ctorArgs: SynSimplePats * selfIdentifier: Ident option *
        doc: XmlDoc.PreXmlDoc * range: Range.range
      | ImplicitInherit of
        inheritType: SynType * inheritArgs: SynExpr * inheritAlias: Ident option *
        range: Range.range
      | LetBindings of
        bindings: SynBinding list * isStatic: bool * isRecursive: bool *
        range: Range.range
      | AbstractSlot of
        slotSig: SynValSig * flags: MemberFlags * range: Range.range
      | Interface of
        interfaceType: SynType * members: SynMemberDefns option *
        range: Range.range
      | Inherit of
        baseType: SynType * asIdent: Ident option * range: Range.range
      | ValField of fieldInfo: SynField * range: Range.range
      | NestedType of
        typeDefn: SynTypeDefn * accessibility: SynAccess option *
        range: Range.range
      | AutoProperty of
        attributes: SynAttributes * isStatic: bool * ident: Ident *
        typeOpt: SynType option * propKind: MemberKind *
        memberFlags: MemberKind -> MemberFlags * xmlDoc: XmlDoc.PreXmlDoc *
        accessibility: SynAccess option * synExpr: SynExpr *
        getSetRange: Range.range option * range: Range.range
      with
        member Range : Range.range
      end
    and SynMemberDefns = SynMemberDefn list
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynModuleDecl =
      | ModuleAbbrev of ident: Ident * longId: LongIdent * range: Range.range
      | NestedModule of
        moduleInfo: SynComponentInfo * isRecursive: bool *
        decls: SynModuleDecl list * isContinuing: bool * range: Range.range
      | Let of
        isRecursive: bool * bindings: SynBinding list * range: Range.range
      | DoExpr of
        spInfo: DebugPointForBinding * expr: SynExpr * range: Range.range
      | Types of typeDefns: SynTypeDefn list * range: Range.range
      | Exception of exnDefn: SynExceptionDefn * range: Range.range
      | Open of target: SynOpenDeclTarget * range: Range.range
      | Attributes of attributes: SynAttributes * range: Range.range
      | HashDirective of hashDirective: ParsedHashDirective * range: Range.range
      | NamespaceFragment of fragment: SynModuleOrNamespace
      with
        member Range : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynOpenDeclTarget =
      | ModuleOrNamespace of longId: LongIdent * range: Range.range
      | Type of typeName: SynType * range: Range.range
      with
        member Range : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynExceptionSig =
      | SynExceptionSig of
        exnRepr: SynExceptionDefnRepr * members: SynMemberSig list *
        range: Range.range
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and SynModuleSigDecl =
      | ModuleAbbrev of ident: Ident * longId: LongIdent * range: Range.range
      | NestedModule of
        moduleInfo: SynComponentInfo * isRecursive: bool *
        moduleDecls: SynModuleSigDecl list * range: Range.range
      | Val of valSig: SynValSig * range: Range.range
      | Types of types: SynTypeDefnSig list * range: Range.range
      | Exception of exnSig: SynExceptionSig * range: Range.range
      | Open of target: SynOpenDeclTarget * range: Range.range
      | HashDirective of hashDirective: ParsedHashDirective * range: Range.range
      | NamespaceFragment of SynModuleOrNamespaceSig
      with
        member Range : Range.range
      end
    [<StructAttribute ()>]
    and SynModuleOrNamespaceKind =
      | NamedModule
      | AnonModule
      | DeclaredNamespace
      | GlobalNamespace
      with
        member IsModule : bool
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynModuleOrNamespace =
      | SynModuleOrNamespace of
        longId: LongIdent * isRecursive: bool * kind: SynModuleOrNamespaceKind *
        decls: SynModuleDecl list * xmlDoc: XmlDoc.PreXmlDoc *
        attribs: SynAttributes * accessibility: SynAccess option *
        range: Range.range
      with
        member Range : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and SynModuleOrNamespaceSig =
      | SynModuleOrNamespaceSig of
        longId: LongIdent * isRecursive: bool * kind: SynModuleOrNamespaceKind *
        decls: SynModuleSigDecl list * xmlDoc: XmlDoc.PreXmlDoc *
        attribs: SynAttributes * accessibility: SynAccess option *
        range: Range.range
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and ParsedHashDirective =
      | ParsedHashDirective of
        ident: string * args: string list * range: Range.range
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and ParsedImplFileFragment =
      | AnonModule of decls: SynModuleDecl list * range: Range.range
      | NamedModule of namedModule: SynModuleOrNamespace
      | NamespaceFragment of
        longId: LongIdent * isRecursive: bool * kind: SynModuleOrNamespaceKind *
        decls: SynModuleDecl list * xmlDoc: XmlDoc.PreXmlDoc *
        attributes: SynAttributes * range: Range.range
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and ParsedSigFileFragment =
      | AnonModule of decls: SynModuleSigDecl list * range: Range.range
      | NamedModule of namedModule: SynModuleOrNamespaceSig
      | NamespaceFragment of
        longId: LongIdent * isRecursive: bool * kind: SynModuleOrNamespaceKind *
        decls: SynModuleSigDecl list * xmlDoc: XmlDoc.PreXmlDoc *
        attributes: SynAttributes * range: Range.range
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and ParsedFsiInteraction =
      | IDefns of defns: SynModuleDecl list * range: Range.range
      | IHash of hashDirective: ParsedHashDirective * range: Range.range
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and ParsedImplFile =
      | ParsedImplFile of
        hashDirectives: ParsedHashDirective list *
        fragments: ParsedImplFileFragment list
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and ParsedSigFile =
      | ParsedSigFile of
        hashDirectives: ParsedHashDirective list *
        fragments: ParsedSigFileFragment list
    [<RequireQualifiedAccessAttribute ()>]
    and ScopedPragma = | WarningOff of range: Range.range * warningNumber: int
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and QualifiedNameOfFile =
      | QualifiedNameOfFile of Ident
      with
        member Id : Ident
        member Range : Range.range
        member Text : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and ParsedImplFileInput =
      | ParsedImplFileInput of
        fileName: string * isScript: bool *
        qualifiedNameOfFile: QualifiedNameOfFile *
        scopedPragmas: ScopedPragma list *
        hashDirectives: ParsedHashDirective list *
        modules: SynModuleOrNamespace list * isLastCompiland: bool * bool
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and ParsedSigFileInput =
      | ParsedSigFileInput of
        fileName: string * qualifiedNameOfFile: QualifiedNameOfFile *
        scopedPragmas: ScopedPragma list *
        hashDirectives: ParsedHashDirective list *
        modules: SynModuleOrNamespaceSig list
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and ParsedInput =
      | ImplFile of ParsedImplFileInput
      | SigFile of ParsedSigFileInput
      with
        member Range : Range.range
      end
  end

namespace FSharp.Compiler
  module SyntaxTreeOps = begin
    [<ClassAttribute ()>]
    type SynArgNameGenerator =
      class
        new : unit -> SynArgNameGenerator
        member New : unit -> string
        member Reset : unit -> unit
      end
    val ident : s:string * r:Range.range -> SyntaxTree.Ident
    val textOfId : id:SyntaxTree.Ident -> string
    val pathOfLid : lid:SyntaxTree.Ident list -> string list
    val arrPathOfLid : lid:SyntaxTree.Ident list -> string []
    val textOfPath : path:seq<string> -> string
    val textOfLid : lid:SyntaxTree.Ident list -> string
    val rangeOfLid : lid:SyntaxTree.Ident list -> Range.range
    val mkSynId : m:Range.range -> s:string -> SyntaxTree.Ident
    val pathToSynLid : m:Range.range -> p:string list -> SyntaxTree.Ident list
    val mkSynIdGet : m:Range.range -> n:string -> SyntaxTree.SynExpr
    val mkSynLidGet :
      m:Range.range -> path:string list -> n:string -> SyntaxTree.SynExpr
    val mkSynIdGetWithAlt :
      m:Range.range ->
        id:SyntaxTree.Ident ->
          altInfo:SyntaxTree.SynSimplePatAlternativeIdInfo ref option ->
            SyntaxTree.SynExpr
    val mkSynSimplePatVar :
      isOpt:bool -> id:SyntaxTree.Ident -> SyntaxTree.SynSimplePat
    val mkSynCompGenSimplePatVar :
      id:SyntaxTree.Ident -> SyntaxTree.SynSimplePat
    val ( |LongOrSingleIdent|_| ) :
      inp:SyntaxTree.SynExpr ->
        (bool * SyntaxTree.LongIdentWithDots *
         SyntaxTree.SynSimplePatAlternativeIdInfo ref option * Range.range) option
    val ( |SingleIdent|_| ) : inp:SyntaxTree.SynExpr -> SyntaxTree.Ident option
    val IsControlFlowExpression : e:SyntaxTree.SynExpr -> bool
    val mkAnonField : ty:SyntaxTree.SynType -> SyntaxTree.SynField
    val mkNamedField :
      ident:SyntaxTree.Ident * ty:SyntaxTree.SynType * m:Range.range ->
        SyntaxTree.SynField
    val mkSynPatVar :
      vis:SyntaxTree.SynAccess option ->
        id:SyntaxTree.Ident -> SyntaxTree.SynPat
    val mkSynThisPatVar : id:SyntaxTree.Ident -> SyntaxTree.SynPat
    val mkSynPatMaybeVar :
      lidwd:SyntaxTree.LongIdentWithDots ->
        vis:SyntaxTree.SynAccess option -> m:Range.range -> SyntaxTree.SynPat
    val ( |SynPatForConstructorDecl|_| ) :
      x:SyntaxTree.SynPat -> SyntaxTree.SynPat option
    val ( |SynPatForNullaryArgs|_| ) : x:SyntaxTree.SynPat -> unit option
    val ( |SynExprErrorSkip| ) : p:SyntaxTree.SynExpr -> SyntaxTree.SynExpr
    val ( |SynExprParen|_| ) :
      e:SyntaxTree.SynExpr ->
        (SyntaxTree.SynExpr * Range.range * Range.range option * Range.range) option
    val ( |SynPatErrorSkip| ) : p:SyntaxTree.SynPat -> SyntaxTree.SynPat
    val SimplePatOfPat :
      synArgNameGenerator:SynArgNameGenerator ->
        p:SyntaxTree.SynPat ->
          SyntaxTree.SynSimplePat *
          (SyntaxTree.SynExpr -> SyntaxTree.SynExpr) option
    val appFunOpt : funOpt:('a -> 'a) option -> x:'a -> 'a
    val composeFunOpt :
      funOpt1:('a -> 'a) option ->
        funOpt2:('a -> 'a) option -> ('a -> 'a) option
    val SimplePatsOfPat :
      synArgNameGenerator:SynArgNameGenerator ->
        p:SyntaxTree.SynPat ->
          SyntaxTree.SynSimplePats *
          (SyntaxTree.SynExpr -> SyntaxTree.SynExpr) option
    val PushPatternToExpr :
      synArgNameGenerator:SynArgNameGenerator ->
        isMember:bool ->
          pat:SyntaxTree.SynPat ->
            rhs:SyntaxTree.SynExpr ->
              SyntaxTree.SynSimplePats * SyntaxTree.SynExpr
    val private isSimplePattern : pat:SyntaxTree.SynPat -> bool
    val PushCurriedPatternsToExpr :
      synArgNameGenerator:SynArgNameGenerator ->
        wholem:Range.range ->
          isMember:bool ->
            pats:SyntaxTree.SynPat list ->
              rhs:SyntaxTree.SynExpr ->
                SyntaxTree.SynSimplePats list * SyntaxTree.SynExpr
    val opNameParenGet : string
    val opNameQMark : string
    val mkSynOperator : opm:Range.range -> oper:string -> SyntaxTree.SynExpr
    val mkSynInfix :
      opm:Range.range ->
        l:SyntaxTree.SynExpr ->
          oper:string -> r:SyntaxTree.SynExpr -> SyntaxTree.SynExpr
    val mkSynBifix :
      m:Range.range ->
        oper:string ->
          x1:SyntaxTree.SynExpr -> x2:SyntaxTree.SynExpr -> SyntaxTree.SynExpr
    val mkSynTrifix :
      m:Range.range ->
        oper:string ->
          x1:SyntaxTree.SynExpr ->
            x2:SyntaxTree.SynExpr -> x3:SyntaxTree.SynExpr -> SyntaxTree.SynExpr
    val mkSynPrefixPrim :
      opm:Range.range ->
        m:Range.range ->
          oper:string -> x:SyntaxTree.SynExpr -> SyntaxTree.SynExpr
    val mkSynPrefix :
      opm:Range.range ->
        m:Range.range ->
          oper:string -> x:SyntaxTree.SynExpr -> SyntaxTree.SynExpr
    val mkSynCaseName : m:Range.range -> n:string -> SyntaxTree.Ident list
    val mkSynApp1 :
      f:SyntaxTree.SynExpr ->
        x1:SyntaxTree.SynExpr -> m:Range.range -> SyntaxTree.SynExpr
    val mkSynApp2 :
      f:SyntaxTree.SynExpr ->
        x1:SyntaxTree.SynExpr ->
          x2:SyntaxTree.SynExpr -> m:Range.range -> SyntaxTree.SynExpr
    val mkSynApp3 :
      f:SyntaxTree.SynExpr ->
        x1:SyntaxTree.SynExpr ->
          x2:SyntaxTree.SynExpr ->
            x3:SyntaxTree.SynExpr -> m:Range.range -> SyntaxTree.SynExpr
    val mkSynApp4 :
      f:SyntaxTree.SynExpr ->
        x1:SyntaxTree.SynExpr ->
          x2:SyntaxTree.SynExpr ->
            x3:SyntaxTree.SynExpr ->
              x4:SyntaxTree.SynExpr -> m:Range.range -> SyntaxTree.SynExpr
    val mkSynApp5 :
      f:SyntaxTree.SynExpr ->
        x1:SyntaxTree.SynExpr ->
          x2:SyntaxTree.SynExpr ->
            x3:SyntaxTree.SynExpr ->
              x4:SyntaxTree.SynExpr ->
                x5:SyntaxTree.SynExpr -> m:Range.range -> SyntaxTree.SynExpr
    val mkSynDotParenSet :
      m:Range.range ->
        a:SyntaxTree.SynExpr ->
          b:SyntaxTree.SynExpr -> c:SyntaxTree.SynExpr -> SyntaxTree.SynExpr
    val mkSynDotBrackGet :
      m:Range.range ->
        mDot:Range.range ->
          a:SyntaxTree.SynExpr ->
            b:SyntaxTree.SynExpr -> fromEnd:bool -> SyntaxTree.SynExpr
    val mkSynQMarkSet :
      m:Range.range ->
        a:SyntaxTree.SynExpr ->
          b:SyntaxTree.SynExpr -> c:SyntaxTree.SynExpr -> SyntaxTree.SynExpr
    val mkSynDotBrackSliceGet :
      m:Range.range ->
        mDot:Range.range ->
          arr:SyntaxTree.SynExpr ->
            sliceArg:SyntaxTree.SynIndexerArg -> SyntaxTree.SynExpr
    val mkSynDotBrackSeqSliceGet :
      m:Range.range ->
        mDot:Range.range ->
          arr:SyntaxTree.SynExpr ->
            argsList:SyntaxTree.SynIndexerArg list -> SyntaxTree.SynExpr
    val mkSynDotParenGet :
      lhsm:Range.range ->
        dotm:Range.range ->
          a:SyntaxTree.SynExpr -> b:SyntaxTree.SynExpr -> SyntaxTree.SynExpr
    val mkSynUnit : m:Range.range -> SyntaxTree.SynExpr
    val mkSynUnitPat : m:Range.range -> SyntaxTree.SynPat
    val mkSynDelay : m:Range.range -> e:SyntaxTree.SynExpr -> SyntaxTree.SynExpr
    val mkSynAssign :
      l:SyntaxTree.SynExpr -> r:SyntaxTree.SynExpr -> SyntaxTree.SynExpr
    val mkSynDot :
      dotm:Range.range ->
        m:Range.range ->
          l:SyntaxTree.SynExpr -> r:SyntaxTree.Ident -> SyntaxTree.SynExpr
    val mkSynDotMissing :
      dotm:Range.range ->
        m:Range.range -> l:SyntaxTree.SynExpr -> SyntaxTree.SynExpr
    val mkSynFunMatchLambdas :
      synArgNameGenerator:SynArgNameGenerator ->
        isMember:bool ->
          wholem:Range.range ->
            ps:SyntaxTree.SynPat list ->
              e:SyntaxTree.SynExpr -> SyntaxTree.SynExpr
    val arbExpr : debugStr:string * range:Range.range -> SyntaxTree.SynExpr
    val unionRangeWithListBy :
      projectRangeFromThing:('a -> Range.range) ->
        m:Range.range -> listOfThing:'a list -> Range.range
    val mkAttributeList :
      attrs:SyntaxTree.SynAttribute list ->
        range:Range.range -> SyntaxTree.SynAttributeList list
    val ConcatAttributesLists :
      attrsLists:SyntaxTree.SynAttributeList list ->
        SyntaxTree.SynAttribute list
    val ( |Attributes| ) :
      synAttributes:SyntaxTree.SynAttributeList list ->
        SyntaxTree.SynAttribute list
    val rangeOfNonNilAttrs : attrs:SyntaxTree.SynAttributes -> Range.range
    val stripParenTypes : synType:SyntaxTree.SynType -> SyntaxTree.SynType
    val ( |StripParenTypes| ) : synType:SyntaxTree.SynType -> SyntaxTree.SynType
    module SynInfo = begin
      val unnamedTopArg1 : SyntaxTree.SynArgInfo
      val unnamedTopArg : SyntaxTree.SynArgInfo list
      val unitArgData : SyntaxTree.SynArgInfo list
      val unnamedRetVal : SyntaxTree.SynArgInfo
      val selfMetadata : SyntaxTree.SynArgInfo list
      val HasNoArgs : SyntaxTree.SynValInfo -> bool
      val IsOptionalArg : SyntaxTree.SynArgInfo -> bool
      val HasOptionalArgs : SyntaxTree.SynValInfo -> bool
      val IncorporateEmptyTupledArgForPropertyGetter :
        SyntaxTree.SynValInfo -> SyntaxTree.SynValInfo
      val IncorporateSelfArg : SyntaxTree.SynValInfo -> SyntaxTree.SynValInfo
      val IncorporateSetterArg : SyntaxTree.SynValInfo -> SyntaxTree.SynValInfo
      val AritiesOfArgs : SyntaxTree.SynValInfo -> int list
      val AttribsOfArgData :
        SyntaxTree.SynArgInfo -> SyntaxTree.SynAttribute list
      val InferSynArgInfoFromSimplePat :
        attribs:SyntaxTree.SynAttributes ->
          p:SyntaxTree.SynSimplePat -> SyntaxTree.SynArgInfo
      val InferSynArgInfoFromSimplePats :
        x:SyntaxTree.SynSimplePats -> SyntaxTree.SynArgInfo list
      val InferSynArgInfoFromPat :
        p:SyntaxTree.SynPat -> SyntaxTree.SynArgInfo list
      val AdjustArgsForUnitElimination :
        infosForArgs:SyntaxTree.SynArgInfo list list ->
          SyntaxTree.SynArgInfo list list
      val AdjustMemberArgs :
        memFlags:SyntaxTree.MemberKind ->
          infosForArgs:'a list list -> 'a list list
      val InferLambdaArgs :
        origRhsExpr:SyntaxTree.SynExpr -> SyntaxTree.SynArgInfo list list
      val InferSynReturnData :
        retInfo:SyntaxTree.SynReturnInfo option -> SyntaxTree.SynArgInfo
      val private emptySynValInfo : SyntaxTree.SynValInfo
      val emptySynValData : SyntaxTree.SynValData
      val InferSynValData :
        memberFlagsOpt:SyntaxTree.MemberFlags option *
        pat:SyntaxTree.SynPat option * retInfo:SyntaxTree.SynReturnInfo option *
        origRhsExpr:SyntaxTree.SynExpr -> SyntaxTree.SynValData
    end
    val mkSynBindingRhs :
      staticOptimizations:(SyntaxTree.SynStaticOptimizationConstraint list *
                           SyntaxTree.SynExpr) list ->
        rhsExpr:SyntaxTree.SynExpr ->
          mRhs:Range.range ->
            retInfo:SyntaxTree.SynReturnInfo option ->
              SyntaxTree.SynExpr * SyntaxTree.SynBindingReturnInfo option
    val mkSynBinding :
      xmlDoc:XmlDoc.PreXmlDoc * headPat:SyntaxTree.SynPat ->
        vis:SyntaxTree.SynAccess option * isInline:bool * isMutable:bool *
        mBind:Range.range * spBind:SyntaxTree.DebugPointForBinding *
        retInfo:SyntaxTree.SynReturnInfo option * origRhsExpr:SyntaxTree.SynExpr *
        mRhs:Range.range *
        staticOptimizations:(SyntaxTree.SynStaticOptimizationConstraint list *
                             SyntaxTree.SynExpr) list *
        attrs:SyntaxTree.SynAttributes *
        memberFlagsOpt:SyntaxTree.MemberFlags option -> SyntaxTree.SynBinding
    val NonVirtualMemberFlags :
      k:SyntaxTree.MemberKind -> SyntaxTree.MemberFlags
    val CtorMemberFlags : SyntaxTree.MemberFlags
    val ClassCtorMemberFlags : SyntaxTree.MemberFlags
    val OverrideMemberFlags : k:SyntaxTree.MemberKind -> SyntaxTree.MemberFlags
    val AbstractMemberFlags : k:SyntaxTree.MemberKind -> SyntaxTree.MemberFlags
    val StaticMemberFlags : k:SyntaxTree.MemberKind -> SyntaxTree.MemberFlags
    val inferredTyparDecls : SyntaxTree.SynValTyparDecls
    val noInferredTypars : SyntaxTree.SynValTyparDecls
    val synExprContainsError : inpExpr:SyntaxTree.SynExpr -> bool
  end

namespace FSharp.Compiler
  module ParseHelpers = begin
    exception SyntaxError of obj * range: Range.range
    exception IndentationProblem of string * Range.range
    val warningStringOfCoords : line:int -> column:int -> string
    val warningStringOfPos : p:Range.pos -> string
    val internal posOfLexPosition :
      p:Internal.Utilities.Text.Lexing.Position -> Range.pos
    val internal mkSynRange :
      p1:Internal.Utilities.Text.Lexing.Position ->
        p2:Internal.Utilities.Text.Lexing.Position -> Range.range
    type internal LexBuffer<'Char> with
      member internal LexemeRange : Range.range
    val internal lhs :
      parseState:Internal.Utilities.Text.Parsing.IParseState -> Range.range
    val internal rhs2 :
      parseState:Internal.Utilities.Text.Parsing.IParseState ->
        i:int -> j:int -> Range.range
    val internal rhs :
      parseState:Internal.Utilities.Text.Parsing.IParseState ->
        i:int -> Range.range
    type internal IParseState with
      member internal SynArgNameGenerator : SyntaxTreeOps.SynArgNameGenerator
    type internal IParseState with
      member internal ResetSynArgNameGenerator : unit -> unit
    module LexbufLocalXmlDocStore = begin
      val private xmlDocKey : string
      val internal ClearXmlDoc : lexbuf:UnicodeLexing.Lexbuf -> unit
      val internal SaveXmlDocLine :
        lexbuf:UnicodeLexing.Lexbuf * lineText:string * range:Range.range ->
          unit
      val internal GrabXmlDocBeforeMarker :
        lexbuf:UnicodeLexing.Lexbuf * markerRange:Range.range ->
          XmlDoc.PreXmlDoc
    end
    type LexerIfdefStackEntry =
      | IfDefIf
      | IfDefElse
    type LexerIfdefStackEntries = (LexerIfdefStackEntry * Range.range) list
    type LexerIfdefStack = LexerIfdefStackEntries
    type LexerEndlineContinuation =
      | Token
      | Skip of int * range: Range.range
    type LexerIfdefExpression =
      | IfdefAnd of LexerIfdefExpression * LexerIfdefExpression
      | IfdefOr of LexerIfdefExpression * LexerIfdefExpression
      | IfdefNot of LexerIfdefExpression
      | IfdefId of string
    val LexerIfdefEval :
      lookup:(string -> bool) -> _arg1:LexerIfdefExpression -> bool
    [<RequireQualifiedAccessAttribute ()>]
    type LexerStringStyle =
      | Verbatim
      | TripleQuote
      | SingleQuote
    [<RequireQualifiedAccessAttribute (); StructAttribute ()>]
    type LexerStringKind =
      { IsByteString: bool
        IsInterpolated: bool
        IsInterpolatedFirst: bool }
      with
        static member ByteString : LexerStringKind
        static member InterpolatedStringFirst : LexerStringKind
        static member InterpolatedStringPart : LexerStringKind
        static member String : LexerStringKind
      end
    type LexerInterpolatedStringNesting =
      (int * LexerStringStyle * Range.range) list
    [<RequireQualifiedAccessAttribute (); NoComparisonAttribute ();
      NoEqualityAttribute ()>]
    type LexerContinuation =
      | Token of
        ifdef: LexerIfdefStackEntries * nesting: LexerInterpolatedStringNesting
      | IfDefSkip of
        ifdef: LexerIfdefStackEntries * nesting: LexerInterpolatedStringNesting *
        int * range: Range.range
      | String of
        ifdef: LexerIfdefStackEntries * nesting: LexerInterpolatedStringNesting *
        style: LexerStringStyle * kind: LexerStringKind * range: Range.range
      | Comment of
        ifdef: LexerIfdefStackEntries * nesting: LexerInterpolatedStringNesting *
        int * range: Range.range
      | SingleLineComment of
        ifdef: LexerIfdefStackEntries * nesting: LexerInterpolatedStringNesting *
        int * range: Range.range
      | StringInComment of
        ifdef: LexerIfdefStackEntries * nesting: LexerInterpolatedStringNesting *
        style: LexerStringStyle * int * range: Range.range
      | MLOnly of
        ifdef: LexerIfdefStackEntries * nesting: LexerInterpolatedStringNesting *
        range: Range.range
      | EndLine of
        ifdef: LexerIfdefStackEntries * nesting: LexerInterpolatedStringNesting *
        LexerEndlineContinuation
      with
        member LexerIfdefStack : LexerIfdefStackEntries
        member LexerInterpStringNesting : LexerInterpolatedStringNesting
        static member Default : LexerContinuation
      end
    and LexCont = LexerContinuation
    val internal internalParseAssemblyCodeInstructions :
      s:string ->
        isFeatureSupported:(Features.LanguageFeature -> bool) ->
          m:Range.range -> AbstractIL.IL.ILInstr []
    val ParseAssemblyCodeInstructions :
      s:string -> m:Range.range -> AbstractIL.IL.ILInstr []
    val internal internalParseAssemblyCodeType :
      s:string ->
        isFeatureSupported:(Features.LanguageFeature -> bool) ->
          m:Range.range -> AbstractIL.IL.ILType
    val ParseAssemblyCodeType :
      s:string -> m:Range.range -> AbstractIL.IL.ILType
  end

namespace FSharp.Compiler
  module internal PPParser = begin
    val dummy : ParseHelpers.LexerIfdefExpression
    val doNothing : 'a -> dflt:'b -> 'b
    val fail :
      ps:Internal.Utilities.Text.Parsing.IParseState ->
        i:int -> int * string -> ParseHelpers.LexerIfdefExpression
    type token =
      | OP_NOT
      | OP_AND
      | OP_OR
      | LPAREN
      | RPAREN
      | PRELUDE
      | EOF
      | ID of string
    type tokenId =
      | TOKEN_OP_NOT
      | TOKEN_OP_AND
      | TOKEN_OP_OR
      | TOKEN_LPAREN
      | TOKEN_RPAREN
      | TOKEN_PRELUDE
      | TOKEN_EOF
      | TOKEN_ID
      | TOKEN_end_of_input
      | TOKEN_error
    type nonTerminalId =
      | NONTERM__startstart
      | NONTERM_start
      | NONTERM_Recover
      | NONTERM_Full
      | NONTERM_Expr
    val tagOfToken : t:token -> int
    val tokenTagToTokenId : tokenIdx:int -> tokenId
    val prodIdxToNonTerminal : prodIdx:int -> nonTerminalId
    val _fsyacc_endOfInputTag : int
    val _fsyacc_tagOfErrorTerminal : int
    val token_to_string : t:token -> string
    val _fsyacc_dataOfToken : t:token -> System.Object
    val _fsyacc_gotos : uint16 []
    val _fsyacc_sparseGotoTableRowOffsets : uint16 []
    val _fsyacc_stateToProdIdxsTableElements : uint16 []
    val _fsyacc_stateToProdIdxsTableRowOffsets : uint16 []
    val _fsyacc_action_rows : int
    val _fsyacc_actionTableElements : uint16 []
    val _fsyacc_actionTableRowOffsets : uint16 []
    val _fsyacc_reductionSymbolCounts : uint16 []
    val _fsyacc_productionToNonTerminalTable : uint16 []
    val _fsyacc_immediateActions : uint16 []
    val _fsyacc_reductions :
      unit -> (Internal.Utilities.Text.Parsing.IParseState -> obj) []
    val tables : unit -> Internal.Utilities.Text.Parsing.Tables<token>
    val engine :
      lexer:(Internal.Utilities.Text.Lexing.LexBuffer<char> -> token) ->
        lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
          startState:int -> obj
    val start :
      lexer:(Internal.Utilities.Text.Lexing.LexBuffer<char> -> token) ->
        lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
          ParseHelpers.LexerIfdefExpression
  end

namespace FSharp.Compiler
  module internal Parser = begin
    val debugPrint : s:string -> unit
    val exprFromParseError : e:SyntaxTree.SynExpr -> SyntaxTree.SynExpr
    val patFromParseError : e:SyntaxTree.SynPat -> SyntaxTree.SynPat
    val mkSynOptionalExpr :
      m:Range.range -> xopt:SyntaxTree.SynExpr option -> SyntaxTree.SynExpr
    val rebindRanges :
      'a * 'b ->
        fields:(('a * 'b) * 'c) list -> lastSep:'c -> ('a * 'b * 'c) list
    val mkUnderscoreRecdField :
      m:Range.range -> SyntaxTree.LongIdentWithDots * bool
    val mkRecdField : lidwd:'a -> 'a * bool
    val mkSynDoBinding :
      vis:'a option * strict:bool * expr:SyntaxTree.SynExpr * m:Range.range ->
        SyntaxTree.SynBinding
    val mkSynDoDecl : e:SyntaxTree.SynExpr -> SyntaxTree.SynModuleDecl
    val addAttribs :
      attrs:SyntaxTree.SynAttributes -> p:SyntaxTree.SynPat -> SyntaxTree.SynPat
    val parse_error_rich :
      (Internal.Utilities.Text.Parsing.ParseErrorContext<'a> -> unit) option
    val reportParseErrorAt : m:Range.range -> int * string -> unit
    val unionRangeWithPos : r:Range.range -> p:Range.pos -> Range.range
    val raiseParseErrorAt : m:Range.range -> int * string -> 'a
    val checkEndOfFileError : t:ParseHelpers.LexerContinuation -> unit
    type BindingSet =
      | BindingSetPreAttrs of
        Range.range * bool * bool *
        (SyntaxTree.SynAttributes -> SyntaxTree.SynAccess option ->
           SyntaxTree.SynAttributes * SyntaxTree.SynBinding list) * Range.range
    val mkClassMemberLocalBindings :
      isStatic:bool * initialRangeOpt:Range.range option *
      attrs:SyntaxTree.SynAttributes * vis:SyntaxTree.SynAccess option *
      BindingSet -> SyntaxTree.SynMemberDefn
    val mkLocalBindings :
      mWhole:Range.range * BindingSet * body:SyntaxTree.SynExpr ->
        SyntaxTree.SynExpr
    val mkDefnBindings :
      mWhole:Range.range * BindingSet * attrs:SyntaxTree.SynAttributes *
      vis:SyntaxTree.SynAccess option * attrsm:Range.range ->
        SyntaxTree.SynModuleDecl list
    val idOfPat :
      parseState:Internal.Utilities.Text.Parsing.IParseState ->
        m:Range.range -> p:SyntaxTree.SynPat -> SyntaxTree.Ident
    val checkForMultipleAugmentations :
      m:Range.range -> a1:'a list -> a2:'a list -> 'a list
    val grabXmlDoc :
      parseState:Internal.Utilities.Text.Parsing.IParseState * elemIdx:int ->
        XmlDoc.PreXmlDoc
    val rangeOfLongIdent : lid:SyntaxTree.LongIdent -> Range.range
    type token =
      | HASH_IF of (Range.range * string * ParseHelpers.LexerContinuation)
      | HASH_ELSE of (Range.range * string * ParseHelpers.LexerContinuation)
      | HASH_ENDIF of (Range.range * string * ParseHelpers.LexerContinuation)
      | COMMENT of ParseHelpers.LexerContinuation
      | WHITESPACE of ParseHelpers.LexerContinuation
      | HASH_LINE of ParseHelpers.LexerContinuation
      | HASH_LIGHT of ParseHelpers.LexerContinuation
      | INACTIVECODE of ParseHelpers.LexerContinuation
      | LINE_COMMENT of ParseHelpers.LexerContinuation
      | STRING_TEXT of ParseHelpers.LexerContinuation
      | EOF of ParseHelpers.LexerContinuation
      | LEX_FAILURE of string
      | ODUMMY of token
      | FIXED
      | OINTERFACE_MEMBER
      | OBLOCKEND
      | OBLOCKEND_COMING_SOON
      | OBLOCKEND_IS_HERE
      | ORIGHT_BLOCK_END
      | ODECLEND
      | OEND
      | OBLOCKSEP
      | OBLOCKBEGIN
      | ORESET
      | OFUN
      | OFUNCTION
      | OWITH
      | OELSE
      | OTHEN
      | ODO_BANG
      | ODO
      | OAND_BANG of bool
      | OBINDER of string
      | OLET of bool
      | HIGH_PRECEDENCE_TYAPP
      | HIGH_PRECEDENCE_PAREN_APP
      | HIGH_PRECEDENCE_BRACK_APP
      | TYPE_COMING_SOON
      | TYPE_IS_HERE
      | MODULE_COMING_SOON
      | MODULE_IS_HERE
      | EXTERN
      | VOID
      | PUBLIC
      | PRIVATE
      | INTERNAL
      | GLOBAL
      | STATIC
      | MEMBER
      | CLASS
      | ABSTRACT
      | OVERRIDE
      | DEFAULT
      | CONSTRUCTOR
      | INHERIT
      | GREATER_RBRACK
      | STRUCT
      | SIG
      | BAR
      | RBRACK
      | RBRACE_COMING_SOON
      | RBRACE_IS_HERE
      | MINUS
      | DOLLAR
      | BAR_RBRACK
      | BAR_RBRACE
      | UNDERSCORE
      | SEMICOLON_SEMICOLON
      | LARROW
      | EQUALS
      | LBRACK
      | LBRACK_BAR
      | LBRACE_BAR
      | LBRACK_LESS
      | QMARK
      | QMARK_QMARK
      | DOT
      | COLON
      | COLON_COLON
      | COLON_GREATER
      | COLON_QMARK_GREATER
      | COLON_QMARK
      | COLON_EQUALS
      | SEMICOLON
      | WHEN
      | WHILE
      | WITH
      | HASH
      | AMP
      | AMP_AMP
      | QUOTE
      | LPAREN
      | RPAREN
      | RPAREN_COMING_SOON
      | RPAREN_IS_HERE
      | STAR
      | COMMA
      | RARROW
      | GREATER_BAR_RBRACK
      | LPAREN_STAR_RPAREN
      | OPEN
      | OR
      | REC
      | THEN
      | TO
      | TRUE
      | TRY
      | TYPE
      | VAL
      | INLINE
      | INTERFACE
      | INSTANCE
      | CONST
      | LAZY
      | OLAZY
      | MATCH
      | MATCH_BANG
      | MUTABLE
      | NEW
      | OF
      | EXCEPTION
      | FALSE
      | FOR
      | FUN
      | FUNCTION
      | IF
      | IN
      | JOIN_IN
      | FINALLY
      | DO_BANG
      | AND
      | AS
      | ASSERT
      | OASSERT
      | ASR
      | BEGIN
      | DO
      | DONE
      | DOWNTO
      | ELSE
      | ELIF
      | END
      | DOT_DOT
      | DOT_DOT_HAT
      | BAR_BAR
      | UPCAST
      | DOWNCAST
      | NULL
      | RESERVED
      | MODULE
      | NAMESPACE
      | DELEGATE
      | CONSTRAINT
      | BASE
      | LQUOTE of (string * bool)
      | RQUOTE of (string * bool)
      | RQUOTE_DOT of (string * bool)
      | PERCENT_OP of string
      | BINDER of string
      | LESS of bool
      | GREATER of bool
      | LET of bool
      | YIELD of bool
      | YIELD_BANG of bool
      | AND_BANG of bool
      | BIGNUM of (string * string)
      | DECIMAL of System.Decimal
      | CHAR of char
      | IEEE64 of double
      | IEEE32 of single
      | UNATIVEINT of uint64
      | UINT64 of uint64
      | UINT32 of uint32
      | UINT16 of uint16
      | UINT8 of byte
      | NATIVEINT of (int64 * bool)
      | INT64 of (int64 * bool)
      | INT32 of (int32 * bool)
      | INT32_DOT_DOT of (int32 * bool)
      | INT16 of (int16 * bool)
      | INT8 of (sbyte * bool)
      | FUNKY_OPERATOR_NAME of string
      | ADJACENT_PREFIX_OP of string
      | PLUS_MINUS_OP of string
      | INFIX_AMP_OP of string
      | INFIX_STAR_DIV_MOD_OP of string
      | PREFIX_OP of string
      | INFIX_BAR_OP of string
      | INFIX_AT_HAT_OP of string
      | INFIX_COMPARE_OP of string
      | INFIX_STAR_STAR_OP of string
      | IDENT of string
      | KEYWORD_STRING of string
      | LBRACE of ParseHelpers.LexerContinuation
      | RBRACE of ParseHelpers.LexerContinuation
      | INTERP_STRING_END of (string * ParseHelpers.LexerContinuation)
      | INTERP_STRING_PART of (string * ParseHelpers.LexerContinuation)
      | INTERP_STRING_BEGIN_PART of (string * ParseHelpers.LexerContinuation)
      | INTERP_STRING_BEGIN_END of (string * ParseHelpers.LexerContinuation)
      | STRING of (string * ParseHelpers.LexerContinuation)
      | BYTEARRAY of (byte [] * ParseHelpers.LexerContinuation)
    type tokenId =
      | TOKEN_HASH_IF
      | TOKEN_HASH_ELSE
      | TOKEN_HASH_ENDIF
      | TOKEN_COMMENT
      | TOKEN_WHITESPACE
      | TOKEN_HASH_LINE
      | TOKEN_HASH_LIGHT
      | TOKEN_INACTIVECODE
      | TOKEN_LINE_COMMENT
      | TOKEN_STRING_TEXT
      | TOKEN_EOF
      | TOKEN_LEX_FAILURE
      | TOKEN_ODUMMY
      | TOKEN_FIXED
      | TOKEN_OINTERFACE_MEMBER
      | TOKEN_OBLOCKEND
      | TOKEN_OBLOCKEND_COMING_SOON
      | TOKEN_OBLOCKEND_IS_HERE
      | TOKEN_ORIGHT_BLOCK_END
      | TOKEN_ODECLEND
      | TOKEN_OEND
      | TOKEN_OBLOCKSEP
      | TOKEN_OBLOCKBEGIN
      | TOKEN_ORESET
      | TOKEN_OFUN
      | TOKEN_OFUNCTION
      | TOKEN_OWITH
      | TOKEN_OELSE
      | TOKEN_OTHEN
      | TOKEN_ODO_BANG
      | TOKEN_ODO
      | TOKEN_OAND_BANG
      | TOKEN_OBINDER
      | TOKEN_OLET
      | TOKEN_HIGH_PRECEDENCE_TYAPP
      | TOKEN_HIGH_PRECEDENCE_PAREN_APP
      | TOKEN_HIGH_PRECEDENCE_BRACK_APP
      | TOKEN_TYPE_COMING_SOON
      | TOKEN_TYPE_IS_HERE
      | TOKEN_MODULE_COMING_SOON
      | TOKEN_MODULE_IS_HERE
      | TOKEN_EXTERN
      | TOKEN_VOID
      | TOKEN_PUBLIC
      | TOKEN_PRIVATE
      | TOKEN_INTERNAL
      | TOKEN_GLOBAL
      | TOKEN_STATIC
      | TOKEN_MEMBER
      | TOKEN_CLASS
      | TOKEN_ABSTRACT
      | TOKEN_OVERRIDE
      | TOKEN_DEFAULT
      | TOKEN_CONSTRUCTOR
      | TOKEN_INHERIT
      | TOKEN_GREATER_RBRACK
      | TOKEN_STRUCT
      | TOKEN_SIG
      | TOKEN_BAR
      | TOKEN_RBRACK
      | TOKEN_RBRACE_COMING_SOON
      | TOKEN_RBRACE_IS_HERE
      | TOKEN_MINUS
      | TOKEN_DOLLAR
      | TOKEN_BAR_RBRACK
      | TOKEN_BAR_RBRACE
      | TOKEN_UNDERSCORE
      | TOKEN_SEMICOLON_SEMICOLON
      | TOKEN_LARROW
      | TOKEN_EQUALS
      | TOKEN_LBRACK
      | TOKEN_LBRACK_BAR
      | TOKEN_LBRACE_BAR
      | TOKEN_LBRACK_LESS
      | TOKEN_QMARK
      | TOKEN_QMARK_QMARK
      | TOKEN_DOT
      | TOKEN_COLON
      | TOKEN_COLON_COLON
      | TOKEN_COLON_GREATER
      | TOKEN_COLON_QMARK_GREATER
      | TOKEN_COLON_QMARK
      | TOKEN_COLON_EQUALS
      | TOKEN_SEMICOLON
      | TOKEN_WHEN
      | TOKEN_WHILE
      | TOKEN_WITH
      | TOKEN_HASH
      | TOKEN_AMP
      | TOKEN_AMP_AMP
      | TOKEN_QUOTE
      | TOKEN_LPAREN
      | TOKEN_RPAREN
      | TOKEN_RPAREN_COMING_SOON
      | TOKEN_RPAREN_IS_HERE
      | TOKEN_STAR
      | TOKEN_COMMA
      | TOKEN_RARROW
      | TOKEN_GREATER_BAR_RBRACK
      | TOKEN_LPAREN_STAR_RPAREN
      | TOKEN_OPEN
      | TOKEN_OR
      | TOKEN_REC
      | TOKEN_THEN
      | TOKEN_TO
      | TOKEN_TRUE
      | TOKEN_TRY
      | TOKEN_TYPE
      | TOKEN_VAL
      | TOKEN_INLINE
      | TOKEN_INTERFACE
      | TOKEN_INSTANCE
      | TOKEN_CONST
      | TOKEN_LAZY
      | TOKEN_OLAZY
      | TOKEN_MATCH
      | TOKEN_MATCH_BANG
      | TOKEN_MUTABLE
      | TOKEN_NEW
      | TOKEN_OF
      | TOKEN_EXCEPTION
      | TOKEN_FALSE
      | TOKEN_FOR
      | TOKEN_FUN
      | TOKEN_FUNCTION
      | TOKEN_IF
      | TOKEN_IN
      | TOKEN_JOIN_IN
      | TOKEN_FINALLY
      | TOKEN_DO_BANG
      | TOKEN_AND
      | TOKEN_AS
      | TOKEN_ASSERT
      | TOKEN_OASSERT
      | TOKEN_ASR
      | TOKEN_BEGIN
      | TOKEN_DO
      | TOKEN_DONE
      | TOKEN_DOWNTO
      | TOKEN_ELSE
      | TOKEN_ELIF
      | TOKEN_END
      | TOKEN_DOT_DOT
      | TOKEN_DOT_DOT_HAT
      | TOKEN_BAR_BAR
      | TOKEN_UPCAST
      | TOKEN_DOWNCAST
      | TOKEN_NULL
      | TOKEN_RESERVED
      | TOKEN_MODULE
      | TOKEN_NAMESPACE
      | TOKEN_DELEGATE
      | TOKEN_CONSTRAINT
      | TOKEN_BASE
      | TOKEN_LQUOTE
      | TOKEN_RQUOTE
      | TOKEN_RQUOTE_DOT
      | TOKEN_PERCENT_OP
      | TOKEN_BINDER
      | TOKEN_LESS
      | TOKEN_GREATER
      | TOKEN_LET
      | TOKEN_YIELD
      | TOKEN_YIELD_BANG
      | TOKEN_AND_BANG
      | TOKEN_BIGNUM
      | TOKEN_DECIMAL
      | TOKEN_CHAR
      | TOKEN_IEEE64
      | TOKEN_IEEE32
      | TOKEN_UNATIVEINT
      | TOKEN_UINT64
      | TOKEN_UINT32
      | TOKEN_UINT16
      | TOKEN_UINT8
      | TOKEN_NATIVEINT
      | TOKEN_INT64
      | TOKEN_INT32
      | TOKEN_INT32_DOT_DOT
      | TOKEN_INT16
      | TOKEN_INT8
      | TOKEN_FUNKY_OPERATOR_NAME
      | TOKEN_ADJACENT_PREFIX_OP
      | TOKEN_PLUS_MINUS_OP
      | TOKEN_INFIX_AMP_OP
      | TOKEN_INFIX_STAR_DIV_MOD_OP
      | TOKEN_PREFIX_OP
      | TOKEN_INFIX_BAR_OP
      | TOKEN_INFIX_AT_HAT_OP
      | TOKEN_INFIX_COMPARE_OP
      | TOKEN_INFIX_STAR_STAR_OP
      | TOKEN_IDENT
      | TOKEN_KEYWORD_STRING
      | TOKEN_LBRACE
      | TOKEN_RBRACE
      | TOKEN_INTERP_STRING_END
      | TOKEN_INTERP_STRING_PART
      | TOKEN_INTERP_STRING_BEGIN_PART
      | TOKEN_INTERP_STRING_BEGIN_END
      | TOKEN_STRING
      | TOKEN_BYTEARRAY
      | TOKEN_end_of_input
      | TOKEN_error
    type nonTerminalId =
      | NONTERM__startsignatureFile
      | NONTERM__startimplementationFile
      | NONTERM__startinteraction
      | NONTERM__starttypedSeqExprEOF
      | NONTERM__starttypEOF
      | NONTERM_interaction
      | NONTERM_interactiveTerminator
      | NONTERM_interactiveItemsTerminator
      | NONTERM_interactiveDefns
      | NONTERM_interactiveExpr
      | NONTERM_interactiveHash
      | NONTERM_interactiveSeparators
      | NONTERM_interactiveSeparator
      | NONTERM_hashDirective
      | NONTERM_hashDirectiveArgs
      | NONTERM_hashDirectiveArg
      | NONTERM_signatureFile
      | NONTERM_moduleIntro
      | NONTERM_namespaceIntro
      | NONTERM_fileNamespaceSpecs
      | NONTERM_fileNamespaceSpecList
      | NONTERM_fileNamespaceSpec
      | NONTERM_fileModuleSpec
      | NONTERM_moduleSpfnsPossiblyEmptyBlock
      | NONTERM_moduleSpfnsPossiblyEmpty
      | NONTERM_moduleSpfns
      | NONTERM_moduleSpfn
      | NONTERM_valSpfn
      | NONTERM_optLiteralValueSpfn
      | NONTERM_moduleSpecBlock
      | NONTERM_tyconSpfns
      | NONTERM_tyconSpfnList
      | NONTERM_tyconSpfn
      | NONTERM_tyconSpfnRhsBlock
      | NONTERM_tyconSpfnRhs
      | NONTERM_tyconClassSpfn
      | NONTERM_classSpfnBlockKindUnspecified
      | NONTERM_classSpfnBlock
      | NONTERM_classSpfnMembers
      | NONTERM_classSpfnMembersAtLeastOne
      | NONTERM_classMemberSpfn
      | NONTERM_classMemberSpfnGetSet
      | NONTERM_classMemberSpfnGetSetElements
      | NONTERM_memberSpecFlags
      | NONTERM_exconSpfn
      | NONTERM_opt_classSpfn
      | NONTERM_implementationFile
      | NONTERM_fileNamespaceImpls
      | NONTERM_fileNamespaceImplList
      | NONTERM_fileNamespaceImpl
      | NONTERM_fileModuleImpl
      | NONTERM_moduleDefnsOrExprPossiblyEmptyOrBlock
      | NONTERM_moduleDefnsOrExprPossiblyEmpty
      | NONTERM_moduleDefnsOrExpr
      | NONTERM_moduleDefns
      | NONTERM_moduleDefnOrDirective
      | NONTERM_moduleDefn
      | NONTERM_openDecl
      | NONTERM_namedModuleAbbrevBlock
      | NONTERM_namedModuleDefnBlock
      | NONTERM_wrappedNamedModuleDefn
      | NONTERM_tyconDefnAugmentation
      | NONTERM_opt_attributes
      | NONTERM_attributes
      | NONTERM_attributeList
      | NONTERM_attributeListElements
      | NONTERM_attribute
      | NONTERM_attributeTarget
      | NONTERM_memberFlags
      | NONTERM_typeNameInfo
      | NONTERM_tyconDefnList
      | NONTERM_tyconDefn
      | NONTERM_tyconDefnRhsBlock
      | NONTERM_tyconDefnRhs
      | NONTERM_tyconClassDefn
      | NONTERM_classDefnBlockKindUnspecified
      | NONTERM_classDefnBlock
      | NONTERM_classDefnMembers
      | NONTERM_classDefnMembersAtLeastOne
      | NONTERM_classDefnMemberGetSet
      | NONTERM_classDefnMemberGetSetElements
      | NONTERM_classDefnMemberGetSetElement
      | NONTERM_memberCore
      | NONTERM_abstractMemberFlags
      | NONTERM_classDefnMember
      | NONTERM_valDefnDecl
      | NONTERM_autoPropsDefnDecl
      | NONTERM_opt_typ
      | NONTERM_atomicPatternLongIdent
      | NONTERM_opt_access
      | NONTERM_access
      | NONTERM_opt_declVisibility
      | NONTERM_opt_interfaceImplDefn
      | NONTERM_opt_classDefn
      | NONTERM_inheritsDefn
      | NONTERM_optAsSpec
      | NONTERM_asSpec
      | NONTERM_optBaseSpec
      | NONTERM_baseSpec
      | NONTERM_objectImplementationBlock
      | NONTERM_objectImplementationMembers
      | NONTERM_objectImplementationMember
      | NONTERM_memberOrOverride
      | NONTERM_tyconDefnOrSpfnSimpleRepr
      | NONTERM_braceFieldDeclList
      | NONTERM_anonRecdType
      | NONTERM_braceBarFieldDeclListCore
      | NONTERM_inlineAssemblyTyconRepr
      | NONTERM_classOrInterfaceOrStruct
      | NONTERM_interfaceMember
      | NONTERM_tyconNameAndTyparDecls
      | NONTERM_prefixTyparDecls
      | NONTERM_typarDeclList
      | NONTERM_typarDecl
      | NONTERM_postfixTyparDecls
      | NONTERM_explicitValTyparDeclsCore
      | NONTERM_explicitValTyparDecls
      | NONTERM_opt_explicitValTyparDecls
      | NONTERM_opt_explicitValTyparDecls2
      | NONTERM_opt_typeConstraints
      | NONTERM_typeConstraints
      | NONTERM_typeConstraint
      | NONTERM_typarAlts
      | NONTERM_unionTypeRepr
      | NONTERM_barAndgrabXmlDoc
      | NONTERM_attrUnionCaseDecls
      | NONTERM_attrUnionCaseDecl
      | NONTERM_unionCaseName
      | NONTERM_firstUnionCaseDeclOfMany
      | NONTERM_firstUnionCaseDecl
      | NONTERM_unionCaseReprElements
      | NONTERM_unionCaseReprElement
      | NONTERM_unionCaseRepr
      | NONTERM_recdFieldDeclList
      | NONTERM_recdFieldDecl
      | NONTERM_fieldDecl
      | NONTERM_exconDefn
      | NONTERM_exceptionAndGrabDoc
      | NONTERM_exconCore
      | NONTERM_exconIntro
      | NONTERM_exconRepr
      | NONTERM_defnBindings
      | NONTERM_doBinding
      | NONTERM_hardwhiteLetBindings
      | NONTERM_hardwhiteDoBinding
      | NONTERM_classDefnBindings
      | NONTERM_hardwhiteDefnBindingsTerminator
      | NONTERM_cPrototype
      | NONTERM_cArgs
      | NONTERM_cMoreArgs
      | NONTERM_cArg
      | NONTERM_cType
      | NONTERM_cRetType
      | NONTERM_localBindings
      | NONTERM_moreLocalBindings
      | NONTERM_attr_localBinding
      | NONTERM_localBinding
      | NONTERM_typedExprWithStaticOptimizationsBlock
      | NONTERM_typedExprWithStaticOptimizations
      | NONTERM_opt_staticOptimizations
      | NONTERM_staticOptimization
      | NONTERM_staticOptimizationConditions
      | NONTERM_staticOptimizationCondition
      | NONTERM_rawConstant
      | NONTERM_rationalConstant
      | NONTERM_atomicUnsignedRationalConstant
      | NONTERM_atomicRationalConstant
      | NONTERM_constant
      | NONTERM_bindingPattern
      | NONTERM_simplePattern
      | NONTERM_simplePatternCommaList
      | NONTERM_simplePatterns
      | NONTERM_headBindingPattern
      | NONTERM_tuplePatternElements
      | NONTERM_conjPatternElements
      | NONTERM_namePatPairs
      | NONTERM_namePatPair
      | NONTERM_constrPattern
      | NONTERM_atomicPatsOrNamePatPairs
      | NONTERM_atomicPatterns
      | NONTERM_atomicPattern
      | NONTERM_parenPatternBody
      | NONTERM_parenPattern
      | NONTERM_tupleParenPatternElements
      | NONTERM_conjParenPatternElements
      | NONTERM_recordPatternElementsAux
      | NONTERM_recordPatternElement
      | NONTERM_listPatternElements
      | NONTERM_typedSeqExprBlock
      | NONTERM_declExprBlock
      | NONTERM_typedSeqExprBlockR
      | NONTERM_typedSeqExpr
      | NONTERM_typedSeqExprEOF
      | NONTERM_seqExpr
      | NONTERM_recover
      | NONTERM_moreBinders
      | NONTERM_declExpr
      | NONTERM_dynamicArg
      | NONTERM_withClauses
      | NONTERM_withPatternClauses
      | NONTERM_patternAndGuard
      | NONTERM_patternClauses
      | NONTERM_patternGuard
      | NONTERM_patternResult
      | NONTERM_ifExprCases
      | NONTERM_ifExprThen
      | NONTERM_ifExprElifs
      | NONTERM_tupleExpr
      | NONTERM_minusExpr
      | NONTERM_appExpr
      | NONTERM_argExpr
      | NONTERM_atomicExpr
      | NONTERM_atomicExprQualification
      | NONTERM_optRangeSeqExpr
      | NONTERM_optRange
      | NONTERM_rangeDeclExpr
      | NONTERM_atomicExprAfterType
      | NONTERM_beginEndExpr
      | NONTERM_quoteExpr
      | NONTERM_arrayExpr
      | NONTERM_parenExpr
      | NONTERM_parenExprBody
      | NONTERM_staticallyKnownHeadTypars
      | NONTERM_staticallyKnownHeadTyparAlts
      | NONTERM_braceExpr
      | NONTERM_braceExprBody
      | NONTERM_listExprElements
      | NONTERM_monadicExprInitial
      | NONTERM_rangeSequenceExpr
      | NONTERM_arrowThenExprR
      | NONTERM_forLoopBinder
      | NONTERM_forLoopRange
      | NONTERM_forLoopDirection
      | NONTERM_inlineAssemblyExpr
      | NONTERM_optCurriedArgExprs
      | NONTERM_opt_atomicExprAfterType
      | NONTERM_opt_inlineAssemblyTypeArg
      | NONTERM_optInlineAssemblyReturnTypes
      | NONTERM_recdExpr
      | NONTERM_recdExprCore
      | NONTERM_opt_seps_recd
      | NONTERM_seps_recd
      | NONTERM_pathOrUnderscore
      | NONTERM_recdExprBindings
      | NONTERM_recdBinding
      | NONTERM_objExpr
      | NONTERM_objExprBaseCall
      | NONTERM_opt_objExprBindings
      | NONTERM_objExprBindings
      | NONTERM_objExprInterfaces
      | NONTERM_opt_objExprInterfaces
      | NONTERM_objExprInterface
      | NONTERM_braceBarExpr
      | NONTERM_braceBarExprCore
      | NONTERM_anonLambdaExpr
      | NONTERM_anonMatchingExpr
      | NONTERM_typeWithTypeConstraints
      | NONTERM_topTypeWithTypeConstraints
      | NONTERM_opt_topReturnTypeWithTypeConstraints
      | NONTERM_topType
      | NONTERM_topTupleType
      | NONTERM_topTupleTypeElements
      | NONTERM_topAppType
      | NONTERM_typ
      | NONTERM_typEOF
      | NONTERM_tupleType
      | NONTERM_tupleOrQuotTypeElements
      | NONTERM_appTypeCon
      | NONTERM_appTypeConPower
      | NONTERM_appType
      | NONTERM_arrayTypeSuffix
      | NONTERM_appTypePrefixArguments
      | NONTERM_typeArgListElements
      | NONTERM_powerType
      | NONTERM_atomTypeNonAtomicDeprecated
      | NONTERM_atomTypeOrAnonRecdType
      | NONTERM_atomType
      | NONTERM_typeArgsNoHpaDeprecated
      | NONTERM_typeArgsActual
      | NONTERM_typeArgActual
      | NONTERM_typeArgActualOrDummyIfEmpty
      | NONTERM_dummyTypeArg
      | NONTERM_measureTypeArg
      | NONTERM_measureTypeAtom
      | NONTERM_measureTypePower
      | NONTERM_measureTypeSeq
      | NONTERM_measureTypeExpr
      | NONTERM_typar
      | NONTERM_staticallyKnownHeadTypar
      | NONTERM_ident
      | NONTERM_path
      | NONTERM_opName
      | NONTERM_operatorName
      | NONTERM_activePatternCaseName
      | NONTERM_activePatternCaseNames
      | NONTERM_identOrOp
      | NONTERM_pathOp
      | NONTERM_nameop
      | NONTERM_identExpr
      | NONTERM_topSeparator
      | NONTERM_topSeparators
      | NONTERM_opt_topSeparators
      | NONTERM_seps
      | NONTERM_declEnd
      | NONTERM_opt_declEnd
      | NONTERM_opt_ODECLEND
      | NONTERM_deprecated_opt_equals
      | NONTERM_opt_equals
      | NONTERM_opt_OBLOCKSEP
      | NONTERM_opt_seps
      | NONTERM_opt_rec
      | NONTERM_opt_bar
      | NONTERM_opt_inline
      | NONTERM_opt_mutable
      | NONTERM_doToken
      | NONTERM_doneDeclEnd
      | NONTERM_structOrBegin
      | NONTERM_sigOrBegin
      | NONTERM_colonOrEquals
      | NONTERM_stringOrKeywordString
      | NONTERM_interpolatedStringFill
      | NONTERM_interpolatedStringParts
      | NONTERM_interpolatedString
      | NONTERM_opt_HIGH_PRECEDENCE_APP
      | NONTERM_opt_HIGH_PRECEDENCE_TYAPP
      | NONTERM_typeKeyword
      | NONTERM_moduleKeyword
      | NONTERM_rbrace
      | NONTERM_bar_rbrace
      | NONTERM_rparen
      | NONTERM_oblockend
      | NONTERM_ends_other_than_rparen_coming_soon_or_recover
      | NONTERM_ends_coming_soon_or_recover
    val tagOfToken : t:token -> int
    val tokenTagToTokenId : tokenIdx:int -> tokenId
    val prodIdxToNonTerminal : prodIdx:int -> nonTerminalId
    val _fsyacc_endOfInputTag : int
    val _fsyacc_tagOfErrorTerminal : int
    val token_to_string : t:token -> string
    val _fsyacc_dataOfToken : t:token -> obj
    val _fsyacc_gotos : uint16 []
    val _fsyacc_sparseGotoTableRowOffsets : uint16 []
    val _fsyacc_stateToProdIdxsTableElements : uint16 []
    val _fsyacc_stateToProdIdxsTableRowOffsets : uint16 []
    val _fsyacc_action_rows : int
    val _fsyacc_actionTableElements : uint16 []
    val _fsyacc_actionTableRowOffsets : uint16 []
    val _fsyacc_reductionSymbolCounts : uint16 []
    val _fsyacc_productionToNonTerminalTable : uint16 []
    val _fsyacc_immediateActions : uint16 []
    val _fsyacc_reductions :
      unit -> (Internal.Utilities.Text.Parsing.IParseState -> obj) []
    val tables : unit -> Internal.Utilities.Text.Parsing.Tables<token>
    val engine :
      lexer:(Internal.Utilities.Text.Lexing.LexBuffer<char> -> token) ->
        lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
          startState:int -> obj
    val signatureFile :
      lexer:(Internal.Utilities.Text.Lexing.LexBuffer<char> -> token) ->
        lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
          SyntaxTree.ParsedSigFile
    val implementationFile :
      lexer:(Internal.Utilities.Text.Lexing.LexBuffer<char> -> token) ->
        lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
          SyntaxTree.ParsedImplFile
    val interaction :
      lexer:(Internal.Utilities.Text.Lexing.LexBuffer<char> -> token) ->
        lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
          SyntaxTree.ParsedFsiInteraction
    val typedSeqExprEOF :
      lexer:(Internal.Utilities.Text.Lexing.LexBuffer<char> -> token) ->
        lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
          SyntaxTree.SynExpr
    val typEOF :
      lexer:(Internal.Utilities.Text.Lexing.LexBuffer<char> -> token) ->
        lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
          SyntaxTree.SynType
  end

namespace FSharp.Compiler
  module internal Lexhelp = begin
    val stdinMockFilename : string
    [<SealedAttribute ()>]
    type LightSyntaxStatus =
      class
        new : initial:bool * warn:bool -> LightSyntaxStatus
        member ExplicitlySet : bool
        member Status : bool
        member WarnOnMultipleTokens : bool
      end
    [<SealedAttribute ()>]
    type LexResourceManager =
      class
        new : ?capacity:int -> LexResourceManager
        member InternIdentifierToken : s:string -> Parser.token
      end
    type LexArgs =
      { defines: string list
        resourceManager: LexResourceManager
        errorLogger: ErrorLogger.ErrorLogger
        applyLineDirectives: bool
        pathMap: Internal.Utilities.PathMap
        mutable ifdefStack: ParseHelpers.LexerIfdefStack
        mutable lightStatus: LightSyntaxStatus
        mutable stringNest: ParseHelpers.LexerInterpolatedStringNesting }
    type LongUnicodeLexResult =
      | SurrogatePair of uint16 * uint16
      | SingleChar of uint16
      | Invalid
    val mkLexargs :
      string list * LightSyntaxStatus * LexResourceManager *
      ParseHelpers.LexerIfdefStack * ErrorLogger.ErrorLogger *
      Internal.Utilities.PathMap -> LexArgs
    val reusingLexbufForParsing : UnicodeLexing.Lexbuf -> (unit -> 'a) -> 'a
    val resetLexbufPos : string -> UnicodeLexing.Lexbuf -> unit
    val usingLexbufForParsing :
      UnicodeLexing.Lexbuf * string -> (UnicodeLexing.Lexbuf -> 'a) -> 'a
    val stringBufferAsString : AbstractIL.Internal.ByteBuffer -> System.String
    val stringBufferAsBytes : AbstractIL.Internal.ByteBuffer -> byte []
    type LexerStringFinisher =
      | LexerStringFinisher of
        (AbstractIL.Internal.ByteBuffer -> ParseHelpers.LexerStringKind ->
           bool -> ParseHelpers.LexerContinuation -> Parser.token)
      with
        member
          Finish : buf:AbstractIL.Internal.ByteBuffer ->
                     kind:ParseHelpers.LexerStringKind ->
                       isInterpolatedStringPart:bool ->
                         cont:ParseHelpers.LexerContinuation -> Parser.token
        static member Default : LexerStringFinisher
      end
    val addUnicodeString : AbstractIL.Internal.ByteBuffer -> string -> unit
    val addIntChar : buf:AbstractIL.Internal.ByteBuffer -> c:int -> unit
    val addUnicodeChar : AbstractIL.Internal.ByteBuffer -> int -> unit
    val addByteChar : AbstractIL.Internal.ByteBuffer -> char -> unit
    val stringBufferIsBytes : AbstractIL.Internal.ByteBuffer -> bool
    val newline : Internal.Utilities.Text.Lexing.LexBuffer<'a> -> unit
    val advanceColumnBy :
      Internal.Utilities.Text.Lexing.LexBuffer<'a> -> n:int -> unit
    val trigraph : char -> char -> char -> char
    val digit : char -> int32
    val hexdigit : char -> int32
    val unicodeGraphShort : string -> uint16
    val hexGraphShort : string -> uint16
    val unicodeGraphLong : string -> LongUnicodeLexResult
    val escape : char -> char
    exception ReservedKeyword of string * Range.range
    module Keywords = begin
      type private compatibilityMode =
        | ALWAYS
        | FSHARP
      val private keywordList : (compatibilityMode * string * Parser.token) list
      val private unreserveWords : string list
      val keywordNames : string list
      val keywordTable :
        System.Collections.Generic.Dictionary<string,Parser.token>
      val KeywordToken : s:string -> Parser.token
      val IdentifierToken :
        LexArgs -> UnicodeLexing.Lexbuf -> string -> Parser.token
      val KeywordOrIdentifierToken :
        LexArgs -> UnicodeLexing.Lexbuf -> string -> Parser.token
      val DoesIdentifierNeedQuotation : string -> bool
      val QuoteIdentifierIfNeeded : string -> string
      val NormalizeIdentifierBackticks : string -> string
      val keywordsWithDescription : (string * string) list
    end
  end

namespace FSharp.Compiler
  module internal PPLexer = begin
    val lexeme : lexbuf:UnicodeLexing.Lexbuf -> string
    val fail :
      args:Lexhelp.LexArgs ->
        lexbuf:UnicodeLexing.Lexbuf -> int * string -> PPParser.token
    val trans : uint16 [] array
    val actions : uint16 []
    val _fslex_tables : Internal.Utilities.Text.Lexing.UnicodeTables
    val _fslex_dummy : unit -> 'a
    val tokenstream :
      args:Lexhelp.LexArgs ->
        lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> -> PPParser.token
    val rest : lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> -> unit
  end

namespace FSharp.Compiler
  module internal Lexer = begin
    module Ranges = begin
      val isInt8BadMax : x:int -> bool
      val isInt16BadMax : x:int -> bool
      val isInt32BadMax : (string -> bool)
      val isInt64BadMax : (string -> bool)
    end
    val lexeme : lexbuf:UnicodeLexing.Lexbuf -> string
    val lexemeTrimBoth : lexbuf:UnicodeLexing.Lexbuf -> n:int -> m:int -> string
    val lexemeTrimRight : lexbuf:UnicodeLexing.Lexbuf -> n:int -> string
    val lexemeTrimLeft : lexbuf:UnicodeLexing.Lexbuf -> n:int -> string
    val fail :
      args:Lexhelp.LexArgs ->
        lexbuf:UnicodeLexing.Lexbuf -> int * string -> dflt:'a -> 'a
    val getSign32 : s:string -> p:byref<int> -> l:int -> int
    val isOXB : c:char -> bool
    val is0OXB : s:string -> p:int -> l:int -> bool
    val get0OXB : s:string -> p:byref<int> -> l:int -> char
    val formatError : unit -> 'a
    val parseBinaryUInt64 : s:string -> uint64
    val parseOctalUInt64 : s:string -> uint64
    val removeUnderscores : s:string -> string
    val parseInt32 : s:string -> int
    val lexemeTrimRightToInt32 :
      args:Lexhelp.LexArgs -> lexbuf:UnicodeLexing.Lexbuf -> n:int -> int
    val checkExprOp : lexbuf:UnicodeLexing.Lexbuf -> unit
    val unexpectedChar : lexbuf:UnicodeLexing.Lexbuf -> Parser.token
    val startString :
      args:Lexhelp.LexArgs ->
        lexbuf:UnicodeLexing.Lexbuf ->
          AbstractIL.Internal.ByteBuffer * Lexhelp.LexerStringFinisher *
          Range.range
    val trySaveXmlDoc :
      lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
        buff:(Range.range * System.Text.StringBuilder) option -> unit
    val tryAppendXmlDoc :
      buff:(Range.range * System.Text.StringBuilder) option -> s:string -> unit
    val shouldStartLine :
      args:Lexhelp.LexArgs ->
        lexbuf:UnicodeLexing.Lexbuf ->
          m:Range.range -> int * string -> tok:'a -> 'a
    val shouldStartFile :
      args:Lexhelp.LexArgs ->
        lexbuf:UnicodeLexing.Lexbuf ->
          m:Range.range -> int * string -> tok:'a -> 'a
    val evalIfDefExpression :
      startPos:Internal.Utilities.Text.Lexing.Position ->
        isFeatureSupported:(Features.LanguageFeature -> bool) ->
          args:Lexhelp.LexArgs ->
            lookup:(string -> bool) -> lexed:string -> bool
    val evalFloat :
      args:Lexhelp.LexArgs -> lexbuf:UnicodeLexing.Lexbuf -> float32
    val trans : uint16 [] array
    val actions : uint16 []
    val _fslex_tables : Internal.Utilities.Text.Lexing.UnicodeTables
    val _fslex_dummy : unit -> 'a
    val token :
      args:Lexhelp.LexArgs ->
        skip:bool ->
          lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> -> Parser.token
    val ifdefSkip :
      n:int ->
        m:Range.range ->
          args:Lexhelp.LexArgs ->
            skip:bool ->
              lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
                Parser.token
    val endline :
      cont:ParseHelpers.LexerEndlineContinuation ->
        args:Lexhelp.LexArgs ->
          skip:bool ->
            lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
              Parser.token
    val singleQuoteString :
      AbstractIL.Internal.ByteBuffer * Lexhelp.LexerStringFinisher * Range.range *
      ParseHelpers.LexerStringKind * Lexhelp.LexArgs ->
        skip:bool ->
          lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> -> Parser.token
    val verbatimString :
      AbstractIL.Internal.ByteBuffer * Lexhelp.LexerStringFinisher * Range.range *
      ParseHelpers.LexerStringKind * Lexhelp.LexArgs ->
        skip:bool ->
          lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> -> Parser.token
    val tripleQuoteString :
      AbstractIL.Internal.ByteBuffer * Lexhelp.LexerStringFinisher * Range.range *
      ParseHelpers.LexerStringKind * Lexhelp.LexArgs ->
        skip:bool ->
          lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> -> Parser.token
    val singleLineComment :
      (Range.range * System.Text.StringBuilder) option * int * Range.range *
      Lexhelp.LexArgs ->
        skip:bool ->
          lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> -> Parser.token
    val comment :
      int * Range.range * Lexhelp.LexArgs ->
        skip:bool ->
          lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> -> Parser.token
    val stringInComment :
      n:int ->
        m:Range.range ->
          args:Lexhelp.LexArgs ->
            skip:bool ->
              lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
                Parser.token
    val verbatimStringInComment :
      n:int ->
        m:Range.range ->
          args:Lexhelp.LexArgs ->
            skip:bool ->
              lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
                Parser.token
    val tripleQuoteStringInComment :
      n:int ->
        m:Range.range ->
          args:Lexhelp.LexArgs ->
            skip:bool ->
              lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
                Parser.token
    val mlOnly :
      m:Range.range ->
        args:Lexhelp.LexArgs ->
          skip:bool ->
            lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
              Parser.token
  end

namespace FSharp.Compiler
  module internal LexFilter = begin
    val debug : bool
    val stringOfPos : p:Internal.Utilities.Text.Lexing.Position -> string
    val outputPos :
      os:System.IO.TextWriter ->
        p:Internal.Utilities.Text.Lexing.Position -> unit
    val warningStringOfPosition :
      p:Internal.Utilities.Text.Lexing.Position -> string
    type Context =
      | CtxtLetDecl of bool * Internal.Utilities.Text.Lexing.Position
      | CtxtIf of Internal.Utilities.Text.Lexing.Position
      | CtxtTry of Internal.Utilities.Text.Lexing.Position
      | CtxtFun of Internal.Utilities.Text.Lexing.Position
      | CtxtFunction of Internal.Utilities.Text.Lexing.Position
      | CtxtWithAsLet of Internal.Utilities.Text.Lexing.Position
      | CtxtWithAsAugment of Internal.Utilities.Text.Lexing.Position
      | CtxtMatch of Internal.Utilities.Text.Lexing.Position
      | CtxtFor of Internal.Utilities.Text.Lexing.Position
      | CtxtWhile of Internal.Utilities.Text.Lexing.Position
      | CtxtWhen of Internal.Utilities.Text.Lexing.Position
      | CtxtVanilla of Internal.Utilities.Text.Lexing.Position * bool
      | CtxtThen of Internal.Utilities.Text.Lexing.Position
      | CtxtElse of Internal.Utilities.Text.Lexing.Position
      | CtxtDo of Internal.Utilities.Text.Lexing.Position
      | CtxtInterfaceHead of Internal.Utilities.Text.Lexing.Position
      | CtxtTypeDefns of Internal.Utilities.Text.Lexing.Position
      | CtxtNamespaceHead of
        Internal.Utilities.Text.Lexing.Position * Parser.token
      | CtxtModuleHead of Internal.Utilities.Text.Lexing.Position * Parser.token
      | CtxtMemberHead of Internal.Utilities.Text.Lexing.Position
      | CtxtMemberBody of Internal.Utilities.Text.Lexing.Position
      | CtxtModuleBody of Internal.Utilities.Text.Lexing.Position * bool
      | CtxtNamespaceBody of Internal.Utilities.Text.Lexing.Position
      | CtxtException of Internal.Utilities.Text.Lexing.Position
      | CtxtParen of Parser.token * Internal.Utilities.Text.Lexing.Position
      | CtxtSeqBlock of
        FirstInSequence * Internal.Utilities.Text.Lexing.Position * AddBlockEnd
      | CtxtMatchClauses of bool * Internal.Utilities.Text.Lexing.Position
      with
        override ToString : unit -> string
        member StartCol : int
        member StartPos : Internal.Utilities.Text.Lexing.Position
      end
    and AddBlockEnd =
      | AddBlockEnd
      | NoAddBlockEnd
      | AddOneSidedBlockEnd
    and FirstInSequence =
      | FirstInSeqBlock
      | NotFirstInSeqBlock
    val isInfix : token:Parser.token -> bool
    val isNonAssocInfixToken : token:Parser.token -> bool
    val infixTokenLength : token:Parser.token -> int
    val isIfBlockContinuator : token:Parser.token -> bool
    val isTryBlockContinuator : token:Parser.token -> bool
    val isThenBlockContinuator : token:Parser.token -> bool
    val isDoContinuator : token:Parser.token -> bool
    val isInterfaceContinuator : token:Parser.token -> bool
    val isNamespaceContinuator : token:Parser.token -> bool
    val isTypeContinuator : token:Parser.token -> bool
    val isForLoopContinuator : token:Parser.token -> bool
    val isWhileBlockContinuator : token:Parser.token -> bool
    val isLetContinuator : token:Parser.token -> bool
    val isTypeSeqBlockElementContinuator : token:Parser.token -> bool
    val isSeqBlockElementContinuator : token:Parser.token -> bool
    val isWithAugmentBlockContinuator : token:Parser.token -> bool
    val isLongIdentifier : token:Parser.token -> bool
    val isLongIdentifierOrGlobal : token:Parser.token -> bool
    val isAtomicExprEndToken : token:Parser.token -> bool
    val parenTokensBalance : t1:Parser.token -> t2:Parser.token -> bool
    [<StructAttribute ()>]
    type LexbufState =
      struct
        new : startPos:Internal.Utilities.Text.Lexing.Position *
              endPos:Internal.Utilities.Text.Lexing.Position * pastEOF:bool ->
                LexbufState
        member EndPos : Internal.Utilities.Text.Lexing.Position
        member PastEOF : bool
        member StartPos : Internal.Utilities.Text.Lexing.Position
      end
    [<ClassAttribute ()>]
    type TokenTup =
      class
        new : token:Parser.token * state:LexbufState *
              lastTokenPos:Internal.Utilities.Text.Lexing.Position -> TokenTup
        val mutable Token: Parser.token
        val mutable LexbufState: LexbufState
        val mutable LastTokenPos: Internal.Utilities.Text.Lexing.Position
        member EndPos : Internal.Utilities.Text.Lexing.Position
        member StartPos : Internal.Utilities.Text.Lexing.Position
      end
    type TokenTupPool =
      class
        new : unit -> TokenTupPool
        member Rent : unit -> TokenTup
        member Return : x:TokenTup -> unit
        member UseLocation : x:TokenTup * tok:Parser.token -> TokenTup
        member
          UseShiftedLocation : x:TokenTup * tok:Parser.token * shiftLeft:int *
                               shiftRight:int -> TokenTup
      end
    val ( |TyparsCloseOp|_| ) :
      txt:string -> ((bool -> Parser.token) [] * Parser.token option) option
    [<StructAttribute ()>]
    type PositionWithColumn =
      struct
        new : position:Internal.Utilities.Text.Lexing.Position * column:int ->
                PositionWithColumn
        val Position: Internal.Utilities.Text.Lexing.Position
        val Column: int
      end
    type LexFilterImpl =
      class
        new : lightStatus:Lexhelp.LightSyntaxStatus * compilingFsLib:bool *
              lexer:(UnicodeLexing.Lexbuf -> Parser.token) *
              lexbuf:UnicodeLexing.Lexbuf -> LexFilterImpl
        member GetToken : unit -> Parser.token
        member LexBuffer : UnicodeLexing.Lexbuf
      end
    type LexFilter =
      class
        new : lightStatus:Lexhelp.LightSyntaxStatus * compilingFsLib:bool *
              lexer:(UnicodeLexing.Lexbuf -> Parser.token) *
              lexbuf:UnicodeLexing.Lexbuf -> LexFilter
        member GetToken : unit -> Parser.token
        member LexBuffer : UnicodeLexing.Lexbuf
      end
  end

namespace FSharp.Compiler
  [<SealedAttribute ()>]
  type internal TypeProviderToken =
    class
      interface AbstractIL.Internal.Library.LockToken
      new : unit -> TypeProviderToken
    end
  [<SealedAttribute (); ClassAttribute ()>]
  type internal TypeProviderLock =
    class
      inherit AbstractIL.Internal.Library.Lock<TypeProviderToken>
      new : unit -> TypeProviderLock
    end
  type internal TypeProviderError =
    class
      inherit System.Exception
      new : int * string * Range.range * seq<string> -> TypeProviderError
      new : (int * string) * string * Range.range -> TypeProviderError
      new : errNum:int * tpDesignation:string * m:Range.range *
            errors:string list * typeNameContext:string option *
            methodNameContext:string option -> TypeProviderError
      member Iter : (TypeProviderError -> unit) -> unit
      member
        MapText : (string -> int * string) * string * Range.range ->
                    TypeProviderError
      member WithContext : string * string -> TypeProviderError
      member ContextualErrorMessage : string
      override Message : string
      member Number : int
      member Range : Range.range
    end
  type TaintedContext =
    { TypeProvider: CompilerServices.ITypeProvider
      TypeProviderAssemblyRef: AbstractIL.IL.ILScopeRef
      Lock: TypeProviderLock }
  [<NoEqualityAttribute (); NoComparisonAttribute (); ClassAttribute ()>]
  type internal Tainted<'T> =
    class
      new : context:TaintedContext * value:'T -> Tainted<'T>
      static member
        CreateAll : (CompilerServices.ITypeProvider * AbstractIL.IL.ILScopeRef) list ->
                      Tainted<CompilerServices.ITypeProvider> list
      member Coerce : range:Range.range -> Tainted<'U>
      member OfType : unit -> Tainted<'U> option
      member PApply : ('T -> 'U) * range:Range.range -> Tainted<'U>
      member
        PApply2 : ('T -> 'U1 * 'U2) * range:Range.range ->
                    Tainted<'U1> * Tainted<'U2>
      member
        PApply3 : ('T -> 'U1 * 'U2 * 'U3) * range:Range.range ->
                    Tainted<'U1> * Tainted<'U2> * Tainted<'U3>
      member
        PApply4 : ('T -> 'U1 * 'U2 * 'U3 * 'U4) * range:Range.range ->
                    Tainted<'U1> * Tainted<'U2> * Tainted<'U3> * Tainted<'U4>
      member
        PApplyArray : ('T -> 'U []) * System.String * range:Range.range ->
                        Tainted<'U> []
      member PApplyNoFailure : f:('T -> 'U) -> Tainted<'U>
      member
        PApplyOption : ('T -> 'U option) * range:Range.range ->
                         Tainted<'U> option
      member
        PApplyWithProvider : ('T * CompilerServices.ITypeProvider -> 'U) *
                             range:Range.range -> Tainted<'U>
      member PUntaint : ('T -> 'U) * range:Range.range -> 'U
      member PUntaintNoFailure : ('T -> 'U) -> 'U
      member Protect : f:('T -> 'a) -> range:Range.range -> 'a
      member AccessObjectDirectly : 'T
      member TypeProvider : Tainted<CompilerServices.ITypeProvider>
      member TypeProviderAssemblyRef : AbstractIL.IL.ILScopeRef
      member TypeProviderDesignation : string
    end
  module internal Tainted = begin
    val ( |Null|_| ) : Tainted<'T> -> unit option when 'T : null
    val Eq : Tainted<'T> -> 'T -> bool when 'T : equality
    val EqTainted : Tainted<'T> -> Tainted<'T> -> bool when 'T : not struct
    val GetHashCodeTainted : Tainted<'T> -> int when 'T : equality
  end

namespace FSharp.Compiler
  module internal ExtensionTyping = begin
    type TypeProviderDesignation = | TypeProviderDesignation of string
    exception ProvidedTypeResolution of Range.range * System.Exception
    exception ProvidedTypeResolutionNoRange of System.Exception
    val toolingCompatiblePaths : unit -> string list
    type ResolutionEnvironment =
      { resolutionFolder: string
        outputFile: string option
        showResolutionMessages: bool
        referencedAssemblies: string []
        temporaryFolder: string }
    val GetTypeProviderImplementationTypes :
      runTimeAssemblyFileName:string *
      designTimeAssemblyNameString:System.String * m:Range.range *
      compilerToolPaths:string list -> System.Type list
    val StripException : e:exn -> exn
    val CreateTypeProvider :
      typeProviderImplementationType:System.Type * runtimeAssemblyPath:string *
      resolutionEnvironment:ResolutionEnvironment * isInvalidationSupported:bool *
      isInteractive:bool * systemRuntimeContainsType:(string -> bool) *
      systemRuntimeAssemblyVersion:System.Version * m:Range.range ->
        CompilerServices.ITypeProvider
    val GetTypeProvidersOfAssembly :
      runtimeAssemblyFilename:string *
      ilScopeRefOfRuntimeAssembly:AbstractIL.IL.ILScopeRef *
      designTimeName:string * resolutionEnvironment:ResolutionEnvironment *
      isInvalidationSupported:bool * isInteractive:bool *
      systemRuntimeContainsType:(string -> bool) *
      systemRuntimeAssemblyVersion:System.Version *
      compilerToolPaths:string list * Range.range ->
        Tainted<CompilerServices.ITypeProvider> list
    val unmarshal : t:Tainted<'a> -> 'a
    val TryTypeMember :
      st:Tainted<'a> * fullName:System.String * memberName:System.String *
      m:Range.range * recover:'b * f:('a -> 'b) -> Tainted<'b>
    val TryTypeMemberArray :
      st:Tainted<'a> * fullName:System.String * memberName:string *
      m:Range.range * f:('a -> 'b []) -> Tainted<'b> []
    val TryTypeMemberNonNull :
      st:Tainted<'a> * fullName:System.String * memberName:System.String *
      m:Range.range * recover:'b * f:('a -> 'b) -> Tainted<'b> when 'b : null
    val TryMemberMember :
      mi:Tainted<'a> * typeName:System.String * memberName:System.String *
      memberMemberName:System.String * m:Range.range * recover:'b * f:('a -> 'b) ->
        Tainted<'b>
    val DisplayNameOfTypeProvider :
      Tainted<CompilerServices.ITypeProvider> * Range.range -> string
    val ValidateNamespaceName :
      name:System.String * typeProvider:Tainted<CompilerServices.ITypeProvider> *
      m:Range.range * nsp:string -> unit
    val bindingFlags : System.Reflection.BindingFlags
    type CustomAttributeData = System.Reflection.CustomAttributeData
    type CustomAttributeNamedArgument =
      System.Reflection.CustomAttributeNamedArgument
    type CustomAttributeTypedArgument =
      System.Reflection.CustomAttributeTypedArgument
    type ProvidedTypeComparer =
      class
        interface System.Collections.Generic.IEqualityComparer<ProvidedType>
        new : unit -> ProvidedTypeComparer
        static member Instance : ProvidedTypeComparer
      end
    [<SealedAttribute ()>]
    and ProvidedTypeContext =
      | NoEntries
      | Entries of
        System.Collections.Generic.Dictionary<ProvidedType,
                                              AbstractIL.IL.ILTypeRef> *
        System.Lazy<System.Collections.Generic.Dictionary<ProvidedType,obj>>
      with
        static member
          Create : System.Collections.Generic.Dictionary<ProvidedType,
                                                         AbstractIL.IL.ILTypeRef> *
                   System.Collections.Generic.Dictionary<ProvidedType,obj> ->
                     ProvidedTypeContext
        member
          GetDictionaries : unit ->
                              System.Collections.Generic.Dictionary<ProvidedType,
                                                                    AbstractIL.IL.ILTypeRef> *
                              System.Collections.Generic.Dictionary<ProvidedType,
                                                                    obj>
        member RemapTyconRefs : (obj -> obj) -> ProvidedTypeContext
        member TryGetILTypeRef : ProvidedType -> AbstractIL.IL.ILTypeRef option
        member TryGetTyconRef : ProvidedType -> obj option
        static member Empty : ProvidedTypeContext
      end
    [<AllowNullLiteralAttribute (); SealedAttribute (); ClassAttribute ()>]
    and ProvidedType =
      class
        inherit ProvidedMemberInfo
        interface IProvidedCustomAttributeProvider
        new : x:System.Type * ctxt:ProvidedTypeContext -> ProvidedType
        static member
          ApplyContext : ProvidedType * ProvidedTypeContext -> ProvidedType
        static member
          Create : ctxt:ProvidedTypeContext -> x:System.Type -> ProvidedType
        static member
          CreateArray : ctxt:ProvidedTypeContext ->
                          xs:System.Type [] -> ProvidedType []
        static member CreateNoContext : System.Type -> ProvidedType
        static member
          CreateWithNullCheck : ctxt:ProvidedTypeContext ->
                                  name:string -> x:System.Type -> ProvidedType
        static member
          TaintedEquals : Tainted<ProvidedType> * Tainted<ProvidedType> -> bool
        member
          ApplyStaticArguments : provider:CompilerServices.ITypeProvider *
                                 fullTypePathAfterArguments:string [] *
                                 staticArgs:obj [] -> ProvidedType
        member AsProvidedVar : name:string -> ProvidedVar
        override Equals : y:obj -> bool
        member GetAllNestedTypes : unit -> ProvidedType []
        member GetArrayRank : unit -> int
        member GetConstructors : unit -> ProvidedConstructorInfo []
        member GetElementType : unit -> ProvidedType
        member GetEnumUnderlyingType : unit -> ProvidedType
        member GetEvent : string -> ProvidedEventInfo
        member GetEvents : unit -> ProvidedEventInfo []
        member GetField : string -> ProvidedFieldInfo
        member GetFields : unit -> ProvidedFieldInfo []
        member GetGenericArguments : unit -> ProvidedType []
        member GetGenericTypeDefinition : unit -> ProvidedType
        override GetHashCode : unit -> int
        member GetInterfaces : unit -> ProvidedType []
        member GetMethods : unit -> ProvidedMethodInfo []
        member GetNestedType : string -> ProvidedType
        member GetNestedTypes : unit -> ProvidedType []
        member GetProperties : unit -> ProvidedPropertyInfo []
        member GetProperty : string -> ProvidedPropertyInfo
        member
          GetStaticParameters : CompilerServices.ITypeProvider ->
                                  ProvidedParameterInfo []
        member MakeArrayType : unit -> ProvidedType
        member MakeArrayType : rank:int -> ProvidedType
        member MakeByRefType : unit -> ProvidedType
        member MakeGenericType : args:ProvidedType [] -> ProvidedType
        member MakePointerType : unit -> ProvidedType
        member TryGetILTypeRef : unit -> AbstractIL.IL.ILTypeRef option
        member TryGetTyconRef : unit -> obj option
        member Assembly : ProvidedAssembly
        member BaseType : ProvidedType
        member Context : ProvidedTypeContext
        member FullName : string
        member GenericParameterPosition : int
        member Handle : System.Type
        member IsAbstract : bool
        member IsArray : bool
        member IsByRef : bool
        member IsClass : bool
        member IsEnum : bool
        member IsErased : bool
        member IsGenericParameter : bool
        member IsGenericType : bool
        member IsInterface : bool
        member IsMeasure : bool
        member IsNestedPublic : bool
        member IsPointer : bool
        member IsPublic : bool
        member IsSealed : bool
        member IsSuppressRelocate : bool
        member IsValueType : bool
        member IsVoid : bool
        member Namespace : string
        member RawSystemType : System.Type
        static member Void : ProvidedType
      end
    [<AllowNullLiteralAttribute ()>]
    and IProvidedCustomAttributeProvider =
      interface
        abstract member
          GetAttributeConstructorArgs : provider:CompilerServices.ITypeProvider *
                                        attribName:string ->
                                          (obj option list *
                                           (string * obj option) list) option
        abstract member
          GetDefinitionLocationAttribute : provider:CompilerServices.ITypeProvider ->
                                             (string * int * int) option
        abstract member
          GetHasTypeProviderEditorHideMethodsAttribute : provider:CompilerServices.ITypeProvider ->
                                                           bool
        abstract member
          GetXmlDocAttributes : provider:CompilerServices.ITypeProvider ->
                                  string []
      end
    and ProvidedCustomAttributeProvider =
      class
        static member
          Create : attributes:(CompilerServices.ITypeProvider ->
                                 seq<CustomAttributeData>) ->
                     IProvidedCustomAttributeProvider
      end
    [<AllowNullLiteralAttribute (); AbstractClassAttribute ()>]
    and ProvidedMemberInfo =
      class
        interface IProvidedCustomAttributeProvider
        new : x:System.Reflection.MemberInfo * ctxt:ProvidedTypeContext ->
                ProvidedMemberInfo
        member DeclaringType : ProvidedType
        member Name : string
      end
    [<AllowNullLiteralAttribute (); SealedAttribute (); ClassAttribute ()>]
    and ProvidedParameterInfo =
      class
        interface IProvidedCustomAttributeProvider
        new : x:System.Reflection.ParameterInfo * ctxt:ProvidedTypeContext ->
                ProvidedParameterInfo
        static member
          Create : ctxt:ProvidedTypeContext ->
                     x:System.Reflection.ParameterInfo -> ProvidedParameterInfo
        static member
          CreateArray : ctxt:ProvidedTypeContext ->
                          xs:System.Reflection.ParameterInfo [] ->
                            ProvidedParameterInfo []
        override Equals : y:obj -> bool
        override GetHashCode : unit -> int
        member Handle : System.Reflection.ParameterInfo
        member HasDefaultValue : bool
        member IsIn : bool
        member IsOptional : bool
        member IsOut : bool
        member Name : string
        member ParameterType : ProvidedType
        member RawDefaultValue : obj
      end
    [<AllowNullLiteralAttribute (); SealedAttribute (); ClassAttribute ()>]
    and ProvidedAssembly =
      class
        new : x:System.Reflection.Assembly -> ProvidedAssembly
        static member Create : x:System.Reflection.Assembly -> ProvidedAssembly
        override Equals : y:obj -> bool
        override GetHashCode : unit -> int
        member
          GetManifestModuleContents : CompilerServices.ITypeProvider -> byte []
        member GetName : unit -> System.Reflection.AssemblyName
        member FullName : string
        member Handle : System.Reflection.Assembly
      end
    [<AllowNullLiteralAttribute (); AbstractClassAttribute ()>]
    and ProvidedMethodBase =
      class
        inherit ProvidedMemberInfo
        new : x:System.Reflection.MethodBase * ctxt:ProvidedTypeContext ->
                ProvidedMethodBase
        static member
          TaintedEquals : Tainted<ProvidedMethodBase> *
                          Tainted<ProvidedMethodBase> -> bool
        static member TaintedGetHashCode : Tainted<ProvidedMethodBase> -> int
        member
          ApplyStaticArgumentsForMethod : provider:CompilerServices.ITypeProvider *
                                          fullNameAfterArguments:string *
                                          staticArgs:obj [] ->
                                            ProvidedMethodBase
        member GetGenericArguments : unit -> ProvidedType []
        member GetParameters : unit -> ProvidedParameterInfo []
        member
          GetStaticParametersForMethod : CompilerServices.ITypeProvider ->
                                           ProvidedParameterInfo []
        member Context : ProvidedTypeContext
        member Handle : System.Reflection.MethodBase
        member IsAbstract : bool
        member IsConstructor : bool
        member IsFamily : bool
        member IsFamilyAndAssembly : bool
        member IsFamilyOrAssembly : bool
        member IsFinal : bool
        member IsGenericMethod : bool
        member IsHideBySig : bool
        member IsPublic : bool
        member IsStatic : bool
        member IsVirtual : bool
      end
    [<AllowNullLiteralAttribute (); ClassAttribute (); SealedAttribute ()>]
    and ProvidedFieldInfo =
      class
        inherit ProvidedMemberInfo
        new : x:System.Reflection.FieldInfo * ctxt:ProvidedTypeContext ->
                ProvidedFieldInfo
        static member
          Create : ctxt:ProvidedTypeContext ->
                     x:System.Reflection.FieldInfo -> ProvidedFieldInfo
        static member
          CreateArray : ctxt:ProvidedTypeContext ->
                          xs:System.Reflection.FieldInfo [] ->
                            ProvidedFieldInfo []
        static member
          TaintedEquals : Tainted<ProvidedFieldInfo> *
                          Tainted<ProvidedFieldInfo> -> bool
        override Equals : y:obj -> bool
        override GetHashCode : unit -> int
        member GetRawConstantValue : unit -> obj
        member FieldType : ProvidedType
        member Handle : System.Reflection.FieldInfo
        member IsFamily : bool
        member IsFamilyAndAssembly : bool
        member IsFamilyOrAssembly : bool
        member IsInitOnly : bool
        member IsLiteral : bool
        member IsPrivate : bool
        member IsPublic : bool
        member IsSpecialName : bool
        member IsStatic : bool
      end
    [<AllowNullLiteralAttribute (); SealedAttribute (); ClassAttribute ()>]
    and ProvidedMethodInfo =
      class
        inherit ProvidedMethodBase
        new : x:System.Reflection.MethodInfo * ctxt:ProvidedTypeContext ->
                ProvidedMethodInfo
        static member
          Create : ctxt:ProvidedTypeContext ->
                     x:System.Reflection.MethodInfo -> ProvidedMethodInfo
        static member
          CreateArray : ctxt:ProvidedTypeContext ->
                          xs:System.Reflection.MethodInfo [] ->
                            ProvidedMethodInfo []
        override Equals : y:obj -> bool
        override GetHashCode : unit -> int
        member Handle : System.Reflection.MethodInfo
        member MetadataToken : int
        member ReturnType : ProvidedType
      end
    [<AllowNullLiteralAttribute (); ClassAttribute (); SealedAttribute ()>]
    and ProvidedPropertyInfo =
      class
        inherit ProvidedMemberInfo
        new : x:System.Reflection.PropertyInfo * ctxt:ProvidedTypeContext ->
                ProvidedPropertyInfo
        static member
          Create : ctxt:ProvidedTypeContext ->
                     x:System.Reflection.PropertyInfo -> ProvidedPropertyInfo
        static member
          CreateArray : ctxt:ProvidedTypeContext ->
                          xs:System.Reflection.PropertyInfo [] ->
                            ProvidedPropertyInfo []
        static member
          TaintedEquals : Tainted<ProvidedPropertyInfo> *
                          Tainted<ProvidedPropertyInfo> -> bool
        static member TaintedGetHashCode : Tainted<ProvidedPropertyInfo> -> int
        override Equals : y:obj -> bool
        member GetGetMethod : unit -> ProvidedMethodInfo
        override GetHashCode : unit -> int
        member GetIndexParameters : unit -> ProvidedParameterInfo []
        member GetSetMethod : unit -> ProvidedMethodInfo
        member CanRead : bool
        member CanWrite : bool
        member Handle : System.Reflection.PropertyInfo
        member PropertyType : ProvidedType
      end
    [<AllowNullLiteralAttribute (); ClassAttribute (); SealedAttribute ()>]
    and ProvidedEventInfo =
      class
        inherit ProvidedMemberInfo
        new : x:System.Reflection.EventInfo * ctxt:ProvidedTypeContext ->
                ProvidedEventInfo
        static member
          Create : ctxt:ProvidedTypeContext ->
                     x:System.Reflection.EventInfo -> ProvidedEventInfo
        static member
          CreateArray : ctxt:ProvidedTypeContext ->
                          xs:System.Reflection.EventInfo [] ->
                            ProvidedEventInfo []
        static member
          TaintedEquals : Tainted<ProvidedEventInfo> *
                          Tainted<ProvidedEventInfo> -> bool
        static member TaintedGetHashCode : Tainted<ProvidedEventInfo> -> int
        override Equals : y:obj -> bool
        member GetAddMethod : unit -> ProvidedMethodInfo
        override GetHashCode : unit -> int
        member GetRemoveMethod : unit -> ProvidedMethodInfo
        member EventHandlerType : ProvidedType
        member Handle : System.Reflection.EventInfo
      end
    [<AllowNullLiteralAttribute (); ClassAttribute (); SealedAttribute ()>]
    and ProvidedConstructorInfo =
      class
        inherit ProvidedMethodBase
        new : x:System.Reflection.ConstructorInfo * ctxt:ProvidedTypeContext ->
                ProvidedConstructorInfo
        static member
          Create : ctxt:ProvidedTypeContext ->
                     x:System.Reflection.ConstructorInfo ->
                       ProvidedConstructorInfo
        static member
          CreateArray : ctxt:ProvidedTypeContext ->
                          xs:System.Reflection.ConstructorInfo [] ->
                            ProvidedConstructorInfo []
        override Equals : y:obj -> bool
        override GetHashCode : unit -> int
        member Handle : System.Reflection.ConstructorInfo
      end
    and ProvidedExprType =
      | ProvidedNewArrayExpr of ProvidedType * ProvidedExpr []
      | ProvidedNewObjectExpr of ProvidedConstructorInfo * ProvidedExpr []
      | ProvidedWhileLoopExpr of ProvidedExpr * ProvidedExpr
      | ProvidedNewDelegateExpr of ProvidedType * ProvidedVar [] * ProvidedExpr
      | ProvidedForIntegerRangeLoopExpr of
        ProvidedVar * ProvidedExpr * ProvidedExpr * ProvidedExpr
      | ProvidedSequentialExpr of ProvidedExpr * ProvidedExpr
      | ProvidedTryWithExpr of
        ProvidedExpr * ProvidedVar * ProvidedExpr * ProvidedVar * ProvidedExpr
      | ProvidedTryFinallyExpr of ProvidedExpr * ProvidedExpr
      | ProvidedLambdaExpr of ProvidedVar * ProvidedExpr
      | ProvidedCallExpr of
        ProvidedExpr option * ProvidedMethodInfo * ProvidedExpr []
      | ProvidedConstantExpr of obj * ProvidedType
      | ProvidedDefaultExpr of ProvidedType
      | ProvidedNewTupleExpr of ProvidedExpr []
      | ProvidedTupleGetExpr of ProvidedExpr * int
      | ProvidedTypeAsExpr of ProvidedExpr * ProvidedType
      | ProvidedTypeTestExpr of ProvidedExpr * ProvidedType
      | ProvidedLetExpr of ProvidedVar * ProvidedExpr * ProvidedExpr
      | ProvidedVarSetExpr of ProvidedVar * ProvidedExpr
      | ProvidedIfThenElseExpr of ProvidedExpr * ProvidedExpr * ProvidedExpr
      | ProvidedVarExpr of ProvidedVar
    [<RequireQualifiedAccessAttribute (); ClassAttribute (); SealedAttribute ();
      AllowNullLiteralAttribute ()>]
    and ProvidedExpr =
      class
        new : x:Quotations.Expr * ctxt:ProvidedTypeContext -> ProvidedExpr
        static member
          Create : ctxt:ProvidedTypeContext -> t:Quotations.Expr -> ProvidedExpr
        static member
          CreateArray : ctxt:ProvidedTypeContext ->
                          xs:Quotations.Expr [] -> ProvidedExpr []
        override Equals : y:obj -> bool
        member GetExprType : unit -> ProvidedExprType option
        override GetHashCode : unit -> int
        member Context : ProvidedTypeContext
        member Handle : Quotations.Expr
        member Type : ProvidedType
        member UnderlyingExpressionString : string
      end
    [<RequireQualifiedAccessAttribute (); ClassAttribute (); SealedAttribute ();
      AllowNullLiteralAttribute ()>]
    and ProvidedVar =
      class
        new : x:Quotations.Var * ctxt:ProvidedTypeContext -> ProvidedVar
        static member
          Create : ctxt:ProvidedTypeContext -> t:Quotations.Var -> ProvidedVar
        static member
          CreateArray : ctxt:ProvidedTypeContext ->
                          xs:Quotations.Var [] -> ProvidedVar []
        override Equals : obj -> bool
        override GetHashCode : unit -> int
        member Context : ProvidedTypeContext
        member Handle : Quotations.Var
        member IsMutable : bool
        member Name : string
        member Type : ProvidedType
      end
    val GetInvokerExpression :
      CompilerServices.ITypeProvider * ProvidedMethodBase * ProvidedVar [] ->
        ProvidedExpr
    val CheckAndComputeProvidedNameProperty :
      m:Range.range * st:Tainted<ProvidedType> * proj:(ProvidedType -> string) *
      propertyString:System.String -> string
    val ValidateAttributesOfProvidedType :
      m:Range.range * st:Tainted<ProvidedType> -> unit
    val ValidateExpectedName :
      m:Range.range ->
        expectedPath:string [] ->
          expectedName:string -> st:Tainted<ProvidedType> -> unit
    val ValidateProvidedTypeAfterStaticInstantiation :
      Range.range * Tainted<ProvidedType> * expectedPath:string [] *
      expectedName:string -> unit
    val ValidateProvidedTypeDefinition :
      m:Range.range * st:Tainted<ProvidedType> * expectedPath:string [] *
      expectedName:string -> unit
    val ResolveProvidedType :
      resolver:Tainted<CompilerServices.ITypeProvider> * m:Range.range *
      moduleOrNamespace:string [] * typeName:string -> Tainted<ProvidedType>
    val TryResolveProvidedType :
      Tainted<CompilerServices.ITypeProvider> * Range.range * string [] *
      typeName:string -> Tainted<ProvidedType> option
    val ILPathToProvidedType :
      st:Tainted<ProvidedType> * m:Range.range -> string list * string
    val ComputeMangledNameForApplyStaticParameters :
      nm:string * staticArgs:'a [] *
      staticParams:Tainted<ProvidedParameterInfo []> * m:Range.range -> string
    val TryApplyProvidedMethod :
      methBeforeArgs:Tainted<ProvidedMethodBase> * staticArgs:obj [] *
      Range.range -> Tainted<ProvidedMethodBase> option
    val TryApplyProvidedType :
      typeBeforeArguments:Tainted<ProvidedType> *
      optGeneratedTypePath:string list option * staticArgs:obj [] * Range.range ->
        (Tainted<ProvidedType> * (unit -> unit)) option
    val TryLinkProvidedType :
      Tainted<CompilerServices.ITypeProvider> * string [] *
      typeLogicalName:string * range:Range.range -> Tainted<ProvidedType> option
    val GetPartsOfNamespaceRecover : namespaceName:string -> string list
    val GetProvidedNamespaceAsPath :
      Range.range * Tainted<CompilerServices.ITypeProvider> * string ->
        string list
    val GetFSharpPathToProvidedType :
      Tainted<ProvidedType> * range:Range.range -> string list
    val GetOriginalILAssemblyRefOfProvidedAssembly :
      assembly:Tainted<ProvidedAssembly> * m:Range.range ->
        AbstractIL.IL.ILAssemblyRef
    val GetOriginalILTypeRefOfProvidedType :
      Tainted<ProvidedType> * range:Range.range -> AbstractIL.IL.ILTypeRef
    val GetILTypeRefOfProvidedType :
      Tainted<ProvidedType> * range:Range.range -> AbstractIL.IL.ILTypeRef
    type ProviderGeneratedType =
      | ProviderGeneratedType of
        AbstractIL.IL.ILTypeRef * AbstractIL.IL.ILTypeRef *
        ProviderGeneratedType list
    type ProvidedAssemblyStaticLinkingMap =
      { ILTypeMap:
          System.Collections.Generic.Dictionary<AbstractIL.IL.ILTypeRef,
                                                AbstractIL.IL.ILTypeRef> }
      with
        static member CreateNew : unit -> ProvidedAssemblyStaticLinkingMap
      end
    val IsGeneratedTypeDirectReference :
      Tainted<ProvidedType> * Range.range -> bool
  end

namespace FSharp.Compiler
  module internal QuotationPickler = begin
    val mkRLinear : mk:('a * 'b -> 'b) -> vs:'a list * body:'b -> 'b
    type TypeVarData =
      { tvName: string }
    type NamedTypeData =
      | Idx of int
      | Named of string * string
    type TypeCombOp =
      | ArrayTyOp of int
      | FunTyOp
      | NamedTyOp of NamedTypeData
    type TypeData =
      | VarType of int
      | AppType of TypeCombOp * TypeData list
    val mkVarTy : int -> TypeData
    val mkFunTy : (TypeData * TypeData) -> TypeData
    val mkArrayTy : (int * TypeData) -> TypeData
    val mkILNamedTy : (NamedTypeData * TypeData list) -> TypeData
    type CtorData =
      { ctorParent: NamedTypeData
        ctorArgTypes: TypeData list }
    type MethodData =
      { methParent: NamedTypeData
        methName: string
        methArgTypes: TypeData list
        methRetType: TypeData
        numGenericArgs: int }
    type VarData =
      { vText: string
        vType: TypeData
        vMutable: bool }
    type PropInfoData = NamedTypeData * string * TypeData * TypeData list
    type CombOp =
      | AppOp
      | CondOp
      | ModuleValueOp of NamedTypeData * string * bool
      | ModuleValueWOp of NamedTypeData * string * bool * string * int
      | LetRecOp
      | LetRecCombOp
      | LetOp
      | RecdMkOp of NamedTypeData
      | RecdGetOp of NamedTypeData * string
      | RecdSetOp of NamedTypeData * string
      | SumMkOp of NamedTypeData * string
      | SumFieldGetOp of NamedTypeData * string * int
      | SumTagTestOp of NamedTypeData * string
      | TupleMkOp
      | TupleGetOp of int
      | UnitOp
      | BoolOp of bool
      | StringOp of string
      | SingleOp of float32
      | DoubleOp of float
      | CharOp of char
      | SByteOp of sbyte
      | ByteOp of byte
      | Int16Op of int16
      | UInt16Op of uint16
      | Int32Op of int32
      | UInt32Op of uint32
      | Int64Op of int64
      | UInt64Op of uint64
      | PropGetOp of PropInfoData
      | FieldGetOp of NamedTypeData * string
      | CtorCallOp of CtorData
      | MethodCallOp of MethodData
      | MethodCallWOp of MethodData * MethodData * int
      | CoerceOp
      | NewArrayOp
      | DelegateOp
      | SeqOp
      | ForLoopOp
      | WhileLoopOp
      | NullOp
      | DefaultValueOp
      | PropSetOp of PropInfoData
      | FieldSetOp of NamedTypeData * string
      | AddressOfOp
      | ExprSetOp
      | AddressSetOp
      | TypeTestOp
      | TryFinallyOp
      | TryWithOp
    type ExprData =
      | AttrExpr of ExprData * ExprData list
      | CombExpr of CombOp * TypeData list * ExprData list
      | VarExpr of int
      | QuoteExpr of ExprData
      | LambdaExpr of VarData * ExprData
      | HoleExpr of TypeData * int
      | ThisVarExpr of TypeData
      | QuoteRawExpr of ExprData
    val mkVar : int -> ExprData
    val mkHole : TypeData * int -> ExprData
    val mkApp : ExprData * ExprData -> ExprData
    val mkLambda : VarData * ExprData -> ExprData
    val mkQuote : ExprData -> ExprData
    val mkQuoteRaw40 : ExprData -> ExprData
    val mkCond : ExprData * ExprData * ExprData -> ExprData
    val mkModuleValueApp :
      NamedTypeData * string * bool * TypeData list * ExprData list -> ExprData
    val mkModuleValueWApp :
      NamedTypeData * string * bool * string * int * TypeData list *
      ExprData list -> ExprData
    val mkTuple : TypeData * ExprData list -> ExprData
    val mkLet : (VarData * ExprData) * ExprData -> ExprData
    val mkUnit : unit -> ExprData
    val mkNull : TypeData -> ExprData
    val mkLetRecRaw : e1:ExprData -> ExprData
    val mkLetRecCombRaw : args:ExprData list -> ExprData
    val mkLetRec : (VarData * ExprData) list * ExprData -> ExprData
    val mkRecdMk : NamedTypeData * TypeData list * ExprData list -> ExprData
    val mkRecdGet :
      NamedTypeData * string * TypeData list * ExprData list -> ExprData
    val mkRecdSet :
      NamedTypeData * string * TypeData list * ExprData list -> ExprData
    val mkUnion :
      NamedTypeData * string * TypeData list * ExprData list -> ExprData
    val mkUnionFieldGet :
      NamedTypeData * string * int * TypeData list * ExprData -> ExprData
    val mkUnionCaseTagTest :
      NamedTypeData * string * TypeData list * ExprData -> ExprData
    val mkTupleGet : TypeData * int * ExprData -> ExprData
    val mkCoerce : TypeData * ExprData -> ExprData
    val mkTypeTest : TypeData * ExprData -> ExprData
    val mkAddressOf : ExprData -> ExprData
    val mkAddressSet : ExprData * ExprData -> ExprData
    val mkVarSet : ExprData * ExprData -> ExprData
    val mkDefaultValue : TypeData -> ExprData
    val mkThisVar : TypeData -> ExprData
    val mkNewArray : TypeData * ExprData list -> ExprData
    val mkBool : bool * TypeData -> ExprData
    val mkString : string * TypeData -> ExprData
    val mkSingle : float32 * TypeData -> ExprData
    val mkDouble : float * TypeData -> ExprData
    val mkChar : char * TypeData -> ExprData
    val mkSByte : sbyte * TypeData -> ExprData
    val mkByte : byte * TypeData -> ExprData
    val mkInt16 : int16 * TypeData -> ExprData
    val mkUInt16 : uint16 * TypeData -> ExprData
    val mkInt32 : int32 * TypeData -> ExprData
    val mkUInt32 : uint32 * TypeData -> ExprData
    val mkInt64 : int64 * TypeData -> ExprData
    val mkUInt64 : uint64 * TypeData -> ExprData
    val mkSequential : ExprData * ExprData -> ExprData
    val mkForLoop : ExprData * ExprData * ExprData -> ExprData
    val mkWhileLoop : ExprData * ExprData -> ExprData
    val mkTryFinally : ExprData * ExprData -> ExprData
    val mkTryWith :
      ExprData * VarData * ExprData * VarData * ExprData -> ExprData
    val mkDelegate : TypeData * ExprData -> ExprData
    val mkPropGet : PropInfoData * TypeData list * ExprData list -> ExprData
    val mkPropSet : PropInfoData * TypeData list * ExprData list -> ExprData
    val mkFieldGet :
      NamedTypeData * string * TypeData list * ExprData list -> ExprData
    val mkFieldSet :
      NamedTypeData * string * TypeData list * ExprData list -> ExprData
    val mkCtorCall : CtorData * TypeData list * ExprData list -> ExprData
    val mkMethodCall : MethodData * TypeData list * ExprData list -> ExprData
    val mkMethodCallW :
      MethodData * MethodData * int * TypeData list * ExprData list -> ExprData
    val mkAttributedExpression : ExprData * ExprData -> ExprData
    val isAttributedExpression : ExprData -> bool
    val SerializedReflectedDefinitionsResourceNameBase : string
    val freshVar : string * TypeData * bool -> VarData
    module SimplePickle = begin
      type Table<'T> =
        { tbl: Internal.Utilities.Collections.HashMultiMap<'T,int>
          mutable rows: 'T list
          mutable count: int }
        with
          static member Create : unit -> Table<'a> when 'a : equality
          member Add : x:'T -> int
          member ContainsKey : x:'T -> bool
          member Find : x:'T -> int
          member FindOrAdd : x:'T -> int
          member AsList : 'T list
          member Count : int
        end
      type QuotationPickleOutState =
        { os: AbstractIL.Internal.ByteBuffer
          ostrings: Table<string> }
      val p_byte : b:int -> st:QuotationPickleOutState -> unit
      val p_bool : b:bool -> st:QuotationPickleOutState -> unit
      val p_void : _os:QuotationPickleOutState -> unit
      val p_unit : unit -> _os:QuotationPickleOutState -> unit
      val prim_pint32 : i:int -> st:QuotationPickleOutState -> unit
      val p_int32 : n:int -> st:QuotationPickleOutState -> unit
      val p_bytes : s:byte [] -> st:QuotationPickleOutState -> unit
      val prim_pstring : s:string -> st:QuotationPickleOutState -> unit
      val p_int : c:int -> st:QuotationPickleOutState -> unit
      val p_int8 : i:int8 -> st:QuotationPickleOutState -> unit
      val p_uint8 : i:uint8 -> st:QuotationPickleOutState -> unit
      val p_int16 : i:int16 -> st:QuotationPickleOutState -> unit
      val p_uint16 : x:uint16 -> st:QuotationPickleOutState -> unit
      val puint32 : x:uint32 -> st:QuotationPickleOutState -> unit
      val p_int64 : i:int64 -> st:QuotationPickleOutState -> unit
      val bits_of_float32 : x:float32 -> int
      val bits_of_float : x:float -> int64
      val p_uint64 : x:uint64 -> st:QuotationPickleOutState -> unit
      val p_double : i:float -> st:QuotationPickleOutState -> unit
      val p_single : i:float32 -> st:QuotationPickleOutState -> unit
      val p_char : i:char -> st:QuotationPickleOutState -> unit
      val inline p_tup2 :
        p1:('a -> QuotationPickleOutState -> unit) ->
          p2:('b -> QuotationPickleOutState -> unit) ->
            a:'a * b:'b -> st:QuotationPickleOutState -> unit
      val inline p_tup3 :
        p1:('a -> 'b -> unit) ->
          p2:('c -> 'b -> unit) ->
            p3:('d -> 'b -> unit) -> a:'a * b:'c * c:'d -> st:'b -> unit
      val inline p_tup4 :
        p1:('a -> 'b -> unit) ->
          p2:('c -> 'b -> unit) ->
            p3:('d -> 'b -> unit) ->
              p4:('e -> 'b -> unit) ->
                a:'a * b:'c * c:'d * d:'e -> st:'b -> unit
      val inline p_tup5 :
        p1:('a -> 'b -> unit) ->
          p2:('c -> 'b -> unit) ->
            p3:('d -> 'b -> unit) ->
              p4:('e -> 'b -> unit) ->
                p5:('f -> 'b -> unit) ->
                  a:'a * b:'c * c:'d * d:'e * e:'f -> st:'b -> unit
      val puniq : tbl:Table<'a> -> key:'a -> st:QuotationPickleOutState -> unit
      val p_string : s:string -> st:QuotationPickleOutState -> unit
      val p_list :
        f:('a -> QuotationPickleOutState -> unit) ->
          x:'a list -> st:QuotationPickleOutState -> unit
      val pickle_obj :
        p:('a -> QuotationPickleOutState -> unit) -> x:'a -> byte []
    end
    val p_assemblyref :
      x:string -> st:SimplePickle.QuotationPickleOutState -> unit
    val p_NamedType :
      x:NamedTypeData -> st:SimplePickle.QuotationPickleOutState -> unit
    val p_tycon :
      x:TypeCombOp -> st:SimplePickle.QuotationPickleOutState -> unit
    val p_type : x:TypeData -> st:SimplePickle.QuotationPickleOutState -> unit
    val p_types :
      x:TypeData list -> st:SimplePickle.QuotationPickleOutState -> unit
    val p_varDecl : v:VarData -> st:SimplePickle.QuotationPickleOutState -> unit
    val p_recdFieldSpec :
      NamedTypeData * string -> st:SimplePickle.QuotationPickleOutState -> unit
    val p_ucaseSpec :
      NamedTypeData * string -> st:SimplePickle.QuotationPickleOutState -> unit
    val p_MethodData :
      a:MethodData -> st:SimplePickle.QuotationPickleOutState -> unit
    val p_CtorData :
      a:CtorData -> st:SimplePickle.QuotationPickleOutState -> unit
    val p_PropInfoData :
      NamedTypeData * string * TypeData * TypeData list ->
        st:SimplePickle.QuotationPickleOutState -> unit
    val p_CombOp : x:CombOp -> st:SimplePickle.QuotationPickleOutState -> unit
    val p_expr : x:ExprData -> st:SimplePickle.QuotationPickleOutState -> unit
    type ModuleDefnData =
      { Module: NamedTypeData
        Name: string
        IsProperty: bool }
    type MethodBaseData =
      | ModuleDefn of ModuleDefnData * (string * int) option
      | Method of MethodData
      | Ctor of CtorData
    val pickle : (ExprData -> byte [])
    val p_MethodBase :
      x:MethodBaseData -> st:SimplePickle.QuotationPickleOutState -> unit
    val PickleDefns : ((MethodBaseData * ExprData) list -> byte [])
  end

namespace FSharp.Compiler
  module CompilerGlobalState = begin
    type NiceNameGenerator =
      class
        new : unit -> NiceNameGenerator
        member
          FreshCompilerGeneratedName : name:string * m:Range.range -> string
        member Reset : unit -> unit
      end
    type StableNiceNameGenerator =
      class
        new : unit -> StableNiceNameGenerator
        member
          GetUniqueCompilerGeneratedName : name:string * m:Range.range *
                                           uniq:int64 -> string
        member Reset : unit -> unit
      end
    type internal CompilerGlobalState =
      class
        new : unit -> CompilerGlobalState
        member IlxGenNiceNameGenerator : NiceNameGenerator
        member NiceNameGenerator : NiceNameGenerator
        member StableNameGenerator : StableNiceNameGenerator
      end
    type Unique = int64
    val newUnique : (unit -> int64)
    val newStamp : (unit -> int64)
  end

namespace FSharp.Compiler
  module internal TypedTree = begin
    type Stamp = int64
    and StampMap<'T> = Map<Stamp,'T>
    [<RequireQualifiedAccessAttribute ()>]
    and ValInline =
      | PseudoVal
      | Always
      | Optional
      | Never
      with
        member MustInline : bool
      end
    and ValRecursiveScopeInfo =
      | ValInRecScope of bool
      | ValNotInRecScope
    and ValMutability =
      | Immutable
      | Mutable
    [<RequireQualifiedAccessAttribute ()>]
    and TyparDynamicReq =
      | No
      | Yes
    and ValBaseOrThisInfo =
      | CtorThisVal
      | BaseVal
      | NormalVal
      | MemberThisVal
    [<StructAttribute ()>]
    and ValFlags =
      struct
        new : recValInfo:ValRecursiveScopeInfo * baseOrThis:ValBaseOrThisInfo *
              isCompGen:bool * inlineInfo:ValInline * isMutable:ValMutability *
              isModuleOrMemberBinding:bool * isExtensionMember:bool *
              isIncrClassSpecialMember:bool * isTyFunc:bool * allowTypeInst:bool *
              isGeneratedEventVal:bool -> ValFlags
        new : flags:int64 -> ValFlags
        member SetIsCompilerGenerated : isCompGen:bool -> ValFlags
        member
          WithRecursiveValInfo : recValInfo:ValRecursiveScopeInfo -> ValFlags
        member BaseOrThisInfo : ValBaseOrThisInfo
        member HasBeenReferenced : bool
        member IgnoresByrefScope : bool
        member InlineInfo : ValInline
        member IsCompiledAsStaticPropertyWithoutField : bool
        member IsCompilerGenerated : bool
        member IsExtensionMember : bool
        member IsFixed : bool
        member IsGeneratedEventVal : bool
        member IsIncrClassSpecialMember : bool
        member IsMemberOrModuleBinding : bool
        member IsTypeFunction : bool
        member MakesNoCriticalTailcalls : bool
        member MutabilityInfo : ValMutability
        member PermitsExplicitTypeInstantiation : bool
        member PickledBits : int64
        member RecursiveValInfo : ValRecursiveScopeInfo
        member WithHasBeenReferenced : ValFlags
        member WithIgnoresByrefScope : ValFlags
        member WithIsCompiledAsStaticPropertyWithoutField : ValFlags
        member WithIsFixed : ValFlags
        member WithIsMemberOrModuleBinding : ValFlags
        member WithMakesNoCriticalTailcalls : ValFlags
      end
    [<RequireQualifiedAccessAttribute ()>]
    and TyparKind =
      | Type
      | Measure
      with
        override ToString : unit -> string
        member AttrName : string voption
      end
    [<RequireQualifiedAccessAttribute ()>]
    and TyparRigidity =
      | Rigid
      | WillBeRigid
      | WarnIfNotRigid
      | Flexible
      | Anon
      with
        member ErrorIfUnified : bool
        member WarnIfMissingConstraint : bool
        member WarnIfUnified : bool
      end
    [<StructAttribute ()>]
    and TyparFlags =
      struct
        new : kind:TyparKind * rigidity:TyparRigidity * isFromError:bool *
              isCompGen:bool * staticReq:SyntaxTree.TyparStaticReq *
              dynamicReq:TyparDynamicReq * equalityDependsOn:bool *
              comparisonDependsOn:bool -> TyparFlags
        new : flags:int32 -> TyparFlags
        member WithCompatFlex : b:bool -> TyparFlags
        member ComparisonConditionalOn : bool
        member DynamicReq : TyparDynamicReq
        member EqualityConditionalOn : bool
        member IsCompatFlex : bool
        member IsCompilerGenerated : bool
        member IsFromError : bool
        member Kind : TyparKind
        member PickledBits : int32
        member Rigidity : TyparRigidity
        member StaticReq : SyntaxTree.TyparStaticReq
      end
    [<StructAttribute ()>]
    and EntityFlags =
      struct
        new : usesPrefixDisplay:bool * isModuleOrNamespace:bool *
              preEstablishedHasDefaultCtor:bool * hasSelfReferentialCtor:bool *
              isStructRecordOrUnionType:bool -> EntityFlags
        new : flags:int64 -> EntityFlags
        member WithIsAssumedReadOnly : flag:bool -> EntityFlags
        member WithIsByRefLike : flag:bool -> EntityFlags
        member WithIsReadOnly : flag:bool -> EntityFlags
        member HasSelfReferentialConstructor : bool
        member IsModuleOrNamespace : bool
        member IsPrefixDisplay : bool
        member IsStructRecordOrUnionType : bool
        member PickledBits : int64
        member PreEstablishedHasDefaultConstructor : bool
        member TryIsAssumedReadOnly : bool voption
        member TryIsByRefLike : bool voption
        member TryIsReadOnly : bool voption
        static member ReservedBitForPickleFormatTyconReprFlag : int64
      end
    and UndefinedName =
    with
      inherit exn
      interface System.Collections.IStructuralEquatable
      val Data0: int
      val Data1: string -> string
      val Data2: SyntaxTree.Ident
      val Data3: ErrorLogger.Suggestions
    end
    and InternalUndefinedItemRef =
    with
      inherit exn
      interface System.Collections.IStructuralEquatable
      val Data0: string * string * string -> int * string
      val Data1: string
      val Data2: string
      val Data3: string
    end
    and ModuleOrNamespaceKind =
      | FSharpModuleWithSuffix
      | ModuleOrType
      | Namespace
    and PublicPath =
      | PubPath of string []
      with
        member EnclosingPath : string []
      end
    and CompilationPath =
      | CompPath of
        AbstractIL.IL.ILScopeRef * (string * ModuleOrNamespaceKind) list
      with
        static member
          DemangleEntityName : nm:string -> k:ModuleOrNamespaceKind -> string
        member
          NestedCompPath : n:string ->
                             modKind:ModuleOrNamespaceKind -> CompilationPath
        member NestedPublicPath : id:SyntaxTree.Ident -> PublicPath
        member AccessPath : (string * ModuleOrNamespaceKind) list
        member DemangledPath : string list
        member ILScopeRef : AbstractIL.IL.ILScopeRef
        member MangledPath : string list
        member ParentCompPath : CompilationPath
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and EntityOptionalData =
      { mutable entity_compiled_name: string option
        mutable entity_other_range: (Range.range * bool) option
        mutable entity_kind: TyparKind
        mutable entity_xmldoc: XmlDoc.XmlDoc
        mutable entity_xmldocsig: string
        mutable entity_tycon_abbrev: TType option
        mutable entity_tycon_repr_accessibility: Accessibility
        mutable entity_accessibility: Accessibility
        mutable entity_exn_info: ExceptionInfo }
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and Entity =
      { mutable entity_typars:
          AbstractIL.Internal.Library.LazyWithContext<Typars,Range.range>
        mutable entity_flags: EntityFlags
        mutable entity_stamp: Stamp
        mutable entity_logical_name: string
        mutable entity_range: Range.range
        mutable entity_attribs: Attribs
        mutable entity_tycon_repr: TyconRepresentation
        mutable entity_tycon_tcaug: TyconAugmentation
        mutable entity_modul_contents: Lib.MaybeLazy<ModuleOrNamespaceType>
        mutable entity_pubpath: PublicPath option
        mutable entity_cpath: CompilationPath option
        mutable entity_il_repr_cache: Lib.cache<CompiledTypeRepr>
        mutable entity_opt_data: EntityOptionalData option }
      with
        static member New : _reason:'b -> data:Entity -> Entity
        static member NewEmptyEntityOptData : unit -> EntityOptionalData
        static member NewUnlinked : unit -> Entity
        member
          GetDisplayName : ?withStaticParameters:bool * ?withTypars:bool *
                           ?withUnderscoreTypars:bool -> string
        member GetFieldByIndex : n:int -> RecdField
        member GetFieldByName : n:string -> RecdField option
        member GetUnionCaseByName : n:string -> UnionCase option
        member Link : tg:EntityData -> unit
        member SetAttribs : attribs:Attribs -> unit
        member SetCompiledName : name:string option -> unit
        member SetExceptionInfo : exn_info:ExceptionInfo -> unit
        member SetIsAssumedReadOnly : b:bool -> unit
        member SetIsByRefLike : b:bool -> unit
        member SetIsReadOnly : b:bool -> unit
        member SetIsStructRecordOrUnion : b:bool -> unit
        member SetOtherRange : m:(Range.range * bool) -> unit
        member SetTypeAbbrev : tycon_abbrev:TType option -> unit
        member SetTypeOrMeasureKind : kind:TyparKind -> unit
        override ToString : unit -> string
        member Typars : m:Range.range -> Typars
        member Accessibility : Accessibility
        member AllFieldTable : TyconRecdFields
        member AllFieldsArray : RecdField []
        member AllFieldsAsList : RecdField list
        member AllGeneratedValues : ValRef list
        member AllInstanceFieldsAsList : RecdField list
        member Attribs : Attribs
        member CompilationPath : CompilationPath
        member CompilationPathOpt : CompilationPath option
        member CompiledName : string
        member CompiledReprCache : Lib.cache<CompiledTypeRepr>
        member CompiledRepresentation : CompiledTypeRepr
        member CompiledRepresentationForNamedType : AbstractIL.IL.ILTypeRef
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member DefinitionRange : Range.range
        member DemangledModuleOrNamespaceName : string
        member DisplayName : string
        member DisplayNameWithStaticParameters : string
        member DisplayNameWithStaticParametersAndTypars : string
        member DisplayNameWithStaticParametersAndUnderscoreTypars : string
        member EntityCompiledName : string option
        member ExceptionInfo : ExceptionInfo
        member FSharpObjectModelTypeInfo : TyconObjModelData
        member GeneratedCompareToValues : (ValRef * ValRef) option
        member GeneratedCompareToWithComparerValues : ValRef option
        member GeneratedHashAndEqualsValues : (ValRef * ValRef) option
        member
          GeneratedHashAndEqualsWithComparerValues : (ValRef * ValRef * ValRef) option
        member HasSelfReferentialConstructor : bool
        member ILTyconInfo : TILObjectReprData
        member ILTyconRawMetadata : AbstractIL.IL.ILTypeDef
        member Id : SyntaxTree.Ident
        member ImmediateInterfaceTypesOfFSharpTycon : TType list
        member
          ImmediateInterfacesOfFSharpTycon : (TType * bool * Range.range) list
        member IsAsmReprTycon : bool
        member IsEnumTycon : bool
        member IsErased : bool
        member IsExceptionDecl : bool
        member IsFSharpClassTycon : bool
        member IsFSharpDelegateTycon : bool
        member IsFSharpEnumTycon : bool
        member IsFSharpInterfaceTycon : bool
        member IsFSharpObjectModelTycon : bool
        member IsFSharpStructOrEnumTycon : bool
        member IsHiddenReprTycon : bool
        member IsILEnumTycon : bool
        member IsILStructOrEnumTycon : bool
        member IsILTycon : bool
        member IsLinked : bool
        member IsMeasureableReprTycon : bool
        member IsModule : bool
        member IsModuleOrNamespace : bool
        member IsNamespace : bool
        member IsPrefixDisplay : bool
        member IsProvided : bool
        member IsProvidedErasedTycon : bool
        member IsProvidedGeneratedTycon : bool
        member IsProvidedNamespace : bool
        member IsRecordTycon : bool
        member IsStaticInstantiationTycon : bool
        member IsStructOrEnumTycon : bool
        member IsStructRecordOrUnionTycon : bool
        member IsTypeAbbrev : bool
        member IsUnionTycon : bool
        member LogicalName : string
        member
          MembersOfFSharpTyconByName : AbstractIL.Internal.Library.NameMultiMap<ValRef>
        member MembersOfFSharpTyconSorted : ValRef list
        member ModuleOrNamespaceType : ModuleOrNamespaceType
        member PreEstablishedHasDefaultConstructor : bool
        member PublicPath : PublicPath option
        member Range : Range.range
        member SigRange : Range.range
        member Stamp : Stamp
        member TrueFieldsAsList : RecdField list
        member TrueInstanceFieldsAsList : RecdField list
        member TryIsAssumedReadOnly : bool voption
        member TryIsByRefLike : bool voption
        member TryIsReadOnly : bool voption
        member TyparsNoRange : Typars
        member TypeAbbrev : TType option
        member TypeContents : TyconAugmentation
        member TypeOrMeasureKind : TyparKind
        member TypeReprAccessibility : Accessibility
        member TypeReprInfo : TyconRepresentation
        member UnionCasesArray : UnionCase []
        member UnionCasesAsList : UnionCase list
        member UnionTypeInfo : TyconUnionData voption
        member XmlDoc : XmlDoc.XmlDoc
        member XmlDocSig : string
      end
    and EntityData = Entity
    and ParentRef =
      | Parent of EntityRef
      | ParentNone
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and CompiledTypeRepr =
      | ILAsmNamed of
        AbstractIL.IL.ILTypeRef * AbstractIL.IL.ILBoxity *
        AbstractIL.IL.ILType option
      | ILAsmOpen of AbstractIL.IL.ILType
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and TyconAugmentation =
      { mutable tcaug_compare: (ValRef * ValRef) option
        mutable tcaug_compare_withc: ValRef option
        mutable tcaug_equals: (ValRef * ValRef) option
        mutable tcaug_hash_and_equals_withc: (ValRef * ValRef * ValRef) option
        mutable tcaug_hasObjectGetHashCode: bool
        tcaug_adhoc_list: ResizeArray<bool * ValRef>
        mutable tcaug_adhoc: AbstractIL.Internal.Library.NameMultiMap<ValRef>
        mutable tcaug_interfaces: (TType * bool * Range.range) list
        mutable tcaug_super: TType option
        mutable tcaug_closed: bool
        mutable tcaug_abstract: bool }
      with
        static member Create : unit -> TyconAugmentation
        member SetCompare : x:(ValRef * ValRef) -> unit
        member SetCompareWith : x:ValRef -> unit
        member SetEquals : x:(ValRef * ValRef) -> unit
        member SetHasObjectGetHashCode : b:bool -> unit
        member SetHashAndEqualsWith : x:(ValRef * ValRef * ValRef) -> unit
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and TyconRepresentation =
      | TFSharpObjectRepr of TyconObjModelData
      | TRecdRepr of TyconRecdFields
      | TUnionRepr of TyconUnionData
      | TILObjectRepr of TILObjectReprData
      | TAsmRepr of AbstractIL.IL.ILType
      | TMeasureableRepr of TType
      | TProvidedTypeExtensionPoint of TProvidedTypeInfo
      | TProvidedNamespaceExtensionPoint of
        ExtensionTyping.ResolutionEnvironment *
        Tainted<CompilerServices.ITypeProvider> list
      | TNoRepr
      with
        override ToString : unit -> string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and TILObjectReprData =
      | TILObjectReprData of
        scope: AbstractIL.IL.ILScopeRef * nesting: AbstractIL.IL.ILTypeDef list *
        definition: AbstractIL.IL.ILTypeDef
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoComparisonAttribute (); NoEqualityAttribute ();
      RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and TProvidedTypeInfo =
      { ResolutionEnvironment: ExtensionTyping.ResolutionEnvironment
        ProvidedType: Tainted<ExtensionTyping.ProvidedType>
        LazyBaseType:
          AbstractIL.Internal.Library.LazyWithContext<TType,
                                                      (Range.range * TType)>
        IsClass: bool
        IsSealed: bool
        IsAbstract: bool
        IsInterface: bool
        IsStructOrEnum: bool
        IsEnum: bool
        UnderlyingTypeOfEnum: unit -> TType
        IsDelegate: unit -> bool
        IsErased: bool
        IsSuppressRelocate: bool }
      with
        member BaseTypeForErased : m:Range.range * objTy:TType -> TType
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member IsGenerated : bool
      end
    and TyconObjModelKind =
      | TTyconClass
      | TTyconInterface
      | TTyconStruct
      | TTyconDelegate of SlotSig
      | TTyconEnum
      with
        member IsValueType : bool
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and TyconObjModelData =
      { fsobjmodel_kind: TyconObjModelKind
        fsobjmodel_vslots: ValRef list
        fsobjmodel_rfields: TyconRecdFields }
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and TyconRecdFields =
      { FieldsByIndex: RecdField []
        FieldsByName: AbstractIL.Internal.Library.NameMap<RecdField> }
      with
        member FieldByIndex : n:int -> RecdField
        member FieldByName : nm:string -> RecdField option
        override ToString : unit -> string
        member AllFieldsAsList : RecdField list
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member TrueFieldsAsList : RecdField list
        member TrueInstanceFieldsAsList : RecdField list
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and TyconUnionCases =
      { CasesByIndex: UnionCase []
        CasesByName: AbstractIL.Internal.Library.NameMap<UnionCase> }
      with
        member GetUnionCaseByIndex : n:int -> UnionCase
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member UnionCasesAsList : UnionCase list
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and TyconUnionData =
      { CasesTable: TyconUnionCases
        CompiledRepresentation:
          Lib.cache<AbstractIL.Extensions.ILX.Types.IlxUnionRef> }
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member UnionCasesAsList : UnionCase list
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and UnionCase =
      { FieldTable: TyconRecdFields
        ReturnType: TType
        XmlDoc: XmlDoc.XmlDoc
        mutable XmlDocSig: string
        Id: SyntaxTree.Ident
        mutable OtherRangeOpt: (Range.range * bool) option
        Accessibility: Accessibility
        mutable Attribs: Attribs }
      with
        member GetFieldByIndex : n:int -> RecdField
        member GetFieldByName : nm:string -> RecdField option
        override ToString : unit -> string
        member CompiledName : string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member DefinitionRange : Range.range
        member DisplayName : string
        member IsNullary : bool
        member Range : Range.range
        member RecdFields : RecdField list
        member RecdFieldsArray : RecdField []
        member SigRange : Range.range
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and RecdField =
      { rfield_mutable: bool
        rfield_xmldoc: XmlDoc.XmlDoc
        mutable rfield_xmldocsig: string
        rfield_type: TType
        rfield_static: bool
        rfield_volatile: bool
        rfield_secret: bool
        rfield_const: Const option
        rfield_access: Accessibility
        mutable rfield_pattribs: Attribs
        mutable rfield_fattribs: Attribs
        rfield_id: SyntaxTree.Ident
        rfield_name_generated: bool
        mutable rfield_other_range: (Range.range * bool) option }
      with
        override ToString : unit -> string
        member Accessibility : Accessibility
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member DefinitionRange : Range.range
        member FieldAttribs : Attribs
        member FormalType : TType
        member Id : SyntaxTree.Ident
        member IsCompilerGenerated : bool
        member IsMutable : bool
        member IsStatic : bool
        member IsVolatile : bool
        member IsZeroInit : bool
        member LiteralValue : Const option
        member Name : string
        member PropertyAttribs : Attribs
        member Range : Range.range
        member SigRange : Range.range
        member XmlDoc : XmlDoc.XmlDoc
        member XmlDocSig : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and ExceptionInfo =
      | TExnAbbrevRepr of TyconRef
      | TExnAsmRepr of AbstractIL.IL.ILTypeRef
      | TExnFresh of TyconRecdFields
      | TExnNone
      with
        override ToString : unit -> string
      end
    [<SealedAttribute (); StructuredFormatDisplayAttribute ("{DebugText}")>]
    and ModuleOrNamespaceType =
      class
        new : kind:ModuleOrNamespaceKind *
              vals:Internal.Utilities.QueueList<Val> *
              entities:Internal.Utilities.QueueList<Entity> ->
                ModuleOrNamespaceType
        member AddEntity : tycon:Tycon -> ModuleOrNamespaceType
        member AddModuleOrNamespaceByMutation : modul:ModuleOrNamespace -> unit
        member AddProvidedTypeEntity : entity:Entity -> unit
        member AddVal : vspec:Val -> ModuleOrNamespaceType
        override ToString : unit -> string
        member TryLinkVal : ccu:CcuThunk * key:ValLinkageFullKey -> Val voption
        member
          ActivePatternElemRefLookupTable : AbstractIL.Internal.Library.NameMap<ActivePatternElemRef> option ref
        member AllEntities : Internal.Utilities.QueueList<Entity>
        member
          AllEntitiesByCompiledAndLogicalMangledNames : AbstractIL.Internal.Library.NameMap<Entity>
        member
          AllEntitiesByLogicalMangledName : AbstractIL.Internal.Library.NameMap<Entity>
        member AllValsAndMembers : Internal.Utilities.QueueList<Val>
        member
          AllValsAndMembersByLogicalNameUncached : AbstractIL.Internal.Library.MultiMap<string,
                                                                                        Val>
        member
          AllValsAndMembersByPartialLinkageKey : AbstractIL.Internal.Library.MultiMap<ValLinkagePartialKey,
                                                                                      Val>
        member AllValsByLogicalName : AbstractIL.Internal.Library.NameMap<Val>
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member ExceptionDefinitions : Entity list
        member
          ExceptionDefinitionsByDemangledName : AbstractIL.Internal.Library.NameMap<Tycon>
        member ModuleAndNamespaceDefinitions : Entity list
        member ModuleOrNamespaceKind : ModuleOrNamespaceKind
        member
          ModulesAndNamespacesByDemangledName : AbstractIL.Internal.Library.NameMap<ModuleOrNamespace>
        member TypeAndExceptionDefinitions : Entity list
        member TypeDefinitions : Entity list
        member
          TypesByAccessNames : AbstractIL.Internal.Library.LayeredMultiMap<string,
                                                                           Tycon>
        member
          TypesByDemangledNameAndArity : AbstractIL.Internal.Library.LayeredMap<PrettyNaming.NameArityPair,
                                                                                Tycon>
        member TypesByMangledName : AbstractIL.Internal.Library.NameMap<Tycon>
      end
    and ModuleOrNamespace = Entity
    and Tycon = Entity
    [<StructuralEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and Accessibility =
      | TAccess of CompilationPath list
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and TyparOptionalData =
      { mutable typar_il_name: string option
        mutable typar_xmldoc: XmlDoc.XmlDoc
        mutable typar_constraints: TyparConstraint list
        mutable typar_attribs: Attribs }
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    and TyparData = Typar
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and Typar =
      { mutable typar_id: SyntaxTree.Ident
        mutable typar_flags: TyparFlags
        mutable typar_stamp: Stamp
        mutable typar_solution: TType option
        mutable typar_astype: TType
        mutable typar_opt_data: TyparOptionalData option }
      with
        static member New : data:TyparData -> Typar
        static member NewUnlinked : unit -> Typar
        member Link : tg:TyparData -> unit
        member SetAttribs : attribs:Attrib list -> unit
        member SetComparisonDependsOn : b:bool -> unit
        member SetCompilerGenerated : b:bool -> unit
        member SetConstraints : cs:TyparConstraint list -> unit
        member SetDynamicReq : b:TyparDynamicReq -> unit
        member SetEqualityDependsOn : b:bool -> unit
        member SetILName : il_name:string option -> unit
        member SetIdent : id:SyntaxTree.Ident -> unit
        member SetIsCompatFlex : b:bool -> unit
        member SetRigidity : b:TyparRigidity -> unit
        member SetStaticReq : b:SyntaxTree.TyparStaticReq -> unit
        override ToString : unit -> string
        member AsType : TType
        member Attribs : Attribs
        member ComparisonConditionalOn : bool
        member Constraints : TyparConstraint list
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member DisplayName : string
        member DynamicReq : TyparDynamicReq
        member EqualityConditionalOn : bool
        member ILName : string option
        member Id : SyntaxTree.Ident
        member IsCompatFlex : bool
        member IsCompilerGenerated : bool
        member IsErased : bool
        member IsFromError : bool
        member IsLinked : bool
        member IsSolved : bool
        member Kind : TyparKind
        member Name : string
        member Range : Range.range
        member Rigidity : TyparRigidity
        member Solution : TType option
        member Stamp : Stamp
        member StaticReq : SyntaxTree.TyparStaticReq
        member XmlDoc : XmlDoc.XmlDoc
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and TyparConstraint =
      | CoercesTo of TType * Range.range
      | DefaultsTo of int * TType * Range.range
      | SupportsNull of Range.range
      | MayResolveMember of TraitConstraintInfo * Range.range
      | IsNonNullableStruct of Range.range
      | IsReferenceType of Range.range
      | SimpleChoice of TTypes * Range.range
      | RequiresDefaultConstructor of Range.range
      | IsEnum of TType * Range.range
      | SupportsComparison of Range.range
      | SupportsEquality of Range.range
      | IsDelegate of TType * TType * Range.range
      | IsUnmanaged of Range.range
      with
        override ToString : unit -> string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and TraitWitnessInfo =
      | TraitWitnessInfo of
        TTypes * string * SyntaxTree.MemberFlags * TTypes * TType option
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member MemberName : string
        member ReturnType : TType option
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and TraitConstraintInfo =
      | TTrait of
        tys: TTypes * memberName: string * _memFlags: SyntaxTree.MemberFlags *
        argTys: TTypes * returnTy: TType option *
        solution: TraitConstraintSln option ref
      with
        override ToString : unit -> string
        member ArgumentTypes : TTypes
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member MemberFlags : SyntaxTree.MemberFlags
        member MemberName : string
        member ReturnType : TType option
        member Solution : TraitConstraintSln option
        member TraitKey : TraitWitnessInfo
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and TraitConstraintSln =
      | FSMethSln of TType * ValRef * TypeInst
      | FSRecdFieldSln of TypeInst * RecdFieldRef * bool
      | FSAnonRecdFieldSln of AnonRecdTypeInfo * TypeInst * int
      | ILMethSln of
        TType * AbstractIL.IL.ILTypeRef option * AbstractIL.IL.ILMethodRef *
        TypeInst
      | ClosedExprSln of Expr
      | BuiltInSln
      with
        override ToString : unit -> string
      end
    [<RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and ValLinkagePartialKey =
      { MemberParentMangledName: string option
        MemberIsOverride: bool
        LogicalName: string
        TotalArgCount: int }
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<StructuredFormatDisplayAttribute ("{DebugText}")>]
    and ValLinkageFullKey =
      class
        new : partialKey:ValLinkagePartialKey * typeForLinkage:TType option ->
                ValLinkageFullKey
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member PartialKey : ValLinkagePartialKey
        member TypeForLinkage : TType option
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and ValOptionalData =
      { mutable val_compiled_name: string option
        mutable val_other_range: (Range.range * bool) option
        mutable val_const: Const option
        mutable val_defn: Expr option
        mutable val_repr_info: ValReprInfo option
        mutable val_access: Accessibility
        mutable val_xmldoc: XmlDoc.XmlDoc
        mutable val_member_info: ValMemberInfo option
        mutable val_declaring_entity: ParentRef
        mutable val_xmldocsig: string
        mutable val_attribs: Attribs }
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    and ValData = Val
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and Val =
      { mutable val_logical_name: string
        mutable val_range: Range.range
        mutable val_type: TType
        mutable val_stamp: Stamp
        mutable val_flags: ValFlags
        mutable val_opt_data: ValOptionalData option }
      with
        static member New : data:Val -> Val
        static member NewEmptyValOptData : unit -> ValOptionalData
        static member NewUnlinked : unit -> Val
        member
          CompiledName : compilerGlobalState:CompilerGlobalState.CompilerGlobalState option ->
                           string
        member GetLinkageFullKey : unit -> ValLinkageFullKey
        member GetLinkagePartialKey : unit -> ValLinkagePartialKey
        member Link : tg:ValData -> unit
        member SetAttribs : attribs:Attribs -> unit
        member SetData : tg:ValData -> unit
        member SetDeclaringEntity : parent:ParentRef -> unit
        member SetHasBeenReferenced : unit -> unit
        member SetIgnoresByrefScope : unit -> unit
        member SetIsCompiledAsStaticPropertyWithoutField : unit -> unit
        member SetIsFixed : unit -> unit
        member SetIsMemberOrModuleBinding : unit -> unit
        member SetMakesNoCriticalTailcalls : unit -> unit
        member SetMemberInfo : member_info:ValMemberInfo -> unit
        member SetOtherRange : m:(Range.range * bool) -> unit
        member SetType : ty:TType -> unit
        member SetValDefn : val_defn:Expr -> unit
        member SetValRec : b:ValRecursiveScopeInfo -> unit
        member SetValReprInfo : info:ValReprInfo option -> unit
        override ToString : unit -> string
        member Accessibility : Accessibility
        member ApparentEnclosingEntity : ParentRef
        member Attribs : Attrib list
        member BaseOrThisInfo : ValBaseOrThisInfo
        member CoreDisplayName : string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member DeclaringEntity : ParentRef
        member DefinitionRange : Range.range
        member DisplayName : string
        member HasBeenReferenced : bool
        member HasDeclaringEntity : bool
        member Id : SyntaxTree.Ident
        member IgnoresByrefScope : bool
        member InlineInfo : ValInline
        member IsClassConstructor : bool
        member IsCompiledAsStaticPropertyWithoutField : bool
        member IsCompiledAsTopLevel : bool
        member IsCompiledIntoModule : bool
        member IsCompilerGenerated : bool
        member IsConstructor : bool
        member IsDispatchSlot : bool
        member IsExtensionMember : bool
        member IsFixed : bool
        member IsIncrClassConstructor : bool
        member IsIncrClassGeneratedMember : bool
        member IsInstanceMember : bool
        member IsIntrinsicMember : bool
        member IsLinked : bool
        member IsMember : bool
        member IsMemberOrModuleBinding : bool
        member IsModuleBinding : bool
        member IsMutable : bool
        member IsOverrideOrExplicitImpl : bool
        member IsTypeFunction : bool
        member LiteralValue : Const option
        member LogicalName : string
        member MakesNoCriticalTailcalls : bool
        member MemberApparentEntity : TyconRef
        member MemberInfo : ValMemberInfo option
        member MustInline : bool
        member NumObjArgs : int
        member PermitsExplicitTypeInstantiation : bool
        member PropertyName : string
        member PublicPath : ValPublicPath option
        member Range : Range.range
        member RecursiveValInfo : ValRecursiveScopeInfo
        member ReflectedDefinition : Expr option
        member SigRange : Range.range
        member Stamp : Stamp
        member TauType : TType
        member TopValDeclaringEntity : EntityRef
        member Typars : Typars
        member Type : TType
        member TypeScheme : Typars * TType
        member ValCompiledName : string option
        member ValReprInfo : ValReprInfo option
        member XmlDoc : XmlDoc.XmlDoc
        member XmlDocSig : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and ValMemberInfo =
      { ApparentEnclosingEntity: TyconRef
        mutable ImplementedSlotSigs: SlotSig list
        mutable IsImplemented: bool
        MemberFlags: SyntaxTree.MemberFlags }
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and NonLocalValOrMemberRef =
      { EnclosingEntity: EntityRef
        ItemKey: ValLinkageFullKey }
      with
        override ToString : unit -> string
        member AssemblyName : string
        member Ccu : CcuThunk
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and ValPublicPath =
      | ValPubPath of PublicPath * ValLinkageFullKey
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and NonLocalEntityRef =
      | NonLocalEntityRef of CcuThunk * string []
      with
        static member
          TryDerefEntityPath : ccu:CcuThunk * path:string [] * i:int *
                               entity:Entity -> Entity voption
        static member
          TryDerefEntityPathViaProvidedType : ccu:CcuThunk * path:string [] *
                                              i:int * entity:Entity ->
                                                Entity voption
        override ToString : unit -> string
        member TryDeref : canError:bool -> Entity voption
        member AssemblyName : string
        member Ccu : CcuThunk
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member Deref : Entity
        member DisplayName : string
        member EnclosingMangledPath : string []
        member LastItemMangledName : string
        member ModuleOrNamespaceType : ModuleOrNamespaceType
        member Path : string []
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and EntityRef =
      { mutable binding: Lib.NonNullSlot<Entity>
        nlr: NonLocalEntityRef }
      with
        member GetFieldByIndex : n:int -> RecdField
        member GetFieldByName : n:string -> RecdField option
        member GetUnionCaseByName : n:string -> UnionCase option
        member MakeNestedRecdFieldRef : rf:RecdField -> RecdFieldRef
        member MakeNestedUnionCaseRef : uc:UnionCase -> UnionCaseRef
        member private Resolve : canError:bool -> unit
        member SetIsAssumedReadOnly : b:bool -> unit
        member SetIsByRefLike : b:bool -> unit
        member SetIsReadOnly : b:bool -> unit
        override ToString : unit -> string
        member Typars : m:Range.range -> Typars
        member Accessibility : Accessibility
        member AllFieldAsRefList : RecdFieldRef list
        member AllFieldTable : TyconRecdFields
        member AllFieldsArray : RecdField []
        member AllFieldsAsList : RecdField list
        member AllInstanceFieldsAsList : RecdField list
        member Attribs : Attribs
        member CanDeref : bool
        member CompilationPath : CompilationPath
        member CompilationPathOpt : CompilationPath option
        member CompiledName : string
        member CompiledReprCache : Lib.cache<CompiledTypeRepr>
        member CompiledRepresentation : CompiledTypeRepr
        member CompiledRepresentationForNamedType : AbstractIL.IL.ILTypeRef
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member DefinitionRange : Range.range
        member DemangledModuleOrNamespaceName : string
        member Deref : Entity
        member DisplayName : string
        member DisplayNameWithStaticParameters : string
        member DisplayNameWithStaticParametersAndTypars : string
        member DisplayNameWithStaticParametersAndUnderscoreTypars : string
        member ExceptionInfo : ExceptionInfo
        member FSharpObjectModelTypeInfo : TyconObjModelData
        member GeneratedCompareToValues : (ValRef * ValRef) option
        member GeneratedCompareToWithComparerValues : ValRef option
        member GeneratedHashAndEqualsValues : (ValRef * ValRef) option
        member
          GeneratedHashAndEqualsWithComparerValues : (ValRef * ValRef * ValRef) option
        member HasSelfReferentialConstructor : bool
        member ILTyconInfo : TILObjectReprData
        member ILTyconRawMetadata : AbstractIL.IL.ILTypeDef
        member Id : SyntaxTree.Ident
        member ImmediateInterfaceTypesOfFSharpTycon : TType list
        member
          ImmediateInterfacesOfFSharpTycon : (TType * bool * Range.range) list
        member IsAsmReprTycon : bool
        member IsEnumTycon : bool
        member IsErased : bool
        member IsExceptionDecl : bool
        member IsFSharpDelegateTycon : bool
        member IsFSharpEnumTycon : bool
        member IsFSharpInterfaceTycon : bool
        member IsFSharpObjectModelTycon : bool
        member IsFSharpStructOrEnumTycon : bool
        member IsHiddenReprTycon : bool
        member IsILEnumTycon : bool
        member IsILStructOrEnumTycon : bool
        member IsILTycon : bool
        member IsLocalRef : bool
        member IsMeasureableReprTycon : bool
        member IsModule : bool
        member IsModuleOrNamespace : bool
        member IsNamespace : bool
        member IsPrefixDisplay : bool
        member IsProvided : bool
        member IsProvidedErasedTycon : bool
        member IsProvidedGeneratedTycon : bool
        member IsProvidedNamespace : bool
        member IsRecordTycon : bool
        member IsResolved : bool
        member IsStaticInstantiationTycon : bool
        member IsStructOrEnumTycon : bool
        member IsTypeAbbrev : bool
        member IsUnionTycon : bool
        member LogicalName : string
        member
          MembersOfFSharpTyconByName : AbstractIL.Internal.Library.NameMultiMap<ValRef>
        member MembersOfFSharpTyconSorted : ValRef list
        member ModuleOrNamespaceType : ModuleOrNamespaceType
        member PreEstablishedHasDefaultConstructor : bool
        member PublicPath : PublicPath option
        member Range : Range.range
        member ResolvedTarget : Lib.NonNullSlot<Entity>
        member SigRange : Range.range
        member Stamp : Stamp
        member TrueFieldsAsList : RecdField list
        member TrueInstanceFieldsAsList : RecdField list
        member TrueInstanceFieldsAsRefList : RecdFieldRef list
        member TryDeref : Lib.NonNullSlot<Entity> voption
        member TryIsAssumedReadOnly : bool voption
        member TryIsByRefLike : bool voption
        member TryIsReadOnly : bool voption
        member TyparsNoRange : Typars
        member TypeAbbrev : TType option
        member TypeContents : TyconAugmentation
        member TypeOrMeasureKind : TyparKind
        member TypeReprAccessibility : Accessibility
        member TypeReprInfo : TyconRepresentation
        member UnionCasesArray : UnionCase []
        member UnionCasesAsList : UnionCase list
        member UnionCasesAsRefList : UnionCaseRef list
        member UnionTypeInfo : TyconUnionData voption
        member XmlDoc : XmlDoc.XmlDoc
        member XmlDocSig : string
      end
    and ModuleOrNamespaceRef = EntityRef
    and TyconRef = EntityRef
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and ValRef =
      { mutable binding: Lib.NonNullSlot<Val>
        nlr: NonLocalValOrMemberRef }
      with
        override ToString : unit -> string
        member Accessibility : Accessibility
        member ApparentEnclosingEntity : ParentRef
        member Attribs : Attrib list
        member BaseOrThisInfo : ValBaseOrThisInfo
        member
          CompiledName : (CompilerGlobalState.CompilerGlobalState option ->
                            string)
        member CoreDisplayName : string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member DeclaringEntity : ParentRef
        member DefinitionRange : Range.range
        member Deref : Val
        member DisplayName : string
        member HasDeclaringEntity : bool
        member Id : SyntaxTree.Ident
        member InlineInfo : ValInline
        member IsCompiledAsTopLevel : bool
        member IsCompilerGenerated : bool
        member IsConstructor : bool
        member IsDispatchSlot : bool
        member IsExtensionMember : bool
        member IsIncrClassConstructor : bool
        member IsIncrClassGeneratedMember : bool
        member IsInstanceMember : bool
        member IsLocalRef : bool
        member IsMember : bool
        member IsMemberOrModuleBinding : bool
        member IsModuleBinding : bool
        member IsMutable : bool
        member IsOverrideOrExplicitImpl : bool
        member IsPropertyGetterMethod : bool
        member IsPropertySetterMethod : bool
        member IsResolved : bool
        member IsTypeFunction : bool
        member LiteralValue : Const option
        member LogicalName : string
        member MakesNoCriticalTailcalls : bool
        member MemberApparentEntity : TyconRef
        member MemberInfo : ValMemberInfo option
        member MustInline : bool
        member NumObjArgs : int
        member PermitsExplicitTypeInstantiation : bool
        member PropertyName : string
        member PublicPath : ValPublicPath option
        member Range : Range.range
        member RecursiveValInfo : ValRecursiveScopeInfo
        member ReflectedDefinition : Expr option
        member ResolvedTarget : Lib.NonNullSlot<Val>
        member SigRange : Range.range
        member Stamp : Stamp
        member TauType : TType
        member TopValDeclaringEntity : EntityRef
        member TryDeref : Val voption
        member Typars : Typars
        member Type : TType
        member TypeScheme : Typars * TType
        member ValReprInfo : ValReprInfo option
        member XmlDoc : XmlDoc.XmlDoc
        member XmlDocSig : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and UnionCaseRef =
      | UnionCaseRef of TyconRef * string
      with
        member FieldByIndex : n:int -> RecdField
        override ToString : unit -> string
        member AllFieldsAsList : RecdField list
        member Attribs : Attribs
        member CaseName : string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member DefinitionRange : Range.range
        member Index : int
        member Range : Range.range
        member ReturnType : TType
        member SigRange : Range.range
        member TryUnionCase : UnionCase voption
        member Tycon : Entity
        member TyconRef : TyconRef
        member UnionCase : UnionCase
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and RecdFieldRef =
      | RecdFieldRef of TyconRef * string
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member DefinitionRange : Range.range
        member FieldName : string
        member Index : int
        member PropertyAttribs : Attribs
        member Range : Range.range
        member RecdField : RecdField
        member SigRange : Range.range
        member TryRecdField : RecdField voption
        member Tycon : Entity
        member TyconRef : TyconRef
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and TType =
      | TType_forall of Typars * TType
      | TType_app of TyconRef * TypeInst
      | TType_anon of AnonRecdTypeInfo * TType list
      | TType_tuple of TupInfo * TTypes
      | TType_fun of TType * TType
      | TType_ucase of UnionCaseRef * TypeInst
      | TType_var of Typar
      | TType_measure of Measure
      with
        member GetAssemblyName : unit -> string
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    and TypeInst = TType list
    and TTypes = TType list
    [<RequireQualifiedAccessAttribute ()>]
    and AnonRecdTypeInfo =
      { mutable Assembly: CcuThunk
        mutable TupInfo: TupInfo
        mutable SortedIds: SyntaxTree.Ident []
        mutable Stamp: Stamp
        mutable SortedNames: string [] }
      with
        static member
          Create : ccu:CcuThunk * tupInfo:TupInfo * ids:SyntaxTree.Ident [] ->
                     AnonRecdTypeInfo
        static member NewUnlinked : unit -> AnonRecdTypeInfo
        member Link : d:AnonRecdTypeInfo -> unit
        member ILTypeRef : AbstractIL.IL.ILTypeRef
        member IsLinked : bool
      end
    [<RequireQualifiedAccessAttribute ()>]
    and TupInfo = | Const of bool
    [<RequireQualifiedAccessAttribute ()>]
    and Measure =
      | Var of Typar
      | Con of TyconRef
      | Prod of Measure * Measure
      | Inv of Measure
      | One
      | RationalPower of Measure * Rational.Rational
      with
        override ToString : unit -> string
      end
    and Attribs = Attrib list
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and AttribKind =
      | ILAttrib of AbstractIL.IL.ILMethodRef
      | FSAttrib of ValRef
      with
        override ToString : unit -> string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and Attrib =
      | Attrib of
        TyconRef * AttribKind * AttribExpr list * AttribNamedArg list * bool *
        System.AttributeTargets option * Range.range
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member Range : Range.range
        member TyconRef : TyconRef
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and AttribExpr =
      | AttribExpr of Expr * Expr
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and AttribNamedArg =
      | AttribNamedArg of (string * TType * bool * AttribExpr)
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and Const =
      | Bool of bool
      | SByte of sbyte
      | Byte of byte
      | Int16 of int16
      | UInt16 of uint16
      | Int32 of int32
      | UInt32 of uint32
      | Int64 of int64
      | UInt64 of uint64
      | IntPtr of int64
      | UIntPtr of uint64
      | Single of single
      | Double of double
      | Char of char
      | String of string
      | Decimal of System.Decimal
      | Unit
      | Zero
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and DecisionTree =
      | TDSwitch of
        Expr * DecisionTreeCase list * DecisionTree option * Range.range
      | TDSuccess of Exprs * int
      | TDBind of Binding * DecisionTree
      with
        override ToString : unit -> string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and DecisionTreeCase =
      | TCase of DecisionTreeTest * DecisionTree
      with
        override ToString : unit -> string
        member CaseTree : DecisionTree
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member Discriminator : DecisionTreeTest
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    and DecisionTreeTest =
      | UnionCase of UnionCaseRef * TypeInst
      | ArrayLength of int * TType
      | Const of Const
      | IsNull
      | IsInst of TType * TType
      | ActivePatternCase of
        Expr * TTypes * (ValRef * TypeInst) option * int *
        PrettyNaming.ActivePatternInfo
      | Error of Range.range
      with
        override ToString : unit -> string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and DecisionTreeTarget =
      | TTarget of Val list * Expr * SyntaxTree.DebugPointForTarget
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    and Bindings = Binding list
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and Binding =
      | TBind of Val * Expr * SyntaxTree.DebugPointForBinding
      with
        override ToString : unit -> string
        member DebugPoint : SyntaxTree.DebugPointForBinding
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member Expr : Expr
        member Var : Val
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and ActivePatternElemRef =
      | APElemRef of PrettyNaming.ActivePatternInfo * ValRef * int
      with
        override ToString : unit -> string
        member ActivePatternInfo : PrettyNaming.ActivePatternInfo
        member ActivePatternVal : ValRef
        member CaseIndex : int
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and ValReprInfo =
      | ValReprInfo of TyparReprInfo list * ArgReprInfo list list * ArgReprInfo
      with
        override ToString : unit -> string
        member ArgInfos : ArgReprInfo list list
        member ArgNames : string list option
        member AritiesOfArgs : int list
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member HasNoArgs : bool
        member KindsOfTypars : TyparKind list
        member NumCurriedArgs : int
        member NumTypars : int
        member TotalArgCount : int
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and ArgReprInfo =
      { mutable Attribs: Attribs
        mutable Name: SyntaxTree.Ident option }
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    and TyparReprInfo = | TyparReprInfo of SyntaxTree.Ident * TyparKind
    and Typars = Typar list
    and Exprs = Expr list
    and Vals = Val list
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and Expr =
      | Const of value: Const * range: Range.range * constType: TType
      | Val of valRef: ValRef * flags: ValUseFlag * range: Range.range
      | Sequential of
        expr1: Expr * expr2: Expr * kind: SequentialOpKind *
        debugPoint: SyntaxTree.DebugPointAtSequential * range: Range.range
      | Lambda of
        unique: CompilerGlobalState.Unique * ctorThisValOpt: Val option *
        baseValOpt: Val option * valParams: Val list * bodyExpr: Expr *
        range: Range.range * overallType: TType
      | TyLambda of
        unique: CompilerGlobalState.Unique * typeParams: Typars * bodyExpr: Expr *
        range: Range.range * overallType: TType
      | App of
        funcExpr: Expr * formalType: TType * typeArgs: TypeInst * args: Exprs *
        range: Range.range
      | LetRec of
        bindings: Bindings * bodyExpr: Expr * range: Range.range *
        frees: FreeVarsCache
      | Let of
        binding: Binding * bodyExpr: Expr * range: Range.range *
        frees: FreeVarsCache
      | Obj of
        unique: CompilerGlobalState.Unique * objTy: TType * baseVal: Val option *
        ctorCall: Expr * overrides: ObjExprMethod list *
        interfaceImpls: (TType * ObjExprMethod list) list * range: Range.range
      | Match of
        debugPoint: SyntaxTree.DebugPointForBinding * inputRange: Range.range *
        decision: DecisionTree * targets: DecisionTreeTarget array *
        fullRange: Range.range * exprType: TType
      | StaticOptimization of
        conditions: StaticOptimization list * expr: Expr * alternativeExpr: Expr *
        range: Range.range
      | Op of op: TOp * typeArgs: TypeInst * args: Exprs * range: Range.range
      | Quote of
        quotedExpr: Expr *
        quotationInfo:
          ((AbstractIL.IL.ILTypeRef list * TTypes * Exprs *
            QuotationPickler.ExprData) *
           (AbstractIL.IL.ILTypeRef list * TTypes * Exprs *
            QuotationPickler.ExprData)) option ref * isFromQueryExpression: bool *
        range: Range.range * quotedType: TType
      | WitnessArg of traitInfo: TraitConstraintInfo * range: Range.range
      | TyChoose of typeParams: Typars * bodyExpr: Expr * range: Range.range
      | Link of Expr ref
      with
        member ToDebugString : depth:int -> string
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and TOp =
      | UnionCase of UnionCaseRef
      | ExnConstr of TyconRef
      | Tuple of TupInfo
      | AnonRecd of AnonRecdTypeInfo
      | AnonRecdGet of AnonRecdTypeInfo * int
      | Array
      | Bytes of byte []
      | UInt16s of uint16 []
      | While of SyntaxTree.DebugPointAtWhile * SpecialWhileLoopMarker
      | For of SyntaxTree.DebugPointAtFor * ForLoopStyle
      | TryWith of SyntaxTree.DebugPointAtTry * SyntaxTree.DebugPointAtWith
      | TryFinally of
        SyntaxTree.DebugPointAtTry * SyntaxTree.DebugPointAtFinally
      | Recd of RecordConstructionInfo * TyconRef
      | ValFieldSet of RecdFieldRef
      | ValFieldGet of RecdFieldRef
      | ValFieldGetAddr of RecdFieldRef * readonly: bool
      | UnionCaseTagGet of TyconRef
      | UnionCaseProof of UnionCaseRef
      | UnionCaseFieldGet of UnionCaseRef * int
      | UnionCaseFieldGetAddr of UnionCaseRef * int * readonly: bool
      | UnionCaseFieldSet of UnionCaseRef * int
      | ExnFieldGet of TyconRef * int
      | ExnFieldSet of TyconRef * int
      | TupleFieldGet of TupInfo * int
      | ILAsm of instrs: AbstractIL.IL.ILInstr list * retTypes: TTypes
      | RefAddrGet of bool
      | Coerce
      | Reraise
      | Return
      | Goto of AbstractIL.IL.ILCodeLabel
      | Label of AbstractIL.IL.ILCodeLabel
      | TraitCall of TraitConstraintInfo
      | LValueOp of LValueOperation * ValRef
      | ILCall of
        isVirtual: bool * isProtected: bool * isStruct: bool * isCtor: bool *
        valUseFlag: ValUseFlag * isProperty: bool * noTailCall: bool *
        ilMethRef: AbstractIL.IL.ILMethodRef * enclTypeInst: TypeInst *
        methInst: TypeInst * retTypes: TTypes
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    and RecordConstructionInfo =
      | RecdExprIsObjInit
      | RecdExpr
    and ConstrainedCallInfo = TType option
    and SpecialWhileLoopMarker =
      | NoSpecialWhileLoopMarker
      | WhileLoopForCompiledForEachExprMarker
    and ForLoopStyle =
      | FSharpForLoopUp
      | FSharpForLoopDown
      | CSharpForLoopUp
    and LValueOperation =
      | LAddrOf of readonly: bool
      | LByrefGet
      | LSet
      | LByrefSet
    and SequentialOpKind =
      | NormalSeq
      | ThenDoSeq
    and ValUseFlag =
      | PossibleConstrainedCall of TType
      | NormalValUse
      | CtorValUsedAsSuperInit
      | CtorValUsedAsSelfInit
      | VSlotDirectCall
    and StaticOptimization =
      | TTyconEqualsTycon of TType * TType
      | TTyconIsStruct of TType
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and ObjExprMethod =
      | TObjExprMethod of
        SlotSig * Attribs * Typars * Val list list * Expr * Range.range
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member Id : SyntaxTree.Ident
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and SlotSig =
      | TSlotSig of
        methodName: string * implementedType: TType * classTypars: Typars *
        methodTypars: Typars * formalParams: SlotParam list list *
        formalReturn: TType option
      with
        override ToString : unit -> string
        member ClassTypars : Typars
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member FormalParams : SlotParam list list
        member FormalReturnType : TType option
        member ImplementedType : TType
        member MethodTypars : Typars
        member Name : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and SlotParam =
      | TSlotParam of
        paramName: string option * paramType: TType * isIn: bool * isOut: bool *
        isOptional: bool * attributes: Attribs
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member Type : TType
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and ModuleOrNamespaceExprWithSig =
      | ModuleOrNamespaceExprWithSig of
        moduleType: ModuleOrNamespaceType * contents: ModuleOrNamespaceExpr *
        range: Range.range
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member Type : ModuleOrNamespaceType
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    and ModuleOrNamespaceExpr =
      | TMAbstract of ModuleOrNamespaceExprWithSig
      | TMDefs of ModuleOrNamespaceExpr list
      | TMDefLet of Binding * Range.range
      | TMDefDo of Expr * Range.range
      | TMDefRec of
        isRec: bool * Tycon list * ModuleOrNamespaceBinding list * Range.range
      with
        override ToString : unit -> string
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and ModuleOrNamespaceBinding =
      | Binding of Binding
      | Module of ModuleOrNamespace * ModuleOrNamespaceExpr
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and TypedImplFile =
      | TImplFile of
        SyntaxTree.QualifiedNameOfFile * SyntaxTree.ScopedPragma list *
        ModuleOrNamespaceExprWithSig * bool * bool * StampMap<AnonRecdTypeInfo>
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and TypedImplFileAfterOptimization =
      { ImplFile: TypedImplFile
        OptimizeDuringCodeGen: bool -> Expr -> Expr }
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and TypedAssemblyAfterOptimization =
      | TypedAssemblyAfterOptimization of TypedImplFileAfterOptimization list
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and CcuData =
      { FileName: string option
        ILScopeRef: AbstractIL.IL.ILScopeRef
        Stamp: Stamp
        QualifiedName: string option
        SourceCodeDirectory: string
        IsFSharp: bool
        IsProviderGenerated: bool
        InvalidateEvent: IEvent<string>
        ImportProvidedType: Tainted<ExtensionTyping.ProvidedType> -> TType
        mutable UsesFSharp20PlusQuotations: bool
        mutable Contents: ModuleOrNamespace
        TryGetILModuleDef: unit -> AbstractIL.IL.ILModuleDef option
        MemberSignatureEquality: TType -> TType -> bool
        TypeForwarders: CcuTypeForwarderTable }
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    and CcuTypeForwarderTable = Map<(string [] * string),System.Lazy<EntityRef>>
    and CcuReference = string
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and CcuThunk =
      { mutable target: CcuData
        name: CcuReference }
      with
        static member Create : nm:CcuReference * x:CcuData -> CcuThunk
        static member CreateDelayed : nm:CcuReference -> CcuThunk
        member EnsureDerefable : requiringPath:string [] -> unit
        member Fixup : avail:CcuThunk -> unit
        member
          ImportProvidedType : ty:Tainted<ExtensionTyping.ProvidedType> -> TType
        member MemberSignatureEquality : ty1:TType * ty2:TType -> bool
        override ToString : unit -> string
        member TryForward : nlpath:string [] * item:string -> EntityRef option
        member TryGetILModuleDef : unit -> AbstractIL.IL.ILModuleDef option
        member AssemblyName : string
        member Contents : Entity
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member Deref : CcuData
        member FileName : string option
        member ILScopeRef : AbstractIL.IL.ILScopeRef
        member IsFSharp : bool
        member IsProviderGenerated : bool
        member IsUnresolvedReference : bool
        member QualifiedName : string option
        member RootModulesAndNamespaces : Entity list
        member RootTypeAndExceptionDefinitions : Entity list
        member SourceCodeDirectory : string
        member Stamp : Stamp
        member TypeForwarders : Map<(string [] * string),System.Lazy<EntityRef>>
        member UsesFSharp20PlusQuotations : bool
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and CcuResolutionResult =
      | ResolvedCcu of CcuThunk
      | UnresolvedCcu of string
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and PickledCcuInfo =
      { mspec: ModuleOrNamespace
        compileTimeWorkingDir: string
        usesQuotations: bool }
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    and FreeLocals = AbstractIL.Internal.Zset<Val>
    and FreeTypars = AbstractIL.Internal.Zset<Typar>
    and FreeTycons = AbstractIL.Internal.Zset<Tycon>
    and FreeRecdFields = AbstractIL.Internal.Zset<RecdFieldRef>
    and FreeUnionCases = AbstractIL.Internal.Zset<UnionCaseRef>
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and FreeTyvars =
      { FreeTycons: FreeTycons
        FreeTraitSolutions: FreeLocals
        FreeTypars: FreeTypars }
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    and FreeVarsCache = Lib.cache<FreeVars>
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    and FreeVars =
      { FreeLocals: FreeLocals
        UsesMethodLocalConstructs: bool
        UsesUnboundRethrow: bool
        FreeLocalTyconReprs: FreeTycons
        FreeRecdFields: FreeRecdFields
        FreeUnionCases: FreeUnionCases
        FreeTyvars: FreeTyvars }
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
      end
    and Construct =
      class
        new : unit -> Construct
        static member
          ComputeDefinitionLocationOfProvidedItem : p:Tainted<#ExtensionTyping.IProvidedCustomAttributeProvider> ->
                                                      Range.range option
        static member
          KeyTyconByAccessNames : nm:string ->
                                    x:'T ->
                                      System.Collections.Generic.KeyValuePair<string,
                                                                              'T> []
        static member
          KeyTyconByDecodedName : nm:string ->
                                    x:'T ->
                                      System.Collections.Generic.KeyValuePair<PrettyNaming.NameArityPair,
                                                                              'T>
        static member
          MakeRecdFieldsTable : ucs:RecdField list -> TyconRecdFields
        static member MakeUnionCases : ucs:UnionCase list -> TyconUnionData
        static member MakeUnionRepr : ucs:UnionCase list -> TyconRepresentation
        static member
          NewCcuContents : sref:AbstractIL.IL.ILScopeRef ->
                             m:Range.range ->
                               nm:string ->
                                 mty:ModuleOrNamespaceType -> ModuleOrNamespace
        static member NewClonedModuleOrNamespace : orig:Tycon -> Entity
        static member NewClonedTycon : orig:Tycon -> Entity
        static member
          NewEmptyModuleOrNamespaceType : mkind:ModuleOrNamespaceKind ->
                                            ModuleOrNamespaceType
        static member
          NewExn : cpath:CompilationPath option ->
                     id:SyntaxTree.Ident ->
                       access:Accessibility ->
                         repr:ExceptionInfo ->
                           attribs:Attribs -> doc:XmlDoc.XmlDoc -> Entity
        static member NewFreeVarsCache : unit -> Lib.cache<'a>
        static member
          NewILTycon : nlpath:CompilationPath option ->
                         nm:string * m:Range.range ->
                           tps:AbstractIL.Internal.Library.LazyWithContext<Typars,
                                                                           Range.range> ->
                             scoref:AbstractIL.IL.ILScopeRef *
                             enc:AbstractIL.IL.ILTypeDef list *
                             tdef:AbstractIL.IL.ILTypeDef ->
                               mtyp:Lib.MaybeLazy<ModuleOrNamespaceType> ->
                                 Entity
        static member
          NewModifiedModuleOrNamespace : f:(ModuleOrNamespaceType ->
                                              ModuleOrNamespaceType) ->
                                           orig:Tycon -> Entity
        static member
          NewModifiedTycon : f:(Tycon -> Entity) -> orig:Tycon -> Entity
        static member NewModifiedVal : f:(Val -> Val) -> orig:Val -> Val
        static member
          NewModuleOrNamespace : cpath:CompilationPath option ->
                                   access:Accessibility ->
                                     id:SyntaxTree.Ident ->
                                       xml:XmlDoc.XmlDoc ->
                                         attribs:Attrib list ->
                                           mtype:Lib.MaybeLazy<ModuleOrNamespaceType> ->
                                             ModuleOrNamespace
        static member
          NewModuleOrNamespaceType : mkind:ModuleOrNamespaceKind ->
                                       tycons:Entity list ->
                                         vals:Val list -> ModuleOrNamespaceType
        static member
          NewProvidedTycon : resolutionEnvironment:ExtensionTyping.ResolutionEnvironment *
                             st:Tainted<ExtensionTyping.ProvidedType> *
                             importProvidedType:(Tainted<ExtensionTyping.ProvidedType> ->
                                                   TType) *
                             isSuppressRelocate:bool * m:Range.range *
                             ?access:Accessibility * ?cpath:CompilationPath ->
                               Entity
        static member
          NewProvidedTyconRepr : resolutionEnvironment:ExtensionTyping.ResolutionEnvironment *
                                 st:Tainted<ExtensionTyping.ProvidedType> *
                                 importProvidedType:(Tainted<ExtensionTyping.ProvidedType> ->
                                                       TType) *
                                 isSuppressRelocate:bool * m:Range.range ->
                                   TyconRepresentation
        static member
          NewRecdField : stat:bool ->
                           konst:Const option ->
                             id:SyntaxTree.Ident ->
                               nameGenerated:bool ->
                                 ty:TType ->
                                   isMutable:bool ->
                                     isVolatile:bool ->
                                       pattribs:Attribs ->
                                         fattribs:Attribs ->
                                           docOption:XmlDoc.XmlDoc ->
                                             access:Accessibility ->
                                               secret:bool -> RecdField
        static member NewRigidTypar : nm:string -> m:Range.range -> Typar
        static member
          NewTycon : cpath:CompilationPath option * nm:string * m:Range.range *
                     access:Accessibility * reprAccess:Accessibility *
                     kind:TyparKind *
                     typars:AbstractIL.Internal.Library.LazyWithContext<Typars,
                                                                        Range.range> *
                     doc:XmlDoc.XmlDoc * usesPrefixDisplay:bool *
                     preEstablishedHasDefaultCtor:bool *
                     hasSelfReferentialCtor:bool *
                     mtyp:Lib.MaybeLazy<ModuleOrNamespaceType> -> Entity
        static member
          NewTypar : kind:TyparKind * rigid:TyparRigidity * SyntaxTree.SynTypar *
                     isFromError:bool * dynamicReq:TyparDynamicReq *
                     attribs:Attrib list * eqDep:bool * compDep:bool -> Typar
        static member
          NewUnionCase : id:SyntaxTree.Ident ->
                           tys:RecdField list ->
                             rty:TType ->
                               attribs:Attribs ->
                                 docOption:XmlDoc.XmlDoc ->
                                   access:Accessibility -> UnionCase
        static member
          NewVal : logicalName:string * m:Range.range *
                   compiledName:string option * ty:TType *
                   isMutable:ValMutability * isCompGen:bool *
                   arity:ValReprInfo option * access:Accessibility *
                   recValInfo:ValRecursiveScopeInfo *
                   specialRepr:ValMemberInfo option *
                   baseOrThis:ValBaseOrThisInfo * attribs:Attrib list *
                   inlineInfo:ValInline * doc:XmlDoc.XmlDoc *
                   isModuleOrMemberBinding:bool * isExtensionMember:bool *
                   isIncrClassSpecialMember:bool * isTyFunc:bool *
                   allowTypeInst:bool * isGeneratedEventVal:bool *
                   konst:Const option * actualParent:ParentRef -> Val
      end
  end

namespace FSharp.Compiler
  module internal TypedTreeBasics = begin
    val getNameOfScopeRef : sref:AbstractIL.IL.ILScopeRef -> string
    module ValReprInfo = begin
      val unnamedTopArg1 : TypedTree.ArgReprInfo
      val unnamedTopArg : TypedTree.ArgReprInfo list
      val unitArgData : TypedTree.ArgReprInfo list list
      val unnamedRetVal : TypedTree.ArgReprInfo
      val selfMetadata : TypedTree.ArgReprInfo list
      val emptyValData : TypedTree.ValReprInfo
      val InferTyparInfo :
        tps:TypedTree.Typar list -> TypedTree.TyparReprInfo list
      val InferArgReprInfo : v:TypedTree.Val -> TypedTree.ArgReprInfo
      val InferArgReprInfos :
        vs:TypedTree.Val list list -> TypedTree.ValReprInfo
      val HasNoArgs : TypedTree.ValReprInfo -> bool
    end
    val typeOfVal : v:TypedTree.Val -> TypedTree.TType
    val typesOfVals : v:TypedTree.Val list -> TypedTree.TType list
    val nameOfVal : v:TypedTree.Val -> string
    val arityOfVal : v:TypedTree.Val -> TypedTree.ValReprInfo
    val tupInfoRef : TypedTree.TupInfo
    val tupInfoStruct : TypedTree.TupInfo
    val mkTupInfo : b:bool -> TypedTree.TupInfo
    val structnessDefault : bool
    val mkRawRefTupleTy : tys:TypedTree.TTypes -> TypedTree.TType
    val mkRawStructTupleTy : tys:TypedTree.TTypes -> TypedTree.TType
    val mapTImplFile :
      f:(TypedTree.ModuleOrNamespaceExprWithSig ->
           TypedTree.ModuleOrNamespaceExprWithSig) ->
        TypedTree.TypedImplFile -> TypedTree.TypedImplFile
    val mapAccImplFile :
      f:('a -> TypedTree.ModuleOrNamespaceExprWithSig ->
           TypedTree.ModuleOrNamespaceExprWithSig * 'b) ->
        z:'a -> TypedTree.TypedImplFile -> TypedTree.TypedImplFile * 'b
    val foldTImplFile :
      f:('a -> TypedTree.ModuleOrNamespaceExprWithSig -> 'b) ->
        z:'a -> TypedTree.TypedImplFile -> 'b
    val typarEq : lv1:TypedTree.Typar -> lv2:TypedTree.Typar -> bool
    val typarRefEq : tp1:TypedTree.Typar -> tp2:TypedTree.Typar -> bool
    val valEq : lv1:TypedTree.Val -> lv2:TypedTree.Val -> bool
    val ccuEq : mv1:TypedTree.CcuThunk -> mv2:TypedTree.CcuThunk -> bool
    val ( |ValDeref| ) : vr:TypedTree.ValRef -> TypedTree.Val
    val mkRecdFieldRef :
      tcref:TypedTree.TyconRef -> f:string -> TypedTree.RecdFieldRef
    val mkUnionCaseRef :
      tcref:TypedTree.TyconRef -> c:string -> TypedTree.UnionCaseRef
    val ERefLocal : x:Lib.NonNullSlot<TypedTree.Entity> -> TypedTree.EntityRef
    val ERefNonLocal : x:TypedTree.NonLocalEntityRef -> TypedTree.EntityRef
    val ERefNonLocalPreResolved :
      x:Lib.NonNullSlot<TypedTree.Entity> ->
        xref:TypedTree.NonLocalEntityRef -> TypedTree.EntityRef
    val ( |ERefLocal|ERefNonLocal| ) :
      x:TypedTree.EntityRef ->
        Choice<Lib.NonNullSlot<TypedTree.Entity>,TypedTree.NonLocalEntityRef>
    val mkLocalTyconRef :
      x:Lib.NonNullSlot<TypedTree.Entity> -> TypedTree.EntityRef
    val mkNonLocalEntityRef :
      ccu:TypedTree.CcuThunk -> mp:string [] -> TypedTree.NonLocalEntityRef
    val mkNestedNonLocalEntityRef :
      nleref:TypedTree.NonLocalEntityRef ->
        id:string -> TypedTree.NonLocalEntityRef
    val mkNonLocalTyconRef :
      nleref:TypedTree.NonLocalEntityRef -> id:string -> TypedTree.EntityRef
    val mkNonLocalTyconRefPreResolved :
      x:Lib.NonNullSlot<TypedTree.Entity> ->
        nleref:TypedTree.NonLocalEntityRef -> id:string -> TypedTree.EntityRef
    type EntityRef with
      member NestedTyconRef : x:TypedTree.Entity -> TypedTree.EntityRef
    type EntityRef with
      member
        RecdFieldRefInNestedTycon : tycon:TypedTree.Entity ->
                                      id:SyntaxTree.Ident ->
                                        TypedTree.RecdFieldRef
    val mkModuleUnionCaseRef :
      modref:TypedTree.ModuleOrNamespaceRef ->
        tycon:TypedTree.Entity ->
          uc:TypedTree.UnionCase -> TypedTree.UnionCaseRef
    val VRefLocal : x:Lib.NonNullSlot<TypedTree.Val> -> TypedTree.ValRef
    val VRefNonLocal : x:TypedTree.NonLocalValOrMemberRef -> TypedTree.ValRef
    val VRefNonLocalPreResolved :
      x:Lib.NonNullSlot<TypedTree.Val> ->
        xref:TypedTree.NonLocalValOrMemberRef -> TypedTree.ValRef
    val ( |VRefLocal|VRefNonLocal| ) :
      x:TypedTree.ValRef ->
        Choice<Lib.NonNullSlot<TypedTree.Val>,TypedTree.NonLocalValOrMemberRef>
    val mkNonLocalValRef :
      mp:TypedTree.NonLocalEntityRef ->
        id:TypedTree.ValLinkageFullKey -> TypedTree.ValRef
    val mkNonLocalValRefPreResolved :
      x:Lib.NonNullSlot<TypedTree.Val> ->
        mp:TypedTree.NonLocalEntityRef ->
          id:TypedTree.ValLinkageFullKey -> TypedTree.ValRef
    val ccuOfValRef : vref:TypedTree.ValRef -> TypedTree.CcuThunk option
    val ccuOfTyconRef : eref:TypedTree.EntityRef -> TypedTree.CcuThunk option
    val mkTyparTy : tp:TypedTree.Typar -> TypedTree.TType
    val copyTypar : tp:TypedTree.Typar -> TypedTree.Typar
    val copyTypars : tps:TypedTree.Typar list -> TypedTree.Typar list
    val tryShortcutSolvedUnitPar :
      canShortcut:bool -> r:TypedTree.Typar -> TypedTree.Measure
    val stripUnitEqnsAux :
      canShortcut:bool -> unt:TypedTree.Measure -> TypedTree.Measure
    val stripTyparEqnsAux :
      canShortcut:bool -> ty:TypedTree.TType -> TypedTree.TType
    val stripTyparEqns : ty:TypedTree.TType -> TypedTree.TType
    val stripUnitEqns : unt:TypedTree.Measure -> TypedTree.Measure
    val mkLocalValRef : v:TypedTree.Val -> TypedTree.ValRef
    val mkLocalModRef : v:TypedTree.ModuleOrNamespace -> TypedTree.EntityRef
    val mkLocalEntityRef : v:TypedTree.Entity -> TypedTree.EntityRef
    val mkNonLocalCcuRootEntityRef :
      ccu:TypedTree.CcuThunk -> x:TypedTree.Entity -> TypedTree.EntityRef
    val mkNestedValRef :
      cref:TypedTree.EntityRef -> v:TypedTree.Val -> TypedTree.ValRef
    val rescopePubPathToParent :
      viewedCcu:TypedTree.CcuThunk ->
        TypedTree.PublicPath -> TypedTree.NonLocalEntityRef
    val rescopePubPath :
      viewedCcu:TypedTree.CcuThunk ->
        TypedTree.PublicPath -> TypedTree.NonLocalEntityRef
    val valRefInThisAssembly : compilingFslib:bool -> x:TypedTree.ValRef -> bool
    val tyconRefUsesLocalXmlDoc :
      compilingFslib:bool -> x:TypedTree.TyconRef -> bool
    val entityRefInThisAssembly :
      compilingFslib:bool -> x:TypedTree.EntityRef -> bool
    val arrayPathEq : y1:string [] -> y2:string [] -> bool
    val nonLocalRefEq :
      TypedTree.NonLocalEntityRef -> TypedTree.NonLocalEntityRef -> bool
    val nonLocalRefDefinitelyNotEq :
      TypedTree.NonLocalEntityRef -> TypedTree.NonLocalEntityRef -> bool
    val pubPathEq : TypedTree.PublicPath -> TypedTree.PublicPath -> bool
    val fslibRefEq :
      nlr1:TypedTree.NonLocalEntityRef -> TypedTree.PublicPath -> bool
    val fslibEntityRefEq :
      fslibCcu:TypedTree.CcuThunk ->
        eref1:TypedTree.EntityRef -> eref2:TypedTree.EntityRef -> bool
    val fslibValRefEq :
      fslibCcu:TypedTree.CcuThunk ->
        vref1:TypedTree.ValRef -> vref2:TypedTree.ValRef -> bool
    val primEntityRefEq :
      compilingFslib:bool ->
        fslibCcu:TypedTree.CcuThunk ->
          x:TypedTree.EntityRef -> y:TypedTree.EntityRef -> bool
    val primUnionCaseRefEq :
      compilingFslib:bool ->
        fslibCcu:TypedTree.CcuThunk ->
          TypedTree.UnionCaseRef -> TypedTree.UnionCaseRef -> bool
    val primValRefEq :
      compilingFslib:bool ->
        fslibCcu:TypedTree.CcuThunk ->
          x:TypedTree.ValRef -> y:TypedTree.ValRef -> bool
    val fullCompPathOfModuleOrNamespace :
      m:TypedTree.ModuleOrNamespace -> TypedTree.CompilationPath
    val inline canAccessCompPathFrom :
      TypedTree.CompilationPath -> TypedTree.CompilationPath -> bool
    val canAccessFromOneOf :
      cpaths:TypedTree.CompilationPath list ->
        cpathTest:TypedTree.CompilationPath -> bool
    val canAccessFrom :
      TypedTree.Accessibility -> cpath:TypedTree.CompilationPath -> bool
    val canAccessFromEverywhere : TypedTree.Accessibility -> bool
    val canAccessFromSomewhere : TypedTree.Accessibility -> bool
    val isLessAccessible :
      TypedTree.Accessibility -> TypedTree.Accessibility -> bool
    val accessSubstPaths :
      newPath:TypedTree.CompilationPath * oldPath:TypedTree.CompilationPath ->
        TypedTree.Accessibility -> TypedTree.Accessibility
    val compPathOfCcu : ccu:TypedTree.CcuThunk -> TypedTree.CompilationPath
    val taccessPublic : TypedTree.Accessibility
    val taccessPrivate :
      accessPath:TypedTree.CompilationPath -> TypedTree.Accessibility
    val compPathInternal : TypedTree.CompilationPath
    val taccessInternal : TypedTree.Accessibility
    val combineAccess :
      TypedTree.Accessibility ->
        TypedTree.Accessibility -> TypedTree.Accessibility
    exception Duplicate of string * string * Range.range
    exception NameClash of
                          string * string * string * Range.range * string *
                          string * Range.range
  end

namespace FSharp.Compiler
  module internal TcGlobals = begin
    val DummyFileNameForRangesWithoutASpecificLocation : string
    val private envRange : Range.range
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    type IntrinsicValRef =
      | IntrinsicValRef of
        TypedTree.NonLocalEntityRef * string * bool * TypedTree.TType *
        TypedTree.ValLinkageFullKey
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member Name : string
      end
    val ValRefForIntrinsic : IntrinsicValRef -> TypedTree.ValRef
    module FSharpLib = begin
      val CoreOperatorsCheckedName : string
      val ControlName : string
      val LinqName : string
      val CollectionsName : string
      val LanguagePrimitivesName : string
      val CompilerServicesName : string
      val LinqRuntimeHelpersName : string
      val RuntimeHelpersName : string
      val ExtraTopLevelOperatorsName : string
      val NativeInteropName : string
      val QuotationsName : string
      val ControlPath : string list
      val LinqPath : string list
      val CollectionsPath : string list
      val NativeInteropPath : string []
      val CompilerServicesPath : string []
      val LinqRuntimeHelpersPath : string []
      val RuntimeHelpersPath : string []
      val QuotationsPath : string []
      val RootPathArray : string []
      val CorePathArray : string []
      val LinqPathArray : string []
      val ControlPathArray : string []
      val CollectionsPathArray : string []
    end
    val private mkNonGenericTy : tcref:TypedTree.TyconRef -> TypedTree.TType
    val mkNonLocalTyconRef2 :
      ccu:TypedTree.CcuThunk ->
        path:string [] -> n:string -> TypedTree.EntityRef
    val mk_MFCore_tcref :
      ccu:TypedTree.CcuThunk -> n:string -> TypedTree.EntityRef
    val mk_MFQuotations_tcref :
      ccu:TypedTree.CcuThunk -> n:string -> TypedTree.EntityRef
    val mk_MFLinq_tcref :
      ccu:TypedTree.CcuThunk -> n:string -> TypedTree.EntityRef
    val mk_MFCollections_tcref :
      ccu:TypedTree.CcuThunk -> n:string -> TypedTree.EntityRef
    val mk_MFCompilerServices_tcref :
      ccu:TypedTree.CcuThunk -> n:string -> TypedTree.EntityRef
    val mk_MFRuntimeHelpers_tcref :
      ccu:TypedTree.CcuThunk -> n:string -> TypedTree.EntityRef
    val mk_MFControl_tcref :
      ccu:TypedTree.CcuThunk -> n:string -> TypedTree.EntityRef
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      StructuredFormatDisplayAttribute ("{DebugText}")>]
    type BuiltinAttribInfo =
      | AttribInfo of AbstractIL.IL.ILTypeRef * TypedTree.TyconRef
      with
        override ToString : unit -> string
        [<System.Diagnostics.DebuggerBrowsable
          (enum<System.Diagnostics.DebuggerBrowsableState> (0))>]
        member DebugText : string
        member TyconRef : TypedTree.TyconRef
        member TypeRef : AbstractIL.IL.ILTypeRef
      end
    [<LiteralAttribute ()>]
    val tname_DebuggerNonUserCodeAttribute : string
    = "System.Diagnostics.DebuggerNonUserCodeAttribute"
    [<LiteralAttribute ()>]
    val tname_DebuggableAttribute_DebuggingModes : string = "DebuggingModes"
    [<LiteralAttribute ()>]
    val tname_DebuggerHiddenAttribute : string
    = "System.Diagnostics.DebuggerHiddenAttribute"
    [<LiteralAttribute ()>]
    val tname_DebuggerDisplayAttribute : string
    = "System.Diagnostics.DebuggerDisplayAttribute"
    [<LiteralAttribute ()>]
    val tname_DebuggerTypeProxyAttribute : string
    = "System.Diagnostics.DebuggerTypeProxyAttribute"
    [<LiteralAttribute ()>]
    val tname_DebuggerStepThroughAttribute : string
    = "System.Diagnostics.DebuggerStepThroughAttribute"
    [<LiteralAttribute ()>]
    val tname_DebuggerBrowsableAttribute : string
    = "System.Diagnostics.DebuggerBrowsableAttribute"
    [<LiteralAttribute ()>]
    val tname_DebuggerBrowsableState : string
    = "System.Diagnostics.DebuggerBrowsableState"
    [<LiteralAttribute ()>]
    val tname_StringBuilder : string = "System.Text.StringBuilder"
    [<LiteralAttribute ()>]
    val tname_IComparable : string = "System.IComparable"
    [<LiteralAttribute ()>]
    val tname_Exception : string = "System.Exception"
    [<LiteralAttribute ()>]
    val tname_Missing : string = "System.Reflection.Missing"
    [<LiteralAttribute ()>]
    val tname_FormattableString : string = "System.FormattableString"
    [<LiteralAttribute ()>]
    val tname_SerializationInfo : string
    = "System.Runtime.Serialization.SerializationInfo"
    [<LiteralAttribute ()>]
    val tname_StreamingContext : string
    = "System.Runtime.Serialization.StreamingContext"
    [<LiteralAttribute ()>]
    val tname_SecurityPermissionAttribute : string
    = "System.Security.Permissions.SecurityPermissionAttribute"
    [<LiteralAttribute ()>]
    val tname_Delegate : string = "System.Delegate"
    [<LiteralAttribute ()>]
    val tname_ValueType : string = "System.ValueType"
    [<LiteralAttribute ()>]
    val tname_Enum : string = "System.Enum"
    [<LiteralAttribute ()>]
    val tname_Array : string = "System.Array"
    [<LiteralAttribute ()>]
    val tname_RuntimeArgumentHandle : string = "System.RuntimeArgumentHandle"
    [<LiteralAttribute ()>]
    val tname_RuntimeTypeHandle : string = "System.RuntimeTypeHandle"
    [<LiteralAttribute ()>]
    val tname_RuntimeMethodHandle : string = "System.RuntimeMethodHandle"
    [<LiteralAttribute ()>]
    val tname_RuntimeFieldHandle : string = "System.RuntimeFieldHandle"
    [<LiteralAttribute ()>]
    val tname_CompilerGeneratedAttribute : string
    = "System.Runtime.CompilerServices.CompilerGeneratedAttribute"
    [<LiteralAttribute ()>]
    val tname_DebuggableAttribute : string
    = "System.Diagnostics.DebuggableAttribute"
    [<LiteralAttribute ()>]
    val tname_AsyncCallback : string = "System.AsyncCallback"
    [<LiteralAttribute ()>]
    val tname_IAsyncResult : string = "System.IAsyncResult"
    type TcGlobals =
      class
        new : compilingFslib:bool * ilg:AbstractIL.IL.ILGlobals *
              fslibCcu:TypedTree.CcuThunk *
              directoryToResolveRelativePaths:string * mlCompatibility:bool *
              isInteractive:bool *
              tryFindSysTypeCcu:(string list -> string ->
                                   TypedTree.CcuThunk option) *
              emitDebugInfoInQuotations:bool * noDebugData:bool *
              pathMap:Internal.Utilities.PathMap *
              langVersion:Features.LanguageVersion -> TcGlobals
        member
          AddFieldGeneratedAttrs : mdef:AbstractIL.IL.ILFieldDef ->
                                     AbstractIL.IL.ILFieldDef
        member
          AddFieldNeverAttrs : mdef:AbstractIL.IL.ILFieldDef ->
                                 AbstractIL.IL.ILFieldDef
        member
          AddMethodGeneratedAttributes : mdef:AbstractIL.IL.ILMethodDef ->
                                           AbstractIL.IL.ILMethodDef
        member
          EraseClassUnionDef : cud:AbstractIL.IL.ILTypeRef ->
                                 (AbstractIL.IL.ILTypeDef ->
                                    AbstractIL.Extensions.ILX.Types.IlxUnionInfo ->
                                    AbstractIL.IL.ILTypeDef)
        member FindSysAttrib : nm:string -> BuiltinAttribInfo
        member FindSysILTypeRef : nm:string -> AbstractIL.IL.ILTypeRef
        member
          FindSysTyconRef : path:string list -> nm:string -> TypedTree.EntityRef
        member
          MakeBuiltInWitnessInfo : t:TypedTree.TraitConstraintInfo ->
                                     IntrinsicValRef * TypedTree.TType list
        override ToString : unit -> string
        member TryFindSysAttrib : nm:string -> BuiltinAttribInfo option
        member TryFindSysILTypeRef : nm:string -> AbstractIL.IL.ILTypeRef option
        member
          TryFindSysTyconRef : path:string list ->
                                 nm:string -> TypedTree.EntityRef option
        member
          TryMakeOperatorAsBuiltInWitnessInfo : isStringTy:(TcGlobals ->
                                                              TypedTree.TType ->
                                                              bool) ->
                                                  isArrayTy:(TcGlobals ->
                                                               TypedTree.TType ->
                                                               bool) ->
                                                    t:TypedTree.TraitConstraintInfo ->
                                                      argExprs:'a list ->
                                                        (IntrinsicValRef *
                                                         TypedTree.TType list *
                                                         'a list) option
        member
          decompileType : tcref:TypedTree.EntityRef ->
                            tinst:TypedTree.TypeInst -> TypedTree.TType
        member
          improveType : tcref:TypedTree.EntityRef ->
                          tinst:TypedTree.TType list -> TypedTree.TType
        member memoize_file : x:int -> AbstractIL.IL.ILSourceDocument
        member
          mkDebuggableAttribute : jitOptimizerDisabled:bool ->
                                    AbstractIL.IL.ILAttribute
        member
          mkDebuggableAttributeV2 : jitTracking:bool *
                                    ignoreSymbolStoreSequencePoints:bool *
                                    jitOptimizerDisabled:bool * enableEnC:bool ->
                                      AbstractIL.IL.ILAttribute
        member
          mkDebuggerDisplayAttribute : s:string -> AbstractIL.IL.ILAttribute
        member mkDebuggerHiddenAttribute : unit -> AbstractIL.IL.ILAttribute
        member
          mkDebuggerStepThroughAttribute : unit -> AbstractIL.IL.ILAttribute
        member
          unionCaseRefEq : x:TypedTree.UnionCaseRef ->
                             y:TypedTree.UnionCaseRef -> bool
        member valRefEq : x:TypedTree.ValRef -> y:TypedTree.ValRef -> bool
        member CompilerGeneratedAttribute : AbstractIL.IL.ILAttribute
        member
          CompilerGlobalState : CompilerGlobalState.CompilerGlobalState option
        member DebuggerBrowsableNeverAttribute : AbstractIL.IL.ILAttribute
        member IComparer_ty : TypedTree.TType
        member IEqualityComparer_ty : TypedTree.TType
        member
          System_Runtime_CompilerServices_RuntimeFeature_ty : TypedTree.TType option
        member addrof2_vref : TypedTree.ValRef
        member addrof_vref : TypedTree.ValRef
        member and2_vref : TypedTree.ValRef
        member and_vref : TypedTree.ValRef
        member array2D_get_info : IntrinsicValRef
        member array2D_get_vref : TypedTree.ValRef
        member array2D_set_info : IntrinsicValRef
        member array3D_get_info : IntrinsicValRef
        member array3D_get_vref : TypedTree.ValRef
        member array3D_set_info : IntrinsicValRef
        member array4D_get_info : IntrinsicValRef
        member array4D_get_vref : TypedTree.ValRef
        member array4D_set_info : IntrinsicValRef
        member array_get_info : IntrinsicValRef
        member array_get_vref : TypedTree.ValRef
        member array_length_info : IntrinsicValRef
        member array_set_info : IntrinsicValRef
        member array_tcr_nice : TypedTree.EntityRef
        member attrib_AbstractClassAttribute : BuiltinAttribInfo
        member attrib_AllowNullLiteralAttribute : BuiltinAttribInfo
        member attrib_AttributeUsageAttribute : BuiltinAttribInfo
        member attrib_AutoOpenAttribute : BuiltinAttribInfo
        member attrib_AutoSerializableAttribute : BuiltinAttribInfo
        member attrib_CLIEventAttribute : BuiltinAttribInfo
        member attrib_CLIMutableAttribute : BuiltinAttribInfo
        member attrib_CallerFilePathAttribute : BuiltinAttribInfo
        member attrib_CallerLineNumberAttribute : BuiltinAttribInfo
        member attrib_CallerMemberNameAttribute : BuiltinAttribInfo
        member attrib_ClassAttribute : BuiltinAttribInfo
        member attrib_ComImportAttribute : BuiltinAttribInfo option
        member attrib_ComVisibleAttribute : BuiltinAttribInfo
        member attrib_ComparisonConditionalOnAttribute : BuiltinAttribInfo
        member attrib_CompilationArgumentCountsAttribute : BuiltinAttribInfo
        member attrib_CompilationMappingAttribute : BuiltinAttribInfo
        member attrib_CompilationRepresentationAttribute : BuiltinAttribInfo
        member attrib_CompiledNameAttribute : BuiltinAttribInfo
        member attrib_CompilerMessageAttribute : BuiltinAttribInfo
        member attrib_ComponentModelEditorBrowsableAttribute : BuiltinAttribInfo
        member attrib_ConditionalAttribute : BuiltinAttribInfo
        member attrib_ContextStaticAttribute : BuiltinAttribInfo option
        member attrib_CustomComparisonAttribute : BuiltinAttribInfo
        member attrib_CustomEqualityAttribute : BuiltinAttribInfo
        member attrib_CustomOperationAttribute : BuiltinAttribInfo
        member attrib_DebuggerDisplayAttribute : BuiltinAttribInfo
        member attrib_DebuggerTypeProxyAttribute : BuiltinAttribInfo
        member attrib_DefaultAugmentationAttribute : BuiltinAttribInfo
        member attrib_DefaultMemberAttribute : BuiltinAttribInfo
        member attrib_DefaultParameterValueAttribute : BuiltinAttribInfo option
        member attrib_DefaultValueAttribute : BuiltinAttribInfo
        member attrib_DllImportAttribute : BuiltinAttribInfo option
        member attrib_EntryPointAttribute : BuiltinAttribInfo
        member attrib_EqualityConditionalOnAttribute : BuiltinAttribInfo
        member attrib_ExperimentalAttribute : BuiltinAttribInfo
        member attrib_ExtensionAttribute : BuiltinAttribInfo
        member attrib_FieldOffsetAttribute : BuiltinAttribInfo
        member attrib_FlagsAttribute : BuiltinAttribInfo
        member attrib_GeneralizableValueAttribute : BuiltinAttribInfo
        member attrib_IDispatchConstantAttribute : BuiltinAttribInfo option
        member attrib_IUnknownConstantAttribute : BuiltinAttribInfo option
        member attrib_InAttribute : BuiltinAttribInfo
        member attrib_InterfaceAttribute : BuiltinAttribInfo
        member attrib_InternalsVisibleToAttribute : BuiltinAttribInfo
        member attrib_IsByRefLikeAttribute : BuiltinAttribInfo
        member attrib_IsReadOnlyAttribute : BuiltinAttribInfo
        member attrib_LiteralAttribute : BuiltinAttribInfo
        member attrib_MarshalAsAttribute : BuiltinAttribInfo option
        member attrib_MeasureAttribute : BuiltinAttribInfo
        member attrib_MeasureableAttribute : BuiltinAttribInfo
        member attrib_MethodImplAttribute : BuiltinAttribInfo
        member attrib_NoComparisonAttribute : BuiltinAttribInfo
        member attrib_NoDynamicInvocationAttribute : BuiltinAttribInfo
        member attrib_NoEqualityAttribute : BuiltinAttribInfo
        member attrib_NonSerializedAttribute : BuiltinAttribInfo option
        member attrib_OptionalArgumentAttribute : BuiltinAttribInfo
        member attrib_OptionalAttribute : BuiltinAttribInfo option
        member attrib_OutAttribute : BuiltinAttribInfo
        member attrib_ParamArrayAttribute : BuiltinAttribInfo
        member attrib_PreserveSigAttribute : BuiltinAttribInfo option
        member attrib_ProjectionParameterAttribute : BuiltinAttribInfo
        member attrib_ReferenceEqualityAttribute : BuiltinAttribInfo
        member attrib_ReflectedDefinitionAttribute : BuiltinAttribInfo
        member attrib_RequireQualifiedAccessAttribute : BuiltinAttribInfo
        member attrib_RequiresExplicitTypeArgumentsAttribute : BuiltinAttribInfo
        member attrib_SealedAttribute : BuiltinAttribInfo
        member attrib_SecurityAttribute : BuiltinAttribInfo option
        member attrib_SecurityCriticalAttribute : BuiltinAttribInfo
        member attrib_SecuritySafeCriticalAttribute : BuiltinAttribInfo
        member attrib_SpecialNameAttribute : BuiltinAttribInfo option
        member attrib_StructAttribute : BuiltinAttribInfo
        member attrib_StructLayoutAttribute : BuiltinAttribInfo
        member attrib_StructuralComparisonAttribute : BuiltinAttribInfo
        member attrib_StructuralEqualityAttribute : BuiltinAttribInfo
        member attrib_SystemObsolete : BuiltinAttribInfo
        member attrib_ThreadStaticAttribute : BuiltinAttribInfo option
        member attrib_TypeForwardedToAttribute : BuiltinAttribInfo
        member attrib_UnverifiableAttribute : BuiltinAttribInfo
        member attrib_VolatileFieldAttribute : BuiltinAttribInfo
        member bitwise_and_info : IntrinsicValRef
        member bitwise_and_vref : TypedTree.ValRef
        member bitwise_or_info : IntrinsicValRef
        member bitwise_or_vref : TypedTree.ValRef
        member bitwise_shift_left_info : IntrinsicValRef
        member bitwise_shift_left_vref : TypedTree.ValRef
        member bitwise_shift_right_info : IntrinsicValRef
        member bitwise_shift_right_vref : TypedTree.ValRef
        member bitwise_unary_not_info : IntrinsicValRef
        member bitwise_unary_not_vref : TypedTree.ValRef
        member bitwise_xor_info : IntrinsicValRef
        member bitwise_xor_vref : TypedTree.ValRef
        member bool_tcr : TypedTree.EntityRef
        member bool_ty : TypedTree.TType
        member box_info : IntrinsicValRef
        member byref2_tcr : TypedTree.EntityRef
        member byref_tcr : TypedTree.EntityRef
        member byrefkind_InOut_tcr : TypedTree.EntityRef
        member byrefkind_In_tcr : TypedTree.EntityRef
        member byrefkind_Out_tcr : TypedTree.EntityRef
        member byte_checked_info : IntrinsicValRef
        member byte_operator_info : IntrinsicValRef
        member byte_tcr : TypedTree.EntityRef
        member byte_ty : TypedTree.TType
        member call_with_witnesses_info : IntrinsicValRef
        member cast_quotation_info : IntrinsicValRef
        member char_operator_info : IntrinsicValRef
        member char_tcr : TypedTree.EntityRef
        member char_ty : TypedTree.TType
        member check_this_info : IntrinsicValRef
        member checked_addition_info : IntrinsicValRef
        member checked_multiply_info : IntrinsicValRef
        member checked_subtraction_info : IntrinsicValRef
        member checked_unary_minus_info : IntrinsicValRef
        member choice2_tcr : TypedTree.EntityRef
        member choice3_tcr : TypedTree.EntityRef
        member choice4_tcr : TypedTree.EntityRef
        member choice5_tcr : TypedTree.EntityRef
        member choice6_tcr : TypedTree.EntityRef
        member choice7_tcr : TypedTree.EntityRef
        member compare_operator_vref : TypedTree.ValRef
        member compilingFslib : bool
        member cons_ucref : TypedTree.UnionCaseRef
        member create_event_info : IntrinsicValRef
        member create_instance_info : IntrinsicValRef
        member date_tcr : TypedTree.EntityRef
        member decimal_tcr : TypedTree.EntityRef
        member decimal_ty : TypedTree.TType
        member deserialize_quoted_FSharp_20_plus_info : IntrinsicValRef
        member deserialize_quoted_FSharp_40_plus_info : IntrinsicValRef
        member directoryToResolveRelativePaths : string
        member dispose_info : IntrinsicValRef
        member emitDebugInfoInQuotations : bool
        member enumOfValue_vref : TypedTree.ValRef
        member enum_operator_info : IntrinsicValRef
        member enum_vref : TypedTree.ValRef
        member equals_nullable_operator_vref : TypedTree.ValRef
        member equals_operator_info : IntrinsicValRef
        member equals_operator_vref : TypedTree.ValRef
        member exn_tcr : TypedTree.EntityRef
        member exn_ty : TypedTree.TType
        member expr_tcr : TypedTree.EntityRef
        member fail_init_info : IntrinsicValRef
        member fail_static_init_info : IntrinsicValRef
        member failwith_info : IntrinsicValRef
        member failwith_vref : TypedTree.ValRef
        member failwithf_info : IntrinsicValRef
        member failwithf_vref : TypedTree.ValRef
        member fastFunc_tcr : TypedTree.EntityRef
        member float32_operator_info : IntrinsicValRef
        member float32_tcr : TypedTree.EntityRef
        member float32_ty : TypedTree.TType
        member float_operator_info : IntrinsicValRef
        member float_tcr : TypedTree.EntityRef
        member float_ty : TypedTree.TType
        member format_tcr : TypedTree.EntityRef
        member fsharpref_vref : TypedTree.ValRef
        member fslibCcu : TypedTree.CcuThunk
        member fslib_IDelegateEvent_tcr : TypedTree.EntityRef
        member fslib_IEvent2_tcr : TypedTree.EntityRef
        member generateWitnesses : bool
        member generic_compare_withc_tuple2_vref : TypedTree.ValRef
        member generic_compare_withc_tuple3_vref : TypedTree.ValRef
        member generic_compare_withc_tuple4_vref : TypedTree.ValRef
        member generic_compare_withc_tuple5_vref : TypedTree.ValRef
        member generic_comparison_inner_vref : TypedTree.ValRef
        member generic_comparison_withc_inner_vref : TypedTree.ValRef
        member generic_comparison_withc_outer_info : IntrinsicValRef
        member generic_equality_er_inner_vref : TypedTree.ValRef
        member generic_equality_er_outer_info : IntrinsicValRef
        member generic_equality_per_inner_vref : TypedTree.ValRef
        member generic_equality_withc_inner_vref : TypedTree.ValRef
        member generic_equality_withc_outer_info : IntrinsicValRef
        member generic_equality_withc_outer_vref : TypedTree.ValRef
        member generic_equals_withc_tuple2_vref : TypedTree.ValRef
        member generic_equals_withc_tuple3_vref : TypedTree.ValRef
        member generic_equals_withc_tuple4_vref : TypedTree.ValRef
        member generic_equals_withc_tuple5_vref : TypedTree.ValRef
        member generic_hash_inner_vref : TypedTree.ValRef
        member generic_hash_withc_inner_vref : TypedTree.ValRef
        member generic_hash_withc_outer_info : IntrinsicValRef
        member generic_hash_withc_tuple2_vref : TypedTree.ValRef
        member generic_hash_withc_tuple3_vref : TypedTree.ValRef
        member generic_hash_withc_tuple4_vref : TypedTree.ValRef
        member generic_hash_withc_tuple5_vref : TypedTree.ValRef
        member get_generic_comparer_info : IntrinsicValRef
        member get_generic_er_equality_comparer_info : IntrinsicValRef
        member get_generic_per_equality_comparer_info : IntrinsicValRef
        member getstring_info : IntrinsicValRef
        member greater_than_operator : IntrinsicValRef
        member greater_than_operator_vref : TypedTree.ValRef
        member greater_than_or_equals_operator : IntrinsicValRef
        member greater_than_or_equals_operator_vref : TypedTree.ValRef
        member hash_info : IntrinsicValRef
        member il_arr_tcr_map : TypedTree.EntityRef []
        member ilg : AbstractIL.IL.ILGlobals
        member ilsigptr_tcr : TypedTree.EntityRef
        member iltyp_AsyncCallback : AbstractIL.IL.ILType
        member iltyp_Exception : AbstractIL.IL.ILType
        member iltyp_IAsyncResult : AbstractIL.IL.ILType
        member iltyp_IComparable : AbstractIL.IL.ILType
        member iltyp_Missing : AbstractIL.IL.ILType
        member iltyp_RuntimeFieldHandle : AbstractIL.IL.ILType
        member iltyp_RuntimeMethodHandle : AbstractIL.IL.ILType
        member iltyp_RuntimeTypeHandle : AbstractIL.IL.ILType
        member iltyp_SerializationInfo : AbstractIL.IL.ILType option
        member iltyp_StreamingContext : AbstractIL.IL.ILType option
        member iltyp_TypedReference : AbstractIL.IL.ILType option
        member iltyp_ValueType : AbstractIL.IL.ILType
        member ilxPubCloEnv : AbstractIL.Extensions.ILX.EraseClosures.cenv
        member inref_tcr : TypedTree.EntityRef
        member int16_checked_info : IntrinsicValRef
        member int16_operator_info : IntrinsicValRef
        member int16_tcr : TypedTree.EntityRef
        member int16_ty : TypedTree.TType
        member int32_checked_info : IntrinsicValRef
        member int32_operator_info : IntrinsicValRef
        member int32_tcr : TypedTree.EntityRef
        member int32_ty : TypedTree.TType
        member int64_checked_info : IntrinsicValRef
        member int64_operator_info : IntrinsicValRef
        member int64_tcr : TypedTree.EntityRef
        member int64_ty : TypedTree.TType
        member int_checked_info : IntrinsicValRef
        member int_operator_info : IntrinsicValRef
        member int_tcr : TypedTree.EntityRef
        member int_ty : TypedTree.TType
        member invalid_arg_info : IntrinsicValRef
        member invalid_arg_vref : TypedTree.ValRef
        member invalid_op_info : IntrinsicValRef
        member invalid_op_vref : TypedTree.ValRef
        member isInteractive : bool
        member isnotnull_info : IntrinsicValRef
        member isnull_info : IntrinsicValRef
        member istype_fast_info : IntrinsicValRef
        member istype_fast_vref : TypedTree.ValRef
        member istype_info : IntrinsicValRef
        member istype_vref : TypedTree.ValRef
        member
          knownFSharpCoreModules : System.Collections.Generic.IDictionary<string,
                                                                          TypedTree.EntityRef>
        member
          knownIntrinsics : System.Collections.Concurrent.ConcurrentDictionary<(string *
                                                                                string option *
                                                                                string *
                                                                                int),
                                                                               TypedTree.ValRef>
        member langVersion : Features.LanguageVersion
        member lazy_create_info : IntrinsicValRef
        member lazy_force_info : IntrinsicValRef
        member lazy_tcr_canon : TypedTree.EntityRef
        member lazy_tcr_nice : TypedTree.EntityRef
        member less_than_operator : IntrinsicValRef
        member less_than_operator_vref : TypedTree.ValRef
        member less_than_or_equals_operator : IntrinsicValRef
        member less_than_or_equals_operator_vref : TypedTree.ValRef
        member lift_value_info : IntrinsicValRef
        member lift_value_with_defn_info : IntrinsicValRef
        member lift_value_with_name_info : IntrinsicValRef
        member list_tcr_canon : TypedTree.EntityRef
        member list_tcr_nice : TypedTree.EntityRef
        member map_tcr_canon : TypedTree.EntityRef
        member measureinverse_tcr : TypedTree.EntityRef
        member measureone_tcr : TypedTree.EntityRef
        member measureproduct_tcr : TypedTree.EntityRef
        member methodhandleof_info : IntrinsicValRef
        member methodhandleof_vref : TypedTree.ValRef
        member mk_IComparable_ty : TypedTree.TType
        member mk_IStructuralComparable_ty : TypedTree.TType
        member mk_IStructuralEquatable_ty : TypedTree.TType
        member mlCompatibility : bool
        member nameof_vref : TypedTree.ValRef
        member nativeint_checked_info : IntrinsicValRef
        member nativeint_operator_info : IntrinsicValRef
        member nativeint_tcr : TypedTree.EntityRef
        member nativeint_ty : TypedTree.TType
        member nativeptr_tcr : TypedTree.EntityRef
        member nativeptr_tobyref_vref : TypedTree.ValRef
        member new_decimal_info : IntrinsicValRef
        member new_format_info : IntrinsicValRef
        member new_format_vref : TypedTree.ValRef
        member new_query_source_info : IntrinsicValRef
        member nil_ucref : TypedTree.UnionCaseRef
        member not_equals_operator : IntrinsicValRef
        member not_equals_operator_vref : TypedTree.ValRef
        member null_arg_info : IntrinsicValRef
        member null_arg_vref : TypedTree.ValRef
        member nullable_equals_nullable_operator_vref : TypedTree.ValRef
        member nullable_equals_operator_vref : TypedTree.ValRef
        member obj_ty : TypedTree.TType
        member option_defaultValue_info : IntrinsicValRef
        member option_tcr_canon : TypedTree.EntityRef
        member option_tcr_nice : TypedTree.EntityRef
        member option_toNullable_info : IntrinsicValRef
        member or2_vref : TypedTree.ValRef
        member or_vref : TypedTree.ValRef
        member outref_tcr : TypedTree.EntityRef
        member pathMap : Internal.Utilities.PathMap
        member pdecimal_tcr : TypedTree.EntityRef
        member pfloat32_tcr : TypedTree.EntityRef
        member pfloat_tcr : TypedTree.EntityRef
        member pint16_tcr : TypedTree.EntityRef
        member pint64_tcr : TypedTree.EntityRef
        member pint8_tcr : TypedTree.EntityRef
        member pint_tcr : TypedTree.EntityRef
        member pnativeint_tcr : TypedTree.EntityRef
        member puint16_tcr : TypedTree.EntityRef
        member puint64_tcr : TypedTree.EntityRef
        member puint8_tcr : TypedTree.EntityRef
        member puint_tcr : TypedTree.EntityRef
        member punativeint_tcr : TypedTree.EntityRef
        member query_builder_tcref : TypedTree.EntityRef
        member query_for_vref : TypedTree.ValRef
        member query_run_enumerable_vref : TypedTree.ValRef
        member query_run_value_vref : TypedTree.ValRef
        member query_select_vref : TypedTree.ValRef
        member query_source_as_enum_info : IntrinsicValRef
        member query_source_vref : TypedTree.ValRef
        member query_value_vref : TypedTree.ValRef
        member query_where_vref : TypedTree.ValRef
        member query_yield_from_vref : TypedTree.ValRef
        member query_yield_vref : TypedTree.ValRef
        member query_zero_vref : TypedTree.ValRef
        member quote_to_linq_lambda_info : IntrinsicValRef
        member raise_info : IntrinsicValRef
        member raise_vref : TypedTree.ValRef
        member range_int32_op_vref : TypedTree.ValRef
        member range_op_vref : TypedTree.ValRef
        member range_step_op_vref : TypedTree.ValRef
        member raw_expr_tcr : TypedTree.EntityRef
        member ref_tuple1_tcr : TypedTree.EntityRef
        member ref_tuple2_tcr : TypedTree.EntityRef
        member ref_tuple3_tcr : TypedTree.EntityRef
        member ref_tuple4_tcr : TypedTree.EntityRef
        member ref_tuple5_tcr : TypedTree.EntityRef
        member ref_tuple6_tcr : TypedTree.EntityRef
        member ref_tuple7_tcr : TypedTree.EntityRef
        member ref_tuple8_tcr : TypedTree.EntityRef
        member refcell_tcr_canon : TypedTree.EntityRef
        member refcell_tcr_nice : TypedTree.EntityRef
        member reference_equality_inner_vref : TypedTree.ValRef
        member reraise_info : IntrinsicValRef
        member reraise_vref : TypedTree.ValRef
        member sbyte_checked_info : IntrinsicValRef
        member sbyte_operator_info : IntrinsicValRef
        member sbyte_tcr : TypedTree.EntityRef
        member sbyte_ty : TypedTree.TType
        member seq_append_info : IntrinsicValRef
        member seq_append_vref : TypedTree.ValRef
        member seq_base_tcr : TypedTree.EntityRef
        member seq_collect_info : IntrinsicValRef
        member seq_collect_vref : TypedTree.ValRef
        member seq_delay_info : IntrinsicValRef
        member seq_delay_vref : TypedTree.ValRef
        member seq_empty_info : IntrinsicValRef
        member seq_empty_vref : TypedTree.ValRef
        member seq_finally_info : IntrinsicValRef
        member seq_finally_vref : TypedTree.ValRef
        member seq_generated_info : IntrinsicValRef
        member seq_generated_vref : TypedTree.ValRef
        member seq_info : IntrinsicValRef
        member seq_map_info : IntrinsicValRef
        member seq_map_vref : TypedTree.ValRef
        member seq_of_functions_info : IntrinsicValRef
        member seq_of_functions_vref : TypedTree.ValRef
        member seq_singleton_info : IntrinsicValRef
        member seq_singleton_vref : TypedTree.ValRef
        member seq_tcr : TypedTree.EntityRef
        member seq_to_array_info : IntrinsicValRef
        member seq_to_list_info : IntrinsicValRef
        member seq_using_info : IntrinsicValRef
        member seq_using_vref : TypedTree.ValRef
        member seq_vref : TypedTree.ValRef
        member set_tcr_canon : TypedTree.EntityRef
        member sizeof_vref : TypedTree.ValRef
        member splice_expr_vref : TypedTree.ValRef
        member splice_raw_expr_vref : TypedTree.ValRef
        member sprintf_info : IntrinsicValRef
        member sprintf_vref : TypedTree.ValRef
        member string_ty : TypedTree.TType
        member struct_tuple1_tcr : TypedTree.EntityRef
        member struct_tuple2_tcr : TypedTree.EntityRef
        member struct_tuple3_tcr : TypedTree.EntityRef
        member struct_tuple4_tcr : TypedTree.EntityRef
        member struct_tuple5_tcr : TypedTree.EntityRef
        member struct_tuple6_tcr : TypedTree.EntityRef
        member struct_tuple7_tcr : TypedTree.EntityRef
        member struct_tuple8_tcr : TypedTree.EntityRef
        member suppressed_types : TypedTree.EntityRef list
        member system_ArgIterator_tcref : TypedTree.EntityRef option
        member system_Array_tcref : TypedTree.EntityRef
        member system_Array_ty : TypedTree.TType
        member system_Bool_tcref : TypedTree.EntityRef
        member system_Byte_tcref : TypedTree.EntityRef
        member system_Char_tcref : TypedTree.EntityRef
        member system_Decimal_tcref : TypedTree.EntityRef
        member system_Delegate_ty : TypedTree.TType
        member system_Double_tcref : TypedTree.EntityRef
        member system_Enum_ty : TypedTree.TType
        member system_ExceptionDispatchInfo_ty : TypedTree.TType option
        member system_Exception_ty : TypedTree.TType
        member system_FormattableStringFactory_tcref : TypedTree.EntityRef
        member system_FormattableStringFactory_ty : TypedTree.TType
        member system_FormattableString_tcref : TypedTree.EntityRef
        member system_FormattableString_ty : TypedTree.TType
        member system_GenericIComparable_tcref : TypedTree.EntityRef
        member system_GenericIEquatable_tcref : TypedTree.EntityRef
        member system_IDisposable_ty : TypedTree.TType
        member system_IFormattable_tcref : TypedTree.EntityRef
        member system_IFormattable_ty : TypedTree.TType
        member system_IndexOutOfRangeException_tcref : TypedTree.EntityRef
        member system_Int16_tcref : TypedTree.EntityRef
        member system_Int32_tcref : TypedTree.EntityRef
        member system_Int32_ty : TypedTree.TType
        member system_Int64_tcref : TypedTree.EntityRef
        member system_IntPtr_tcref : TypedTree.EntityRef
        member system_LinqExpression_tcref : TypedTree.EntityRef
        member system_MarshalByRefObject_tcref : TypedTree.EntityRef option
        member system_MarshalByRefObject_ty : TypedTree.TType option
        member system_MulticastDelegate_ty : TypedTree.TType
        member system_Nullable_tcref : TypedTree.EntityRef
        member system_Object_tcref : TypedTree.EntityRef
        member system_Object_ty : TypedTree.TType
        member system_Reflection_MethodInfo_ty : TypedTree.TType
        member system_RuntimeArgumentHandle_tcref : TypedTree.EntityRef option
        member system_RuntimeHelpers_ty : TypedTree.TType
        member system_RuntimeMethodHandle_ty : TypedTree.TType
        member system_RuntimeTypeHandle_ty : TypedTree.TType
        member system_SByte_tcref : TypedTree.EntityRef
        member system_Single_tcref : TypedTree.EntityRef
        member system_String_tcref : TypedTree.EntityRef
        member system_String_typ : TypedTree.TType
        member system_Type_ty : TypedTree.TType
        member system_TypedReference_tcref : TypedTree.EntityRef option
        member system_UInt16_tcref : TypedTree.EntityRef
        member system_UInt32_tcref : TypedTree.EntityRef
        member system_UInt64_tcref : TypedTree.EntityRef
        member system_UIntPtr_tcref : TypedTree.EntityRef
        member system_Value_tcref : TypedTree.EntityRef
        member system_Value_ty : TypedTree.TType
        member system_Void_tcref : TypedTree.EntityRef
        member tcref_IObservable : TypedTree.EntityRef
        member tcref_IObserver : TypedTree.EntityRef
        member tcref_IQueryable : TypedTree.EntityRef
        member tcref_LanguagePrimitives : TypedTree.EntityRef
        member tcref_System_Attribute : TypedTree.EntityRef
        member tcref_System_Collections_Generic_Dictionary : TypedTree.EntityRef
        member
          tcref_System_Collections_Generic_ICollection : TypedTree.EntityRef
        member
          tcref_System_Collections_Generic_IDictionary : TypedTree.EntityRef
        member
          tcref_System_Collections_Generic_IEnumerable : TypedTree.EntityRef
        member
          tcref_System_Collections_Generic_IEnumerator : TypedTree.EntityRef
        member
          tcref_System_Collections_Generic_IEqualityComparer : TypedTree.EntityRef
        member tcref_System_Collections_Generic_IList : TypedTree.EntityRef
        member
          tcref_System_Collections_Generic_IReadOnlyCollection : TypedTree.EntityRef
        member
          tcref_System_Collections_Generic_IReadOnlyList : TypedTree.EntityRef
        member tcref_System_Collections_Generic_List : TypedTree.EntityRef
        member tcref_System_Collections_IComparer : TypedTree.EntityRef
        member tcref_System_Collections_IEnumerable : TypedTree.EntityRef
        member tcref_System_Collections_IEqualityComparer : TypedTree.EntityRef
        member tcref_System_IComparable : TypedTree.EntityRef
        member tcref_System_IDisposable : TypedTree.EntityRef
        member tcref_System_IStructuralComparable : TypedTree.EntityRef
        member tcref_System_IStructuralEquatable : TypedTree.EntityRef
        member typedefof_info : IntrinsicValRef
        member typedefof_vref : TypedTree.ValRef
        member typeof_info : IntrinsicValRef
        member typeof_vref : TypedTree.ValRef
        member uint16_checked_info : IntrinsicValRef
        member uint16_operator_info : IntrinsicValRef
        member uint16_tcr : TypedTree.EntityRef
        member uint16_ty : TypedTree.TType
        member uint32_checked_info : IntrinsicValRef
        member uint32_operator_info : IntrinsicValRef
        member uint32_tcr : TypedTree.EntityRef
        member uint32_ty : TypedTree.TType
        member uint64_checked_info : IntrinsicValRef
        member uint64_operator_info : IntrinsicValRef
        member uint64_tcr : TypedTree.EntityRef
        member uint64_ty : TypedTree.TType
        member unativeint_checked_info : IntrinsicValRef
        member unativeint_operator_info : IntrinsicValRef
        member unativeint_tcr : TypedTree.EntityRef
        member unativeint_ty : TypedTree.TType
        member unbox_fast_info : IntrinsicValRef
        member unbox_fast_vref : TypedTree.ValRef
        member unbox_info : IntrinsicValRef
        member unbox_vref : TypedTree.ValRef
        member unchecked_addition_info : IntrinsicValRef
        member unchecked_addition_vref : TypedTree.ValRef
        member unchecked_defaultof_info : IntrinsicValRef
        member unchecked_defaultof_vref : TypedTree.ValRef
        member unchecked_division_info : IntrinsicValRef
        member unchecked_modulus_info : IntrinsicValRef
        member unchecked_multiply_info : IntrinsicValRef
        member unchecked_multiply_vref : TypedTree.ValRef
        member unchecked_subtraction_info : IntrinsicValRef
        member unchecked_subtraction_vref : TypedTree.ValRef
        member unchecked_unary_minus_info : IntrinsicValRef
        member unchecked_unary_minus_vref : TypedTree.ValRef
        member unchecked_unary_not_info : IntrinsicValRef
        member unchecked_unary_not_vref : TypedTree.ValRef
        member unchecked_unary_plus_info : IntrinsicValRef
        member unchecked_unary_plus_vref : TypedTree.ValRef
        member unit_tcr_canon : TypedTree.EntityRef
        member unit_tcr_nice : TypedTree.EntityRef
        member unit_ty : TypedTree.TType
        member voidptr_tcr : TypedTree.EntityRef
      end
    val mutable global_g : TcGlobals option
  end

namespace FSharp.Compiler
  module internal TypedTreeOps = begin
    [<SealedAttribute (); NoEqualityAttribute (); NoComparisonAttribute ()>]
    type TyparMap<'T> =
      | TPMap of TypedTree.StampMap<'T>
      with
        member Add : TypedTree.Typar * 'T -> TyparMap<'T>
        member ContainsKey : TypedTree.Typar -> bool
        member TryFind : TypedTree.Typar -> 'T option
        member Item : TypedTree.Typar -> 'T with get
        static member Empty : TyparMap<'T>
      end
    [<NoEqualityAttribute (); NoComparisonAttribute (); SealedAttribute ()>]
    type TyconRefMap<'T> =
      class
        new : imap:TypedTree.StampMap<'T> -> TyconRefMap<'T>
        static member OfList : (TypedTree.TyconRef * 'T) list -> TyconRefMap<'T>
        member Add : TypedTree.TyconRef -> 'T -> TyconRefMap<'T>
        member ContainsKey : TypedTree.TyconRef -> bool
        member Remove : TypedTree.TyconRef -> TyconRefMap<'T>
        member TryFind : TypedTree.TyconRef -> 'T option
        member IsEmpty : bool
        member Item : TypedTree.TyconRef -> 'T with get
        static member Empty : TyconRefMap<'T>
      end
    [<StructAttribute (); NoEqualityAttribute (); NoComparisonAttribute ()>]
    type ValMap<'T> =
      struct
        new : imap:TypedTree.StampMap<'T> -> ValMap<'T>
        static member OfList : (TypedTree.Val * 'T) list -> ValMap<'T>
        member Add : TypedTree.Val -> 'T -> ValMap<'T>
        member ContainsVal : TypedTree.Val -> bool
        member Remove : TypedTree.Val -> ValMap<'T>
        member TryFind : TypedTree.Val -> 'T option
        member Contents : TypedTree.StampMap<'T>
        member IsEmpty : bool
        member Item : TypedTree.Val -> 'T with get
        static member Empty : ValMap<'T>
      end
    type TyparInst = (TypedTree.Typar * TypedTree.TType) list
    type TyconRefRemap = TyconRefMap<TypedTree.TyconRef>
    type ValRemap = ValMap<TypedTree.ValRef>
    val emptyTyconRefRemap : TyconRefRemap
    val emptyTyparInst : TyparInst
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type Remap =
      { tpinst: TyparInst
        valRemap: ValRemap
        tyconRefRemap: TyconRefRemap
        removeTraitSolutions: bool }
      with
        static member Empty : Remap
      end
    val emptyRemap : Remap
    val addTyconRefRemap :
      TypedTree.TyconRef -> TypedTree.TyconRef -> Remap -> Remap
    val isRemapEmpty : remap:Remap -> bool
    val instTyparRef :
      tpinst:(TypedTree.Typar * 'a) list -> ty:'a -> tp:TypedTree.Typar -> 'a
    val instMeasureTyparRef :
      tpinst:(TypedTree.Typar * TypedTree.TType) list ->
        unt:TypedTree.Measure -> tp:TypedTree.Typar -> TypedTree.Measure
    val remapTyconRef :
      TyconRefMap<TypedTree.TyconRef> ->
        TypedTree.TyconRef -> TypedTree.TyconRef
    val remapUnionCaseRef :
      TyconRefMap<TypedTree.TyconRef> ->
        TypedTree.UnionCaseRef -> TypedTree.UnionCaseRef
    val remapRecdFieldRef :
      TyconRefMap<TypedTree.TyconRef> ->
        TypedTree.RecdFieldRef -> TypedTree.RecdFieldRef
    val mkTyparInst : TypedTree.Typars -> TypedTree.TType list -> TyparInst
    val generalizeTypar : tp:TypedTree.Typar -> TypedTree.TType
    val generalizeTypars : TypedTree.Typar list -> TypedTree.TType list
    val remapTypeAux : tyenv:Remap -> ty:TypedTree.TType -> TypedTree.TType
    val remapMeasureAux :
      tyenv:Remap -> unt:TypedTree.Measure -> TypedTree.Measure
    val remapTupInfoAux :
      _tyenv:Remap -> unt:TypedTree.TupInfo -> TypedTree.TupInfo
    val remapTypesAux :
      tyenv:Remap -> types:TypedTree.TypeInst -> TypedTree.TypeInst
    val remapTyparConstraintsAux :
      tyenv:Remap ->
        cs:TypedTree.TyparConstraint list -> TypedTree.TyparConstraint list
    val remapTraitWitnessInfo :
      tyenv:Remap -> TypedTree.TraitWitnessInfo -> TypedTree.TraitWitnessInfo
    val remapTraitInfo :
      tyenv:Remap ->
        TypedTree.TraitConstraintInfo -> TypedTree.TraitConstraintInfo
    val bindTypars :
      tps:'a list -> tyargs:'b list -> tpinst:('a * 'b) list -> ('a * 'b) list
    val copyAndRemapAndBindTyparsFull :
      remapAttrib:(TypedTree.Attribs -> TypedTree.Attrib list) ->
        tyenv:Remap -> tps:TypedTree.Typar list -> TypedTree.Typar list * Remap
    val copyAndRemapAndBindTypars :
      tyenv:Remap -> tps:TypedTree.Typars -> TypedTree.Typars * Remap
    val remapValLinkage :
      tyenv:Remap ->
        vlink:TypedTree.ValLinkageFullKey -> TypedTree.ValLinkageFullKey
    val remapNonLocalValRef :
      tyenv:Remap ->
        nlvref:TypedTree.NonLocalValOrMemberRef ->
          TypedTree.NonLocalValOrMemberRef
    val remapValRef : Remap -> TypedTree.ValRef -> TypedTree.ValRef
    val remapType : tyenv:Remap -> x:TypedTree.TType -> TypedTree.TType
    val remapTypes : tyenv:Remap -> x:TypedTree.TypeInst -> TypedTree.TypeInst
    val remapTypeFull :
      remapAttrib:(TypedTree.Attribs -> TypedTree.Attrib list) ->
        tyenv:Remap -> ty:TypedTree.TType -> TypedTree.TType
    val remapParam : tyenv:Remap -> TypedTree.SlotParam -> TypedTree.SlotParam
    val remapSlotSig :
      remapAttrib:(TypedTree.Attribs -> TypedTree.Attrib list) ->
        tyenv:Remap -> TypedTree.SlotSig -> TypedTree.SlotSig
    val mkInstRemap : tpinst:TyparInst -> Remap
    val instType :
      (TypedTree.Typar * TypedTree.TType) list ->
        TypedTree.TType -> TypedTree.TType
    val instTypes :
      (TypedTree.Typar * TypedTree.TType) list ->
        TypedTree.TypeInst -> TypedTree.TypeInst
    val instTrait :
      (TypedTree.Typar * TypedTree.TType) list ->
        TypedTree.TraitConstraintInfo -> TypedTree.TraitConstraintInfo
    val instTyparConstraints :
      (TypedTree.Typar * TypedTree.TType) list ->
        TypedTree.TyparConstraint list -> TypedTree.TyparConstraint list
    val instSlotSig : TyparInst -> TypedTree.SlotSig -> TypedTree.SlotSig
    val copySlotSig : TypedTree.SlotSig -> TypedTree.SlotSig
    val mkTyparToTyparRenaming :
      TypedTree.Typars ->
        TypedTree.Typar list -> TyparInst * TypedTree.TType list
    val mkTyconInst :
      tycon:TypedTree.Tycon -> tinst:TypedTree.TType list -> TyparInst
    val mkTyconRefInst : TypedTree.TyconRef -> TypedTree.TType list -> TyparInst
    val tyconRefEq :
      TcGlobals.TcGlobals -> TypedTree.EntityRef -> TypedTree.EntityRef -> bool
    val valRefEq :
      TcGlobals.TcGlobals -> TypedTree.ValRef -> TypedTree.ValRef -> bool
    val reduceTyconRefAbbrevMeasureable :
      TypedTree.TyconRef -> TypedTree.Measure
    val stripUnitEqnsFromMeasureAux :
      canShortcut:bool -> unt:TypedTree.Measure -> TypedTree.Measure
    val stripUnitEqnsFromMeasure : m:TypedTree.Measure -> TypedTree.Measure
    val MeasureExprConExponent :
      TcGlobals.TcGlobals ->
        bool -> TypedTree.EntityRef -> TypedTree.Measure -> Rational.Rational
    val MeasureConExponentAfterRemapping :
      g:TcGlobals.TcGlobals ->
        r:(TypedTree.TyconRef -> TypedTree.EntityRef) ->
          ucref:TypedTree.EntityRef ->
            unt:TypedTree.Measure -> Rational.Rational
    val MeasureVarExponent :
      TypedTree.Typar -> TypedTree.Measure -> Rational.Rational
    val ListMeasureVarOccs : unt:TypedTree.Measure -> TypedTree.Typar list
    val ListMeasureVarOccsWithNonZeroExponents :
      TypedTree.Measure -> (TypedTree.Typar * Rational.Rational) list
    val ListMeasureConOccsWithNonZeroExponents :
      TcGlobals.TcGlobals ->
        bool ->
          TypedTree.Measure -> (TypedTree.EntityRef * Rational.Rational) list
    val ListMeasureConOccsAfterRemapping :
      g:TcGlobals.TcGlobals ->
        r:(TypedTree.TyconRef -> TypedTree.EntityRef) ->
          unt:TypedTree.Measure -> TypedTree.EntityRef list
    val MeasurePower : TypedTree.Measure -> int -> TypedTree.Measure
    val MeasureProdOpt :
      m1:TypedTree.Measure -> m2:TypedTree.Measure -> TypedTree.Measure
    val ProdMeasures : TypedTree.Measure list -> TypedTree.Measure
    val isDimensionless : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val destUnitParMeasure :
      g:TcGlobals.TcGlobals -> unt:TypedTree.Measure -> TypedTree.Typar
    val isUnitParMeasure :
      g:TcGlobals.TcGlobals -> unt:TypedTree.Measure -> bool
    val normalizeMeasure :
      TcGlobals.TcGlobals -> TypedTree.Measure -> TypedTree.Measure
    val tryNormalizeMeasureInType :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkNativePtrTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkByrefTy : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkInByrefTy : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkOutByrefTy : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkByrefTyWithFlag :
      g:TcGlobals.TcGlobals ->
        readonly:bool -> ty:TypedTree.TType -> TypedTree.TType
    val mkByref2Ty :
      g:TcGlobals.TcGlobals ->
        ty1:TypedTree.TType -> ty2:TypedTree.TType -> TypedTree.TType
    val mkVoidPtrTy : TcGlobals.TcGlobals -> TypedTree.TType
    val mkByrefTyWithInference :
      TcGlobals.TcGlobals ->
        TypedTree.TType -> TypedTree.TType -> TypedTree.TType
    val mkArrayTy :
      TcGlobals.TcGlobals ->
        int -> TypedTree.TType -> Range.range -> TypedTree.TType
    val maxTuple : int
    val goodTupleFields : int
    val isCompiledTupleTyconRef :
      TcGlobals.TcGlobals -> TypedTree.EntityRef -> bool
    val mkCompiledTupleTyconRef :
      TcGlobals.TcGlobals -> bool -> int -> TypedTree.EntityRef
    val mkCompiledTupleTy :
      TcGlobals.TcGlobals -> bool -> TypedTree.TType list -> TypedTree.TType
    val mkOuterCompiledTupleTy :
      g:TcGlobals.TcGlobals ->
        isStruct:bool -> tupElemTys:TypedTree.TType list -> TypedTree.TType
    val applyTyconAbbrev :
      abbrevTy:TypedTree.TType ->
        tycon:TypedTree.Tycon -> tyargs:TypedTree.TType list -> TypedTree.TType
    val reduceTyconAbbrev :
      tycon:TypedTree.Tycon -> tyargs:TypedTree.TType list -> TypedTree.TType
    val reduceTyconRefAbbrev :
      TypedTree.TyconRef -> TypedTree.TType list -> TypedTree.TType
    val reduceTyconMeasureableOrProvided :
      g:TcGlobals.TcGlobals ->
        tycon:TypedTree.Tycon -> tyargs:TypedTree.TType list -> TypedTree.TType
    val reduceTyconRefMeasureableOrProvided :
      TcGlobals.TcGlobals ->
        TypedTree.TyconRef -> TypedTree.TType list -> TypedTree.TType
    val stripTyEqnsA :
      TcGlobals.TcGlobals -> bool -> TypedTree.TType -> TypedTree.TType
    val stripTyEqns : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val evalTupInfoIsStruct : TypedTree.TupInfo -> bool
    val evalAnonInfoIsStruct : TypedTree.AnonRecdTypeInfo -> bool
    val stripTyEqnsAndErase :
      eraseFuncAndTuple:bool ->
        g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> TypedTree.TType
    val stripTyEqnsAndMeasureEqns :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    type Erasure =
      | EraseAll
      | EraseMeasures
      | EraseNone
    val stripTyEqnsWrtErasure :
      Erasure -> TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val stripExnEqns : TypedTree.TyconRef -> TypedTree.Entity
    val primDestForallTy :
      g:TcGlobals.TcGlobals ->
        ty:TypedTree.TType -> TypedTree.Typars * TypedTree.TType
    val destFunTy :
      TcGlobals.TcGlobals ->
        TypedTree.TType -> TypedTree.TType * TypedTree.TType
    val destAnyTupleTy :
      TcGlobals.TcGlobals ->
        TypedTree.TType -> TypedTree.TupInfo * TypedTree.TTypes
    val destRefTupleTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TTypes
    val destStructTupleTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TTypes
    val destTyparTy : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.Typar
    val destAnyParTy : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.Typar
    val destMeasureTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.Measure
    val isFunTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isForallTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isAnyTupleTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isRefTupleTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isStructTupleTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isAnonRecdTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isStructAnonRecdTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isUnionTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isReprHiddenTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isFSharpObjModelTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isRecdTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isFSharpStructOrEnumTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isFSharpEnumTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isTyparTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isAnyParTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isMeasureTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isProvenUnionCaseTy : TypedTree.TType -> bool
    val mkAppTy : TypedTree.TyconRef -> TypedTree.TypeInst -> TypedTree.TType
    val mkProvenUnionCaseTy :
      TypedTree.UnionCaseRef -> TypedTree.TypeInst -> TypedTree.TType
    val isAppTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val tryAppTy :
      TcGlobals.TcGlobals ->
        TypedTree.TType -> (TypedTree.TyconRef * TypedTree.TypeInst) voption
    val destAppTy :
      TcGlobals.TcGlobals ->
        TypedTree.TType -> TypedTree.TyconRef * TypedTree.TypeInst
    val tcrefOfAppTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TyconRef
    val argsOfAppTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TypeInst
    val tryDestTyparTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.Typar voption
    val tryDestFunTy :
      TcGlobals.TcGlobals ->
        TypedTree.TType -> (TypedTree.TType * TypedTree.TType) voption
    val tryTcrefOfAppTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TyconRef voption
    val tryDestAnonRecdTy :
      TcGlobals.TcGlobals ->
        TypedTree.TType ->
          (TypedTree.AnonRecdTypeInfo * TypedTree.TType list) voption
    val tryAnyParTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.Typar voption
    val tryAnyParTyOption :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.Typar option
    val ( |AppTy|_| ) :
      TcGlobals.TcGlobals ->
        TypedTree.TType -> (TypedTree.TyconRef * TypedTree.TypeInst) option
    val ( |RefTupleTy|_| ) :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> TypedTree.TTypes option
    val ( |FunTy|_| ) :
      g:TcGlobals.TcGlobals ->
        ty:TypedTree.TType -> (TypedTree.TType * TypedTree.TType) option
    val tryNiceEntityRefOfTy : TypedTree.TType -> TypedTree.TyconRef voption
    val tryNiceEntityRefOfTyOption :
      TypedTree.TType -> TypedTree.TyconRef option
    val mkInstForAppTy : TcGlobals.TcGlobals -> TypedTree.TType -> TyparInst
    val domainOfFunTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val rangeOfFunTy : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val convertToTypeWithMetadataIfPossible :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val stripMeasuresFromTType :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type TypeEquivEnv =
      { EquivTypars: TyparMap<TypedTree.TType>
        EquivTycons: TyconRefRemap }
      with
        static member
          FromEquivTypars : TypedTree.Typar list ->
                              TypedTree.Typar list -> TypeEquivEnv
        static member
          FromTyparInst : (TypedTree.Typar * TypedTree.TType) list ->
                            TypeEquivEnv
        member
          BindEquivTypars : TypedTree.Typar list ->
                              TypedTree.Typar list -> TypeEquivEnv
        member
          BindTyparsToTypes : tps1:TypedTree.Typar list ->
                                tys2:TypedTree.TType list -> TypeEquivEnv
        static member Empty : TypeEquivEnv
      end
    val typeEquivEnvEmpty : TypeEquivEnv
    val traitsAEquivAux :
      Erasure ->
        TcGlobals.TcGlobals ->
          TypeEquivEnv ->
            TypedTree.TraitConstraintInfo ->
              TypedTree.TraitConstraintInfo -> bool
    val traitKeysAEquivAux :
      Erasure ->
        TcGlobals.TcGlobals ->
          TypeEquivEnv ->
            TypedTree.TraitWitnessInfo -> TypedTree.TraitWitnessInfo -> bool
    val returnTypesAEquivAux :
      Erasure ->
        TcGlobals.TcGlobals ->
          TypeEquivEnv ->
            TypedTree.TType option -> TypedTree.TType option -> bool
    val typarConstraintsAEquivAux :
      Erasure ->
        TcGlobals.TcGlobals ->
          TypeEquivEnv ->
            TypedTree.TyparConstraint -> TypedTree.TyparConstraint -> bool
    val typarConstraintSetsAEquivAux :
      erasureFlag:Erasure ->
        g:TcGlobals.TcGlobals ->
          aenv:TypeEquivEnv ->
            tp1:TypedTree.Typar -> tp2:TypedTree.Typar -> bool
    val typarsAEquivAux :
      erasureFlag:Erasure ->
        g:TcGlobals.TcGlobals ->
          aenv:TypeEquivEnv ->
            tps1:TypedTree.Typar list -> tps2:TypedTree.Typar list -> bool
    val tcrefAEquiv :
      TcGlobals.TcGlobals ->
        TypeEquivEnv -> TypedTree.EntityRef -> TypedTree.EntityRef -> bool
    val typeAEquivAux :
      Erasure ->
        TcGlobals.TcGlobals ->
          TypeEquivEnv -> TypedTree.TType -> TypedTree.TType -> bool
    val anonInfoEquiv :
      TypedTree.AnonRecdTypeInfo -> TypedTree.AnonRecdTypeInfo -> bool
    val structnessAEquiv :
      un1:TypedTree.TupInfo -> un2:TypedTree.TupInfo -> bool
    val measureAEquiv :
      g:TcGlobals.TcGlobals ->
        aenv:TypeEquivEnv ->
          un1:TypedTree.Measure -> un2:TypedTree.Measure -> bool
    val typesAEquivAux :
      erasureFlag:Erasure ->
        g:TcGlobals.TcGlobals ->
          aenv:TypeEquivEnv ->
            l1:TypedTree.TypeInst -> l2:TypedTree.TypeInst -> bool
    val typeEquivAux :
      Erasure ->
        TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType -> bool
    val typeAEquiv :
      TcGlobals.TcGlobals ->
        TypeEquivEnv -> TypedTree.TType -> TypedTree.TType -> bool
    val typeEquiv :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType -> bool
    val traitsAEquiv :
      TcGlobals.TcGlobals ->
        TypeEquivEnv ->
          TypedTree.TraitConstraintInfo -> TypedTree.TraitConstraintInfo -> bool
    val traitKeysAEquiv :
      TcGlobals.TcGlobals ->
        TypeEquivEnv ->
          TypedTree.TraitWitnessInfo -> TypedTree.TraitWitnessInfo -> bool
    val typarConstraintsAEquiv :
      TcGlobals.TcGlobals ->
        TypeEquivEnv ->
          TypedTree.TyparConstraint -> TypedTree.TyparConstraint -> bool
    val typarsAEquiv :
      TcGlobals.TcGlobals ->
        TypeEquivEnv -> TypedTree.Typar list -> TypedTree.Typar list -> bool
    val returnTypesAEquiv :
      TcGlobals.TcGlobals ->
        TypeEquivEnv -> TypedTree.TType option -> TypedTree.TType option -> bool
    val measureEquiv :
      TcGlobals.TcGlobals -> TypedTree.Measure -> TypedTree.Measure -> bool
    val getMeasureOfType :
      TcGlobals.TcGlobals ->
        TypedTree.TType -> (TypedTree.TyconRef * TypedTree.Measure) option
    val isErasedType : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val getErasedTypes :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType list
    val valOrder : System.Collections.Generic.IComparer<TypedTree.Val>
    val tyconOrder : System.Collections.Generic.IComparer<TypedTree.Tycon>
    val recdFieldRefOrder :
      System.Collections.Generic.IComparer<TypedTree.RecdFieldRef>
    val unionCaseRefOrder :
      System.Collections.Generic.IComparer<TypedTree.UnionCaseRef>
    val mkFunTy : TypedTree.TType -> TypedTree.TType -> TypedTree.TType
    val ( --> ) : TypedTree.TType -> TypedTree.TType -> TypedTree.TType
    val mkForallTy : d:TypedTree.Typars -> r:TypedTree.TType -> TypedTree.TType
    val mkForallTyIfNeeded :
      TypedTree.Typar list -> TypedTree.TType -> TypedTree.TType
    val ( +-> ) : TypedTree.Typar list -> TypedTree.TType -> TypedTree.TType
    val mkIteratedFunTy :
      TypedTree.TType list -> TypedTree.TType -> TypedTree.TType
    val mkLambdaArgTy :
      m:Range.range -> tys:TypedTree.TType list -> TypedTree.TType
    val typeOfLambdaArg : Range.range -> TypedTree.Val list -> TypedTree.TType
    val mkMultiLambdaTy :
      Range.range -> TypedTree.Val list -> TypedTree.TType -> TypedTree.TType
    val mkLambdaTy :
      TypedTree.Typar list ->
        TypedTree.TType list -> TypedTree.TType -> TypedTree.TType
    val ensureCcuHasModuleOrNamespaceAtPath :
      TypedTree.CcuThunk ->
        SyntaxTree.Ident list ->
          TypedTree.CompilationPath -> XmlDoc.XmlDoc -> unit
    val stripExpr : TypedTree.Expr -> TypedTree.Expr
    val mkCase :
      TypedTree.DecisionTreeTest * TypedTree.DecisionTree ->
        TypedTree.DecisionTreeCase
    val isRefTupleExpr : TypedTree.Expr -> bool
    val tryDestRefTupleExpr : TypedTree.Expr -> TypedTree.Exprs
    val rangeOfExpr : x:TypedTree.Expr -> Range.range
    type Expr with
      member Range : Range.range
    val primMkMatch :
      SyntaxTree.DebugPointForBinding * Range.range * TypedTree.DecisionTree *
      TypedTree.DecisionTreeTarget array * Range.range * TypedTree.TType ->
        TypedTree.Expr
    type MatchBuilder =
      class
        new : SyntaxTree.DebugPointForBinding * Range.range -> MatchBuilder
        member
          AddResultTarget : TypedTree.Expr * SyntaxTree.DebugPointForTarget ->
                              TypedTree.DecisionTree
        member AddTarget : TypedTree.DecisionTreeTarget -> int
        member
          Close : TypedTree.DecisionTree * Range.range * TypedTree.TType ->
                    TypedTree.Expr
        member CloseTargets : unit -> TypedTree.DecisionTreeTarget list
      end
    val mkBoolSwitch :
      Range.range ->
        TypedTree.Expr ->
          TypedTree.DecisionTree ->
            TypedTree.DecisionTree -> TypedTree.DecisionTree
    val primMkCond :
      SyntaxTree.DebugPointForBinding ->
        SyntaxTree.DebugPointForTarget ->
          SyntaxTree.DebugPointForTarget ->
            Range.range ->
              TypedTree.TType ->
                TypedTree.Expr ->
                  TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCond :
      SyntaxTree.DebugPointForBinding ->
        SyntaxTree.DebugPointForTarget ->
          Range.range ->
            TypedTree.TType ->
              TypedTree.Expr ->
                TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val exprForValRef : Range.range -> TypedTree.ValRef -> TypedTree.Expr
    val exprForVal : Range.range -> TypedTree.Val -> TypedTree.Expr
    val mkLocalAux :
      m:Range.range ->
        s:string ->
          ty:TypedTree.TType ->
            mut:TypedTree.ValMutability ->
              compgen:bool -> TypedTree.Val * TypedTree.Expr
    val mkLocal :
      Range.range -> string -> TypedTree.TType -> TypedTree.Val * TypedTree.Expr
    val mkCompGenLocal :
      Range.range -> string -> TypedTree.TType -> TypedTree.Val * TypedTree.Expr
    val mkMutableCompGenLocal :
      Range.range -> string -> TypedTree.TType -> TypedTree.Val * TypedTree.Expr
    val mkMultiLambda :
      Range.range ->
        TypedTree.Val list -> TypedTree.Expr * TypedTree.TType -> TypedTree.Expr
    val rebuildLambda :
      Range.range ->
        TypedTree.Val option ->
          TypedTree.Val option ->
            TypedTree.Val list ->
              TypedTree.Expr * TypedTree.TType -> TypedTree.Expr
    val mkLambda :
      Range.range ->
        TypedTree.Val -> TypedTree.Expr * TypedTree.TType -> TypedTree.Expr
    val mkTypeLambda :
      Range.range ->
        TypedTree.Typar list ->
          TypedTree.Expr * TypedTree.TType -> TypedTree.Expr
    val mkTypeChoose :
      Range.range -> TypedTree.Typar list -> TypedTree.Expr -> TypedTree.Expr
    val mkObjExpr :
      TypedTree.TType * TypedTree.Val option * TypedTree.Expr *
      TypedTree.ObjExprMethod list *
      (TypedTree.TType * TypedTree.ObjExprMethod list) list * Range.range ->
        TypedTree.Expr
    val mkLambdas :
      Range.range ->
        TypedTree.Typar list ->
          TypedTree.Val list ->
            TypedTree.Expr * TypedTree.TType -> TypedTree.Expr
    val mkMultiLambdasCore :
      Range.range ->
        TypedTree.Val list list ->
          TypedTree.Expr * TypedTree.TType -> TypedTree.Expr * TypedTree.TType
    val mkMultiLambdas :
      Range.range ->
        TypedTree.Typar list ->
          TypedTree.Val list list ->
            TypedTree.Expr * TypedTree.TType -> TypedTree.Expr
    val mkMemberLambdas :
      Range.range ->
        TypedTree.Typar list ->
          TypedTree.Val option ->
            TypedTree.Val option ->
              TypedTree.Val list list ->
                TypedTree.Expr * TypedTree.TType -> TypedTree.Expr
    val mkMultiLambdaBind :
      TypedTree.Val ->
        SyntaxTree.DebugPointForBinding ->
          Range.range ->
            TypedTree.Typar list ->
              TypedTree.Val list list ->
                TypedTree.Expr * TypedTree.TType -> TypedTree.Binding
    val mkBind :
      SyntaxTree.DebugPointForBinding ->
        TypedTree.Val -> TypedTree.Expr -> TypedTree.Binding
    val mkLetBind :
      Range.range -> TypedTree.Binding -> TypedTree.Expr -> TypedTree.Expr
    val mkLetsBind :
      Range.range -> TypedTree.Binding list -> TypedTree.Expr -> TypedTree.Expr
    val mkLetsFromBindings :
      Range.range -> TypedTree.Binding list -> TypedTree.Expr -> TypedTree.Expr
    val mkLet :
      SyntaxTree.DebugPointForBinding ->
        Range.range ->
          TypedTree.Val -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCompGenBind : TypedTree.Val -> TypedTree.Expr -> TypedTree.Binding
    val mkCompGenBinds :
      TypedTree.Val list -> TypedTree.Expr list -> TypedTree.Binding list
    val mkCompGenLet :
      Range.range ->
        TypedTree.Val -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCompGenLets :
      m:Range.range ->
        vs:TypedTree.Val list ->
          xs:TypedTree.Expr list -> body:TypedTree.Expr -> TypedTree.Expr
    val mkCompGenLetsFromBindings :
      m:Range.range ->
        vs:TypedTree.Val list ->
          xs:TypedTree.Expr list -> body:TypedTree.Expr -> TypedTree.Expr
    val mkInvisibleBind : TypedTree.Val -> TypedTree.Expr -> TypedTree.Binding
    val mkInvisibleBinds :
      TypedTree.Val list -> TypedTree.Expr list -> TypedTree.Binding list
    val mkInvisibleLet :
      Range.range ->
        TypedTree.Val -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkInvisibleLets :
      m:Range.range ->
        vs:TypedTree.Val list ->
          xs:TypedTree.Expr list -> body:TypedTree.Expr -> TypedTree.Expr
    val mkInvisibleLetsFromBindings :
      m:Range.range ->
        vs:TypedTree.Val list ->
          xs:TypedTree.Expr list -> body:TypedTree.Expr -> TypedTree.Expr
    val mkLetRecBinds :
      Range.range -> TypedTree.Binding list -> TypedTree.Expr -> TypedTree.Expr
    val NormalizeDeclaredTyparsForEquiRecursiveInference :
      TcGlobals.TcGlobals -> TypedTree.Typar list -> TypedTree.Typar list
    type TypeScheme = | TypeScheme of TypedTree.Typars * TypedTree.TType
    val mkGenericBindRhs :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.Typar list -> TypeScheme -> TypedTree.Expr -> TypedTree.Expr
    val isBeingGeneralized : TypedTree.Typar -> TypeScheme -> bool
    val mkLazyAnd :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkLazyOr :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCoerceExpr :
      TypedTree.Expr * TypedTree.TType * Range.range * TypedTree.TType ->
        TypedTree.Expr
    val mkAsmExpr :
      AbstractIL.IL.ILInstr list * TypedTree.TypeInst * TypedTree.Exprs *
      TypedTree.TTypes * Range.range -> TypedTree.Expr
    val mkUnionCaseExpr :
      TypedTree.UnionCaseRef * TypedTree.TypeInst * TypedTree.Exprs *
      Range.range -> TypedTree.Expr
    val mkExnExpr :
      TypedTree.TyconRef * TypedTree.Exprs * Range.range -> TypedTree.Expr
    val mkTupleFieldGetViaExprAddr :
      tupInfo:TypedTree.TupInfo * e:TypedTree.Expr * tinst:TypedTree.TypeInst *
      i:int * m:Range.range -> TypedTree.Expr
    val mkAnonRecdFieldGetViaExprAddr :
      TypedTree.AnonRecdTypeInfo * TypedTree.Expr * TypedTree.TypeInst * int *
      Range.range -> TypedTree.Expr
    val mkRecdFieldGetViaExprAddr :
      TypedTree.Expr * TypedTree.RecdFieldRef * TypedTree.TypeInst * Range.range ->
        TypedTree.Expr
    val mkRecdFieldGetAddrViaExprAddr :
      readonly:bool * TypedTree.Expr * TypedTree.RecdFieldRef *
      TypedTree.TypeInst * Range.range -> TypedTree.Expr
    val mkStaticRecdFieldGetAddr :
      readonly:bool * TypedTree.RecdFieldRef * TypedTree.TypeInst * Range.range ->
        TypedTree.Expr
    val mkStaticRecdFieldGet :
      TypedTree.RecdFieldRef * TypedTree.TypeInst * Range.range ->
        TypedTree.Expr
    val mkStaticRecdFieldSet :
      TypedTree.RecdFieldRef * TypedTree.TypeInst * TypedTree.Expr * Range.range ->
        TypedTree.Expr
    val mkArrayElemAddress :
      TcGlobals.TcGlobals ->
        readonly:bool * AbstractIL.IL.ILReadonly * bool *
        AbstractIL.IL.ILArrayShape * TypedTree.TType * TypedTree.Exprs *
        Range.range -> TypedTree.Expr
    val mkRecdFieldSetViaExprAddr :
      TypedTree.Expr * TypedTree.RecdFieldRef * TypedTree.TypeInst *
      TypedTree.Expr * Range.range -> TypedTree.Expr
    val mkUnionCaseTagGetViaExprAddr :
      TypedTree.Expr * TypedTree.TyconRef * TypedTree.TypeInst * Range.range ->
        TypedTree.Expr
    val mkUnionCaseProof :
      TypedTree.Expr * TypedTree.UnionCaseRef * TypedTree.TypeInst * Range.range ->
        TypedTree.Expr
    val mkUnionCaseFieldGetProvenViaExprAddr :
      TypedTree.Expr * TypedTree.UnionCaseRef * TypedTree.TypeInst * int *
      Range.range -> TypedTree.Expr
    val mkUnionCaseFieldGetAddrProvenViaExprAddr :
      readonly:bool * TypedTree.Expr * TypedTree.UnionCaseRef *
      TypedTree.TypeInst * int * Range.range -> TypedTree.Expr
    val mkUnionCaseFieldGetUnprovenViaExprAddr :
      TypedTree.Expr * TypedTree.UnionCaseRef * TypedTree.TypeInst * int *
      Range.range -> TypedTree.Expr
    val mkUnionCaseFieldSet :
      TypedTree.Expr * TypedTree.UnionCaseRef * TypedTree.TypeInst * int *
      TypedTree.Expr * Range.range -> TypedTree.Expr
    val mkExnCaseFieldGet :
      TypedTree.Expr * TypedTree.TyconRef * int * Range.range -> TypedTree.Expr
    val mkExnCaseFieldSet :
      TypedTree.Expr * TypedTree.TyconRef * int * TypedTree.Expr * Range.range ->
        TypedTree.Expr
    val mkDummyLambda :
      g:TcGlobals.TcGlobals ->
        e:TypedTree.Expr * ety:TypedTree.TType -> TypedTree.Expr
    val mkWhile :
      TcGlobals.TcGlobals ->
        SyntaxTree.DebugPointAtWhile * TypedTree.SpecialWhileLoopMarker *
        TypedTree.Expr * TypedTree.Expr * Range.range -> TypedTree.Expr
    val mkFor :
      TcGlobals.TcGlobals ->
        SyntaxTree.DebugPointAtFor * TypedTree.Val * TypedTree.Expr *
        TypedTree.ForLoopStyle * TypedTree.Expr * TypedTree.Expr * Range.range ->
          TypedTree.Expr
    val mkTryWith :
      TcGlobals.TcGlobals ->
        TypedTree.Expr * TypedTree.Val * TypedTree.Expr * TypedTree.Val *
        TypedTree.Expr * Range.range * TypedTree.TType *
        SyntaxTree.DebugPointAtTry * SyntaxTree.DebugPointAtWith ->
          TypedTree.Expr
    val mkTryFinally :
      TcGlobals.TcGlobals ->
        TypedTree.Expr * TypedTree.Expr * Range.range * TypedTree.TType *
        SyntaxTree.DebugPointAtTry * SyntaxTree.DebugPointAtFinally ->
          TypedTree.Expr
    val mkDefault : Range.range * TypedTree.TType -> TypedTree.Expr
    val mkValSet :
      Range.range -> TypedTree.ValRef -> TypedTree.Expr -> TypedTree.Expr
    val mkAddrSet :
      Range.range -> TypedTree.ValRef -> TypedTree.Expr -> TypedTree.Expr
    val mkAddrGet : Range.range -> TypedTree.ValRef -> TypedTree.Expr
    val mkValAddr :
      Range.range -> readonly:bool -> TypedTree.ValRef -> TypedTree.Expr
    [<SealedAttribute (); NoEqualityAttribute (); NoComparisonAttribute ()>]
    type ValHash<'T> =
      | ValHash of System.Collections.Generic.Dictionary<TypedTree.Stamp,'T>
      with
        static member Create : unit -> ValHash<'T>
        member Add : TypedTree.Val * 'T -> unit
        member TryFind : TypedTree.Val -> 'T option
        member Values : seq<'T>
      end
    [<StructAttribute (); NoEqualityAttribute (); NoComparisonAttribute ()>]
    type ValMultiMap<'T> =
      struct
        new : contents:TypedTree.StampMap<'T list> -> ValMultiMap<'T>
        member Add : TypedTree.Val * 'T -> ValMultiMap<'T>
        member ContainsKey : TypedTree.Val -> bool
        member Find : TypedTree.Val -> 'T list
        member Remove : TypedTree.Val -> ValMultiMap<'T>
        member Contents : TypedTree.StampMap<'T list>
        static member Empty : ValMultiMap<'T>
      end
    [<StructAttribute (); NoEqualityAttribute (); NoComparisonAttribute ()>]
    type TyconRefMultiMap<'T> =
      struct
        new : contents:TyconRefMap<'T list> -> TyconRefMultiMap<'T>
        static member
          OfList : (TypedTree.TyconRef * 'T) list -> TyconRefMultiMap<'T>
        member Add : TypedTree.TyconRef * 'T -> TyconRefMultiMap<'T>
        member Find : TypedTree.TyconRef -> 'T list
        static member Empty : TyconRefMultiMap<'T>
      end
    val tryRescopeEntity :
      TypedTree.CcuThunk -> TypedTree.Entity -> ValueOption<TypedTree.EntityRef>
    val tryRescopeVal :
      TypedTree.CcuThunk ->
        Remap -> TypedTree.Val -> ValueOption<TypedTree.ValRef>
    val actualTyOfRecdField :
      (TypedTree.Typar * TypedTree.TType) list ->
        TypedTree.RecdField -> TypedTree.TType
    val actualTysOfRecdFields :
      inst:(TypedTree.Typar * TypedTree.TType) list ->
        rfields:TypedTree.RecdField list -> TypedTree.TType list
    val actualTysOfInstanceRecdFields :
      (TypedTree.Typar * TypedTree.TType) list ->
        TypedTree.TyconRef -> TypedTree.TType list
    val actualTysOfUnionCaseFields :
      (TypedTree.Typar * TypedTree.TType) list ->
        TypedTree.UnionCaseRef -> TypedTree.TType list
    val actualResultTyOfUnionCase :
      TypedTree.TType list -> TypedTree.UnionCaseRef -> TypedTree.TType
    val recdFieldsOfExnDefRef : TypedTree.TyconRef -> TypedTree.RecdField list
    val recdFieldOfExnDefRefByIdx :
      x:TypedTree.TyconRef -> n:int -> TypedTree.RecdField
    val recdFieldTysOfExnDefRef : TypedTree.TyconRef -> TypedTree.TType list
    val recdFieldTyOfExnDefRefByIdx :
      x:TypedTree.TyconRef -> j:int -> TypedTree.TType
    val actualTyOfRecdFieldForTycon :
      TypedTree.Tycon ->
        TypedTree.TType list -> TypedTree.RecdField -> TypedTree.TType
    val actualTyOfRecdFieldRef :
      TypedTree.RecdFieldRef -> TypedTree.TType list -> TypedTree.TType
    val actualTyOfUnionFieldRef :
      fref:TypedTree.UnionCaseRef ->
        n:int -> tinst:TypedTree.TType list -> TypedTree.TType
    val destForallTy :
      TcGlobals.TcGlobals ->
        TypedTree.TType -> TypedTree.Typar list * TypedTree.TType
    val tryDestForallTy :
      TcGlobals.TcGlobals ->
        TypedTree.TType -> TypedTree.Typar list * TypedTree.TType
    val stripFunTy :
      TcGlobals.TcGlobals ->
        TypedTree.TType -> TypedTree.TType list * TypedTree.TType
    val applyForallTy :
      TcGlobals.TcGlobals ->
        TypedTree.TType -> TypedTree.TType list -> TypedTree.TType
    val reduceIteratedFunTy :
      g:TcGlobals.TcGlobals ->
        ty:TypedTree.TType -> args:'a list -> TypedTree.TType
    val applyTyArgs :
      g:TcGlobals.TcGlobals ->
        functy:TypedTree.TType -> tyargs:TypedTree.TType list -> TypedTree.TType
    val applyTys :
      TcGlobals.TcGlobals ->
        TypedTree.TType -> TypedTree.TType list * 'T list -> TypedTree.TType
    val formalApplyTys :
      g:TcGlobals.TcGlobals ->
        functy:TypedTree.TType ->
          tyargs:'a list * args:'b list -> TypedTree.TType
    val stripFunTyN :
      TcGlobals.TcGlobals ->
        int -> TypedTree.TType -> TypedTree.TType list * TypedTree.TType
    val tryDestAnyTupleTy :
      TcGlobals.TcGlobals ->
        TypedTree.TType -> TypedTree.TupInfo * TypedTree.TTypes
    val tryDestRefTupleTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TTypes
    type UncurriedArgInfos = (TypedTree.TType * TypedTree.ArgReprInfo) list
    type CurriedArgInfos = (TypedTree.TType * TypedTree.ArgReprInfo) list list
    type TraitWitnessInfos = TypedTree.TraitWitnessInfo list
    val GetTopTauTypeInFSharpForm :
      TcGlobals.TcGlobals ->
        TypedTree.ArgReprInfo list list ->
          TypedTree.TType ->
            Range.range ->
              (TypedTree.TType * TypedTree.ArgReprInfo) list list *
              TypedTree.TType
    val destTopForallTy :
      TcGlobals.TcGlobals ->
        TypedTree.ValReprInfo ->
          TypedTree.TType -> TypedTree.Typar list * TypedTree.TType
    val GetTopValTypeInFSharpForm :
      TcGlobals.TcGlobals ->
        TypedTree.ValReprInfo ->
          TypedTree.TType ->
            Range.range ->
              TypedTree.Typar list *
              (TypedTree.TType * TypedTree.ArgReprInfo) list list *
              TypedTree.TType * TypedTree.ArgReprInfo
    val IsCompiledAsStaticProperty :
      TcGlobals.TcGlobals -> TypedTree.Val -> bool
    val IsCompiledAsStaticPropertyWithField :
      TcGlobals.TcGlobals -> TypedTree.Val -> bool
    val isArrayTyconRef : TcGlobals.TcGlobals -> TypedTree.EntityRef -> bool
    val rankOfArrayTyconRef : TcGlobals.TcGlobals -> TypedTree.EntityRef -> int
    val destArrayTy : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val destListTy : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val tyconRefEqOpt :
      g:TcGlobals.TcGlobals ->
        tcOpt:TypedTree.EntityRef option -> tc:TypedTree.EntityRef -> bool
    val isStringTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isListTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isArrayTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isArray1DTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isUnitTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isObjTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isValueTypeTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isVoidTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isILAppTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isNativePtrTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isByrefTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isInByrefTag : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val isInByrefTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isOutByrefTag : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val isOutByrefTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val extensionInfoOfTy :
      g:TcGlobals.TcGlobals ->
        ty:TypedTree.TType -> TypedTree.TyconRepresentation
    type TypeDefMetadata =
      | ILTypeMetadata of TypedTree.TILObjectReprData
      | FSharpOrArrayOrByrefOrTupleOrExnTypeMetadata
      | ProvidedTypeMetadata of TypedTree.TProvidedTypeInfo
    val metadataOfTycon : TypedTree.Tycon -> TypeDefMetadata
    val metadataOfTy : TcGlobals.TcGlobals -> TypedTree.TType -> TypeDefMetadata
    val isILReferenceTy : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val isILInterfaceTycon : tycon:TypedTree.Tycon -> bool
    val rankOfArrayTy : TcGlobals.TcGlobals -> TypedTree.TType -> int
    val isFSharpObjModelRefTy :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val isFSharpClassTy : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val isFSharpStructTy : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val isFSharpInterfaceTy :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val isDelegateTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isInterfaceTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isClassTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isStructOrEnumTyconTy :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val isStructRecordOrUnionTyconTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isStructTyconRef : tcref:TypedTree.TyconRef -> bool
    val isStructTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isRefTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isForallFunctionTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isUnmanagedTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isInterfaceTycon : x:TypedTree.Tycon -> bool
    val isInterfaceTyconRef : TypedTree.TyconRef -> bool
    val isEnumTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val actualReturnTyOfSlotSig :
      TypedTree.TType list ->
        TypedTree.TType list -> TypedTree.SlotSig -> TypedTree.TType option
    val slotSigHasVoidReturnTy : TypedTree.SlotSig -> bool
    val returnTyOfMethod :
      TcGlobals.TcGlobals -> TypedTree.ObjExprMethod -> TypedTree.TType option
    val isAbstractTycon : TypedTree.Tycon -> bool
    val MemberIsExplicitImpl :
      TcGlobals.TcGlobals -> TypedTree.ValMemberInfo -> bool
    val ValIsExplicitImpl : TcGlobals.TcGlobals -> TypedTree.Val -> bool
    val ValRefIsExplicitImpl : TcGlobals.TcGlobals -> TypedTree.ValRef -> bool
    val emptyFreeLocals : AbstractIL.Internal.Zset<TypedTree.Val>
    val unionFreeLocals :
      AbstractIL.Internal.Zset<TypedTree.Val> ->
        AbstractIL.Internal.Zset<TypedTree.Val> ->
          AbstractIL.Internal.Zset<TypedTree.Val>
    val emptyFreeRecdFields : AbstractIL.Internal.Zset<TypedTree.RecdFieldRef>
    val unionFreeRecdFields :
      s1:AbstractIL.Internal.Zset<TypedTree.RecdFieldRef> ->
        s2:AbstractIL.Internal.Zset<TypedTree.RecdFieldRef> ->
          AbstractIL.Internal.Zset<TypedTree.RecdFieldRef>
    val emptyFreeUnionCases : AbstractIL.Internal.Zset<TypedTree.UnionCaseRef>
    val unionFreeUnionCases :
      s1:AbstractIL.Internal.Zset<TypedTree.UnionCaseRef> ->
        s2:AbstractIL.Internal.Zset<TypedTree.UnionCaseRef> ->
          AbstractIL.Internal.Zset<TypedTree.UnionCaseRef>
    val emptyFreeTycons : AbstractIL.Internal.Zset<TypedTree.Tycon>
    val unionFreeTycons :
      AbstractIL.Internal.Zset<TypedTree.Tycon> ->
        AbstractIL.Internal.Zset<TypedTree.Tycon> ->
          AbstractIL.Internal.Zset<TypedTree.Tycon>
    val typarOrder : System.Collections.Generic.IComparer<TypedTree.Typar>
    val emptyFreeTypars : AbstractIL.Internal.Zset<TypedTree.Typar>
    val unionFreeTypars :
      AbstractIL.Internal.Zset<TypedTree.Typar> ->
        AbstractIL.Internal.Zset<TypedTree.Typar> ->
          AbstractIL.Internal.Zset<TypedTree.Typar>
    val emptyFreeTyvars : TypedTree.FreeTyvars
    val isEmptyFreeTyvars : TypedTree.FreeTyvars -> bool
    val unionFreeTyvars :
      TypedTree.FreeTyvars -> TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    type FreeVarOptions =
      { canCache: bool
        collectInTypes: bool
        includeLocalTycons: bool
        includeTypars: bool
        includeLocalTyconReprs: bool
        includeRecdFields: bool
        includeUnionCases: bool
        includeLocals: bool }
    val CollectAllNoCaching : FreeVarOptions
    val CollectTyparsNoCaching : FreeVarOptions
    val CollectLocalsNoCaching : FreeVarOptions
    val CollectTyparsAndLocalsNoCaching : FreeVarOptions
    val CollectAll : FreeVarOptions
    val CollectTyparsAndLocals : FreeVarOptions
    val CollectTypars : FreeVarOptions
    val CollectLocals : FreeVarOptions
    val accFreeLocalTycon :
      opts:FreeVarOptions ->
        x:TypedTree.Tycon -> acc:TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val accFreeTycon :
      opts:FreeVarOptions ->
        tcref:TypedTree.TyconRef ->
          acc:TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val boundTypars :
      opts:FreeVarOptions ->
        tps:TypedTree.Typar list ->
          acc:TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val accFreeInTyparConstraints :
      opts:FreeVarOptions ->
        cxs:TypedTree.TyparConstraint list ->
          acc:TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val accFreeInTyparConstraint :
      opts:FreeVarOptions ->
        tpc:TypedTree.TyparConstraint ->
          acc:TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val accFreeInTrait :
      opts:FreeVarOptions ->
        TypedTree.TraitConstraintInfo ->
          acc:TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val accFreeInWitnessArg :
      opts:FreeVarOptions ->
        TypedTree.TraitWitnessInfo ->
          acc:TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val accFreeInTraitSln :
      opts:FreeVarOptions ->
        sln:TypedTree.TraitConstraintSln ->
          acc:TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val accFreeLocalValInTraitSln :
      _opts:'a ->
        v:TypedTree.Val -> fvs:TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val accFreeValRefInTraitSln :
      opts:FreeVarOptions ->
        vref:TypedTree.ValRef ->
          fvs:TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val accFreeTyparRef :
      opts:FreeVarOptions ->
        tp:TypedTree.Typar -> acc:TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val accFreeInType :
      FreeVarOptions ->
        TypedTree.TType -> TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val accFreeInTupInfo :
      _opts:FreeVarOptions ->
        unt:TypedTree.TupInfo ->
          acc:TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val accFreeInMeasure :
      opts:FreeVarOptions ->
        unt:TypedTree.Measure ->
          acc:TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val accFreeInTypes :
      FreeVarOptions ->
        TypedTree.TTypes -> TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val freeInType : FreeVarOptions -> TypedTree.TType -> TypedTree.FreeTyvars
    val accFreeInVal :
      opts:FreeVarOptions ->
        v:TypedTree.Val -> acc:TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val freeInTypes : FreeVarOptions -> TypedTree.TTypes -> TypedTree.FreeTyvars
    val freeInVal : FreeVarOptions -> TypedTree.Val -> TypedTree.FreeTyvars
    val freeInTyparConstraints :
      opts:FreeVarOptions ->
        v:TypedTree.TyparConstraint list -> TypedTree.FreeTyvars
    val accFreeInTypars :
      FreeVarOptions ->
        TypedTree.Typar list -> TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val addFreeInModuleTy :
      mtyp:TypedTree.ModuleOrNamespaceType ->
        acc:TypedTree.FreeTyvars -> TypedTree.FreeTyvars
    val freeInModuleTy : TypedTree.ModuleOrNamespaceType -> TypedTree.FreeTyvars
    val emptyFreeTyparsLeftToRight : 'a list
    val unionFreeTyparsLeftToRight :
      fvs1:TypedTree.Typar list ->
        fvs2:TypedTree.Typar list -> TypedTree.Typar list
    val boundTyparsLeftToRight :
      g:TcGlobals.TcGlobals ->
        cxFlag:bool ->
          thruFlag:bool ->
            acc:TypedTree.Typar list ->
              tps:TypedTree.Typar list -> TypedTree.Typar list
    val accFreeInTyparConstraintsLeftToRight :
      g:TcGlobals.TcGlobals ->
        cxFlag:bool ->
          thruFlag:bool ->
            acc:TypedTree.Typar list ->
              cxs:TypedTree.TyparConstraint list -> TypedTree.Typar list
    val accFreeInTyparConstraintLeftToRight :
      g:TcGlobals.TcGlobals ->
        cxFlag:bool ->
          thruFlag:bool ->
            acc:TypedTree.Typar list ->
              tpc:TypedTree.TyparConstraint -> TypedTree.Typar list
    val accFreeInTraitLeftToRight :
      g:TcGlobals.TcGlobals ->
        cxFlag:bool ->
          thruFlag:bool ->
            acc:TypedTree.Typar list ->
              TypedTree.TraitConstraintInfo -> TypedTree.Typar list
    val accFreeTyparRefLeftToRight :
      g:TcGlobals.TcGlobals ->
        cxFlag:bool ->
          thruFlag:bool ->
            acc:TypedTree.Typar list ->
              tp:TypedTree.Typar -> TypedTree.Typar list
    val accFreeInTypeLeftToRight :
      g:TcGlobals.TcGlobals ->
        cxFlag:bool ->
          thruFlag:bool ->
            acc:TypedTree.Typar list ->
              ty:TypedTree.TType -> TypedTree.Typar list
    val accFreeInTupInfoLeftToRight :
      _g:TcGlobals.TcGlobals ->
        _cxFlag:bool ->
          _thruFlag:bool ->
            acc:TypedTree.Typar list ->
              unt:TypedTree.TupInfo -> TypedTree.Typar list
    val accFreeInTypesLeftToRight :
      g:TcGlobals.TcGlobals ->
        cxFlag:bool ->
          thruFlag:bool ->
            acc:TypedTree.Typar list ->
              tys:TypedTree.TTypes -> TypedTree.Typar list
    val freeInTypeLeftToRight :
      TcGlobals.TcGlobals -> bool -> TypedTree.TType -> TypedTree.Typar list
    val freeInTypesLeftToRight :
      TcGlobals.TcGlobals -> bool -> TypedTree.TTypes -> TypedTree.Typar list
    val freeInTypesLeftToRightSkippingConstraints :
      TcGlobals.TcGlobals -> TypedTree.TTypes -> TypedTree.Typar list
    val valOfBind : b:TypedTree.Binding -> TypedTree.Val
    val valsOfBinds : TypedTree.Bindings -> TypedTree.Val list
    val GetMemberTypeInFSharpForm :
      g:TcGlobals.TcGlobals ->
        memberFlags:SyntaxTree.MemberFlags ->
          arities:TypedTree.ValReprInfo ->
            ty:TypedTree.TType ->
              m:Range.range ->
                TypedTree.Typar list *
                (TypedTree.TType * TypedTree.ArgReprInfo) list list *
                TypedTree.TType * TypedTree.ArgReprInfo
    val checkMemberVal :
      membInfo:'a option -> arity:'b option -> m:Range.range -> 'a * 'b
    val checkMemberValRef :
      vref:TypedTree.ValRef -> TypedTree.ValMemberInfo * TypedTree.ValReprInfo
    val GetTraitConstraintInfosOfTypars :
      TcGlobals.TcGlobals ->
        TypedTree.Typars -> TypedTree.TraitConstraintInfo list
    val GetTraitWitnessInfosOfTypars :
      TcGlobals.TcGlobals ->
        numParentTypars:int ->
          typars:TypedTree.Typar list -> TypedTree.TraitWitnessInfo list
    val CountEnclosingTyparsOfActualParentOfVal : TypedTree.Val -> int
    val GetTopValTypeInCompiledForm :
      TcGlobals.TcGlobals ->
        TypedTree.ValReprInfo ->
          int ->
            TypedTree.TType ->
              Range.range ->
                TypedTree.Typar list * TypedTree.TraitWitnessInfo list *
                (TypedTree.TType * TypedTree.ArgReprInfo) list list *
                TypedTree.TType option * TypedTree.ArgReprInfo
    val GetMemberTypeInMemberForm :
      TcGlobals.TcGlobals ->
        SyntaxTree.MemberFlags ->
          TypedTree.ValReprInfo ->
            int ->
              TypedTree.TType ->
                Range.range ->
                  TypedTree.Typar list * TypedTree.TraitWitnessInfo list *
                  (TypedTree.TType * TypedTree.ArgReprInfo) list list *
                  TypedTree.TType option * TypedTree.ArgReprInfo
    val GetTypeOfMemberInMemberForm :
      TcGlobals.TcGlobals ->
        TypedTree.ValRef ->
          TypedTree.Typar list * TypedTree.TraitWitnessInfo list *
          (TypedTree.TType * TypedTree.ArgReprInfo) list list *
          TypedTree.TType option * TypedTree.ArgReprInfo
    val GetTypeOfMemberInFSharpForm :
      TcGlobals.TcGlobals ->
        TypedTree.ValRef ->
          TypedTree.Typar list *
          (TypedTree.TType * TypedTree.ArgReprInfo) list list * TypedTree.TType *
          TypedTree.ArgReprInfo
    val PartitionValTyparsForApparentEnclosingType :
      TcGlobals.TcGlobals ->
        TypedTree.Val ->
          (TypedTree.Typars * TypedTree.Typar list * TypedTree.Typar list *
           TyparInst * TypedTree.TType list) option
    val PartitionValTypars :
      TcGlobals.TcGlobals ->
        TypedTree.Val ->
          (TypedTree.Typar list * TypedTree.Typar list * TypedTree.Typar list *
           TyparInst * TypedTree.TType list) option
    val PartitionValRefTypars :
      TcGlobals.TcGlobals ->
        TypedTree.ValRef ->
          (TypedTree.Typar list * TypedTree.Typar list * TypedTree.Typar list *
           TyparInst * TypedTree.TType list) option
    val ArgInfosOfMemberVal :
      g:TcGlobals.TcGlobals ->
        v:TypedTree.Val -> (TypedTree.TType * TypedTree.ArgReprInfo) list list
    val ArgInfosOfMember :
      TcGlobals.TcGlobals ->
        TypedTree.ValRef -> (TypedTree.TType * TypedTree.ArgReprInfo) list list
    val GetFSharpViewOfReturnType :
      TcGlobals.TcGlobals -> TypedTree.TType option -> TypedTree.TType
    val ReturnTypeOfPropertyVal :
      TcGlobals.TcGlobals -> TypedTree.Val -> TypedTree.TType
    val ArgInfosOfPropertyVal :
      TcGlobals.TcGlobals ->
        TypedTree.Val -> (TypedTree.TType * TypedTree.ArgReprInfo) list
    val generalTyconRefInst : tc:TypedTree.TyconRef -> TypedTree.TType list
    val generalizeTyconRef :
      TypedTree.TyconRef -> TypedTree.TType list * TypedTree.TType
    val generalizedTyconRef : TypedTree.TyconRef -> TypedTree.TType
    val isTTyparSupportsStaticMethod : _arg1:TypedTree.TyparConstraint -> bool
    val isTTyparCoercesToType : _arg1:TypedTree.TyparConstraint -> bool
    val prefixOfStaticReq : SyntaxTree.TyparStaticReq -> string
    val prefixOfRigidTypar : TypedTree.Typar -> string
    type TyparConstraintsWithTypars =
      (TypedTree.Typar * TypedTree.TyparConstraint) list
    module PrettyTypes = begin
      val newPrettyTypar : tp:TypedTree.Typar -> nm:string -> TypedTree.Typar
      val NewPrettyTypars :
        (TypedTree.Typar * TypedTree.TType) list ->
          TypedTree.Typar list ->
            string list ->
              TypedTree.Typar list * (TypedTree.Typar * TypedTree.TType) list
      val NeedsPrettyTyparName : TypedTree.Typar -> bool
      val PrettyTyparNames :
        (TypedTree.Typar -> bool) ->
          string list -> TypedTree.Typar list -> string list
      val PrettifyThings :
        g:TcGlobals.TcGlobals ->
          foldTys:((TypedTree.Typar list -> TypedTree.TType ->
                      TypedTree.Typar list) -> 'a list -> 'b ->
                     TypedTree.Typar list) ->
            mapTys:((TypedTree.TType -> TypedTree.TType) -> 'b -> 'b) ->
              things:'b ->
                'b * (TypedTree.Typar * TypedTree.TyparConstraint) list
      val PrettifyType :
        TcGlobals.TcGlobals ->
          TypedTree.TType ->
            TypedTree.TType * (TypedTree.Typar * TypedTree.TyparConstraint) list
      val PrettifyTypePair :
        TcGlobals.TcGlobals ->
          TypedTree.TType * TypedTree.TType ->
            (TypedTree.TType * TypedTree.TType) *
            (TypedTree.Typar * TypedTree.TyparConstraint) list
      val PrettifyTypes :
        TcGlobals.TcGlobals ->
          TypedTree.TType list ->
            TypedTree.TType list *
            (TypedTree.Typar * TypedTree.TyparConstraint) list
      val PrettifyDiscriminantAndTypePairs :
        TcGlobals.TcGlobals ->
          ('Discriminant * TypedTree.TType) list ->
            ('Discriminant * TypedTree.TType) list *
            (TypedTree.Typar * TypedTree.TyparConstraint) list
      val PrettifyCurriedTypes :
        TcGlobals.TcGlobals ->
          TypedTree.TType list list ->
            TypedTree.TType list list *
            (TypedTree.Typar * TypedTree.TyparConstraint) list
      val PrettifyCurriedSigTypes :
        TcGlobals.TcGlobals ->
          TypedTree.TType list list * TypedTree.TType ->
            (TypedTree.TType list list * TypedTree.TType) *
            (TypedTree.Typar * TypedTree.TyparConstraint) list
      val safeDestAnyParTy :
        orig:TypedTree.Typar ->
          g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> TypedTree.Typar
      val tee : f:('a -> 'a -> 'b) -> x:'a -> 'b
      val foldUnurriedArgInfos :
        f:('a -> TypedTree.TType -> 'a) -> z:'a -> x:UncurriedArgInfos -> 'a
      val mapUnurriedArgInfos :
        f:(TypedTree.TType -> 'a) ->
          x:UncurriedArgInfos -> ('a * TypedTree.ArgReprInfo) list
      val foldTypar :
        f:('a -> TypedTree.TType -> 'b) -> z:'a -> x:TypedTree.Typar -> 'b
      val mapTypar :
        g:TcGlobals.TcGlobals ->
          f:(TypedTree.TType -> TypedTree.TType) ->
            x:TypedTree.Typar -> TypedTree.Typar
      val foldTypars :
        f:('a -> TypedTree.TType -> 'a) -> z:'a -> x:TypedTree.Typars -> 'a
      val mapTypars :
        g:TcGlobals.TcGlobals ->
          f:(TypedTree.TType -> TypedTree.TType) ->
            x:TypedTree.Typars -> TypedTree.Typars
      val foldTyparInst :
        f:('a -> TypedTree.TType -> 'a) -> z:'a -> x:TyparInst -> 'a
      val mapTyparInst :
        g:TcGlobals.TcGlobals ->
          f:(TypedTree.TType -> TypedTree.TType) -> x:TyparInst -> TyparInst
      val PrettifyInstAndTyparsAndType :
        TcGlobals.TcGlobals ->
          TyparInst * TypedTree.Typars * TypedTree.TType ->
            (TyparInst * TypedTree.Typars * TypedTree.TType) *
            (TypedTree.Typar * TypedTree.TyparConstraint) list
      val PrettifyInstAndUncurriedSig :
        TcGlobals.TcGlobals ->
          TyparInst * UncurriedArgInfos * TypedTree.TType ->
            (TyparInst * UncurriedArgInfos * TypedTree.TType) *
            (TypedTree.Typar * TypedTree.TyparConstraint) list
      val PrettifyInstAndCurriedSig :
        TcGlobals.TcGlobals ->
          TyparInst * TypedTree.TTypes * CurriedArgInfos * TypedTree.TType ->
            (TyparInst * TypedTree.TType list *
             (TypedTree.TType * TypedTree.ArgReprInfo) list list *
             TypedTree.TType) *
            (TypedTree.Typar * TypedTree.TyparConstraint) list
      val PrettifyInstAndSig :
        TcGlobals.TcGlobals ->
          TyparInst * TypedTree.TType list * TypedTree.TType ->
            (TyparInst * TypedTree.TType list * TypedTree.TType) *
            (TypedTree.Typar * TypedTree.TyparConstraint) list
      val PrettifyInstAndTypes :
        TcGlobals.TcGlobals ->
          TyparInst * TypedTree.TType list ->
            (TyparInst * TypedTree.TType list) *
            (TypedTree.Typar * TypedTree.TyparConstraint) list
      val PrettifyInstAndType :
        TcGlobals.TcGlobals ->
          TyparInst * TypedTree.TType ->
            (TyparInst * TypedTree.TType) *
            (TypedTree.Typar * TypedTree.TyparConstraint) list
      val PrettifyInst :
        TcGlobals.TcGlobals ->
          TyparInst ->
            TyparInst * (TypedTree.Typar * TypedTree.TyparConstraint) list
    end
    module SimplifyTypes = begin
      val foldTypeButNotConstraints :
        f:('a -> TypedTree.TType -> 'a) -> z:'a -> ty:TypedTree.TType -> 'a
      val incM :
        x:'a ->
          m:AbstractIL.Internal.Zmap<'a,int> -> AbstractIL.Internal.Zmap<'a,int>
      val accTyparCounts :
        z:AbstractIL.Internal.Zmap<TypedTree.Typar,int> ->
          ty:TypedTree.TType -> AbstractIL.Internal.Zmap<TypedTree.Typar,int>
      val emptyTyparCounts : AbstractIL.Internal.Zmap<TypedTree.Typar,int>
      val accTyparCountsMulti :
        acc:AbstractIL.Internal.Zmap<TypedTree.Typar,int> ->
          l:TypedTree.TType list ->
            AbstractIL.Internal.Zmap<TypedTree.Typar,int>
      type TypeSimplificationInfo =
        { singletons: AbstractIL.Internal.Zset<TypedTree.Typar>
          inplaceConstraints:
            AbstractIL.Internal.Zmap<TypedTree.Typar,TypedTree.TType>
          postfixConstraints: (TypedTree.Typar * TypedTree.TyparConstraint) list }
      val typeSimplificationInfo0 : TypeSimplificationInfo
      val categorizeConstraints :
        simplify:bool ->
          m:AbstractIL.Internal.Zmap<TypedTree.Typar,int> ->
            cxs:(TypedTree.Typar * TypedTree.TyparConstraint) list ->
              TypeSimplificationInfo
      val CollectInfo :
        bool ->
          TypedTree.TType list ->
            (TypedTree.Typar * TypedTree.TyparConstraint) list ->
              TypeSimplificationInfo
    end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type DisplayEnv =
      { includeStaticParametersInTypeNames: bool
        openTopPathsSorted: Lazy<string list list>
        openTopPathsRaw: string list list
        shortTypeNames: bool
        suppressNestedTypes: bool
        maxMembers: int option
        showObsoleteMembers: bool
        showHiddenMembers: bool
        showTyparBinding: bool
        showImperativeTyparAnnotations: bool
        suppressInlineKeyword: bool
        suppressMutableKeyword: bool
        showMemberContainers: bool
        shortConstraints: bool
        useColonForReturnType: bool
        showAttributes: bool
        showOverrides: bool
        showConstraintTyparAnnotations: bool
        abbreviateAdditionalConstraints: bool
        showTyparDefaultConstraints: bool
        shrinkOverloads: bool
        printVerboseSignatures: bool
        g: TcGlobals.TcGlobals
        contextAccessibility: TypedTree.Accessibility
        generatedValueLayout: TypedTree.Val -> Layout.layout option }
      with
        static member Empty : TcGlobals.TcGlobals -> DisplayEnv
        member AddAccessibility : TypedTree.Accessibility -> DisplayEnv
        member
          AddOpenModuleOrNamespace : TypedTree.ModuleOrNamespaceRef ->
                                       DisplayEnv
        member AddOpenPath : string list -> DisplayEnv
        member SetOpenPaths : string list list -> DisplayEnv
      end
    val ( +.+ ) : s1:string -> s2:string -> string
    val layoutOfPath :
      p:string list -> Internal.Utilities.StructuredFormat.Layout
    val fullNameOfParentOfPubPath : pp:TypedTree.PublicPath -> string voption
    val fullNameOfParentOfPubPathAsLayout :
      pp:TypedTree.PublicPath ->
        Internal.Utilities.StructuredFormat.Layout voption
    val fullNameOfPubPath : TypedTree.PublicPath -> string
    val fullNameOfPubPathAsLayout :
      TypedTree.PublicPath -> Internal.Utilities.StructuredFormat.Layout
    val fullNameOfParentOfNonLocalEntityRef :
      nlr:TypedTree.NonLocalEntityRef -> string voption
    val fullNameOfParentOfNonLocalEntityRefAsLayout :
      nlr:TypedTree.NonLocalEntityRef ->
        Internal.Utilities.StructuredFormat.Layout voption
    val fullNameOfParentOfEntityRef : eref:TypedTree.EntityRef -> string voption
    val fullNameOfParentOfEntityRefAsLayout :
      eref:TypedTree.EntityRef ->
        Internal.Utilities.StructuredFormat.Layout voption
    val fullNameOfEntityRef :
      nmF:(TypedTree.EntityRef -> string) -> xref:TypedTree.EntityRef -> string
    val tagEntityRefName :
      xref:TypedTree.EntityRef -> name:string -> Layout.TaggedText
    val fullDisplayTextOfTyconRef : TypedTree.TyconRef -> string
    val fullNameOfEntityRefAsLayout :
      nmF:(TypedTree.EntityRef -> string) ->
        xref:TypedTree.EntityRef -> Internal.Utilities.StructuredFormat.Layout
    val fullNameOfParentOfValRef : vref:TypedTree.ValRef -> string voption
    val fullNameOfParentOfValRefAsLayout :
      vref:TypedTree.ValRef ->
        Internal.Utilities.StructuredFormat.Layout voption
    val fullDisplayTextOfParentOfModRef : TypedTree.EntityRef -> string voption
    val fullDisplayTextOfModRef : TypedTree.EntityRef -> string
    val fullDisplayTextOfTyconRefAsLayout :
      TypedTree.EntityRef -> Internal.Utilities.StructuredFormat.Layout
    val fullDisplayTextOfExnRef : TypedTree.EntityRef -> string
    val fullDisplayTextOfExnRefAsLayout :
      TypedTree.EntityRef -> Internal.Utilities.StructuredFormat.Layout
    val fullDisplayTextOfUnionCaseRef : TypedTree.UnionCaseRef -> string
    val fullDisplayTextOfRecdFieldRef : TypedTree.RecdFieldRef -> string
    val fullDisplayTextOfValRef : TypedTree.ValRef -> string
    val fullDisplayTextOfValRefAsLayout :
      TypedTree.ValRef -> Internal.Utilities.StructuredFormat.Layout
    val fullMangledPathToTyconRef : tcref:TypedTree.TyconRef -> string []
    val tyconRefToFullName : tc:TypedTree.TyconRef -> string
    val qualifiedInterfaceImplementationNameAux :
      g:TcGlobals.TcGlobals -> x:TypedTree.TType -> string
    val qualifiedInterfaceImplementationName :
      TcGlobals.TcGlobals -> TypedTree.TType -> string -> string
    val qualifiedMangledNameOfTyconRef : TypedTree.TyconRef -> string -> string
    val firstEq : p1:'a list -> p2:'a list -> bool when 'a : equality
    val firstRem : p1:'a list -> p2:'b list -> 'b list
    val trimPathByDisplayEnv : DisplayEnv -> string list -> string
    val superOfTycon : TcGlobals.TcGlobals -> TypedTree.Tycon -> TypedTree.TType
    val isILAttribByName :
      tencl:string list * tname:string -> attr:AbstractIL.IL.ILAttribute -> bool
    val isILAttrib :
      tref:AbstractIL.IL.ILTypeRef -> attr:AbstractIL.IL.ILAttribute -> bool
    val HasILAttribute :
      tref:AbstractIL.IL.ILTypeRef -> attrs:AbstractIL.IL.ILAttributes -> bool
    val TryDecodeILAttribute :
      TcGlobals.TcGlobals ->
        AbstractIL.IL.ILTypeRef ->
          AbstractIL.IL.ILAttributes ->
            (AbstractIL.IL.ILAttribElem list *
             AbstractIL.IL.ILAttributeNamedArg list) option
    val IsMatchingFSharpAttribute :
      TcGlobals.TcGlobals ->
        TcGlobals.BuiltinAttribInfo -> TypedTree.Attrib -> bool
    val HasFSharpAttribute :
      TcGlobals.TcGlobals ->
        TcGlobals.BuiltinAttribInfo -> TypedTree.Attrib list -> bool
    val findAttrib :
      g:TcGlobals.TcGlobals ->
        tref:TcGlobals.BuiltinAttribInfo ->
          attrs:TypedTree.Attrib list -> TypedTree.Attrib
    val TryFindFSharpAttribute :
      TcGlobals.TcGlobals ->
        TcGlobals.BuiltinAttribInfo ->
          TypedTree.Attrib list -> TypedTree.Attrib option
    val TryFindFSharpAttributeOpt :
      TcGlobals.TcGlobals ->
        TcGlobals.BuiltinAttribInfo option ->
          TypedTree.Attrib list -> TypedTree.Attrib option
    val HasFSharpAttributeOpt :
      TcGlobals.TcGlobals ->
        TcGlobals.BuiltinAttribInfo option -> TypedTree.Attrib list -> bool
    val IsMatchingFSharpAttributeOpt :
      TcGlobals.TcGlobals ->
        TcGlobals.BuiltinAttribInfo option -> TypedTree.Attrib -> bool
    val ( |ExtractAttribNamedArg|_| ) :
      string -> TypedTree.AttribNamedArg list -> TypedTree.AttribExpr option
    val ( |AttribInt32Arg|_| ) : TypedTree.AttribExpr -> int32 option
    val ( |AttribInt16Arg|_| ) : TypedTree.AttribExpr -> int16 option
    val ( |AttribBoolArg|_| ) : TypedTree.AttribExpr -> bool option
    val ( |AttribStringArg|_| ) : TypedTree.AttribExpr -> string option
    val TryFindFSharpBoolAttributeWithDefault :
      dflt:bool ->
        g:TcGlobals.TcGlobals ->
          nm:TcGlobals.BuiltinAttribInfo ->
            attrs:TypedTree.Attrib list -> bool option
    val TryFindFSharpBoolAttribute :
      TcGlobals.TcGlobals ->
        TcGlobals.BuiltinAttribInfo -> TypedTree.Attrib list -> bool option
    val TryFindFSharpBoolAttributeAssumeFalse :
      TcGlobals.TcGlobals ->
        TcGlobals.BuiltinAttribInfo -> TypedTree.Attrib list -> bool option
    val TryFindFSharpInt32Attribute :
      TcGlobals.TcGlobals ->
        TcGlobals.BuiltinAttribInfo -> TypedTree.Attrib list -> int32 option
    val TryFindFSharpStringAttribute :
      TcGlobals.TcGlobals ->
        TcGlobals.BuiltinAttribInfo -> TypedTree.Attrib list -> string option
    val TryFindILAttribute :
      TcGlobals.BuiltinAttribInfo -> AbstractIL.IL.ILAttributes -> bool
    val TryFindILAttributeOpt :
      TcGlobals.BuiltinAttribInfo option -> AbstractIL.IL.ILAttributes -> bool
    val TryBindTyconRefAttribute :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          TcGlobals.BuiltinAttribInfo ->
            tcref:TypedTree.TyconRef ->
              f1:(AbstractIL.IL.ILAttribElem list *
                  AbstractIL.IL.ILAttributeNamedArg list -> 'a option) ->
                f2:(TypedTree.Attrib -> 'a option) ->
                  f3:(obj option list * (string * obj option) list -> 'a option) ->
                    'a option
    val TryFindTyconRefBoolAttribute :
      TcGlobals.TcGlobals ->
        Range.range ->
          TcGlobals.BuiltinAttribInfo -> TypedTree.TyconRef -> bool option
    val TryFindAttributeUsageAttribute :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TyconRef -> bool option
    val TryFindTyconRefStringAttribute :
      TcGlobals.TcGlobals ->
        Range.range ->
          TcGlobals.BuiltinAttribInfo -> TypedTree.TyconRef -> string option
    val TyconRefHasAttribute :
      TcGlobals.TcGlobals ->
        Range.range -> TcGlobals.BuiltinAttribInfo -> TypedTree.TyconRef -> bool
    val isByrefTyconRef : TcGlobals.TcGlobals -> TypedTree.TyconRef -> bool
    val isByrefLikeTyconRef :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TyconRef -> bool
    val isSpanLikeTyconRef :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TyconRef -> bool
    val isByrefLikeTy :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TType -> bool
    val isSpanLikeTy :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TType -> bool
    val isSpanTyconRef :
      g:TcGlobals.TcGlobals -> m:Range.range -> tcref:TypedTree.TyconRef -> bool
    val isSpanTy : TcGlobals.TcGlobals -> Range.range -> TypedTree.TType -> bool
    val tryDestSpanTy :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            struct (TypedTree.TyconRef * TypedTree.TType) voption
    val destSpanTy :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> struct (TypedTree.TyconRef * TypedTree.TType)
    val isReadOnlySpanTyconRef :
      g:TcGlobals.TcGlobals -> m:Range.range -> tcref:TypedTree.TyconRef -> bool
    val isReadOnlySpanTy :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TType -> bool
    val tryDestReadOnlySpanTy :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            struct (TypedTree.TyconRef * TypedTree.TType) voption
    val destReadOnlySpanTy :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> struct (TypedTree.TyconRef * TypedTree.TType)
    val destByrefTy : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val ( |ByrefTy|_| ) :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType option
    val destNativePtrTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val isRefCellTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val destRefCellTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val StripSelfRefCell :
      TcGlobals.TcGlobals * TypedTree.ValBaseOrThisInfo * TypedTree.TType ->
        TypedTree.TType
    val mkRefCellTy : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkLazyTy : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkPrintfFormatTy :
      TcGlobals.TcGlobals ->
        TypedTree.TType ->
          TypedTree.TType ->
            TypedTree.TType ->
              TypedTree.TType -> TypedTree.TType -> TypedTree.TType
    val mkOptionTy : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkNullableTy : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkListTy : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val isOptionTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val tryDestOptionTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType voption
    val destOptionTy : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val isNullableTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val tryDestNullableTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType voption
    val destNullableTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val ( |NullableTy|_| ) :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType option
    val ( |StripNullableTy| ) :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val isLinqExpressionTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val tryDestLinqExpressionTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType option
    val destLinqExpressionTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkNoneCase : TcGlobals.TcGlobals -> TypedTree.UnionCaseRef
    val mkSomeCase : TcGlobals.TcGlobals -> TypedTree.UnionCaseRef
    val mkSome :
      TcGlobals.TcGlobals ->
        TypedTree.TType -> TypedTree.Expr -> Range.range -> TypedTree.Expr
    val mkNone :
      TcGlobals.TcGlobals -> TypedTree.TType -> Range.range -> TypedTree.Expr
    val mkOptionGetValueUnprovenViaAddr :
      TcGlobals.TcGlobals ->
        TypedTree.Expr -> TypedTree.TType -> Range.range -> TypedTree.Expr
    type ValRef with
      member IsDispatchSlot : bool
    val ( |UnopExpr|_| ) :
      _g:'a -> expr:TypedTree.Expr -> (TypedTree.ValRef * TypedTree.Expr) option
    val ( |BinopExpr|_| ) :
      _g:'a ->
        expr:TypedTree.Expr ->
          (TypedTree.ValRef * TypedTree.Expr * TypedTree.Expr) option
    val ( |SpecificUnopExpr|_| ) :
      g:TcGlobals.TcGlobals ->
        vrefReqd:TypedTree.ValRef ->
          expr:TypedTree.Expr -> TypedTree.Expr option
    val ( |SpecificBinopExpr|_| ) :
      g:TcGlobals.TcGlobals ->
        vrefReqd:TypedTree.ValRef ->
          expr:TypedTree.Expr -> (TypedTree.Expr * TypedTree.Expr) option
    val ( |EnumExpr|_| ) :
      TcGlobals.TcGlobals -> TypedTree.Expr -> TypedTree.Expr option
    val ( |BitwiseOrExpr|_| ) :
      g:TcGlobals.TcGlobals ->
        expr:TypedTree.Expr -> (TypedTree.Expr * TypedTree.Expr) option
    val ( |AttribBitwiseOrExpr|_| ) :
      TcGlobals.TcGlobals ->
        TypedTree.Expr -> (TypedTree.Expr * TypedTree.Expr) option
    val isUncheckedDefaultOfValRef :
      g:TcGlobals.TcGlobals -> vref:TypedTree.ValRef -> bool
    val isTypeOfValRef : g:TcGlobals.TcGlobals -> vref:TypedTree.ValRef -> bool
    val isSizeOfValRef : g:TcGlobals.TcGlobals -> vref:TypedTree.ValRef -> bool
    val isNameOfValRef : TcGlobals.TcGlobals -> TypedTree.ValRef -> bool
    val isTypeDefOfValRef :
      g:TcGlobals.TcGlobals -> vref:TypedTree.ValRef -> bool
    val ( |UncheckedDefaultOfExpr|_| ) :
      g:TcGlobals.TcGlobals -> expr:TypedTree.Expr -> TypedTree.TType option
    val ( |TypeOfExpr|_| ) :
      TcGlobals.TcGlobals -> TypedTree.Expr -> TypedTree.TType option
    val ( |SizeOfExpr|_| ) :
      g:TcGlobals.TcGlobals -> expr:TypedTree.Expr -> TypedTree.TType option
    val ( |TypeDefOfExpr|_| ) :
      TcGlobals.TcGlobals -> TypedTree.Expr -> TypedTree.TType option
    val ( |NameOfExpr|_| ) :
      TcGlobals.TcGlobals -> TypedTree.Expr -> TypedTree.TType option
    val ( |SeqExpr|_| ) : TcGlobals.TcGlobals -> TypedTree.Expr -> unit option
    module DebugPrint = begin
      val layoutRanges : bool ref
      val squareAngleL :
        x:Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
      val angleL :
        x:Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
      val braceL :
        x:Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
      val braceBarL :
        x:Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
      val boolL : _arg1:bool -> Internal.Utilities.StructuredFormat.Layout
      val intL : int -> Internal.Utilities.StructuredFormat.Layout
      val int64L : n:int64 -> Internal.Utilities.StructuredFormat.Layout
      val jlistL :
        xL:('a -> Internal.Utilities.StructuredFormat.Layout) ->
          xmap:Internal.Utilities.QueueList<'a> ->
            Internal.Utilities.StructuredFormat.Layout
      val bracketIfL :
        x:bool ->
          lyt:Internal.Utilities.StructuredFormat.Layout ->
            Internal.Utilities.StructuredFormat.Layout
      val lvalopL :
        x:TypedTree.LValueOperation ->
          Internal.Utilities.StructuredFormat.Layout
      val angleBracketL :
        l:Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
      val angleBracketListL :
        l:Internal.Utilities.StructuredFormat.Layout list ->
          Internal.Utilities.StructuredFormat.Layout
      val layoutMemberFlags :
        memFlags:SyntaxTree.MemberFlags ->
          Internal.Utilities.StructuredFormat.Layout
      val stampL : _n:'a -> w:'b -> 'b
      val layoutTyconRef :
        tc:TypedTree.TyconRef -> Internal.Utilities.StructuredFormat.Layout
      val auxTypeL :
        env:SimplifyTypes.TypeSimplificationInfo ->
          ty:TypedTree.TType -> Internal.Utilities.StructuredFormat.Layout
      val auxTypeAtomL :
        env:SimplifyTypes.TypeSimplificationInfo ->
          ty:TypedTree.TType -> Internal.Utilities.StructuredFormat.Layout
      val auxTyparsL :
        env:SimplifyTypes.TypeSimplificationInfo ->
          tcL:Internal.Utilities.StructuredFormat.Layout ->
            prefix:bool ->
              tinst:TypedTree.TType list ->
                Internal.Utilities.StructuredFormat.Layout
      val auxTypeWrapL :
        env:SimplifyTypes.TypeSimplificationInfo ->
          isAtomic:bool ->
            ty:TypedTree.TType -> Internal.Utilities.StructuredFormat.Layout
      val auxTyparWrapL :
        env:SimplifyTypes.TypeSimplificationInfo ->
          isAtomic:bool ->
            typar:TypedTree.Typar -> Internal.Utilities.StructuredFormat.Layout
      val auxTypar2L :
        env:SimplifyTypes.TypeSimplificationInfo ->
          typar:TypedTree.Typar -> Internal.Utilities.StructuredFormat.Layout
      val auxTyparAtomL :
        env:SimplifyTypes.TypeSimplificationInfo ->
          typar:TypedTree.Typar -> Internal.Utilities.StructuredFormat.Layout
      val auxTyparConstraintTypL :
        env:SimplifyTypes.TypeSimplificationInfo ->
          ty:TypedTree.TType -> Internal.Utilities.StructuredFormat.Layout
      val auxTraitL :
        env:SimplifyTypes.TypeSimplificationInfo ->
          ttrait:TypedTree.TraitConstraintInfo ->
            Internal.Utilities.StructuredFormat.Layout
      val auxTyparConstraintL :
        env:SimplifyTypes.TypeSimplificationInfo ->
          tp:TypedTree.Typar * tpc:TypedTree.TyparConstraint ->
            Internal.Utilities.StructuredFormat.Layout
      val auxTyparConstraintsL :
        env:SimplifyTypes.TypeSimplificationInfo ->
          x:(TypedTree.Typar * TypedTree.TyparConstraint) list ->
            Internal.Utilities.StructuredFormat.Layout
      val typarL : TypedTree.Typar -> Internal.Utilities.StructuredFormat.Layout
      val typarAtomL :
        tp:TypedTree.Typar -> Internal.Utilities.StructuredFormat.Layout
      val typeAtomL :
        tau:TypedTree.TType -> Internal.Utilities.StructuredFormat.Layout
      val typeL : TypedTree.TType -> Internal.Utilities.StructuredFormat.Layout
      val typarDeclL :
        TypedTree.Typar -> Internal.Utilities.StructuredFormat.Layout
      val layoutTyparDecls :
        tps:TypedTree.Typars -> Internal.Utilities.StructuredFormat.Layout
      val rangeL : m:Range.range -> Internal.Utilities.StructuredFormat.Layout
      val instL :
        tyL:('a -> Internal.Utilities.StructuredFormat.Layout) ->
          tys:'a list -> Internal.Utilities.StructuredFormat.Layout
      val valRefL :
        TypedTree.ValRef -> Internal.Utilities.StructuredFormat.Layout
      val layoutAttrib :
        TypedTree.Attrib -> Internal.Utilities.StructuredFormat.Layout
      val layoutAttribs :
        attribs:TypedTree.Attrib list ->
          Internal.Utilities.StructuredFormat.Layout
      val arityInfoL :
        TypedTree.ValReprInfo -> Internal.Utilities.StructuredFormat.Layout
      val valL : TypedTree.Val -> Internal.Utilities.StructuredFormat.Layout
      val typeOfValL :
        TypedTree.Val -> Internal.Utilities.StructuredFormat.Layout
      val tslotparamL :
        TypedTree.SlotParam -> Internal.Utilities.StructuredFormat.Layout
      val slotSigL :
        TypedTree.SlotSig -> Internal.Utilities.StructuredFormat.Layout
      val memberL :
        g:TcGlobals.TcGlobals ->
          v:TypedTree.Val ->
            membInfo:TypedTree.ValMemberInfo ->
              Internal.Utilities.StructuredFormat.Layout
      val valAtBindL :
        TcGlobals.TcGlobals ->
          TypedTree.Val -> Internal.Utilities.StructuredFormat.Layout
      val unionCaseRefL :
        TypedTree.UnionCaseRef -> Internal.Utilities.StructuredFormat.Layout
      val recdFieldRefL :
        TypedTree.RecdFieldRef -> Internal.Utilities.StructuredFormat.Layout
      val identL :
        id:SyntaxTree.Ident -> Internal.Utilities.StructuredFormat.Layout
      val constL :
        c:TypedTree.Const -> Internal.Utilities.StructuredFormat.Layout
      val tyconL :
        TcGlobals.TcGlobals ->
          TypedTree.Tycon -> Internal.Utilities.StructuredFormat.Layout
      val bindingL :
        TcGlobals.TcGlobals ->
          TypedTree.Binding -> Internal.Utilities.StructuredFormat.Layout
      val exprL :
        TcGlobals.TcGlobals ->
          TypedTree.Expr -> Internal.Utilities.StructuredFormat.Layout
      val atomL :
        g:TcGlobals.TcGlobals ->
          expr:TypedTree.Expr -> Internal.Utilities.StructuredFormat.Layout
      val letRecL :
        g:TcGlobals.TcGlobals ->
          binds:TypedTree.Binding list ->
            bodyL:Internal.Utilities.StructuredFormat.Layout ->
              Internal.Utilities.StructuredFormat.Layout
      val letL :
        g:TcGlobals.TcGlobals ->
          bind:TypedTree.Binding ->
            bodyL:Internal.Utilities.StructuredFormat.Layout ->
              Internal.Utilities.StructuredFormat.Layout
      val exprWrapL :
        g:TcGlobals.TcGlobals ->
          isAtomic:bool ->
            expr:TypedTree.Expr -> Internal.Utilities.StructuredFormat.Layout
      val implFilesL :
        TcGlobals.TcGlobals ->
          TypedTree.TypedImplFile list ->
            Internal.Utilities.StructuredFormat.Layout
      val appL :
        g:TcGlobals.TcGlobals ->
          flayout:Internal.Utilities.StructuredFormat.Layout ->
            tys:TypedTree.TypeInst ->
              args:TypedTree.Exprs -> Internal.Utilities.StructuredFormat.Layout
      val implFileL :
        TcGlobals.TcGlobals ->
          TypedTree.TypedImplFile -> Internal.Utilities.StructuredFormat.Layout
      val mexprL :
        g:TcGlobals.TcGlobals ->
          x:TypedTree.ModuleOrNamespaceExprWithSig ->
            Internal.Utilities.StructuredFormat.Layout
      val mdefsL :
        g:TcGlobals.TcGlobals ->
          defs:TypedTree.ModuleOrNamespaceExpr list ->
            Internal.Utilities.StructuredFormat.Layout
      val mdefL :
        g:TcGlobals.TcGlobals ->
          x:TypedTree.ModuleOrNamespaceExpr ->
            Internal.Utilities.StructuredFormat.Layout
      val mbindL :
        g:TcGlobals.TcGlobals ->
          x:TypedTree.ModuleOrNamespaceBinding ->
            Internal.Utilities.StructuredFormat.Layout
      val entityTypeL :
        TcGlobals.TcGlobals ->
          TypedTree.ModuleOrNamespaceType ->
            Internal.Utilities.StructuredFormat.Layout
      val entityL :
        TcGlobals.TcGlobals ->
          TypedTree.ModuleOrNamespace ->
            Internal.Utilities.StructuredFormat.Layout
      val ccuL :
        g:TcGlobals.TcGlobals ->
          ccu:TypedTree.CcuThunk -> Internal.Utilities.StructuredFormat.Layout
      val decisionTreeL :
        TcGlobals.TcGlobals ->
          TypedTree.DecisionTree -> Internal.Utilities.StructuredFormat.Layout
      val dcaseL :
        g:TcGlobals.TcGlobals ->
          TypedTree.DecisionTreeCase ->
            Internal.Utilities.StructuredFormat.Layout
      val dtestL :
        g:TcGlobals.TcGlobals ->
          x:TypedTree.DecisionTreeTest ->
            Internal.Utilities.StructuredFormat.Layout
      val targetL :
        g:TcGlobals.TcGlobals ->
          i:int ->
            TypedTree.DecisionTreeTarget ->
              Internal.Utilities.StructuredFormat.Layout
      val flatValsL :
        vs:TypedTree.Val list -> Internal.Utilities.StructuredFormat.Layout list
      val tmethodL :
        g:TcGlobals.TcGlobals ->
          TypedTree.ObjExprMethod -> Internal.Utilities.StructuredFormat.Layout
      val iimplL :
        g:TcGlobals.TcGlobals ->
          ty:TypedTree.TType * tmeths:TypedTree.ObjExprMethod list ->
            Internal.Utilities.StructuredFormat.Layout
      val showType : TypedTree.TType -> string
      val showExpr : TcGlobals.TcGlobals -> TypedTree.Expr -> string
      val traitL :
        TypedTree.TraitConstraintInfo ->
          Internal.Utilities.StructuredFormat.Layout
      val typarsL :
        TypedTree.Typars -> Internal.Utilities.StructuredFormat.Layout
    end
    val wrapModuleOrNamespaceType :
      SyntaxTree.Ident ->
        TypedTree.CompilationPath ->
          TypedTree.ModuleOrNamespaceType -> TypedTree.ModuleOrNamespace
    val wrapModuleOrNamespaceTypeInNamespace :
      SyntaxTree.Ident ->
        TypedTree.CompilationPath ->
          TypedTree.ModuleOrNamespaceType ->
            TypedTree.ModuleOrNamespaceType * TypedTree.ModuleOrNamespace
    val wrapModuleOrNamespaceExprInNamespace :
      SyntaxTree.Ident ->
        TypedTree.CompilationPath ->
          TypedTree.ModuleOrNamespaceExpr -> TypedTree.ModuleOrNamespaceExpr
    val SigTypeOfImplFile :
      TypedTree.TypedImplFile -> TypedTree.ModuleOrNamespaceType
    type SignatureRepackageInfo =
      { RepackagedVals: (TypedTree.ValRef * TypedTree.ValRef) list
        RepackagedEntities: (TypedTree.TyconRef * TypedTree.TyconRef) list }
      with
        member ImplToSigMapping : TypeEquivEnv
        static member Empty : SignatureRepackageInfo
      end
    type SignatureHidingInfo =
      { HiddenTycons: AbstractIL.Internal.Zset<TypedTree.Tycon>
        HiddenTyconReprs: AbstractIL.Internal.Zset<TypedTree.Tycon>
        HiddenVals: AbstractIL.Internal.Zset<TypedTree.Val>
        HiddenRecdFields: AbstractIL.Internal.Zset<TypedTree.RecdFieldRef>
        HiddenUnionCases: AbstractIL.Internal.Zset<TypedTree.UnionCaseRef> }
      with
        static member Empty : SignatureHidingInfo
      end
    val addValRemap : TypedTree.Val -> TypedTree.Val -> Remap -> Remap
    val mkRepackageRemapping : SignatureRepackageInfo -> Remap
    val accEntityRemap :
      msigty:TypedTree.ModuleOrNamespaceType ->
        entity:TypedTree.Entity ->
          mrpi:SignatureRepackageInfo * mhi:SignatureHidingInfo ->
            SignatureRepackageInfo * SignatureHidingInfo
    val accSubEntityRemap :
      msigty:TypedTree.ModuleOrNamespaceType ->
        entity:TypedTree.Entity ->
          mrpi:SignatureRepackageInfo * mhi:SignatureHidingInfo ->
            SignatureRepackageInfo * SignatureHidingInfo
    val valLinkageAEquiv :
      TcGlobals.TcGlobals ->
        TypeEquivEnv -> TypedTree.Val -> TypedTree.Val -> bool
    val accValRemap :
      g:TcGlobals.TcGlobals ->
        aenv:TypeEquivEnv ->
          msigty:TypedTree.ModuleOrNamespaceType ->
            implVal:TypedTree.Val ->
              mrpi:SignatureRepackageInfo * mhi:SignatureHidingInfo ->
                SignatureRepackageInfo * SignatureHidingInfo
    val getCorrespondingSigTy :
      nm:string ->
        msigty:TypedTree.ModuleOrNamespaceType ->
          TypedTree.ModuleOrNamespaceType
    val accEntityRemapFromModuleOrNamespaceType :
      mty:TypedTree.ModuleOrNamespaceType ->
        msigty:TypedTree.ModuleOrNamespaceType ->
          SignatureRepackageInfo * SignatureHidingInfo ->
            SignatureRepackageInfo * SignatureHidingInfo
    val accValRemapFromModuleOrNamespaceType :
      g:TcGlobals.TcGlobals ->
        aenv:TypeEquivEnv ->
          mty:TypedTree.ModuleOrNamespaceType ->
            msigty:TypedTree.ModuleOrNamespaceType ->
              SignatureRepackageInfo * SignatureHidingInfo ->
                SignatureRepackageInfo * SignatureHidingInfo
    val ComputeRemappingFromInferredSignatureToExplicitSignature :
      TcGlobals.TcGlobals ->
        TypedTree.ModuleOrNamespaceType ->
          TypedTree.ModuleOrNamespaceType ->
            SignatureRepackageInfo * SignatureHidingInfo
    val abstractSlotValRefsOfTycons :
      TypedTree.Tycon list -> TypedTree.ValRef list
    val abstractSlotValsOfTycons : TypedTree.Tycon list -> TypedTree.Val list
    val accEntityRemapFromModuleOrNamespace :
      msigty:TypedTree.ModuleOrNamespaceType ->
        x:TypedTree.ModuleOrNamespaceExpr ->
          SignatureRepackageInfo * SignatureHidingInfo ->
            SignatureRepackageInfo * SignatureHidingInfo
    val accEntityRemapFromModuleOrNamespaceDefs :
      msigty:TypedTree.ModuleOrNamespaceType ->
        mdefs:TypedTree.ModuleOrNamespaceExpr list ->
          SignatureRepackageInfo * SignatureHidingInfo ->
            SignatureRepackageInfo * SignatureHidingInfo
    val accEntityRemapFromModuleOrNamespaceBind :
      msigty:TypedTree.ModuleOrNamespaceType ->
        x:TypedTree.ModuleOrNamespaceBinding ->
          SignatureRepackageInfo * SignatureHidingInfo ->
            SignatureRepackageInfo * SignatureHidingInfo
    val accValRemapFromModuleOrNamespace :
      g:TcGlobals.TcGlobals ->
        aenv:TypeEquivEnv ->
          msigty:TypedTree.ModuleOrNamespaceType ->
            x:TypedTree.ModuleOrNamespaceExpr ->
              SignatureRepackageInfo * SignatureHidingInfo ->
                SignatureRepackageInfo * SignatureHidingInfo
    val accValRemapFromModuleOrNamespaceBind :
      g:TcGlobals.TcGlobals ->
        aenv:TypeEquivEnv ->
          msigty:TypedTree.ModuleOrNamespaceType ->
            x:TypedTree.ModuleOrNamespaceBinding ->
              SignatureRepackageInfo * SignatureHidingInfo ->
                SignatureRepackageInfo * SignatureHidingInfo
    val accValRemapFromModuleOrNamespaceDefs :
      g:TcGlobals.TcGlobals ->
        aenv:TypeEquivEnv ->
          msigty:TypedTree.ModuleOrNamespaceType ->
            mdefs:TypedTree.ModuleOrNamespaceExpr list ->
              SignatureRepackageInfo * SignatureHidingInfo ->
                SignatureRepackageInfo * SignatureHidingInfo
    val ComputeRemappingFromImplementationToSignature :
      TcGlobals.TcGlobals ->
        TypedTree.ModuleOrNamespaceExpr ->
          TypedTree.ModuleOrNamespaceType ->
            SignatureRepackageInfo * SignatureHidingInfo
    val accTyconHidingInfoAtAssemblyBoundary :
      tycon:TypedTree.Tycon -> mhi:SignatureHidingInfo -> SignatureHidingInfo
    val accValHidingInfoAtAssemblyBoundary :
      vspec:TypedTree.Val -> mhi:SignatureHidingInfo -> SignatureHidingInfo
    val accModuleOrNamespaceHidingInfoAtAssemblyBoundary :
      mty:TypedTree.ModuleOrNamespaceType ->
        acc:SignatureHidingInfo -> SignatureHidingInfo
    val ComputeHidingInfoAtAssemblyBoundary :
      TypedTree.ModuleOrNamespaceType ->
        SignatureHidingInfo -> SignatureHidingInfo
    val IsHidden :
      setF:('a -> AbstractIL.Internal.Zset<'b>) ->
        accessF:('b -> TypedTree.Accessibility) ->
          remapF:('c -> 'b -> 'b) -> (('c * 'a) list -> 'b -> bool)
    val IsHiddenTycon :
      (Remap * SignatureHidingInfo) list -> TypedTree.Tycon -> bool
    val IsHiddenTyconRepr :
      (Remap * SignatureHidingInfo) list -> TypedTree.Tycon -> bool
    val IsHiddenVal :
      (Remap * SignatureHidingInfo) list -> TypedTree.Val -> bool
    val IsHiddenRecdField :
      (Remap * SignatureHidingInfo) list -> TypedTree.RecdFieldRef -> bool
    val foldModuleOrNamespaceTy :
      ft:(TypedTree.Entity -> 'a -> 'a) ->
        fv:(TypedTree.Val -> 'a -> 'a) ->
          mty:TypedTree.ModuleOrNamespaceType -> acc:'a -> 'a
    val allValsOfModuleOrNamespaceTy :
      m:TypedTree.ModuleOrNamespaceType -> TypedTree.Val list
    val allEntitiesOfModuleOrNamespaceTy :
      m:TypedTree.ModuleOrNamespaceType -> TypedTree.Entity list
    val isPublicVal : lv:TypedTree.Val -> bool
    val isPublicUnionCase : ucr:TypedTree.UnionCaseRef -> bool
    val isPublicRecdField : rfr:TypedTree.RecdFieldRef -> bool
    val isPublicTycon : tcref:TypedTree.Tycon -> bool
    val freeVarsAllPublic : TypedTree.FreeVars -> bool
    val freeTyvarsAllPublic : TypedTree.FreeTyvars -> bool
    val ( |LinearMatchExpr|_| ) :
      TypedTree.Expr ->
        (SyntaxTree.DebugPointForBinding * Range.range * TypedTree.DecisionTree *
         TypedTree.DecisionTreeTarget * TypedTree.Expr *
         SyntaxTree.DebugPointForTarget * Range.range * TypedTree.TType) option
    val rebuildLinearMatchExpr :
      (SyntaxTree.DebugPointForBinding * Range.range * TypedTree.DecisionTree *
       TypedTree.DecisionTreeTarget * TypedTree.Expr *
       SyntaxTree.DebugPointForTarget * Range.range * TypedTree.TType) ->
        TypedTree.Expr
    val ( |LinearOpExpr|_| ) :
      TypedTree.Expr ->
        (TypedTree.TOp * TypedTree.TypeInst * TypedTree.Expr list *
         TypedTree.Expr * Range.range) option
    val rebuildLinearOpExpr :
      (TypedTree.TOp * TypedTree.TypeInst * TypedTree.Expr list * TypedTree.Expr *
       Range.range) -> TypedTree.Expr
    val emptyFreeVars : TypedTree.FreeVars
    val unionFreeVars :
      TypedTree.FreeVars -> TypedTree.FreeVars -> TypedTree.FreeVars
    val inline accFreeTyvars :
      opts:FreeVarOptions ->
        f:(FreeVarOptions -> 'a -> TypedTree.FreeTyvars -> TypedTree.FreeTyvars) ->
          v:'a -> acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeVarsInTy :
      opts:FreeVarOptions ->
        ty:TypedTree.TType -> acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeVarsInTys :
      opts:FreeVarOptions ->
        tys:TypedTree.TType list -> acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreevarsInTycon :
      opts:FreeVarOptions ->
        tcref:TypedTree.TyconRef -> acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreevarsInVal :
      opts:FreeVarOptions ->
        v:TypedTree.Val -> acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeVarsInTraitSln :
      opts:FreeVarOptions ->
        tys:TypedTree.TraitConstraintSln ->
          acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeVarsInTraitInfo :
      opts:FreeVarOptions ->
        tys:TypedTree.TraitConstraintInfo ->
          acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val boundLocalVal :
      opts:FreeVarOptions ->
        v:TypedTree.Val -> fvs:TypedTree.FreeVars -> TypedTree.FreeVars
    val boundProtect : fvs:TypedTree.FreeVars -> TypedTree.FreeVars
    val accUsesFunctionLocalConstructs :
      flg:bool -> fvs:TypedTree.FreeVars -> TypedTree.FreeVars
    val bound_rethrow : fvs:TypedTree.FreeVars -> TypedTree.FreeVars
    val accUsesRethrow :
      flg:bool -> fvs:TypedTree.FreeVars -> TypedTree.FreeVars
    val boundLocalVals :
      opts:FreeVarOptions ->
        vs:TypedTree.Val list -> fvs:TypedTree.FreeVars -> TypedTree.FreeVars
    val bindLhs :
      opts:FreeVarOptions ->
        bind:TypedTree.Binding -> fvs:TypedTree.FreeVars -> TypedTree.FreeVars
    val freeVarsCacheCompute :
      opts:FreeVarOptions -> cache:Lib.cache<'a> -> f:(unit -> 'a) -> 'a
    val tryGetFreeVarsCacheValue :
      opts:FreeVarOptions -> cache:Lib.cache<'a> -> Lib.NonNullSlot<'a> voption
    val accBindRhs :
      opts:FreeVarOptions ->
        TypedTree.Binding -> acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInSwitchCases :
      FreeVarOptions ->
        TypedTree.DecisionTreeCase list ->
          TypedTree.DecisionTree option ->
            TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInSwitchCase :
      opts:FreeVarOptions ->
        TypedTree.DecisionTreeCase ->
          acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInTest :
      opts:FreeVarOptions ->
        discrim:TypedTree.DecisionTreeTest ->
          acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInDecisionTree :
      FreeVarOptions ->
        TypedTree.DecisionTree -> TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInValFlags :
      opts:FreeVarOptions ->
        flag:TypedTree.ValUseFlag ->
          acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeLocalVal :
      opts:FreeVarOptions ->
        v:TypedTree.Val -> fvs:TypedTree.FreeVars -> TypedTree.FreeVars
    val accLocalTyconRepr :
      opts:FreeVarOptions ->
        b:TypedTree.Tycon -> fvs:TypedTree.FreeVars -> TypedTree.FreeVars
    val accUsedRecdOrUnionTyconRepr :
      opts:FreeVarOptions ->
        tc:TypedTree.Tycon -> fvs:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeUnionCaseRef :
      opts:FreeVarOptions ->
        ucref:TypedTree.UnionCaseRef ->
          fvs:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeRecdFieldRef :
      opts:FreeVarOptions ->
        rfref:TypedTree.RecdFieldRef ->
          fvs:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeExnRef : _exnc:'a -> fvs:'b -> 'b
    val accFreeValRef :
      opts:FreeVarOptions ->
        vref:TypedTree.ValRef -> fvs:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInMethod :
      opts:FreeVarOptions ->
        TypedTree.ObjExprMethod -> acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInMethods :
      opts:FreeVarOptions ->
        methods:TypedTree.ObjExprMethod list ->
          acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInInterfaceImpl :
      opts:FreeVarOptions ->
        ty:TypedTree.TType * overrides:TypedTree.ObjExprMethod list ->
          acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInExpr :
      opts:FreeVarOptions ->
        x:TypedTree.Expr -> acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInExprLinear :
      opts:FreeVarOptions ->
        x:TypedTree.Expr ->
          acc:TypedTree.FreeVars ->
            contf:(TypedTree.FreeVars -> TypedTree.FreeVars) ->
              TypedTree.FreeVars
    val accFreeInExprNonLinear :
      opts:FreeVarOptions ->
        x:TypedTree.Expr -> acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInOp :
      opts:FreeVarOptions ->
        op:TypedTree.TOp -> acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInTargets :
      FreeVarOptions ->
        TypedTree.DecisionTreeTarget array ->
          TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInTarget :
      opts:FreeVarOptions ->
        TypedTree.DecisionTreeTarget ->
          acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInFlatExprs :
      opts:FreeVarOptions ->
        exprs:TypedTree.Exprs -> acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInExprs :
      FreeVarOptions ->
        TypedTree.Exprs -> TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInSlotSig :
      opts:FreeVarOptions ->
        TypedTree.SlotSig -> acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val freeInDecisionTree :
      opts:FreeVarOptions -> dtree:TypedTree.DecisionTree -> TypedTree.FreeVars
    val freeInExpr : FreeVarOptions -> TypedTree.Expr -> TypedTree.FreeVars
    val accFreeInModuleOrNamespace :
      opts:FreeVarOptions ->
        mexpr:TypedTree.ModuleOrNamespaceExpr ->
          acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInModuleOrNamespaceBind :
      opts:FreeVarOptions ->
        mbind:TypedTree.ModuleOrNamespaceBinding ->
          acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val accFreeInModuleOrNamespaces :
      opts:FreeVarOptions ->
        mexprs:TypedTree.ModuleOrNamespaceExpr list ->
          acc:TypedTree.FreeVars -> TypedTree.FreeVars
    val freeInBindingRhs :
      FreeVarOptions -> TypedTree.Binding -> TypedTree.FreeVars
    val freeInModuleOrNamespace :
      FreeVarOptions -> TypedTree.ModuleOrNamespaceExpr -> TypedTree.FreeVars
    val stripLambda :
      expr:TypedTree.Expr * ty:TypedTree.TType ->
        TypedTree.Val list list * TypedTree.Expr * TypedTree.TType
    val stripLambdaN :
      n:int ->
        expr:TypedTree.Expr -> TypedTree.Val list list * TypedTree.Expr * int
    val tryStripLambdaN :
      n:int ->
        expr:TypedTree.Expr -> (TypedTree.Val list list * TypedTree.Expr) option
    val stripTopLambda :
      TypedTree.Expr * TypedTree.TType ->
        TypedTree.Typars * TypedTree.Val list list * TypedTree.Expr *
        TypedTree.TType
    [<RequireQualifiedAccessAttribute ()>]
    type AllowTypeDirectedDetupling =
      | Yes
      | No
    val InferArityOfExpr :
      TcGlobals.TcGlobals ->
        AllowTypeDirectedDetupling ->
          TypedTree.TType ->
            TypedTree.Attrib list list list ->
              TypedTree.Attribs -> TypedTree.Expr -> TypedTree.ValReprInfo
    val InferArityOfExprBinding :
      TcGlobals.TcGlobals ->
        AllowTypeDirectedDetupling ->
          TypedTree.Val -> TypedTree.Expr -> TypedTree.ValReprInfo
    val underlyingTypeOfEnumTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val setValHasNoArity : TypedTree.Val -> TypedTree.Val
    val normalizeEnumTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    type StaticOptimizationAnswer =
      | Yes = 1y
      | No = -1y
      | Unknown = 0y
    val decideStaticOptimizationConstraint :
      g:TcGlobals.TcGlobals ->
        c:TypedTree.StaticOptimization ->
          haveWitnesses:bool -> StaticOptimizationAnswer
    val DecideStaticOptimizations :
      TcGlobals.TcGlobals ->
        TypedTree.StaticOptimization list ->
          haveWitnesses:bool -> StaticOptimizationAnswer
    val mkStaticOptimizationExpr :
      TcGlobals.TcGlobals ->
        TypedTree.StaticOptimization list * TypedTree.Expr * TypedTree.Expr *
        Range.range -> TypedTree.Expr
    type ValCopyFlag =
      | CloneAll
      | CloneAllAndMarkExprValsAsCompilerGenerated
      | OnlyCloneExprVals
    val fixValCopyFlagForQuotations : _arg1:ValCopyFlag -> ValCopyFlag
    val markAsCompGen : compgen:ValCopyFlag -> d:TypedTree.Val -> TypedTree.Val
    val bindLocalVal :
      v:TypedTree.Val -> v':TypedTree.Val -> tmenv:Remap -> Remap
    val bindLocalVals :
      vs:TypedTree.Val list -> vs':TypedTree.Val list -> tmenv:Remap -> Remap
    val bindTycon :
      tc:TypedTree.Tycon -> tc':TypedTree.Tycon -> tyenv:Remap -> Remap
    val bindTycons :
      tcs:Lib.NonNullSlot<TypedTree.Entity> list ->
        tcs':Lib.NonNullSlot<TypedTree.Entity> list -> tyenv:Remap -> Remap
    val remapAttribKind :
      tmenv:Remap -> k:TypedTree.AttribKind -> TypedTree.AttribKind
    val tmenvCopyRemapAndBindTypars :
      remapAttrib:(TypedTree.Attribs -> TypedTree.Attrib list) ->
        tmenv:Remap -> tps:TypedTree.Typar list -> TypedTree.Typar list * Remap
    val remapAttrib :
      TcGlobals.TcGlobals -> Remap -> TypedTree.Attrib -> TypedTree.Attrib
    val remapAttribExpr :
      g:TcGlobals.TcGlobals ->
        tmenv:Remap -> TypedTree.AttribExpr -> TypedTree.AttribExpr
    val remapAttribs :
      g:TcGlobals.TcGlobals ->
        tmenv:Remap -> xs:TypedTree.Attrib list -> TypedTree.Attrib list
    val remapPossibleForallTy :
      TcGlobals.TcGlobals -> Remap -> TypedTree.TType -> TypedTree.TType
    val remapArgData :
      g:TcGlobals.TcGlobals ->
        tmenv:Remap -> argInfo:TypedTree.ArgReprInfo -> TypedTree.ArgReprInfo
    val remapValReprInfo :
      g:TcGlobals.TcGlobals ->
        tmenv:Remap -> TypedTree.ValReprInfo -> TypedTree.ValReprInfo
    val remapValData :
      g:TcGlobals.TcGlobals ->
        tmenv:Remap -> d:TypedTree.ValData -> TypedTree.ValData
    val remapParentRef :
      tyenv:Remap -> p:TypedTree.ParentRef -> TypedTree.ParentRef
    val mapImmediateValsAndTycons :
      ft:(TypedTree.Entity -> TypedTree.Entity) ->
        fv:(TypedTree.Val -> TypedTree.Val) ->
          x:TypedTree.ModuleOrNamespaceType -> TypedTree.ModuleOrNamespaceType
    val copyVal : compgen:ValCopyFlag -> v:TypedTree.Val -> TypedTree.Val
    val fixupValData :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag -> tmenv:Remap -> v2:TypedTree.Val -> unit
    val copyAndRemapAndBindVals :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap -> vs:TypedTree.Val list -> TypedTree.Val list * Remap
    val copyAndRemapAndBindVal :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap -> v:TypedTree.Val -> TypedTree.Val * Remap
    val remapExpr :
      TcGlobals.TcGlobals ->
        ValCopyFlag -> Remap -> TypedTree.Expr -> TypedTree.Expr
    val remapTarget :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap ->
            TypedTree.DecisionTreeTarget -> TypedTree.DecisionTreeTarget
    val remapLinearExpr :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap ->
            expr:TypedTree.Expr ->
              contf:(TypedTree.Expr -> TypedTree.Expr) -> TypedTree.Expr
    val remapConstraint :
      tyenv:Remap ->
        c:TypedTree.StaticOptimization -> TypedTree.StaticOptimization
    val remapOp : tmenv:Remap -> op:TypedTree.TOp -> TypedTree.TOp
    val remapValFlags :
      tmenv:Remap -> x:TypedTree.ValUseFlag -> TypedTree.ValUseFlag
    val remapExprs :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap -> es:TypedTree.Exprs -> TypedTree.Exprs
    val remapFlatExprs :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap -> es:TypedTree.Expr list -> TypedTree.Expr list
    val remapDecisionTree :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap -> x:TypedTree.DecisionTree -> TypedTree.DecisionTree
    val copyAndRemapAndBindBinding :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap -> bind:TypedTree.Binding -> TypedTree.Binding * Remap
    val copyAndRemapAndBindBindings :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap -> binds:TypedTree.Bindings -> TypedTree.Bindings * Remap
    val remapAndRenameBinds :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenvinner:Remap ->
            binds:TypedTree.Bindings ->
              vs':TypedTree.Val list -> TypedTree.Bindings
    val remapAndRenameBind :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenvinner:Remap ->
            TypedTree.Binding -> v':TypedTree.Val -> TypedTree.Binding
    val remapMethod :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap -> TypedTree.ObjExprMethod -> TypedTree.ObjExprMethod
    val remapInterfaceImpl :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap ->
            ty:TypedTree.TType * overrides:TypedTree.ObjExprMethod list ->
              TypedTree.TType * TypedTree.ObjExprMethod list
    val remapRecdField :
      g:TcGlobals.TcGlobals ->
        tmenv:Remap -> x:TypedTree.RecdField -> TypedTree.RecdField
    val remapRecdFields :
      g:TcGlobals.TcGlobals ->
        tmenv:Remap -> x:TypedTree.TyconRecdFields -> TypedTree.TyconRecdFields
    val remapUnionCase :
      g:TcGlobals.TcGlobals ->
        tmenv:Remap -> x:TypedTree.UnionCase -> TypedTree.UnionCase
    val remapUnionCases :
      g:TcGlobals.TcGlobals ->
        tmenv:Remap -> x:TypedTree.TyconUnionData -> TypedTree.TyconUnionData
    val remapFsObjData :
      g:TcGlobals.TcGlobals ->
        tmenv:Remap ->
          x:TypedTree.TyconObjModelData -> TypedTree.TyconObjModelData
    val remapTyconRepr :
      g:TcGlobals.TcGlobals ->
        tmenv:Remap ->
          repr:TypedTree.TyconRepresentation -> TypedTree.TyconRepresentation
    val remapTyconAug :
      tmenv:Remap ->
        x:TypedTree.TyconAugmentation -> TypedTree.TyconAugmentation
    val remapTyconExnInfo :
      g:TcGlobals.TcGlobals ->
        tmenv:Remap -> inp:TypedTree.ExceptionInfo -> TypedTree.ExceptionInfo
    val remapMemberInfo :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          topValInfo:TypedTree.ValReprInfo option ->
            ty:TypedTree.TType ->
              ty':TypedTree.TType ->
                tmenv:Remap ->
                  x:TypedTree.ValMemberInfo -> TypedTree.ValMemberInfo
    val copyAndRemapAndBindModTy :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap ->
            mty:TypedTree.ModuleOrNamespaceType ->
              TypedTree.ModuleOrNamespaceType * Remap
    val remapModTy :
      g:TcGlobals.TcGlobals ->
        _compgen:ValCopyFlag ->
          tmenv:Remap ->
            mty:TypedTree.ModuleOrNamespaceType ->
              TypedTree.ModuleOrNamespaceType
    val renameTycon :
      g:TcGlobals.TcGlobals ->
        tyenv:Remap -> x:TypedTree.Entity -> TypedTree.Entity
    val renameVal : tmenv:Remap -> x:TypedTree.Val -> TypedTree.Val
    val copyTycon :
      compgen:ValCopyFlag -> tycon:TypedTree.Tycon -> TypedTree.Tycon
    val copyAndRemapAndBindTyconsAndVals :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap ->
            tycons:TypedTree.Entity list ->
              vs:TypedTree.Val list ->
                TypedTree.Tycon list * TypedTree.Val list * Remap
    val allTyconsOfTycon : tycon:TypedTree.Tycon -> seq<TypedTree.Tycon>
    val allEntitiesOfModDef :
      mdef:TypedTree.ModuleOrNamespaceExpr -> seq<TypedTree.Tycon>
    val allValsOfModDef : TypedTree.ModuleOrNamespaceExpr -> seq<TypedTree.Val>
    val remapAndBindModuleOrNamespaceExprWithSig :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap ->
            TypedTree.ModuleOrNamespaceExprWithSig ->
              TypedTree.ModuleOrNamespaceExprWithSig * Remap
    val remapModuleOrNamespaceExprWithSig :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap ->
            TypedTree.ModuleOrNamespaceExprWithSig ->
              TypedTree.ModuleOrNamespaceExprWithSig
    val copyAndRemapModDef :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap ->
            mdef:TypedTree.ModuleOrNamespaceExpr ->
              TypedTree.ModuleOrNamespaceExpr
    val remapAndRenameModDefs :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap ->
            x:TypedTree.ModuleOrNamespaceExpr list ->
              TypedTree.ModuleOrNamespaceExpr list
    val remapAndRenameModDef :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap ->
            mdef:TypedTree.ModuleOrNamespaceExpr ->
              TypedTree.ModuleOrNamespaceExpr
    val remapAndRenameModBind :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap ->
            x:TypedTree.ModuleOrNamespaceBinding ->
              TypedTree.ModuleOrNamespaceBinding
    val remapImplFile :
      g:TcGlobals.TcGlobals ->
        compgen:ValCopyFlag ->
          tmenv:Remap ->
            mv:TypedTree.TypedImplFile -> TypedTree.TypedImplFile * Remap
    val copyModuleOrNamespaceType :
      TcGlobals.TcGlobals ->
        ValCopyFlag ->
          TypedTree.ModuleOrNamespaceType -> TypedTree.ModuleOrNamespaceType
    val copyExpr :
      TcGlobals.TcGlobals -> ValCopyFlag -> TypedTree.Expr -> TypedTree.Expr
    val copyImplFile :
      TcGlobals.TcGlobals ->
        ValCopyFlag -> TypedTree.TypedImplFile -> TypedTree.TypedImplFile
    val instExpr :
      TcGlobals.TcGlobals -> TyparInst -> TypedTree.Expr -> TypedTree.Expr
    val remarkExpr : Range.range -> TypedTree.Expr -> TypedTree.Expr
    val remarkObjExprMethod :
      m:Range.range -> TypedTree.ObjExprMethod -> TypedTree.ObjExprMethod
    val remarkInterfaceImpl :
      m:Range.range ->
        ty:TypedTree.TType * overrides:TypedTree.ObjExprMethod list ->
          TypedTree.TType * TypedTree.ObjExprMethod list
    val remarkExprs : m:Range.range -> es:TypedTree.Exprs -> TypedTree.Exprs
    val remarkFlatExprs :
      m:Range.range -> es:TypedTree.Expr list -> TypedTree.Expr list
    val remarkDecisionTree :
      m:Range.range -> x:TypedTree.DecisionTree -> TypedTree.DecisionTree
    val remarkBinds :
      m:Range.range -> binds:TypedTree.Bindings -> TypedTree.Bindings
    val remarkBind : m:Range.range -> TypedTree.Binding -> TypedTree.Binding
    val isRecdOrStructFieldDefinitelyMutable : f:TypedTree.RecdField -> bool
    val isUnionCaseDefinitelyMutable : uc:TypedTree.UnionCase -> bool
    val isUnionCaseRefDefinitelyMutable : TypedTree.UnionCaseRef -> bool
    val isRecdOrUnionOrStructTyconRefDefinitelyMutable :
      TypedTree.TyconRef -> bool
    val isExnDefinitelyMutable : TypedTree.TyconRef -> bool
    val isUnionCaseFieldMutable :
      TcGlobals.TcGlobals -> TypedTree.UnionCaseRef -> int -> bool
    val isExnFieldMutable : TypedTree.TyconRef -> int -> bool
    val useGenuineField : TypedTree.Tycon -> TypedTree.RecdField -> bool
    val ComputeFieldName : TypedTree.Tycon -> TypedTree.RecdField -> string
    val isQuotedExprTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val destQuotedExprTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkQuotedExprTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkRawQuotedExprTy : TcGlobals.TcGlobals -> TypedTree.TType
    val mkAnyTupledTy :
      TcGlobals.TcGlobals ->
        TypedTree.TupInfo -> TypedTree.TType list -> TypedTree.TType
    val mkAnyAnonRecdTy :
      TcGlobals.TcGlobals ->
        TypedTree.AnonRecdTypeInfo -> TypedTree.TType list -> TypedTree.TType
    val mkRefTupledTy :
      TcGlobals.TcGlobals -> TypedTree.TType list -> TypedTree.TType
    val mkRefTupledVarsTy :
      TcGlobals.TcGlobals -> TypedTree.Val list -> TypedTree.TType
    val mkMethodTy :
      TcGlobals.TcGlobals ->
        TypedTree.TType list list -> TypedTree.TType -> TypedTree.TType
    val mkArrayType : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkByteArrayTy : TcGlobals.TcGlobals -> TypedTree.TType
    val GenWitnessArgTys :
      TcGlobals.TcGlobals ->
        TypedTree.TraitWitnessInfo -> TypedTree.TType list list
    val GenWitnessTy :
      TcGlobals.TcGlobals -> TypedTree.TraitWitnessInfo -> TypedTree.TType
    val GenWitnessTys :
      TcGlobals.TcGlobals -> TraitWitnessInfos -> TypedTree.TType list
    val tyOfExpr : TcGlobals.TcGlobals -> TypedTree.Expr -> TypedTree.TType
    val primMkApp :
      (TypedTree.Expr * TypedTree.TType) ->
        TypedTree.TypeInst -> TypedTree.Exprs -> Range.range -> TypedTree.Expr
    val isExpansiveUnderInstantiation :
      g:TcGlobals.TcGlobals ->
        fty0:TypedTree.TType ->
          tyargs:'a list -> pargs:'b list -> argsl:'c list -> bool
    val mkExprAppAux :
      g:TcGlobals.TcGlobals ->
        f:TypedTree.Expr ->
          fty:TypedTree.TType ->
            argsl:TypedTree.Expr list -> m:Range.range -> TypedTree.Expr
    val mkAppsAux :
      g:TcGlobals.TcGlobals ->
        f:TypedTree.Expr ->
          fty:TypedTree.TType ->
            tyargsl:TypedTree.TType list list ->
              argsl:TypedTree.Expr list -> m:Range.range -> TypedTree.Expr
    val mkApps :
      TcGlobals.TcGlobals ->
        (TypedTree.Expr * TypedTree.TType) * TypedTree.TType list list *
        TypedTree.Expr list * Range.range -> TypedTree.Expr
    val mkTyAppExpr :
      Range.range ->
        TypedTree.Expr * TypedTree.TType ->
          TypedTree.TType list -> TypedTree.Expr
    val accTargetsOfDecisionTree :
      TypedTree.DecisionTree -> int list -> int list
    val mapTargetsOfDecisionTree :
      f:(int -> int) -> tree:TypedTree.DecisionTree -> TypedTree.DecisionTree
    val mapTargetsOfDecisionTreeCase :
      f:(int -> int) -> TypedTree.DecisionTreeCase -> TypedTree.DecisionTreeCase
    val eliminateDeadTargetsFromMatch :
      tree:TypedTree.DecisionTree ->
        targets:'a [] -> TypedTree.DecisionTree * 'a []
    val targetOfSuccessDecisionTree : tree:TypedTree.DecisionTree -> int option
    val decisionTreeHasNonTrivialBindings : tree:TypedTree.DecisionTree -> bool
    val foldLinearBindingTargetsOfMatch :
      tree:TypedTree.DecisionTree ->
        targets:TypedTree.DecisionTreeTarget [] ->
          TypedTree.DecisionTree * TypedTree.DecisionTreeTarget []
    val simplifyTrivialMatch :
      spBind:SyntaxTree.DebugPointForBinding ->
        exprm:Range.range ->
          matchm:Range.range ->
            ty:TypedTree.TType ->
              tree:TypedTree.DecisionTree ->
                targets:TypedTree.DecisionTreeTarget [] -> TypedTree.Expr
    val mkAndSimplifyMatch :
      SyntaxTree.DebugPointForBinding ->
        Range.range ->
          Range.range ->
            TypedTree.TType ->
              TypedTree.DecisionTree ->
                TypedTree.DecisionTreeTarget list -> TypedTree.Expr
    type Mutates =
      | AddressOfOp
      | DefinitelyMutates
      | PossiblyMutates
      | NeverMutates
    exception DefensiveCopyWarning of string * Range.range
    val isRecdOrStructTyconRefAssumedImmutable :
      TcGlobals.TcGlobals -> TypedTree.TyconRef -> bool
    val isTyconRefReadOnly :
      g:TcGlobals.TcGlobals -> m:Range.range -> tcref:TypedTree.TyconRef -> bool
    val isTyconRefAssumedReadOnly :
      g:TcGlobals.TcGlobals -> tcref:TypedTree.TyconRef -> bool
    val isRecdOrStructTyconRefReadOnlyAux :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> isInref:bool -> tcref:TypedTree.TyconRef -> bool
    val isRecdOrStructTyconRefReadOnly :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TyconRef -> bool
    val isRecdOrStructTyReadOnlyAux :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> isInref:bool -> ty:TypedTree.TType -> bool
    val isRecdOrStructTyReadOnly :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TType -> bool
    val CanTakeAddressOf :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          isInref:bool -> ty:TypedTree.TType -> mut:Mutates -> bool
    val CanTakeAddressOfImmutableVal :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> vref:TypedTree.ValRef -> mut:Mutates -> bool
    val MustTakeAddressOfVal :
      g:TcGlobals.TcGlobals -> vref:TypedTree.ValRef -> bool
    val MustTakeAddressOfByrefGet :
      g:TcGlobals.TcGlobals -> vref:TypedTree.ValRef -> bool
    val CanTakeAddressOfByrefGet :
      g:TcGlobals.TcGlobals -> vref:TypedTree.ValRef -> mut:Mutates -> bool
    val MustTakeAddressOfRecdField : rfref:TypedTree.RecdField -> bool
    val MustTakeAddressOfRecdFieldRef : rfref:TypedTree.RecdFieldRef -> bool
    val CanTakeAddressOfRecdFieldRef :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          rfref:TypedTree.RecdFieldRef ->
            tinst:TypedTree.TType list -> mut:Mutates -> bool
    val CanTakeAddressOfUnionFieldRef :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          uref:TypedTree.UnionCaseRef ->
            cidx:int -> tinst:TypedTree.TType list -> mut:Mutates -> bool
    val mkDerefAddrExpr :
      mAddrGet:Range.range ->
        expr:TypedTree.Expr ->
          mExpr:Range.range -> exprTy:TypedTree.TType -> TypedTree.Expr
    val mkExprAddrOfExprAux :
      TcGlobals.TcGlobals ->
        bool ->
          bool ->
            Mutates ->
              TypedTree.Expr ->
                TypedTree.ValRef option ->
                  Range.range ->
                    (TypedTree.Val * TypedTree.Expr) option * TypedTree.Expr *
                    bool * bool
    val mkExprAddrOfExpr :
      TcGlobals.TcGlobals ->
        bool ->
          bool ->
            Mutates ->
              TypedTree.Expr ->
                TypedTree.ValRef option ->
                  Range.range ->
                    (TypedTree.Expr -> TypedTree.Expr) * TypedTree.Expr * bool *
                    bool
    val mkTupleFieldGet :
      TcGlobals.TcGlobals ->
        TypedTree.TupInfo * TypedTree.Expr * TypedTree.TypeInst * int *
        Range.range -> TypedTree.Expr
    val mkAnonRecdFieldGet :
      TcGlobals.TcGlobals ->
        TypedTree.AnonRecdTypeInfo * TypedTree.Expr * TypedTree.TypeInst * int *
        Range.range -> TypedTree.Expr
    val mkRecdFieldGet :
      TcGlobals.TcGlobals ->
        TypedTree.Expr * TypedTree.RecdFieldRef * TypedTree.TypeInst *
        Range.range -> TypedTree.Expr
    val mkUnionCaseFieldGetUnproven :
      TcGlobals.TcGlobals ->
        TypedTree.Expr * TypedTree.UnionCaseRef * TypedTree.TypeInst * int *
        Range.range -> TypedTree.Expr
    val mkArray :
      TypedTree.TType * TypedTree.Exprs * Range.range -> TypedTree.Expr
    val IterateRecursiveFixups :
      TcGlobals.TcGlobals ->
        TypedTree.Val option ->
          (TypedTree.Val option -> TypedTree.Expr ->
             (TypedTree.Expr -> TypedTree.Expr) -> TypedTree.Expr -> unit) ->
            TypedTree.Expr * (TypedTree.Expr -> TypedTree.Expr) ->
              TypedTree.Expr -> unit
    val JoinTyparStaticReq :
      SyntaxTree.TyparStaticReq ->
        SyntaxTree.TyparStaticReq -> SyntaxTree.TyparStaticReq
    type ExprFolder<'State> =
      { exprIntercept:
          ('State -> TypedTree.Expr -> 'State) ->
            ('State -> TypedTree.Expr -> 'State) -> 'State -> TypedTree.Expr ->
            'State
        valBindingSiteIntercept: 'State -> bool * TypedTree.Val -> 'State
        nonRecBindingsIntercept: 'State -> TypedTree.Binding -> 'State
        recBindingsIntercept: 'State -> TypedTree.Bindings -> 'State
        dtreeIntercept: 'State -> TypedTree.DecisionTree -> 'State
        targetIntercept:
          ('State -> TypedTree.Expr -> 'State) -> 'State ->
            TypedTree.DecisionTreeTarget -> 'State option
        tmethodIntercept:
          ('State -> TypedTree.Expr -> 'State) -> 'State ->
            TypedTree.ObjExprMethod -> 'State option }
    val ExprFolder0 : ExprFolder<'State>
    type ExprFolders<'State> =
      class
        new : folders:ExprFolder<'State> -> ExprFolders<'State>
        member FoldExpr : ('State -> TypedTree.Expr -> 'State)
        member FoldImplFile : ('State -> TypedTree.TypedImplFile -> 'State)
      end
    val FoldExpr : ExprFolder<'State> -> ('State -> TypedTree.Expr -> 'State)
    val FoldImplFile :
      ExprFolder<'State> -> ('State -> TypedTree.TypedImplFile -> 'State)
    val ExprStats : TypedTree.Expr -> string
    val mkString :
      TcGlobals.TcGlobals -> Range.range -> string -> TypedTree.Expr
    val mkBool : TcGlobals.TcGlobals -> Range.range -> bool -> TypedTree.Expr
    val mkByte : TcGlobals.TcGlobals -> Range.range -> byte -> TypedTree.Expr
    val mkUInt16 :
      TcGlobals.TcGlobals -> Range.range -> uint16 -> TypedTree.Expr
    val mkTrue : TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr
    val mkFalse : TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr
    val mkUnit : TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr
    val mkInt32 : TcGlobals.TcGlobals -> Range.range -> int32 -> TypedTree.Expr
    val mkInt : TcGlobals.TcGlobals -> Range.range -> int32 -> TypedTree.Expr
    val mkZero : TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr
    val mkOne : TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr
    val mkTwo : TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr
    val mkMinusOne : TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr
    val destInt32 : TypedTree.Expr -> int32 option
    val isIDelegateEventType : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val destIDelegateEventType :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkIEventType :
      TcGlobals.TcGlobals ->
        TypedTree.TType -> TypedTree.TType -> TypedTree.TType
    val mkIObservableType :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkIObserverType :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkRefCellContentsRef : TcGlobals.TcGlobals -> TypedTree.RecdFieldRef
    val mkSequential :
      SyntaxTree.DebugPointAtSequential ->
        Range.range -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCompGenSequential :
      Range.range -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkSequentials :
      SyntaxTree.DebugPointAtSequential ->
        TcGlobals.TcGlobals ->
          Range.range -> TypedTree.Expr list -> TypedTree.Expr
    val mkGetArg0 : Range.range -> TypedTree.TType -> TypedTree.Expr
    val mkAnyTupled :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TupInfo ->
            TypedTree.Expr list -> TypedTree.TypeInst -> TypedTree.Expr
    val mkRefTupled :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.Expr list -> TypedTree.TypeInst -> TypedTree.Expr
    val mkRefTupledNoTypes :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.Expr list -> TypedTree.Expr
    val mkRefTupledVars :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.Val list -> TypedTree.Expr
    val inversePerm : sigma:int array -> int []
    val permute : sigma:int [] -> data:'T [] -> 'T []
    val existsR : a:int -> b:int -> pred:(int -> bool) -> bool
    val liftAllBefore : sigma:int array -> int
    val permuteExprList :
      sigma:int [] ->
        exprs:TypedTree.Expr list ->
          ty:TypedTree.TType list ->
            names:string list -> TypedTree.Binding list * TypedTree.Expr list
    val mkRecordExpr :
      TcGlobals.TcGlobals ->
        TypedTree.RecordConstructionInfo * TypedTree.TyconRef *
        TypedTree.TypeInst * TypedTree.RecdFieldRef list * TypedTree.Expr list *
        Range.range -> TypedTree.Expr
    val mkAnonRecd :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.AnonRecdTypeInfo ->
            SyntaxTree.Ident [] ->
              TypedTree.Expr list -> TypedTree.TType list -> TypedTree.Expr
    val mkRefCell :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkRefCellGet :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkRefCellSet :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkNil :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TType -> TypedTree.Expr
    val mkCons :
      TcGlobals.TcGlobals ->
        TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCompGenLocalAndInvisibleBind :
      TcGlobals.TcGlobals ->
        string ->
          Range.range ->
            TypedTree.Expr -> TypedTree.Val * TypedTree.Expr * TypedTree.Binding
    val box : AbstractIL.IL.ILInstr
    val isinst : AbstractIL.IL.ILInstr
    val unbox : AbstractIL.IL.ILInstr
    val mkUnbox :
      TypedTree.TType -> TypedTree.Expr -> Range.range -> TypedTree.Expr
    val mkBox :
      TypedTree.TType -> TypedTree.Expr -> Range.range -> TypedTree.Expr
    val mkIsInst :
      TypedTree.TType -> TypedTree.Expr -> Range.range -> TypedTree.Expr
    val mspec_Type_GetTypeFromHandle :
      TcGlobals.TcGlobals -> AbstractIL.IL.ILMethodSpec
    val mspec_String_Length :
      g:TcGlobals.TcGlobals -> AbstractIL.IL.ILMethodSpec
    val mspec_String_Concat2 :
      g:TcGlobals.TcGlobals -> AbstractIL.IL.ILMethodSpec
    val mspec_String_Concat3 :
      g:TcGlobals.TcGlobals -> AbstractIL.IL.ILMethodSpec
    val mspec_String_Concat4 :
      g:TcGlobals.TcGlobals -> AbstractIL.IL.ILMethodSpec
    val mspec_String_Concat_Array :
      g:TcGlobals.TcGlobals -> AbstractIL.IL.ILMethodSpec
    val fspec_Missing_Value : TcGlobals.TcGlobals -> AbstractIL.IL.ILFieldSpec
    val mkInitializeArrayMethSpec :
      TcGlobals.TcGlobals -> AbstractIL.IL.ILMethodSpec
    val mkInvalidCastExnNewobj : TcGlobals.TcGlobals -> AbstractIL.IL.ILInstr
    val typedExprForIntrinsic :
      _g:'a ->
        m:Range.range ->
          TcGlobals.IntrinsicValRef -> TypedTree.Expr * TypedTree.TType
    val mkCallGetGenericComparer :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr
    val mkCallGetGenericEREqualityComparer :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr
    val mkCallGetGenericPEREqualityComparer :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr
    val mkCallUnbox :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallUnboxFast :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallTypeTest :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallTypeOf :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TType -> TypedTree.Expr
    val mkCallTypeDefOf :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TType -> TypedTree.Expr
    val mkCallDispose :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallSeq :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallCreateInstance :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TType -> TypedTree.Expr
    val mkCallGetQuerySourceAsEnumerable :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallNewQuerySource :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallCreateEvent :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            TypedTree.TType ->
              TypedTree.Expr ->
                TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallGenericComparisonWithComparerOuter :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallGenericEqualityEROuter :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallGenericEqualityWithComparerOuter :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallGenericHashWithComparerOuter :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallEqualsOperator :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallNotEqualsOperator :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallLessThanOperator :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallLessThanOrEqualsOperator :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallGreaterThanOperator :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallGreaterThanOrEqualsOperator :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallAdditionOperator :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallSubtractionOperator :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallMultiplyOperator :
      TcGlobals.TcGlobals ->
        Range.range ->
          ty1:TypedTree.TType ->
            ty2:TypedTree.TType ->
              rty:TypedTree.TType ->
                TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallDivisionOperator :
      TcGlobals.TcGlobals ->
        Range.range ->
          ty1:TypedTree.TType ->
            ty2:TypedTree.TType ->
              rty:TypedTree.TType ->
                TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallModulusOperator :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallDefaultOf :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TType -> TypedTree.Expr
    val mkCallBitwiseAndOperator :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallBitwiseOrOperator :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallBitwiseXorOperator :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallShiftLeftOperator :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallShiftRightOperator :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallUnaryNegOperator :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallUnaryNotOperator :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallAdditionChecked :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallSubtractionChecked :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallMultiplyChecked :
      TcGlobals.TcGlobals ->
        Range.range ->
          ty1:TypedTree.TType ->
            ty2:TypedTree.TType ->
              rty:TypedTree.TType ->
                TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallUnaryNegChecked :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToByteChecked :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToSByteChecked :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToInt16Checked :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToUInt16Checked :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToIntChecked :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToInt32Checked :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToUInt32Checked :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToInt64Checked :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToUInt64Checked :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToIntPtrChecked :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToUIntPtrChecked :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToByteOperator :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToSByteOperator :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToInt16Operator :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToUInt16Operator :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToIntOperator :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToInt32Operator :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToUInt32Operator :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToInt64Operator :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToUInt64Operator :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToSingleOperator :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToDoubleOperator :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToIntPtrOperator :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToUIntPtrOperator :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToCharOperator :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallToEnumOperator :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallArrayLength :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallArrayGet :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallArray2DGet :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallArray3DGet :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            TypedTree.Expr ->
              TypedTree.Expr ->
                TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallArray4DGet :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            TypedTree.Expr ->
              TypedTree.Expr ->
                TypedTree.Expr ->
                  TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallArraySet :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallArray2DSet :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            TypedTree.Expr ->
              TypedTree.Expr ->
                TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallArray3DSet :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            TypedTree.Expr ->
              TypedTree.Expr ->
                TypedTree.Expr ->
                  TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallArray4DSet :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            TypedTree.Expr ->
              TypedTree.Expr ->
                TypedTree.Expr ->
                  TypedTree.Expr ->
                    TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallHash :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallBox :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallIsNull :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallIsNotNull :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallRaise :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallNewDecimal :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          e1:TypedTree.Expr * e2:TypedTree.Expr * e3:TypedTree.Expr *
          e4:TypedTree.Expr * e5:TypedTree.Expr -> TypedTree.Expr
    val mkCallNewFormat :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            TypedTree.TType ->
              TypedTree.TType ->
                TypedTree.TType ->
                  TypedTree.TType ->
                    formatStringExpr:TypedTree.Expr -> TypedTree.Expr
    val tryMkCallBuiltInWitness :
      TcGlobals.TcGlobals ->
        TypedTree.TraitConstraintInfo ->
          TypedTree.Expr list -> Range.range -> TypedTree.Expr option
    val tryMkCallCoreFunctionAsBuiltInWitness :
      TcGlobals.TcGlobals ->
        TcGlobals.IntrinsicValRef ->
          TypedTree.TType list ->
            TypedTree.Expr list -> Range.range -> TypedTree.Expr option
    val TryEliminateDesugaredConstants :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.Const -> TypedTree.Expr option
    val mkSeqTy : TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkIEnumeratorTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TType
    val mkCallSeqCollect :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            TypedTree.TType ->
              TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallSeqUsing :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            TypedTree.TType ->
              TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallSeqDelay :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallSeqAppend :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallSeqGenerated :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallSeqFinally :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallSeqOfFunctions :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            TypedTree.TType ->
              TypedTree.Expr ->
                TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallSeqToArray :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallSeqToList :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallSeqMap :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            TypedTree.TType ->
              TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallSeqSingleton :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallSeqEmpty :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TType -> TypedTree.Expr
    val mkCall_sprintf :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          funcTy:TypedTree.TType ->
            fmtExpr:TypedTree.Expr ->
              fillExprs:TypedTree.Expr list -> TypedTree.Expr
    val mkCallDeserializeQuotationFSharp20Plus :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.Expr ->
            TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallDeserializeQuotationFSharp40Plus :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.Expr ->
            TypedTree.Expr ->
              TypedTree.Expr ->
                TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkCallCastQuotation :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallLiftValue :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallLiftValueWithName :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> string -> TypedTree.Expr -> TypedTree.Expr
    val mkCallLiftValueWithDefn :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallCheckThis :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCallFailInit : TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr
    val mkCallFailStaticInit :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr
    val mkCallQuoteToLinqLambdaExpression :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkOptionToNullable :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkOptionDefaultValue :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkLazyDelayed :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkLazyForce :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkGetString :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          e1:TypedTree.Expr -> e2:TypedTree.Expr -> TypedTree.Expr
    val mkGetStringChar :
      (TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr -> TypedTree.Expr ->
         TypedTree.Expr)
    val mkGetStringLength :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> e:TypedTree.Expr -> TypedTree.Expr
    val mkStaticCall_String_Concat2 :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkStaticCall_String_Concat3 :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkStaticCall_String_Concat4 :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.Expr ->
            TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkStaticCall_String_Concat_Array :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr -> TypedTree.Expr
    val mkDecr :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr -> TypedTree.Expr
    val mkIncr :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr -> TypedTree.Expr
    val mkLdlen :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr -> TypedTree.Expr
    val mkLdelem :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkILAsmCeq :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkILAsmClt :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkNull : Range.range -> TypedTree.TType -> TypedTree.Expr
    val mkThrow :
      Range.range -> TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val destThrow :
      _arg1:TypedTree.Expr ->
        (Range.range * TypedTree.TType * TypedTree.Expr) option
    val isThrow : TypedTree.Expr -> bool
    val mkReraiseLibCall :
      TcGlobals.TcGlobals -> TypedTree.TType -> Range.range -> TypedTree.Expr
    val mkReraise : Range.range -> TypedTree.TType -> TypedTree.Expr
    val tnameCompilationSourceNameAttr : string
    val tnameCompilationArgumentCountsAttr : string
    val tnameCompilationMappingAttr : string
    val tnameSourceConstructFlags : string
    val tref_CompilationArgumentCountsAttr :
      g:TcGlobals.TcGlobals -> AbstractIL.IL.ILTypeRef
    val tref_CompilationMappingAttr :
      g:TcGlobals.TcGlobals -> AbstractIL.IL.ILTypeRef
    val tref_CompilationSourceNameAttr :
      g:TcGlobals.TcGlobals -> AbstractIL.IL.ILTypeRef
    val tref_SourceConstructFlags :
      g:TcGlobals.TcGlobals -> AbstractIL.IL.ILTypeRef
    val mkCompilationMappingAttrPrim :
      g:TcGlobals.TcGlobals ->
        k:int32 -> nums:int32 list -> AbstractIL.IL.ILAttribute
    val mkCompilationMappingAttr :
      TcGlobals.TcGlobals -> int32 -> AbstractIL.IL.ILAttribute
    val mkCompilationMappingAttrWithSeqNum :
      TcGlobals.TcGlobals -> int32 -> int32 -> AbstractIL.IL.ILAttribute
    val mkCompilationMappingAttrWithVariantNumAndSeqNum :
      TcGlobals.TcGlobals ->
        int32 -> int32 -> int32 -> AbstractIL.IL.ILAttribute
    val mkCompilationArgumentCountsAttr :
      TcGlobals.TcGlobals -> int32 list -> AbstractIL.IL.ILAttribute
    val mkCompilationSourceNameAttr :
      TcGlobals.TcGlobals -> string -> AbstractIL.IL.ILAttribute
    val mkCompilationMappingAttrForQuotationResource :
      TcGlobals.TcGlobals ->
        string * AbstractIL.IL.ILTypeRef list -> AbstractIL.IL.ILAttribute
    val isTypeProviderAssemblyAttr : cattr:AbstractIL.IL.ILAttribute -> bool
    val TryDecodeTypeProviderAssemblyAttr :
      AbstractIL.IL.ILGlobals -> AbstractIL.IL.ILAttribute -> string option
    val tname_SignatureDataVersionAttr : string
    val tnames_SignatureDataVersionAttr : string list * string
    val tref_SignatureDataVersionAttr : unit -> AbstractIL.IL.ILTypeRef
    val mkSignatureDataVersionAttr :
      TcGlobals.TcGlobals ->
        AbstractIL.IL.ILVersionInfo -> AbstractIL.IL.ILAttribute
    val tname_AutoOpenAttr : string
    val IsSignatureDataVersionAttr : AbstractIL.IL.ILAttribute -> bool
    val TryFindAutoOpenAttr :
      AbstractIL.IL.ILGlobals -> AbstractIL.IL.ILAttribute -> string option
    val tname_InternalsVisibleToAttr : string
    val TryFindInternalsVisibleToAttr :
      AbstractIL.IL.ILGlobals -> AbstractIL.IL.ILAttribute -> string option
    val IsMatchingSignatureDataVersionAttr :
      AbstractIL.IL.ILGlobals ->
        AbstractIL.IL.ILVersionInfo -> AbstractIL.IL.ILAttribute -> bool
    val mkCompilerGeneratedAttr :
      TcGlobals.TcGlobals -> int32 -> AbstractIL.IL.ILAttribute
    val untupledToRefTupled :
      g:TcGlobals.TcGlobals ->
        vs:TypedTree.Val list ->
          TypedTree.Val * (TypedTree.Expr -> TypedTree.Expr)
    val AdjustArityOfLambdaBody :
      TcGlobals.TcGlobals ->
        int ->
          TypedTree.Val list ->
            TypedTree.Expr -> TypedTree.Val list * TypedTree.Expr
    val MultiLambdaToTupledLambda :
      TcGlobals.TcGlobals ->
        TypedTree.Val list -> TypedTree.Expr -> TypedTree.Val * TypedTree.Expr
    val ( |RefTuple|_| ) : expr:TypedTree.Expr -> TypedTree.Exprs option
    val MultiLambdaToTupledLambdaIfNeeded :
      g:TcGlobals.TcGlobals ->
        vs:TypedTree.Val list * arg:TypedTree.Expr ->
          body:TypedTree.Expr ->
            (TypedTree.Val * TypedTree.Expr) list * TypedTree.Expr
    val MakeApplicationAndBetaReduceAux :
      g:TcGlobals.TcGlobals ->
        f:TypedTree.Expr * fty:TypedTree.TType *
        tyargsl:TypedTree.TType list list * argsl:TypedTree.Expr list *
        m:Range.range -> TypedTree.Expr
    val MakeApplicationAndBetaReduce :
      TcGlobals.TcGlobals ->
        TypedTree.Expr * TypedTree.TType * TypedTree.TType list list *
        TypedTree.Expr list * Range.range -> TypedTree.Expr
    val MakeArgsForTopArgs :
      _g:'a ->
        m:Range.range ->
          argtysl:(TypedTree.TType * TypedTree.ArgReprInfo) list list ->
            tpenv:(TypedTree.Typar * TypedTree.TType) list ->
              TypedTree.Val list list
    val AdjustValForExpectedArity :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.ValRef ->
            TypedTree.ValUseFlag ->
              TypedTree.ValReprInfo -> TypedTree.Expr * TypedTree.TType
    val IsSubsumptionExpr : g:TcGlobals.TcGlobals -> expr:TypedTree.Expr -> bool
    val stripTupledFunTy :
      g:TcGlobals.TcGlobals ->
        ty:TypedTree.TType -> TypedTree.TTypes list * TypedTree.TType
    val ( |ExprValWithPossibleTypeInst|_| ) :
      TypedTree.Expr ->
        (TypedTree.ValRef * TypedTree.ValUseFlag * TypedTree.TypeInst *
         Range.range) option
    val mkCoerceIfNeeded :
      TcGlobals.TcGlobals ->
        tgtTy:TypedTree.TType ->
          srcTy:TypedTree.TType -> TypedTree.Expr -> TypedTree.Expr
    val mkCompGenLetIn :
      Range.range ->
        string ->
          TypedTree.TType ->
            TypedTree.Expr ->
              (TypedTree.Val * TypedTree.Expr -> TypedTree.Expr) ->
                TypedTree.Expr
    val AdjustPossibleSubsumptionExpr :
      TcGlobals.TcGlobals ->
        TypedTree.Expr ->
          TypedTree.Expr list -> (TypedTree.Expr * TypedTree.Expr list) option
    val NormalizeAndAdjustPossibleSubsumptionExprs :
      TcGlobals.TcGlobals -> TypedTree.Expr -> TypedTree.Expr
    val etaExpandTypeLambda :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          tps:TypedTree.Typar list ->
            tm:TypedTree.Expr * ty:TypedTree.TType -> TypedTree.Expr
    val AdjustValToTopVal :
      TypedTree.Val -> TypedTree.ParentRef -> TypedTree.ValReprInfo -> unit
    val LinearizeTopMatchAux :
      g:TcGlobals.TcGlobals ->
        parent:TypedTree.ParentRef ->
          spBind:SyntaxTree.DebugPointForBinding * m:Range.range *
          tree:TypedTree.DecisionTree * targets:TypedTree.DecisionTreeTarget [] *
          m2:Range.range * ty:TypedTree.TType -> TypedTree.Expr
    val LinearizeTopMatch :
      TcGlobals.TcGlobals ->
        TypedTree.ParentRef -> TypedTree.Expr -> TypedTree.Expr
    val commaEncs : strs:seq<string> -> string
    val angleEnc : str:string -> string
    val ticksAndArgCountTextOfTyconRef : TypedTree.TyconRef -> string
    val typarEnc :
      _g:'a ->
        gtpsType:TypedTree.Typar list * gtpsMethod:TypedTree.Typar list ->
          typar:TypedTree.Typar -> string
    val typeEnc :
      g:TcGlobals.TcGlobals ->
        gtpsType:TypedTree.Typar list * gtpsMethod:TypedTree.Typar list ->
          ty:TypedTree.TType -> string
    val tyargsEnc :
      g:TcGlobals.TcGlobals ->
        gtpsType:TypedTree.Typar list * gtpsMethod:TypedTree.Typar list ->
          args:TypedTree.TypeInst -> string
    val XmlDocArgsEnc :
      TcGlobals.TcGlobals ->
        TypedTree.Typar list * TypedTree.Typar list ->
          TypedTree.TType list -> string
    val buildAccessPath : TypedTree.CompilationPath option -> string
    val prependPath : path:string -> name:string -> string
    val XmlDocSigOfVal :
      TcGlobals.TcGlobals -> full:bool -> string -> TypedTree.Val -> string
    val BuildXmlDocSig : prefix:string -> paths:string list -> string
    val XmlDocSigOfUnionCase : (string list -> string)
    val XmlDocSigOfField : (string list -> string)
    val XmlDocSigOfProperty : (string list -> string)
    val XmlDocSigOfTycon : (string list -> string)
    val XmlDocSigOfSubModul : (string list -> string)
    val XmlDocSigOfEntity : TypedTree.EntityRef -> string
    val enum_CompilationRepresentationAttribute_Static : int
    val enum_CompilationRepresentationAttribute_Instance : int
    val enum_CompilationRepresentationAttribute_StaticInstanceMask : int
    val enum_CompilationRepresentationAttribute_ModuleSuffix : int
    val enum_CompilationRepresentationAttribute_PermitNull : int
    val HasUseNullAsTrueValueAttribute :
      g:TcGlobals.TcGlobals -> attribs:TypedTree.Attrib list -> bool
    val TyconHasUseNullAsTrueValueAttribute :
      TcGlobals.TcGlobals -> TypedTree.Tycon -> bool
    val CanHaveUseNullAsTrueValueAttribute :
      TcGlobals.TcGlobals -> TypedTree.Tycon -> bool
    val IsUnionTypeWithNullAsTrueValue :
      TcGlobals.TcGlobals -> TypedTree.Tycon -> bool
    val TyconCompilesInstanceMembersAsStatic :
      g:TcGlobals.TcGlobals -> tycon:TypedTree.Tycon -> bool
    val TcrefCompilesInstanceMembersAsStatic :
      g:TcGlobals.TcGlobals -> tcref:TypedTree.TyconRef -> bool
    val isNonNullableStructTyparTy :
      TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isReferenceTyparTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val TypeNullNever : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val TypeNullIsExtraValue :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TType -> bool
    val TypeNullIsTrueValue : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val TypeNullNotLiked :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TType -> bool
    val TypeSatisfiesNullConstraint :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TType -> bool
    val TypeHasDefaultValue :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TType -> bool
    val ( |SpecialComparableHeadType|_| ) :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TTypes option
    val ( |SpecialEquatableHeadType|_| ) :
      TcGlobals.TcGlobals -> TypedTree.TType -> TypedTree.TTypes option
    val ( |SpecialNotEquatableHeadType|_| ) :
      TcGlobals.TcGlobals -> TypedTree.TType -> unit option
    val canUseTypeTestFast : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val canUseUnboxFast :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TType -> bool
    val mkIsInstConditional :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            TypedTree.Expr ->
              TypedTree.Val ->
                TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkNullTest :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkNonNullTest :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr -> TypedTree.Expr
    val mkNonNullCond :
      TcGlobals.TcGlobals ->
        Range.range ->
          TypedTree.TType ->
            TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val mkIfThen :
      TcGlobals.TcGlobals ->
        Range.range -> TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr
    val ModuleNameIsMangled :
      TcGlobals.TcGlobals -> TypedTree.Attrib list -> bool
    val CompileAsEvent : TcGlobals.TcGlobals -> TypedTree.Attrib list -> bool
    val MemberIsCompiledAsInstance :
      TcGlobals.TcGlobals ->
        TypedTree.TyconRef ->
          bool -> TypedTree.ValMemberInfo -> TypedTree.Attrib list -> bool
    val isSealedTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val isComInteropTy : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    val ValSpecIsCompiledAsInstance :
      TcGlobals.TcGlobals -> TypedTree.Val -> bool
    val ValRefIsCompiledAsInstanceMember :
      TcGlobals.TcGlobals -> TypedTree.ValRef -> bool
    val GetMemberCallInfo :
      TcGlobals.TcGlobals ->
        TypedTree.ValRef * TypedTree.ValUseFlag ->
          int * bool * bool * bool * bool * bool * bool * bool
    val TryGetActivePatternInfo :
      TypedTree.ValRef -> PrettyNaming.ActivePatternInfo option
    type ActivePatternElemRef with
      member Name : string
    val mkChoiceTyconRef :
      g:TcGlobals.TcGlobals -> m:Range.range -> n:int -> TypedTree.EntityRef
    val mkChoiceTy :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> tinst:TypedTree.TType list -> TypedTree.TType
    val mkChoiceCaseRef :
      TcGlobals.TcGlobals -> Range.range -> int -> int -> TypedTree.UnionCaseRef
    type ActivePatternInfo with
      member Names : string list
    type ActivePatternInfo with
      member
        ResultType : TcGlobals.TcGlobals ->
                       Range.range -> TypedTree.TType list -> TypedTree.TType
    type ActivePatternInfo with
      member
        OverallType : TcGlobals.TcGlobals ->
                        Range.range ->
                          TypedTree.TType ->
                            TypedTree.TType list -> TypedTree.TType
    val doesActivePatternHaveFreeTypars :
      TcGlobals.TcGlobals -> TypedTree.ValRef -> bool
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type ExprRewritingEnv =
      { PreIntercept:
          ((TypedTree.Expr -> TypedTree.Expr) -> TypedTree.Expr ->
             TypedTree.Expr option) option
        PostTransform: TypedTree.Expr -> TypedTree.Expr option
        PreInterceptBinding:
          ((TypedTree.Expr -> TypedTree.Expr) -> TypedTree.Binding ->
             TypedTree.Binding option) option
        IsUnderQuotations: bool }
    val rewriteBind :
      env:ExprRewritingEnv -> bind:TypedTree.Binding -> TypedTree.Binding
    val rewriteBindStructure :
      env:ExprRewritingEnv -> TypedTree.Binding -> TypedTree.Binding
    val rewriteBinds :
      env:ExprRewritingEnv ->
        binds:TypedTree.Binding list -> TypedTree.Binding list
    val RewriteExpr : ExprRewritingEnv -> TypedTree.Expr -> TypedTree.Expr
    val preRewriteExpr :
      env:ExprRewritingEnv -> expr:TypedTree.Expr -> TypedTree.Expr option
    val postRewriteExpr :
      env:ExprRewritingEnv -> expr:TypedTree.Expr -> TypedTree.Expr
    val rewriteExprStructure :
      env:ExprRewritingEnv -> expr:TypedTree.Expr -> TypedTree.Expr
    val rewriteLinearExpr :
      env:ExprRewritingEnv ->
        expr:TypedTree.Expr ->
          contf:(TypedTree.Expr -> TypedTree.Expr) -> TypedTree.Expr
    val rewriteExprs :
      env:ExprRewritingEnv -> exprs:TypedTree.Exprs -> TypedTree.Exprs
    val rewriteFlatExprs :
      env:ExprRewritingEnv -> exprs:TypedTree.Expr list -> TypedTree.Expr list
    val RewriteDecisionTree :
      env:ExprRewritingEnv -> x:TypedTree.DecisionTree -> TypedTree.DecisionTree
    val rewriteTarget :
      env:ExprRewritingEnv ->
        TypedTree.DecisionTreeTarget -> TypedTree.DecisionTreeTarget
    val rewriteTargets :
      env:ExprRewritingEnv ->
        targets:TypedTree.DecisionTreeTarget array ->
          TypedTree.DecisionTreeTarget list
    val rewriteObjExprOverride :
      env:ExprRewritingEnv -> TypedTree.ObjExprMethod -> TypedTree.ObjExprMethod
    val rewriteObjExprInterfaceImpl :
      env:ExprRewritingEnv ->
        ty:TypedTree.TType * overrides:TypedTree.ObjExprMethod list ->
          TypedTree.TType * TypedTree.ObjExprMethod list
    val rewriteModuleOrNamespaceExpr :
      env:ExprRewritingEnv ->
        x:TypedTree.ModuleOrNamespaceExprWithSig ->
          TypedTree.ModuleOrNamespaceExprWithSig
    val rewriteModuleOrNamespaceDefs :
      env:ExprRewritingEnv ->
        x:TypedTree.ModuleOrNamespaceExpr list ->
          TypedTree.ModuleOrNamespaceExpr list
    val rewriteModuleOrNamespaceDef :
      env:ExprRewritingEnv ->
        x:TypedTree.ModuleOrNamespaceExpr -> TypedTree.ModuleOrNamespaceExpr
    val rewriteModuleOrNamespaceBinding :
      env:ExprRewritingEnv ->
        x:TypedTree.ModuleOrNamespaceBinding ->
          TypedTree.ModuleOrNamespaceBinding
    val rewriteModuleOrNamespaceBindings :
      env:ExprRewritingEnv ->
        mbinds:TypedTree.ModuleOrNamespaceBinding list ->
          TypedTree.ModuleOrNamespaceBinding list
    val RewriteImplFile :
      ExprRewritingEnv -> TypedTree.TypedImplFile -> TypedTree.TypedImplFile
    val MakeExportRemapping :
      TypedTree.CcuThunk -> TypedTree.ModuleOrNamespace -> Remap
    val remapEntityDataToNonLocal :
      g:TcGlobals.TcGlobals ->
        tmenv:Remap -> d:TypedTree.Entity -> TypedTree.Entity
    val remapTyconToNonLocal :
      g:TcGlobals.TcGlobals ->
        tmenv:Remap -> x:TypedTree.Entity -> TypedTree.Entity
    val remapValToNonLocal :
      g:TcGlobals.TcGlobals -> tmenv:Remap -> inp:TypedTree.Val -> TypedTree.Val
    val ApplyExportRemappingToEntity :
      TcGlobals.TcGlobals -> Remap -> TypedTree.Entity -> TypedTree.Entity
    val isCompiledConstraint : cx:TypedTree.TyparConstraint -> bool
    val IsGenericValWithGenericConstraints :
      TcGlobals.TcGlobals -> TypedTree.Val -> bool
    type Entity with
      member HasInterface : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    type Entity with
      member
        HasOverride : TcGlobals.TcGlobals ->
                        string -> TypedTree.TType list -> bool
    type Entity with
      member
        HasMember : TcGlobals.TcGlobals ->
                      string -> TypedTree.TType list -> bool
    type EntityRef with
      member HasInterface : TcGlobals.TcGlobals -> TypedTree.TType -> bool
    type EntityRef with
      member
        HasOverride : TcGlobals.TcGlobals ->
                        string -> TypedTree.TType list -> bool
    type EntityRef with
      member
        HasMember : TcGlobals.TcGlobals ->
                      string -> TypedTree.TType list -> bool
    val mkFastForLoop :
      TcGlobals.TcGlobals ->
        SyntaxTree.DebugPointAtFor * Range.range * TypedTree.Val *
        TypedTree.Expr * bool * TypedTree.Expr * TypedTree.Expr ->
          TypedTree.Expr
    val IsSimpleSyntacticConstantExpr :
      TcGlobals.TcGlobals -> TypedTree.Expr -> bool
    val EvalArithBinOp :
      opInt8:(sbyte -> sbyte -> sbyte) * opInt16:(int16 -> int16 -> int16) *
      opInt32:(int32 -> int32 -> int32) * opInt64:(int64 -> int64 -> int64) *
      opUInt8:(byte -> byte -> byte) * opUInt16:(uint16 -> uint16 -> uint16) *
      opUInt32:(uint32 -> uint32 -> uint32) *
      opUInt64:(uint64 -> uint64 -> uint64) ->
        arg1:TypedTree.Expr -> arg2:TypedTree.Expr -> TypedTree.Expr
    val EvalAttribArgExpr :
      g:TcGlobals.TcGlobals -> x:TypedTree.Expr -> TypedTree.Expr
    val EvaledAttribExprEquality :
      TcGlobals.TcGlobals -> TypedTree.Expr -> TypedTree.Expr -> bool
    val ( |ConstToILFieldInit|_| ) :
      TypedTree.Const -> AbstractIL.IL.ILFieldInit option
    val EvalLiteralExprOrAttribArg :
      TcGlobals.TcGlobals -> TypedTree.Expr -> TypedTree.Expr
    val GetTypeOfIntrinsicMemberInCompiledForm :
      TcGlobals.TcGlobals ->
        TypedTree.ValRef ->
          TypedTree.Typar list * TypedTree.TraitWitnessInfo list *
          (TypedTree.TType * TypedTree.ArgReprInfo) list list *
          TypedTree.TType option * TypedTree.ArgReprInfo
    val mkCompiledTuple :
      TcGlobals.TcGlobals ->
        bool ->
          TypedTree.TType list * TypedTree.Expr list * Range.range ->
            TypedTree.EntityRef * TypedTree.TType list * TypedTree.Expr list *
            Range.range
    val mkILMethodSpecForTupleItem :
      _g:TcGlobals.TcGlobals ->
        ty:AbstractIL.IL.ILType -> n:int -> AbstractIL.IL.ILMethodSpec
    val mkILFieldSpecForTupleItem :
      ty:AbstractIL.IL.ILType -> n:int -> AbstractIL.IL.ILFieldSpec
    val mkGetTupleItemN :
      TcGlobals.TcGlobals ->
        Range.range ->
          int ->
            AbstractIL.IL.ILType ->
              bool -> TypedTree.Expr -> TypedTree.TType -> TypedTree.Expr
    val ( |Int32Expr|_| ) : TypedTree.Expr -> int32 option
    val ( |TryFinally|_| ) :
      expr:TypedTree.Expr -> (TypedTree.Expr * TypedTree.Expr) option
    val ( |WhileLoopForCompiledForEachExpr|_| ) :
      expr:TypedTree.Expr ->
        (TypedTree.Expr * TypedTree.Expr * Range.range) option
    val ( |Let|_| ) :
      expr:TypedTree.Expr ->
        (TypedTree.Val * TypedTree.Expr * SyntaxTree.DebugPointForBinding *
         TypedTree.Expr) option
    val ( |RangeInt32Step|_| ) :
      g:TcGlobals.TcGlobals ->
        expr:TypedTree.Expr -> (TypedTree.Expr * int * TypedTree.Expr) option
    val ( |GetEnumeratorCall|_| ) :
      expr:TypedTree.Expr -> TypedTree.ValRef option
    val ( |CompiledForEachExpr|_| ) :
      g:TcGlobals.TcGlobals ->
        expr:TypedTree.Expr ->
          (TypedTree.TType * TypedTree.Expr * TypedTree.Val * TypedTree.Expr *
           (Range.range * Range.range * SyntaxTree.DebugPointAtFor * Range.range *
            SyntaxTree.DebugPointAtWhile * Range.range)) option
    val ( |CompiledInt32RangeForEachExpr|_| ) :
      g:TcGlobals.TcGlobals ->
        expr:TypedTree.Expr ->
          (TypedTree.Expr * int * TypedTree.Expr * TypedTree.Val *
           TypedTree.Expr *
           (Range.range * Range.range * SyntaxTree.DebugPointAtFor * Range.range *
            SyntaxTree.DebugPointAtWhile * Range.range)) option
    type OptimizeForExpressionOptions =
      | OptimizeIntRangesOnly
      | OptimizeAllForExpressions
    val DetectAndOptimizeForExpression :
      TcGlobals.TcGlobals ->
        OptimizeForExpressionOptions -> TypedTree.Expr -> TypedTree.Expr
    val ( |InnerExprPat| ) : TypedTree.Expr -> TypedTree.Expr
    val BindUnitVars :
      TcGlobals.TcGlobals ->
        (TypedTree.Val list * TypedTree.ArgReprInfo list * TypedTree.Expr) ->
          TypedTree.Val list * TypedTree.Expr
    val isThreadOrContextStatic :
      TcGlobals.TcGlobals -> TypedTree.Attrib list -> bool
    val mkUnitDelayLambda :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.Expr -> TypedTree.Expr
    val ( |ValApp|_| ) :
      TcGlobals.TcGlobals ->
        TypedTree.ValRef ->
          TypedTree.Expr ->
            (TypedTree.TypeInst * TypedTree.Exprs * Range.range) option
    val CombineCcuContentFragments :
      Range.range ->
        TypedTree.ModuleOrNamespaceType list -> TypedTree.ModuleOrNamespaceType
    type TraitWitnessInfoHashMap<'T> =
      System.Collections.Immutable.ImmutableDictionary<TypedTree.TraitWitnessInfo,
                                                       'T>
    val EmptyTraitWitnessInfoHashMap :
      TcGlobals.TcGlobals -> TraitWitnessInfoHashMap<'T>
    val ( |WhileExpr|_| ) :
      TypedTree.Expr ->
        (SyntaxTree.DebugPointAtWhile * TypedTree.SpecialWhileLoopMarker *
         TypedTree.Expr * TypedTree.Expr * Range.range) option
    val ( |TryFinallyExpr|_| ) :
      TypedTree.Expr ->
        (SyntaxTree.DebugPointAtTry * SyntaxTree.DebugPointAtFinally *
         TypedTree.TType * TypedTree.Expr * TypedTree.Expr * Range.range) option
    val ( |ForLoopExpr|_| ) :
      TypedTree.Expr ->
        (SyntaxTree.DebugPointAtFor * TypedTree.ForLoopStyle * TypedTree.Expr *
         TypedTree.Expr * TypedTree.Val * TypedTree.Expr * Range.range) option
    val ( |TryWithExpr|_| ) :
      TypedTree.Expr ->
        (SyntaxTree.DebugPointAtTry * SyntaxTree.DebugPointAtWith *
         TypedTree.TType * TypedTree.Expr * TypedTree.Val * TypedTree.Expr *
         TypedTree.Val * TypedTree.Expr * Range.range) option
    val mkLabelled :
      Range.range ->
        AbstractIL.IL.ILCodeLabel -> TypedTree.Expr -> TypedTree.Expr
  end

namespace FSharp.Compiler
  module internal TypedTreePickle = begin
    val verbose : bool
    val ffailwith : fileName:System.String -> str:System.String -> 'a
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type PickledDataWithReferences<'RawData> =
      { RawData: 'RawData
        FixupThunks: TypedTree.CcuThunk [] }
      with
        member Fixup : (string -> TypedTree.CcuThunk) -> 'RawData
        member OptionalFixup : (string -> TypedTree.CcuThunk option) -> 'RawData
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type Table<'T> =
      { name: string
        tbl: System.Collections.Generic.Dictionary<'T,int>
        mutable rows: ResizeArray<'T>
        mutable count: int }
      with
        static member Create : n:string -> Table<'a> when 'a : equality
        member Add : x:'T -> int
        member FindOrAdd : x:'T -> int
        member AsArray : 'T []
        member Size : int
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type InputTable<'T> =
      { itbl_name: string
        itbl_rows: 'T array }
    val new_itbl : n:string -> r:'a array -> InputTable<'a>
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type NodeOutTable<'Data,'Node> =
      { NodeStamp: 'Node -> TypedTree.Stamp
        NodeName: 'Node -> string
        GetRange: 'Node -> Range.range
        Deref: 'Node -> 'Data
        Name: string
        Table: Table<TypedTree.Stamp> }
      with
        static member
          Create : stampF:('a -> TypedTree.Stamp) * nameF:('a -> string) *
                   rangeF:('a -> Range.range) * derefF:('a -> 'b) * nm:string ->
                     NodeOutTable<'b,'a>
        member Size : int
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type WriterState =
      { os: AbstractIL.Internal.ByteBuffer
        oscope: TypedTree.CcuThunk
        occus: Table<TypedTree.CcuReference>
        oentities: NodeOutTable<TypedTree.EntityData,TypedTree.Entity>
        otypars: NodeOutTable<TypedTree.TyparData,TypedTree.Typar>
        ovals: NodeOutTable<TypedTree.ValData,TypedTree.Val>
        oanoninfos:
          NodeOutTable<TypedTree.AnonRecdTypeInfo,TypedTree.AnonRecdTypeInfo>
        ostrings: Table<string>
        opubpaths: Table<int []>
        onlerefs: Table<int * int []>
        osimpletys: Table<int>
        oglobals: TcGlobals.TcGlobals
        mutable isStructThisArgPos: bool
        ofile: string
        oInMem: bool }
    val pfailwith : st:WriterState -> str:System.String -> 'a
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type NodeInTable<'Data,'Node> =
      { LinkNode: 'Node -> 'Data -> unit
        IsLinked: 'Node -> bool
        Name: string
        Nodes: 'Node [] }
      with
        static member
          Create : mkEmpty:(unit -> 'a) * lnk:('a -> 'b -> unit) *
                   isLinked:('a -> bool) * nm:string * n:int ->
                     NodeInTable<'b,'a>
        member Get : n:int -> 'Node
        member Count : int
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type ReaderState =
      { is: AbstractIL.Internal.ByteStream
        iilscope: AbstractIL.IL.ILScopeRef
        iccus: InputTable<TypedTree.CcuThunk>
        ientities: NodeInTable<TypedTree.EntityData,TypedTree.Tycon>
        itypars: NodeInTable<TypedTree.TyparData,TypedTree.Typar>
        ivals: NodeInTable<TypedTree.ValData,TypedTree.Val>
        ianoninfos:
          NodeInTable<TypedTree.AnonRecdTypeInfo,TypedTree.AnonRecdTypeInfo>
        istrings: InputTable<string>
        ipubpaths: InputTable<TypedTree.PublicPath>
        inlerefs: InputTable<TypedTree.NonLocalEntityRef>
        isimpletys: InputTable<TypedTree.TType>
        ifile: string
        iILModule: AbstractIL.IL.ILModuleDef option }
    val ufailwith : st:ReaderState -> str:System.String -> 'a
    type 'T pickler = 'T -> WriterState -> unit
    val p_byte : int -> WriterState -> unit
    val p_bool : bool -> WriterState -> unit
    val prim_p_int32 : i:int -> st:WriterState -> unit
    val p_int32 : n:int -> st:WriterState -> unit
    val space : unit
    val p_space : n:int -> unit -> st:WriterState -> unit
    val p_used_space1 : f:(WriterState -> unit) -> st:WriterState -> unit
    val p_bytes : s:byte [] -> st:WriterState -> unit
    val p_prim_string : s:string -> st:WriterState -> unit
    val p_int : int -> WriterState -> unit
    val p_int8 : i:sbyte -> st:WriterState -> unit
    val p_uint8 : i:byte -> st:WriterState -> unit
    val p_int16 : i:int16 -> st:WriterState -> unit
    val p_uint16 : x:uint16 -> st:WriterState -> unit
    val p_uint32 : x:uint32 -> st:WriterState -> unit
    val p_int64 : i:int64 -> st:WriterState -> unit
    val p_uint64 : x:uint64 -> st:WriterState -> unit
    val bits_of_float32 : x:float32 -> int
    val bits_of_float : x:float -> int64
    val p_single : i:float32 -> st:WriterState -> unit
    val p_double : i:float -> st:WriterState -> unit
    val p_ieee64 : i:float -> st:WriterState -> unit
    val p_char : i:char -> st:WriterState -> unit
    val inline p_tup2 :
      ('T1 -> WriterState -> unit) ->
        ('T2 -> WriterState -> unit) -> ('T1 * 'T2 -> WriterState -> unit)
    val inline p_tup3 :
      ('T1 -> WriterState -> unit) ->
        ('T2 -> WriterState -> unit) ->
          ('T3 -> WriterState -> unit) ->
            ('T1 * 'T2 * 'T3 -> WriterState -> unit)
    val inline p_tup4 :
      ('T1 -> WriterState -> unit) ->
        ('T2 -> WriterState -> unit) ->
          ('T3 -> WriterState -> unit) ->
            ('T4 -> WriterState -> unit) ->
              ('T1 * 'T2 * 'T3 * 'T4 -> WriterState -> unit)
    val inline p_tup5 :
      p1:('a -> WriterState -> unit) ->
        p2:('b -> WriterState -> unit) ->
          p3:('c -> WriterState -> unit) ->
            p4:('d -> WriterState -> unit) ->
              p5:('e -> WriterState -> unit) ->
                a:'a * b:'b * c:'c * d:'d * e:'e -> st:WriterState -> unit
    val inline p_tup6 :
      p1:('a -> WriterState -> unit) ->
        p2:('b -> WriterState -> unit) ->
          p3:('c -> WriterState -> unit) ->
            p4:('d -> WriterState -> unit) ->
              p5:('e -> WriterState -> unit) ->
                p6:('f -> WriterState -> unit) ->
                  a:'a * b:'b * c:'c * d:'d * e:'e * f:'f ->
                    st:WriterState -> unit
    val inline p_tup7 :
      p1:('a -> WriterState -> unit) ->
        p2:('b -> WriterState -> unit) ->
          p3:('c -> WriterState -> unit) ->
            p4:('d -> WriterState -> unit) ->
              p5:('e -> WriterState -> unit) ->
                p6:('f -> WriterState -> unit) ->
                  p7:('g -> WriterState -> unit) ->
                    a:'a * b:'b * c:'c * d:'d * e:'e * f:'f * x7:'g ->
                      st:WriterState -> unit
    val inline p_tup8 :
      p1:('a -> WriterState -> unit) ->
        p2:('b -> WriterState -> unit) ->
          p3:('c -> WriterState -> unit) ->
            p4:('d -> WriterState -> unit) ->
              p5:('e -> WriterState -> unit) ->
                p6:('f -> WriterState -> unit) ->
                  p7:('g -> WriterState -> unit) ->
                    p8:('h -> WriterState -> unit) ->
                      a:'a * b:'b * c:'c * d:'d * e:'e * f:'f * x7:'g * x8:'h ->
                        st:WriterState -> unit
    val inline p_tup9 :
      p1:('a -> WriterState -> unit) ->
        p2:('b -> WriterState -> unit) ->
          p3:('c -> WriterState -> unit) ->
            p4:('d -> WriterState -> unit) ->
              p5:('e -> WriterState -> unit) ->
                p6:('f -> WriterState -> unit) ->
                  p7:('g -> WriterState -> unit) ->
                    p8:('h -> WriterState -> unit) ->
                      p9:('i -> WriterState -> unit) ->
                        a:'a * b:'b * c:'c * d:'d * e:'e * f:'f * x7:'g * x8:'h *
                        x9:'i -> st:WriterState -> unit
    val inline p_tup10 :
      p1:('a -> WriterState -> unit) ->
        p2:('b -> WriterState -> unit) ->
          p3:('c -> WriterState -> unit) ->
            p4:('d -> WriterState -> unit) ->
              p5:('e -> WriterState -> unit) ->
                p6:('f -> WriterState -> unit) ->
                  p7:('g -> WriterState -> unit) ->
                    p8:('h -> WriterState -> unit) ->
                      p9:('i -> WriterState -> unit) ->
                        p10:('j -> WriterState -> unit) ->
                          a:'a * b:'b * c:'c * d:'d * e:'e * f:'f * x7:'g *
                          x8:'h * x9:'i * x10:'j -> st:WriterState -> unit
    val inline p_tup11 :
      p1:('a -> WriterState -> unit) ->
        p2:('b -> WriterState -> unit) ->
          p3:('c -> WriterState -> unit) ->
            p4:('d -> WriterState -> unit) ->
              p5:('e -> WriterState -> unit) ->
                p6:('f -> WriterState -> unit) ->
                  p7:('g -> WriterState -> unit) ->
                    p8:('h -> WriterState -> unit) ->
                      p9:('i -> WriterState -> unit) ->
                        p10:('j -> WriterState -> unit) ->
                          p11:('k -> WriterState -> unit) ->
                            a:'a * b:'b * c:'c * d:'d * e:'e * f:'f * x7:'g *
                            x8:'h * x9:'i * x10:'j * x11:'k ->
                              st:WriterState -> unit
    val u_byte : ReaderState -> int
    type unpickler<'T> = ReaderState -> 'T
    val u_bool : ReaderState -> bool
    val prim_u_int32 : st:ReaderState -> int
    val u_int32 : st:ReaderState -> int
    val u_byte_memory : st:ReaderState -> AbstractIL.Internal.ReadOnlyByteMemory
    val u_bytes : st:ReaderState -> byte []
    val u_prim_string : st:ReaderState -> string
    val u_int : ReaderState -> int
    val u_int8 : st:ReaderState -> sbyte
    val u_uint8 : st:ReaderState -> byte
    val u_int16 : st:ReaderState -> int16
    val u_uint16 : st:ReaderState -> uint16
    val u_uint32 : st:ReaderState -> uint32
    val u_int64 : st:ReaderState -> int64
    val u_uint64 : st:ReaderState -> uint64
    val float32_of_bits : x:int32 -> float32
    val float_of_bits : x:int64 -> float
    val u_single : st:ReaderState -> float32
    val u_double : st:ReaderState -> float
    val u_ieee64 : st:ReaderState -> float
    val u_char : st:ReaderState -> char
    val u_space : n:int -> st:ReaderState -> unit
    val u_used_space1 : f:(ReaderState -> 'a) -> st:ReaderState -> 'a option
    val inline u_tup2 :
      (ReaderState -> 'T2) -> (ReaderState -> 'T3) -> (ReaderState -> 'T2 * 'T3)
    val inline u_tup3 :
      (ReaderState -> 'T2) ->
        (ReaderState -> 'T3) ->
          (ReaderState -> 'T4) -> (ReaderState -> 'T2 * 'T3 * 'T4)
    val inline u_tup4 :
      (ReaderState -> 'T2) ->
        (ReaderState -> 'T3) ->
          (ReaderState -> 'T4) ->
            (ReaderState -> 'T5) -> (ReaderState -> 'T2 * 'T3 * 'T4 * 'T5)
    val inline u_tup5 :
      p1:(ReaderState -> 'a) ->
        p2:(ReaderState -> 'b) ->
          p3:(ReaderState -> 'c) ->
            p4:(ReaderState -> 'd) ->
              p5:(ReaderState -> 'e) -> st:ReaderState -> 'a * 'b * 'c * 'd * 'e
    val inline u_tup6 :
      p1:(ReaderState -> 'a) ->
        p2:(ReaderState -> 'b) ->
          p3:(ReaderState -> 'c) ->
            p4:(ReaderState -> 'd) ->
              p5:(ReaderState -> 'e) ->
                p6:(ReaderState -> 'f) ->
                  st:ReaderState -> 'a * 'b * 'c * 'd * 'e * 'f
    val inline u_tup7 :
      p1:(ReaderState -> 'a) ->
        p2:(ReaderState -> 'b) ->
          p3:(ReaderState -> 'c) ->
            p4:(ReaderState -> 'd) ->
              p5:(ReaderState -> 'e) ->
                p6:(ReaderState -> 'f) ->
                  p7:(ReaderState -> 'g) ->
                    st:ReaderState -> 'a * 'b * 'c * 'd * 'e * 'f * 'g
    val inline u_tup8 :
      p1:(ReaderState -> 'a) ->
        p2:(ReaderState -> 'b) ->
          p3:(ReaderState -> 'c) ->
            p4:(ReaderState -> 'd) ->
              p5:(ReaderState -> 'e) ->
                p6:(ReaderState -> 'f) ->
                  p7:(ReaderState -> 'g) ->
                    p8:(ReaderState -> 'h) ->
                      st:ReaderState -> 'a * 'b * 'c * 'd * 'e * 'f * 'g * 'h
    val inline u_tup9 :
      p1:(ReaderState -> 'a) ->
        p2:(ReaderState -> 'b) ->
          p3:(ReaderState -> 'c) ->
            p4:(ReaderState -> 'd) ->
              p5:(ReaderState -> 'e) ->
                p6:(ReaderState -> 'f) ->
                  p7:(ReaderState -> 'g) ->
                    p8:(ReaderState -> 'h) ->
                      p9:(ReaderState -> 'i) ->
                        st:ReaderState ->
                          'a * 'b * 'c * 'd * 'e * 'f * 'g * 'h * 'i
    val inline u_tup10 :
      p1:(ReaderState -> 'a) ->
        p2:(ReaderState -> 'b) ->
          p3:(ReaderState -> 'c) ->
            p4:(ReaderState -> 'd) ->
              p5:(ReaderState -> 'e) ->
                p6:(ReaderState -> 'f) ->
                  p7:(ReaderState -> 'g) ->
                    p8:(ReaderState -> 'h) ->
                      p9:(ReaderState -> 'i) ->
                        p10:(ReaderState -> 'j) ->
                          st:ReaderState ->
                            'a * 'b * 'c * 'd * 'e * 'f * 'g * 'h * 'i * 'j
    val inline u_tup11 :
      p1:(ReaderState -> 'a) ->
        p2:(ReaderState -> 'b) ->
          p3:(ReaderState -> 'c) ->
            p4:(ReaderState -> 'd) ->
              p5:(ReaderState -> 'e) ->
                p6:(ReaderState -> 'f) ->
                  p7:(ReaderState -> 'g) ->
                    p8:(ReaderState -> 'h) ->
                      p9:(ReaderState -> 'i) ->
                        p10:(ReaderState -> 'j) ->
                          p11:(ReaderState -> 'k) ->
                            st:ReaderState ->
                              'a * 'b * 'c * 'd * 'e * 'f * 'g * 'h * 'i * 'j *
                              'k
    val inline u_tup12 :
      p1:(ReaderState -> 'a) ->
        p2:(ReaderState -> 'b) ->
          p3:(ReaderState -> 'c) ->
            p4:(ReaderState -> 'd) ->
              p5:(ReaderState -> 'e) ->
                p6:(ReaderState -> 'f) ->
                  p7:(ReaderState -> 'g) ->
                    p8:(ReaderState -> 'h) ->
                      p9:(ReaderState -> 'i) ->
                        p10:(ReaderState -> 'j) ->
                          p11:(ReaderState -> 'k) ->
                            p12:(ReaderState -> 'l) ->
                              st:ReaderState ->
                                'a * 'b * 'c * 'd * 'e * 'f * 'g * 'h * 'i * 'j *
                                'k * 'l
    val inline u_tup13 :
      p1:(ReaderState -> 'a) ->
        p2:(ReaderState -> 'b) ->
          p3:(ReaderState -> 'c) ->
            p4:(ReaderState -> 'd) ->
              p5:(ReaderState -> 'e) ->
                p6:(ReaderState -> 'f) ->
                  p7:(ReaderState -> 'g) ->
                    p8:(ReaderState -> 'h) ->
                      p9:(ReaderState -> 'i) ->
                        p10:(ReaderState -> 'j) ->
                          p11:(ReaderState -> 'k) ->
                            p12:(ReaderState -> 'l) ->
                              p13:(ReaderState -> 'm) ->
                                st:ReaderState ->
                                  'a * 'b * 'c * 'd * 'e * 'f * 'g * 'h * 'i *
                                  'j * 'k * 'l * 'm
    val inline u_tup14 :
      p1:(ReaderState -> 'a) ->
        p2:(ReaderState -> 'b) ->
          p3:(ReaderState -> 'c) ->
            p4:(ReaderState -> 'd) ->
              p5:(ReaderState -> 'e) ->
                p6:(ReaderState -> 'f) ->
                  p7:(ReaderState -> 'g) ->
                    p8:(ReaderState -> 'h) ->
                      p9:(ReaderState -> 'i) ->
                        p10:(ReaderState -> 'j) ->
                          p11:(ReaderState -> 'k) ->
                            p12:(ReaderState -> 'l) ->
                              p13:(ReaderState -> 'm) ->
                                p14:(ReaderState -> 'n) ->
                                  st:ReaderState ->
                                    'a * 'b * 'c * 'd * 'e * 'f * 'g * 'h * 'i *
                                    'j * 'k * 'l * 'm * 'n
    val inline u_tup15 :
      p1:(ReaderState -> 'a) ->
        p2:(ReaderState -> 'b) ->
          p3:(ReaderState -> 'c) ->
            p4:(ReaderState -> 'd) ->
              p5:(ReaderState -> 'e) ->
                p6:(ReaderState -> 'f) ->
                  p7:(ReaderState -> 'g) ->
                    p8:(ReaderState -> 'h) ->
                      p9:(ReaderState -> 'i) ->
                        p10:(ReaderState -> 'j) ->
                          p11:(ReaderState -> 'k) ->
                            p12:(ReaderState -> 'l) ->
                              p13:(ReaderState -> 'm) ->
                                p14:(ReaderState -> 'n) ->
                                  p15:(ReaderState -> 'o) ->
                                    st:ReaderState ->
                                      'a * 'b * 'c * 'd * 'e * 'f * 'g * 'h * 'i *
                                      'j * 'k * 'l * 'm * 'n * 'o
    val inline u_tup16 :
      p1:(ReaderState -> 'a) ->
        p2:(ReaderState -> 'b) ->
          p3:(ReaderState -> 'c) ->
            p4:(ReaderState -> 'd) ->
              p5:(ReaderState -> 'e) ->
                p6:(ReaderState -> 'f) ->
                  p7:(ReaderState -> 'g) ->
                    p8:(ReaderState -> 'h) ->
                      p9:(ReaderState -> 'i) ->
                        p10:(ReaderState -> 'j) ->
                          p11:(ReaderState -> 'k) ->
                            p12:(ReaderState -> 'l) ->
                              p13:(ReaderState -> 'm) ->
                                p14:(ReaderState -> 'n) ->
                                  p15:(ReaderState -> 'o) ->
                                    p16:(ReaderState -> 'p) ->
                                      st:ReaderState ->
                                        'a * 'b * 'c * 'd * 'e * 'f * 'g * 'h *
                                        'i * 'j * 'k * 'l * 'm * 'n * 'o * 'p
    val inline u_tup17 :
      p1:(ReaderState -> 'a) ->
        p2:(ReaderState -> 'b) ->
          p3:(ReaderState -> 'c) ->
            p4:(ReaderState -> 'd) ->
              p5:(ReaderState -> 'e) ->
                p6:(ReaderState -> 'f) ->
                  p7:(ReaderState -> 'g) ->
                    p8:(ReaderState -> 'h) ->
                      p9:(ReaderState -> 'i) ->
                        p10:(ReaderState -> 'j) ->
                          p11:(ReaderState -> 'k) ->
                            p12:(ReaderState -> 'l) ->
                              p13:(ReaderState -> 'm) ->
                                p14:(ReaderState -> 'n) ->
                                  p15:(ReaderState -> 'o) ->
                                    p16:(ReaderState -> 'p) ->
                                      p17:(ReaderState -> 'q) ->
                                        st:ReaderState ->
                                          'a * 'b * 'c * 'd * 'e * 'f * 'g * 'h *
                                          'i * 'j * 'k * 'l * 'm * 'n * 'o * 'p *
                                          'q
    val p_osgn_ref :
      _ctxt:string ->
        outMap:NodeOutTable<'a,'b> -> x:'b -> st:WriterState -> unit
    val p_osgn_decl :
      outMap:NodeOutTable<'a,'b> ->
        p:('a -> WriterState -> unit) -> x:'b -> st:WriterState -> unit
    val u_osgn_ref : inMap:NodeInTable<'a,'b> -> st:ReaderState -> 'b
    val u_osgn_decl :
      inMap:NodeInTable<'a,'b> -> u:(ReaderState -> 'a) -> st:ReaderState -> 'b
    val encode_uniq : tbl:Table<'a> -> key:'a -> int
    val lookup_uniq : st:ReaderState -> tbl:InputTable<'a> -> n:int -> 'a
    val p_array_core : f:('T -> 'a -> unit) -> x:'T [] -> st:'a -> unit
    val p_array : ('T -> WriterState -> unit) -> ('T [] -> WriterState -> unit)
    val p_array_ext :
      extraf:(WriterState -> unit) option ->
        f:('T -> WriterState -> unit) -> x:'T [] -> st:WriterState -> unit
    val p_list_core : f:('T -> 'a -> unit) -> xs:'T list -> st:'a -> unit
    val p_list :
      f:('a -> WriterState -> unit) -> x:'a list -> st:WriterState -> unit
    val p_list_ext :
      extraf:(WriterState -> unit) option ->
        f:('a -> WriterState -> unit) -> x:'a list -> st:WriterState -> unit
    val p_List :
      f:('T -> WriterState -> unit) -> x:'T list -> st:WriterState -> unit
    val p_wrap : f:('T -> 'U) -> p:'U pickler -> x:'T -> st:WriterState -> unit
    val p_option :
      f:('a -> WriterState -> unit) -> x:'a option -> st:WriterState -> unit
    val private p_lazy_impl :
      p:('a -> WriterState -> unit) -> v:'a -> st:WriterState -> unit
    val p_lazy :
      ('T -> WriterState -> unit) -> (System.Lazy<'T> -> WriterState -> unit)
    val p_maybe_lazy :
      p:('a -> WriterState -> unit) ->
        x:Lib.MaybeLazy<'a> -> st:WriterState -> unit
    val p_hole :
      unit -> (('a -> WriterState -> 'b) -> unit) * ('a -> WriterState -> 'b)
    val p_hole2 :
      unit ->
        (('a -> 'b -> WriterState -> 'c) -> unit) *
        ('a -> 'b -> WriterState -> 'c)
    val u_array_core : f:('a -> 'b) -> n:int -> st:'a -> 'b []
    val u_array : (ReaderState -> 'T) -> (ReaderState -> 'T [])
    val u_array_ext :
      extraf:(ReaderState -> 'a) ->
        f:(ReaderState -> 'b) -> st:ReaderState -> 'a option * 'b []
    val u_list_core : f:('a -> 'b) -> n:int -> st:'a -> 'b list
    val u_list : f:(ReaderState -> 'a) -> st:ReaderState -> 'a list
    val u_list_ext :
      extra:(ReaderState -> 'a) ->
        f:(ReaderState -> 'b) -> st:ReaderState -> 'a option * 'b list
    val u_List : f:(ReaderState -> 'a) -> st:ReaderState -> 'a list
    val u_array_revi : f:(ReaderState -> int -> 'a) -> st:ReaderState -> 'a []
    val u_list_revi : f:(ReaderState -> int -> 'a) -> st:ReaderState -> 'a list
    val u_wrap : f:('U -> 'T) -> u:unpickler<'U> -> st:ReaderState -> 'T
    val u_option : f:(ReaderState -> 'a) -> st:ReaderState -> 'a option
    val u_lazy : (ReaderState -> 'T) -> (ReaderState -> System.Lazy<'T>)
    val u_hole : unit -> ((ReaderState -> 'a) -> unit) * (ReaderState -> 'a)
    val encode_string : stringTab:Table<'a> -> x:'a -> int
    val decode_string : x:'a -> 'a
    val lookup_string :
      st:ReaderState -> stringTab:InputTable<'a> -> x:int -> 'a
    val u_encoded_string : (ReaderState -> string)
    val u_string : ReaderState -> string
    val u_strings : (ReaderState -> string list)
    val u_ints : (ReaderState -> int list)
    val p_encoded_string : (string -> WriterState -> unit)
    val p_string : string -> WriterState -> unit
    val p_strings : (string list -> WriterState -> unit)
    val p_ints : (int list -> WriterState -> unit)
    val encode_ccuref : ccuTab:Table<string> -> x:TypedTree.CcuThunk -> int
    val decode_ccuref : x:'a -> 'a
    val lookup_ccuref : st:ReaderState -> ccuTab:InputTable<'a> -> x:int -> 'a
    val u_encoded_ccuref : st:ReaderState -> string
    val u_ccuref : st:ReaderState -> TypedTree.CcuThunk
    val p_encoded_ccuref : x:string -> st:WriterState -> unit
    val p_ccuref : s:TypedTree.CcuThunk -> st:WriterState -> unit
    val decode_pubpath :
      st:ReaderState ->
        stringTab:InputTable<string> -> a:int [] -> TypedTree.PublicPath
    val lookup_pubpath :
      st:ReaderState -> pubpathTab:InputTable<'a> -> x:int -> 'a
    val u_encoded_pubpath : (ReaderState -> int [])
    val u_pubpath : st:ReaderState -> TypedTree.PublicPath
    val encode_pubpath :
      stringTab:Table<string> ->
        pubpathTab:Table<int []> -> TypedTree.PublicPath -> int
    val p_encoded_pubpath : (int [] -> WriterState -> unit)
    val p_pubpath : x:TypedTree.PublicPath -> st:WriterState -> unit
    val decode_nleref :
      st:ReaderState ->
        ccuTab:InputTable<TypedTree.CcuThunk> ->
          stringTab:InputTable<string> ->
            a:int * b:int [] -> TypedTree.NonLocalEntityRef
    val lookup_nleref :
      st:ReaderState -> nlerefTab:InputTable<'a> -> x:int -> 'a
    val u_encoded_nleref : (ReaderState -> int * int [])
    val u_nleref : st:ReaderState -> TypedTree.NonLocalEntityRef
    val encode_nleref :
      ccuTab:Table<string> ->
        stringTab:Table<string> ->
          nlerefTab:Table<int * int []> ->
            thisCcu:TypedTree.CcuThunk ->
              nleref:TypedTree.NonLocalEntityRef -> int
    val p_encoded_nleref : (int * int [] -> WriterState -> unit)
    val p_nleref : x:TypedTree.NonLocalEntityRef -> st:WriterState -> unit
    val decode_simpletyp :
      st:ReaderState ->
        _ccuTab:'a ->
          _stringTab:'b ->
            nlerefTab:InputTable<TypedTree.NonLocalEntityRef> ->
              a:int -> TypedTree.TType
    val lookup_simpletyp :
      st:ReaderState -> simpleTyTab:InputTable<'a> -> x:int -> 'a
    val u_encoded_simpletyp : st:ReaderState -> int
    val u_encoded_anoninfo : st:ReaderState -> int
    val u_simpletyp : st:ReaderState -> TypedTree.TType
    val encode_simpletyp :
      ccuTab:Table<string> ->
        stringTab:Table<string> ->
          nlerefTab:Table<int * int []> ->
            simpleTyTab:Table<int> ->
              thisCcu:TypedTree.CcuThunk -> a:TypedTree.NonLocalEntityRef -> int
    val p_encoded_simpletyp : x:int -> st:WriterState -> unit
    val p_encoded_anoninfo : x:int -> st:WriterState -> unit
    val p_simpletyp : x:TypedTree.NonLocalEntityRef -> st:WriterState -> unit
    val pickleObjWithDanglingCcus :
      inMem:bool ->
        file:string ->
          TcGlobals.TcGlobals ->
            scope:TypedTree.CcuThunk ->
              ('T -> WriterState -> unit) -> 'T -> byte []
    val check :
      ilscope:AbstractIL.IL.ILScopeRef -> inMap:NodeInTable<'a,'b> -> unit
    val unpickleObjWithDanglingCcus :
      file:string ->
        viewedScope:AbstractIL.IL.ILScopeRef ->
          ilModule:AbstractIL.IL.ILModuleDef option ->
            (ReaderState -> 'T) ->
              AbstractIL.Internal.ReadOnlyByteMemory ->
                PickledDataWithReferences<'T>
    val p_ILPublicKey : x:AbstractIL.IL.PublicKey -> st:WriterState -> unit
    val p_ILVersion : x:AbstractIL.IL.ILVersionInfo -> st:WriterState -> unit
    val p_ILModuleRef : x:AbstractIL.IL.ILModuleRef -> st:WriterState -> unit
    val p_ILAssemblyRef :
      x:AbstractIL.IL.ILAssemblyRef -> st:WriterState -> unit
    val p_ILScopeRef : x:AbstractIL.IL.ILScopeRef -> st:WriterState -> unit
    val u_ILPublicKey : st:ReaderState -> AbstractIL.IL.PublicKey
    val u_ILVersion : st:ReaderState -> AbstractIL.IL.ILVersionInfo
    val u_ILModuleRef : st:ReaderState -> AbstractIL.IL.ILModuleRef
    val u_ILAssemblyRef : st:ReaderState -> AbstractIL.IL.ILAssemblyRef
    val u_ILScopeRef : st:ReaderState -> AbstractIL.IL.ILScopeRef
    val p_ILHasThis : x:AbstractIL.IL.ILThisConvention -> st:WriterState -> unit
    val p_ILArrayShape : AbstractIL.IL.ILArrayShape pickler
    val p_ILType : ty:AbstractIL.IL.ILType -> st:WriterState -> unit
    val p_ILTypes : tys:AbstractIL.IL.ILType list -> (WriterState -> unit)
    val p_ILBasicCallConv :
      x:AbstractIL.IL.ILArgConvention -> st:WriterState -> unit
    val p_ILCallConv : AbstractIL.IL.ILCallingConv -> st:WriterState -> unit
    val p_ILCallSig :
      x:AbstractIL.IL.ILCallingSignature -> st:WriterState -> unit
    val p_ILTypeRef : x:AbstractIL.IL.ILTypeRef -> st:WriterState -> unit
    val p_ILTypeSpec : a:AbstractIL.IL.ILTypeSpec -> st:WriterState -> unit
    val u_ILBasicCallConv : st:ReaderState -> AbstractIL.IL.ILArgConvention
    val u_ILHasThis : st:ReaderState -> AbstractIL.IL.ILThisConvention
    val u_ILCallConv : st:ReaderState -> AbstractIL.IL.ILCallingConv
    val u_ILTypeRef : st:ReaderState -> AbstractIL.IL.ILTypeRef
    val u_ILArrayShape : unpickler<AbstractIL.IL.ILArrayShape>
    val u_ILType : st:ReaderState -> AbstractIL.IL.ILType
    val u_ILTypes : st:ReaderState -> AbstractIL.IL.ILType list
    val u_ILCallSig : (ReaderState -> AbstractIL.IL.ILCallingSignature)
    val u_ILTypeSpec : st:ReaderState -> AbstractIL.IL.ILTypeSpec
    val p_ILMethodRef : x:AbstractIL.IL.ILMethodRef -> st:WriterState -> unit
    val p_ILFieldRef : x:AbstractIL.IL.ILFieldRef -> st:WriterState -> unit
    val p_ILMethodSpec : x:AbstractIL.IL.ILMethodSpec -> st:WriterState -> unit
    val p_ILFieldSpec : x:AbstractIL.IL.ILFieldSpec -> st:WriterState -> unit
    val p_ILBasicType : x:AbstractIL.IL.ILBasicType -> st:WriterState -> unit
    val p_ILVolatility : x:AbstractIL.IL.ILVolatility -> st:WriterState -> unit
    val p_ILReadonly : x:AbstractIL.IL.ILReadonly -> st:WriterState -> unit
    val u_ILMethodRef : st:ReaderState -> AbstractIL.IL.ILMethodRef
    val u_ILFieldRef : st:ReaderState -> AbstractIL.IL.ILFieldRef
    val u_ILMethodSpec : st:ReaderState -> AbstractIL.IL.ILMethodSpec
    val u_ILFieldSpec : st:ReaderState -> AbstractIL.IL.ILFieldSpec
    val u_ILBasicType : st:ReaderState -> AbstractIL.IL.ILBasicType
    val u_ILVolatility : st:ReaderState -> AbstractIL.IL.ILVolatility
    val u_ILReadonly : st:ReaderState -> AbstractIL.IL.ILReadonly
    [<LiteralAttribute ()>]
    val itag_nop : int = 0
    [<LiteralAttribute ()>]
    val itag_ldarg : int = 1
    [<LiteralAttribute ()>]
    val itag_ldnull : int = 2
    [<LiteralAttribute ()>]
    val itag_ilzero : int = 3
    [<LiteralAttribute ()>]
    val itag_call : int = 4
    [<LiteralAttribute ()>]
    val itag_add : int = 5
    [<LiteralAttribute ()>]
    val itag_sub : int = 6
    [<LiteralAttribute ()>]
    val itag_mul : int = 7
    [<LiteralAttribute ()>]
    val itag_div : int = 8
    [<LiteralAttribute ()>]
    val itag_div_un : int = 9
    [<LiteralAttribute ()>]
    val itag_rem : int = 10
    [<LiteralAttribute ()>]
    val itag_rem_un : int = 11
    [<LiteralAttribute ()>]
    val itag_and : int = 12
    [<LiteralAttribute ()>]
    val itag_or : int = 13
    [<LiteralAttribute ()>]
    val itag_xor : int = 14
    [<LiteralAttribute ()>]
    val itag_shl : int = 15
    [<LiteralAttribute ()>]
    val itag_shr : int = 16
    [<LiteralAttribute ()>]
    val itag_shr_un : int = 17
    [<LiteralAttribute ()>]
    val itag_neg : int = 18
    [<LiteralAttribute ()>]
    val itag_not : int = 19
    [<LiteralAttribute ()>]
    val itag_conv : int = 20
    [<LiteralAttribute ()>]
    val itag_conv_un : int = 21
    [<LiteralAttribute ()>]
    val itag_conv_ovf : int = 22
    [<LiteralAttribute ()>]
    val itag_conv_ovf_un : int = 23
    [<LiteralAttribute ()>]
    val itag_callvirt : int = 24
    [<LiteralAttribute ()>]
    val itag_ldobj : int = 25
    [<LiteralAttribute ()>]
    val itag_ldstr : int = 26
    [<LiteralAttribute ()>]
    val itag_castclass : int = 27
    [<LiteralAttribute ()>]
    val itag_isinst : int = 28
    [<LiteralAttribute ()>]
    val itag_unbox : int = 29
    [<LiteralAttribute ()>]
    val itag_throw : int = 30
    [<LiteralAttribute ()>]
    val itag_ldfld : int = 31
    [<LiteralAttribute ()>]
    val itag_ldflda : int = 32
    [<LiteralAttribute ()>]
    val itag_stfld : int = 33
    [<LiteralAttribute ()>]
    val itag_ldsfld : int = 34
    [<LiteralAttribute ()>]
    val itag_ldsflda : int = 35
    [<LiteralAttribute ()>]
    val itag_stsfld : int = 36
    [<LiteralAttribute ()>]
    val itag_stobj : int = 37
    [<LiteralAttribute ()>]
    val itag_box : int = 38
    [<LiteralAttribute ()>]
    val itag_newarr : int = 39
    [<LiteralAttribute ()>]
    val itag_ldlen : int = 40
    [<LiteralAttribute ()>]
    val itag_ldelema : int = 41
    [<LiteralAttribute ()>]
    val itag_ckfinite : int = 42
    [<LiteralAttribute ()>]
    val itag_ldtoken : int = 43
    [<LiteralAttribute ()>]
    val itag_add_ovf : int = 44
    [<LiteralAttribute ()>]
    val itag_add_ovf_un : int = 45
    [<LiteralAttribute ()>]
    val itag_mul_ovf : int = 46
    [<LiteralAttribute ()>]
    val itag_mul_ovf_un : int = 47
    [<LiteralAttribute ()>]
    val itag_sub_ovf : int = 48
    [<LiteralAttribute ()>]
    val itag_sub_ovf_un : int = 49
    [<LiteralAttribute ()>]
    val itag_ceq : int = 50
    [<LiteralAttribute ()>]
    val itag_cgt : int = 51
    [<LiteralAttribute ()>]
    val itag_cgt_un : int = 52
    [<LiteralAttribute ()>]
    val itag_clt : int = 53
    [<LiteralAttribute ()>]
    val itag_clt_un : int = 54
    [<LiteralAttribute ()>]
    val itag_ldvirtftn : int = 55
    [<LiteralAttribute ()>]
    val itag_localloc : int = 56
    [<LiteralAttribute ()>]
    val itag_rethrow : int = 57
    [<LiteralAttribute ()>]
    val itag_sizeof : int = 58
    [<LiteralAttribute ()>]
    val itag_ldelem_any : int = 59
    [<LiteralAttribute ()>]
    val itag_stelem_any : int = 60
    [<LiteralAttribute ()>]
    val itag_unbox_any : int = 61
    [<LiteralAttribute ()>]
    val itag_ldlen_multi : int = 62
    [<LiteralAttribute ()>]
    val itag_initobj : int = 63
    [<LiteralAttribute ()>]
    val itag_initblk : int = 64
    [<LiteralAttribute ()>]
    val itag_cpobj : int = 65
    [<LiteralAttribute ()>]
    val itag_cpblk : int = 66
    val simple_instrs : (int * AbstractIL.IL.ILInstr) list
    val encode_table :
      System.Collections.Generic.Dictionary<AbstractIL.IL.ILInstr,int>
    val encode_instr : si:AbstractIL.IL.ILInstr -> int
    val isNoArgInstr : s:AbstractIL.IL.ILInstr -> bool
    val decoders : (int * (ReaderState -> AbstractIL.IL.ILInstr)) list
    val decode_tab : (ReaderState -> AbstractIL.IL.ILInstr) []
    val p_ILInstr : x:AbstractIL.IL.ILInstr -> st:WriterState -> unit
    val u_ILInstr : st:ReaderState -> AbstractIL.IL.ILInstr
    val p_Map_core :
      pk:('a -> 'b -> unit) ->
        pv:('c -> 'b -> unit) -> xs:Map<'a,'c> -> st:'b -> unit
        when 'a : comparison
    val p_Map :
      pk:('a -> WriterState -> unit) ->
        pv:('b -> WriterState -> unit) -> x:Map<'a,'b> -> st:WriterState -> unit
        when 'a : comparison
    val p_qlist :
      pv:('a -> WriterState -> unit) -> Internal.Utilities.QueueList<'a> pickler
    val p_namemap :
      ('T -> WriterState -> unit) -> (Map<string,'T> -> WriterState -> unit)
    val u_Map_core :
      uk:('a -> 'b) -> uv:('a -> 'c) -> n:int -> st:'a -> Map<'b,'c>
        when 'b : comparison
    val u_Map :
      uk:(ReaderState -> 'a) ->
        uv:(ReaderState -> 'b) -> st:ReaderState -> Map<'a,'b>
        when 'a : comparison
    val u_qlist :
      uv:(ReaderState -> 'a) -> unpickler<Internal.Utilities.QueueList<'a>>
    val u_namemap : (ReaderState -> 'T) -> (ReaderState -> Map<string,'T>)
    val p_pos : x:Range.pos -> st:WriterState -> unit
    val p_range : x:Range.range -> st:WriterState -> unit
    val p_dummy_range : _x:Range.range -> _st:WriterState -> unit
    val p_ident : x:SyntaxTree.Ident -> st:WriterState -> unit
    val p_xmldoc : doc:XmlDoc.XmlDoc -> st:WriterState -> unit
    val u_pos : st:ReaderState -> Range.pos
    val u_range : st:ReaderState -> Range.range
    val u_dummy_range : _st:ReaderState -> Range.range
    val u_ident : st:ReaderState -> SyntaxTree.Ident
    val u_xmldoc : st:ReaderState -> XmlDoc.XmlDoc
    val p_local_item_ref :
      ctxt:string -> tab:NodeOutTable<'a,'b> -> st:'b -> (WriterState -> unit)
    val p_tcref : string -> (TypedTree.EntityRef -> WriterState -> unit)
    val p_ucref : (TypedTree.UnionCaseRef -> WriterState -> unit)
    val p_rfref : TypedTree.RecdFieldRef -> st:WriterState -> unit
    val p_tpref : x:TypedTree.Typar -> st:WriterState -> unit
    val u_local_item_ref : tab:NodeInTable<'a,'b> -> st:ReaderState -> 'b
    val u_tcref : (ReaderState -> TypedTree.EntityRef)
    val u_ucref : (ReaderState -> TypedTree.UnionCaseRef)
    val u_rfref : st:ReaderState -> TypedTree.RecdFieldRef
    val u_tpref : st:ReaderState -> TypedTree.Typar
    val p_ty2 : (bool -> TypedTree.TType -> WriterState -> unit)
    val fill_p_ty2 : ((bool -> TypedTree.TType -> WriterState -> unit) -> unit)
    val p_ty : (TypedTree.TType -> WriterState -> unit)
    val p_tys : (TypedTree.TType list -> WriterState -> unit)
    val p_attribs : (TypedTree.Attribs -> WriterState -> unit)
    val fill_p_attribs : ((TypedTree.Attribs -> WriterState -> unit) -> unit)
    val checkForInRefStructThisArg :
      st:WriterState -> ty:TypedTree.TType -> bool
    val p_nonlocal_val_ref :
      nlv:TypedTree.NonLocalValOrMemberRef -> st:WriterState -> unit
    val p_vref : string -> (TypedTree.ValRef -> WriterState -> unit)
    val p_vrefs : ctxt:string -> (TypedTree.ValRef list -> WriterState -> unit)
    val u_ty : (ReaderState -> TypedTree.TType)
    val fill_u_ty : ((ReaderState -> TypedTree.TType) -> unit)
    val u_tys : (ReaderState -> TypedTree.TType list)
    val u_attribs : (ReaderState -> TypedTree.Attrib list)
    val fill_u_attribs : ((ReaderState -> TypedTree.Attrib list) -> unit)
    val u_nonlocal_val_ref : st:ReaderState -> TypedTree.NonLocalValOrMemberRef
    val u_vref : (ReaderState -> TypedTree.ValRef)
    val u_vrefs : (ReaderState -> TypedTree.ValRef list)
    val p_kind : x:TypedTree.TyparKind -> st:WriterState -> unit
    val p_member_kind : x:SyntaxTree.MemberKind -> st:WriterState -> unit
    val u_kind : st:ReaderState -> TypedTree.TyparKind
    val u_member_kind : st:ReaderState -> SyntaxTree.MemberKind
    val p_MemberFlags : x:SyntaxTree.MemberFlags -> st:WriterState -> unit
    val u_MemberFlags : st:ReaderState -> SyntaxTree.MemberFlags
    val u_expr_fwd : (ReaderState -> TypedTree.Expr)
    val fill_u_Expr_hole : ((ReaderState -> TypedTree.Expr) -> unit)
    val p_expr_fwd : (TypedTree.Expr -> WriterState -> unit)
    val fill_p_Expr_hole : ((TypedTree.Expr -> WriterState -> unit) -> unit)
    val p_anonInfo_data :
      anonInfo:TypedTree.AnonRecdTypeInfo -> st:WriterState -> unit
    val p_anonInfo : x:TypedTree.AnonRecdTypeInfo -> st:WriterState -> unit
    val p_trait_sln : sln:TypedTree.TraitConstraintSln -> st:WriterState -> unit
    val p_trait : TypedTree.TraitConstraintInfo -> st:WriterState -> unit
    val u_anonInfo_data : st:ReaderState -> TypedTree.AnonRecdTypeInfo
    val u_anonInfo : st:ReaderState -> TypedTree.AnonRecdTypeInfo
    val u_trait_sln : st:ReaderState -> TypedTree.TraitConstraintSln
    val u_trait : st:ReaderState -> TypedTree.TraitConstraintInfo
    val p_rational : q:Rational.Rational -> st:WriterState -> unit
    val p_measure_con : tcref:TypedTree.EntityRef -> st:WriterState -> unit
    val p_measure_var : v:TypedTree.Typar -> st:WriterState -> unit
    val p_measure_one : (WriterState -> unit)
    val p_measure_varcon : unt:TypedTree.Measure -> st:WriterState -> unit
    val p_measure_pospower :
      unt:TypedTree.Measure -> n:int -> st:WriterState -> unit
    val p_measure_intpower :
      unt:TypedTree.Measure -> n:int -> st:WriterState -> unit
    val p_measure_power :
      unt:TypedTree.Measure -> q:Rational.Rational -> st:WriterState -> unit
    val p_normalized_measure : unt:TypedTree.Measure -> st:WriterState -> unit
    val p_measure_expr : unt:TypedTree.Measure -> st:WriterState -> unit
    val u_rational : st:ReaderState -> Rational.Rational
    val u_measure_expr : st:ReaderState -> TypedTree.Measure
    val p_tyar_constraint :
      x:TypedTree.TyparConstraint -> st:WriterState -> unit
    val p_tyar_constraints :
      (TypedTree.TyparConstraint list -> WriterState -> unit)
    val u_tyar_constraint : st:ReaderState -> (int -> TypedTree.TyparConstraint)
    val u_tyar_constraints : (ReaderState -> TypedTree.TyparConstraint list)
    val p_tyar_spec_data : x:TypedTree.Typar -> st:WriterState -> unit
    val p_tyar_spec : x:TypedTree.Typar -> st:WriterState -> unit
    val p_tyar_specs : (TypedTree.Typar list -> WriterState -> unit)
    val u_tyar_spec_data : st:ReaderState -> TypedTree.Typar
    val u_tyar_spec : st:ReaderState -> TypedTree.Typar
    val u_tyar_specs : (ReaderState -> TypedTree.Typar list)
    val p_binds : (TypedTree.Bindings -> WriterState -> unit)
    val fill_p_binds : ((TypedTree.Bindings -> WriterState -> unit) -> unit)
    val p_targets : (TypedTree.DecisionTreeTarget array -> WriterState -> unit)
    val fill_p_targets :
      ((TypedTree.DecisionTreeTarget array -> WriterState -> unit) -> unit)
    val p_Exprs : (TypedTree.Exprs -> WriterState -> unit)
    val fill_p_Exprs : ((TypedTree.Exprs -> WriterState -> unit) -> unit)
    val p_constraints :
      (TypedTree.StaticOptimization list -> WriterState -> unit)
    val fill_p_constraints :
      ((TypedTree.StaticOptimization list -> WriterState -> unit) -> unit)
    val p_Vals : (TypedTree.Val list -> WriterState -> unit)
    val fill_p_Vals : ((TypedTree.Val list -> WriterState -> unit) -> unit)
    val u_binds : (ReaderState -> TypedTree.Bindings)
    val fill_u_binds : ((ReaderState -> TypedTree.Bindings) -> unit)
    val u_targets : (ReaderState -> TypedTree.DecisionTreeTarget array)
    val fill_u_targets :
      ((ReaderState -> TypedTree.DecisionTreeTarget array) -> unit)
    val u_Exprs : (ReaderState -> TypedTree.Exprs)
    val fill_u_Exprs : ((ReaderState -> TypedTree.Exprs) -> unit)
    val u_constraints : (ReaderState -> TypedTree.StaticOptimization list)
    val fill_u_constraints :
      ((ReaderState -> TypedTree.StaticOptimization list) -> unit)
    val u_Vals : (ReaderState -> TypedTree.Val list)
    val fill_u_Vals : ((ReaderState -> TypedTree.Val list) -> unit)
    val p_ArgReprInfo : x:TypedTree.ArgReprInfo -> st:WriterState -> unit
    val p_TyparReprInfo : TypedTree.TyparReprInfo -> st:WriterState -> unit
    val p_ValReprInfo : TypedTree.ValReprInfo -> st:WriterState -> unit
    val u_ArgReprInfo : st:ReaderState -> TypedTree.ArgReprInfo
    val u_TyparReprInfo : st:ReaderState -> TypedTree.TyparReprInfo
    val u_ValReprInfo : st:ReaderState -> TypedTree.ValReprInfo
    val p_ranges :
      x:(Range.range * Range.range) option -> st:WriterState -> unit
    val p_istype : x:TypedTree.ModuleOrNamespaceKind -> st:WriterState -> unit
    val p_cpath : TypedTree.CompilationPath -> st:WriterState -> unit
    val u_ranges : st:ReaderState -> (Range.range * Range.range) option
    val u_istype : st:ReaderState -> TypedTree.ModuleOrNamespaceKind
    val u_cpath : st:ReaderState -> TypedTree.CompilationPath
    val dummy : x:'a -> 'a
    val p_tycon_repr : x:TypedTree.TyconRepresentation -> st:WriterState -> bool
    val p_tycon_objmodel_data :
      x:TypedTree.TyconObjModelData -> st:WriterState -> unit
    val p_attribs_ext :
      f:(WriterState -> unit) option ->
        x:TypedTree.Attrib list -> st:WriterState -> unit
    val p_unioncase_spec : x:TypedTree.UnionCase -> st:WriterState -> unit
    val p_exnc_spec_data : x:TypedTree.Entity -> st:WriterState -> unit
    val p_exnc_repr : x:TypedTree.ExceptionInfo -> st:WriterState -> unit
    val p_exnc_spec : x:TypedTree.Entity -> st:WriterState -> unit
    val p_access : TypedTree.Accessibility -> st:WriterState -> unit
    val p_recdfield_spec : x:TypedTree.RecdField -> st:WriterState -> unit
    val p_rfield_table : x:TypedTree.TyconRecdFields -> st:WriterState -> unit
    val p_entity_spec_data : x:TypedTree.Entity -> st:WriterState -> unit
    val p_tcaug : p:TypedTree.TyconAugmentation -> st:WriterState -> unit
    val p_entity_spec : x:TypedTree.Entity -> st:WriterState -> unit
    val p_parentref : x:TypedTree.ParentRef -> st:WriterState -> unit
    val p_attribkind : x:TypedTree.AttribKind -> st:WriterState -> unit
    val p_attrib : TypedTree.Attrib -> st:WriterState -> unit
    val p_attrib_expr : TypedTree.AttribExpr -> st:WriterState -> unit
    val p_attrib_arg : TypedTree.AttribNamedArg -> st:WriterState -> unit
    val p_member_info : x:TypedTree.ValMemberInfo -> st:WriterState -> unit
    val p_tycon_objmodel_kind :
      x:TypedTree.TyconObjModelKind -> st:WriterState -> unit
    val p_mustinline : x:TypedTree.ValInline -> st:WriterState -> unit
    val p_basethis : x:TypedTree.ValBaseOrThisInfo -> st:WriterState -> unit
    val p_vrefFlags : x:TypedTree.ValUseFlag -> st:WriterState -> unit
    val p_ValData : x:TypedTree.Val -> st:WriterState -> unit
    val p_Val : x:TypedTree.Val -> st:WriterState -> unit
    val p_modul_typ :
      x:TypedTree.ModuleOrNamespaceType -> st:WriterState -> unit
    val u_tycon_repr : st:ReaderState -> (bool -> TypedTree.TyconRepresentation)
    val u_tycon_objmodel_data : st:ReaderState -> TypedTree.TyconObjModelData
    val u_attribs_ext :
      extraf:(ReaderState -> 'a) ->
        st:ReaderState -> 'a option * TypedTree.Attrib list
    val u_unioncase_spec : st:ReaderState -> TypedTree.UnionCase
    val u_exnc_spec_data : st:ReaderState -> TypedTree.Entity
    val u_exnc_repr : st:ReaderState -> TypedTree.ExceptionInfo
    val u_exnc_spec : st:ReaderState -> TypedTree.Tycon
    val u_access : st:ReaderState -> TypedTree.Accessibility
    val u_recdfield_spec : st:ReaderState -> TypedTree.RecdField
    val u_rfield_table : st:ReaderState -> TypedTree.TyconRecdFields
    val u_entity_spec_data : st:ReaderState -> TypedTree.Entity
    val u_tcaug : st:ReaderState -> TypedTree.TyconAugmentation
    val u_entity_spec : st:ReaderState -> TypedTree.Tycon
    val u_parentref : st:ReaderState -> TypedTree.ParentRef
    val u_attribkind : st:ReaderState -> TypedTree.AttribKind
    val u_attrib : st:ReaderState -> TypedTree.Attrib
    val u_attrib_expr : st:ReaderState -> TypedTree.AttribExpr
    val u_attrib_arg : st:ReaderState -> TypedTree.AttribNamedArg
    val u_member_info : st:ReaderState -> TypedTree.ValMemberInfo
    val u_tycon_objmodel_kind : st:ReaderState -> TypedTree.TyconObjModelKind
    val u_mustinline : st:ReaderState -> TypedTree.ValInline
    val u_basethis : st:ReaderState -> TypedTree.ValBaseOrThisInfo
    val u_vrefFlags : st:ReaderState -> TypedTree.ValUseFlag
    val u_ValData : st:ReaderState -> TypedTree.Val
    val u_Val : st:ReaderState -> TypedTree.Val
    val u_modul_typ : st:ReaderState -> TypedTree.ModuleOrNamespaceType
    val p_const : (TypedTree.Const -> WriterState -> unit)
    val u_const : (ReaderState -> TypedTree.Const)
    val p_dtree : x:TypedTree.DecisionTree -> st:WriterState -> unit
    val p_dtree_case : TypedTree.DecisionTreeCase -> st:WriterState -> unit
    val p_dtree_discrim : x:TypedTree.DecisionTreeTest -> st:WriterState -> unit
    val p_target : TypedTree.DecisionTreeTarget -> st:WriterState -> unit
    val p_bind : TypedTree.Binding -> st:WriterState -> unit
    val p_lval_op_kind : x:TypedTree.LValueOperation -> st:WriterState -> unit
    val p_recdInfo :
      x:TypedTree.RecordConstructionInfo -> st:WriterState -> unit
    val u_dtree : st:ReaderState -> TypedTree.DecisionTree
    val u_dtree_case : st:ReaderState -> TypedTree.DecisionTreeCase
    val u_dtree_discrim : st:ReaderState -> TypedTree.DecisionTreeTest
    val u_target : st:ReaderState -> TypedTree.DecisionTreeTarget
    val u_bind : st:ReaderState -> TypedTree.Binding
    val u_lval_op_kind : st:ReaderState -> TypedTree.LValueOperation
    val p_op : x:TypedTree.TOp -> st:WriterState -> unit
    val u_op : st:ReaderState -> TypedTree.TOp
    val p_expr : (TypedTree.Expr -> WriterState -> unit)
    val u_expr : (ReaderState -> TypedTree.Expr)
    val p_static_optimization_constraint :
      x:TypedTree.StaticOptimization -> st:WriterState -> unit
    val p_slotparam : TypedTree.SlotParam -> st:WriterState -> unit
    val p_slotsig : TypedTree.SlotSig -> st:WriterState -> unit
    val p_method : TypedTree.ObjExprMethod -> st:WriterState -> unit
    val p_methods : x:TypedTree.ObjExprMethod list -> st:WriterState -> unit
    val p_intf :
      TypedTree.TType * TypedTree.ObjExprMethod list -> st:WriterState -> unit
    val p_intfs :
      x:(TypedTree.TType * TypedTree.ObjExprMethod list) list ->
        st:WriterState -> unit
    val u_static_optimization_constraint :
      st:ReaderState -> TypedTree.StaticOptimization
    val u_slotparam : st:ReaderState -> TypedTree.SlotParam
    val u_slotsig : st:ReaderState -> TypedTree.SlotSig
    val u_method : st:ReaderState -> TypedTree.ObjExprMethod
    val u_methods : st:ReaderState -> TypedTree.ObjExprMethod list
    val u_intf :
      st:ReaderState -> TypedTree.TType * TypedTree.ObjExprMethod list
    val u_intfs :
      st:ReaderState -> (TypedTree.TType * TypedTree.ObjExprMethod list) list
    val pickleModuleOrNamespace :
      mspec:TypedTree.Entity -> st:WriterState -> unit
    val pickleCcuInfo : (TypedTree.PickledCcuInfo -> WriterState -> unit)
    val unpickleModuleOrNamespace : st:ReaderState -> TypedTree.Tycon
    val unpickleCcuInfo : ReaderState -> TypedTree.PickledCcuInfo
  end

namespace FSharp.Compiler
  module internal Import = begin
    type AssemblyLoader =
      interface
        abstract member
          FindCcuFromAssemblyRef : AbstractIL.Internal.Library.CompilationThreadToken *
                                   Range.range * AbstractIL.IL.ILAssemblyRef ->
                                     TypedTree.CcuResolutionResult
        abstract member
          GetProvidedAssemblyInfo : AbstractIL.Internal.Library.CompilationThreadToken *
                                    Range.range *
                                    Tainted<ExtensionTyping.ProvidedAssembly> ->
                                      bool *
                                      ExtensionTyping.ProvidedAssemblyStaticLinkingMap option
        abstract member
          RecordGeneratedTypeRoot : ExtensionTyping.ProviderGeneratedType ->
                                      unit
      end
    [<SealedAttribute ()>]
    type ImportMap =
      class
        new : g:TcGlobals.TcGlobals * assemblyLoader:AssemblyLoader -> ImportMap
        member
          ILTypeRefToTyconRefCache : System.Collections.Concurrent.ConcurrentDictionary<AbstractIL.IL.ILTypeRef,
                                                                                        TypedTree.TyconRef>
        member assemblyLoader : AssemblyLoader
        member g : TcGlobals.TcGlobals
      end
    val CanImportILScopeRef :
      env:ImportMap -> m:Range.range -> scoref:AbstractIL.IL.ILScopeRef -> bool
    val ImportTypeRefData :
      env:ImportMap ->
        m:Range.range ->
          scoref:AbstractIL.IL.ILScopeRef * path:string [] *
          typeName:System.String -> TypedTree.EntityRef
    val ImportILTypeRefUncached :
      env:ImportMap ->
        m:Range.range -> tref:AbstractIL.IL.ILTypeRef -> TypedTree.EntityRef
    val ImportILTypeRef :
      ImportMap -> Range.range -> AbstractIL.IL.ILTypeRef -> TypedTree.TyconRef
    val CanImportILTypeRef :
      ImportMap -> Range.range -> AbstractIL.IL.ILTypeRef -> bool
    val ImportTyconRefApp :
      env:ImportMap ->
        tcref:TypedTree.EntityRef ->
          tyargs:TypedTree.TType list -> TypedTree.TType
    val ImportILType :
      ImportMap ->
        Range.range ->
          TypedTree.TType list -> AbstractIL.IL.ILType -> TypedTree.TType
    val CanImportILType :
      ImportMap -> Range.range -> AbstractIL.IL.ILType -> bool
    val ImportProvidedNamedType :
      ImportMap ->
        Range.range ->
          Tainted<ExtensionTyping.ProvidedType> -> TypedTree.TyconRef
    val ImportProvidedTypeAsILType :
      ImportMap ->
        Range.range ->
          Tainted<ExtensionTyping.ProvidedType> -> AbstractIL.IL.ILType
    val ImportProvidedType :
      ImportMap ->
        Range.range -> Tainted<ExtensionTyping.ProvidedType> -> TypedTree.TType
    val ImportProvidedMethodBaseAsILMethodRef :
      ImportMap ->
        Range.range ->
          Tainted<ExtensionTyping.ProvidedMethodBase> ->
            AbstractIL.IL.ILMethodRef
    val ImportILGenericParameters :
      (unit -> ImportMap) ->
        Range.range ->
          AbstractIL.IL.ILScopeRef ->
            TypedTree.TType list ->
              AbstractIL.IL.ILGenericParameterDefs -> TypedTree.Typar list
    val multisetDiscriminateAndMap :
      nodef:('Key -> ('Key list * 'Value) list -> 'a) ->
        tipf:('Value -> 'a) -> items:('Key list * 'Value) list -> 'a list
        when 'Key : equality
    val ImportILTypeDef :
      amap:(unit -> ImportMap) ->
        m:Range.range ->
          scoref:AbstractIL.IL.ILScopeRef ->
            cpath:TypedTree.CompilationPath ->
              enc:AbstractIL.IL.ILTypeDef list ->
                nm:string -> tdef:AbstractIL.IL.ILTypeDef -> TypedTree.Entity
    val ImportILTypeDefList :
      amap:(unit -> ImportMap) ->
        m:Range.range ->
          cpath:TypedTree.CompilationPath ->
            enc:AbstractIL.IL.ILTypeDef list ->
              items:(string list *
                     (string *
                      Lazy<AbstractIL.IL.ILScopeRef * AbstractIL.IL.ILPreTypeDef>)) list ->
                TypedTree.ModuleOrNamespaceType
    val ImportILTypeDefs :
      amap:(unit -> ImportMap) ->
        m:Range.range ->
          scoref:AbstractIL.IL.ILScopeRef ->
            cpath:TypedTree.CompilationPath ->
              enc:AbstractIL.IL.ILTypeDef list ->
                tdefs:AbstractIL.IL.ILTypeDefs ->
                  TypedTree.ModuleOrNamespaceType
    val ImportILAssemblyMainTypeDefs :
      amap:(unit -> ImportMap) ->
        m:Range.range ->
          scoref:AbstractIL.IL.ILScopeRef ->
            modul:AbstractIL.IL.ILModuleDef -> TypedTree.ModuleOrNamespaceType
    val ImportILAssemblyExportedType :
      amap:(unit -> ImportMap) ->
        m:Range.range ->
          auxModLoader:(AbstractIL.IL.ILScopeRef -> AbstractIL.IL.ILModuleDef) ->
            scoref:AbstractIL.IL.ILScopeRef ->
              exportedType:AbstractIL.IL.ILExportedTypeOrForwarder ->
                TypedTree.ModuleOrNamespaceType list
    val ImportILAssemblyExportedTypes :
      amap:(unit -> ImportMap) ->
        m:Range.range ->
          auxModLoader:(AbstractIL.IL.ILScopeRef -> AbstractIL.IL.ILModuleDef) ->
            scoref:AbstractIL.IL.ILScopeRef ->
              exportedTypes:AbstractIL.IL.ILExportedTypesAndForwarders ->
                TypedTree.ModuleOrNamespaceType list
    val ImportILAssemblyTypeDefs :
      amap:(unit -> ImportMap) * m:Range.range *
      auxModLoader:(AbstractIL.IL.ILScopeRef -> AbstractIL.IL.ILModuleDef) *
      aref:AbstractIL.IL.ILAssemblyRef * mainmod:AbstractIL.IL.ILModuleDef ->
        TypedTree.ModuleOrNamespaceType
    val ImportILAssemblyTypeForwarders :
      (unit -> ImportMap) * Range.range *
      AbstractIL.IL.ILExportedTypesAndForwarders ->
        Map<(string [] * string),Lazy<TypedTree.EntityRef>>
    val ImportILAssembly :
      (unit -> ImportMap) * Range.range *
      (AbstractIL.IL.ILScopeRef -> AbstractIL.IL.ILModuleDef) *
      AbstractIL.IL.ILScopeRef * sourceDir:string * filename:string option *
      AbstractIL.IL.ILModuleDef * IEvent<string> -> TypedTree.CcuThunk
  end

namespace FSharp.Compiler
  module internal Infos = begin
    val ImportILType :
      scoref:AbstractIL.IL.ILScopeRef ->
        amap:Import.ImportMap ->
          m:Range.range ->
            importInst:TypedTree.TType list ->
              ilty:AbstractIL.IL.ILType -> TypedTree.TType
    val CanImportILType :
      scoref:AbstractIL.IL.ILScopeRef ->
        amap:Import.ImportMap ->
          m:Range.range -> ilty:AbstractIL.IL.ILType -> bool
    val isExnDeclTy : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val GetSuperTypeOfType :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range -> ty:TypedTree.TType -> TypedTree.TType option
    val mkSystemCollectionsGenericIListTy :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> TypedTree.TType
    [<RequireQualifiedAccessAttribute ()>]
    type SkipUnrefInterfaces =
      | Yes
      | No
    val GetImmediateInterfacesOfType :
      skipUnref:SkipUnrefInterfaces ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range -> ty:TypedTree.TType -> TypedTree.TType list
    [<RequireQualifiedAccessAttribute ()>]
    type AllowMultiIntfInstantiations =
      | Yes
      | No
    val private FoldHierarchyOfTypeAux :
      followInterfaces:bool ->
        allowMultiIntfInst:AllowMultiIntfInstantiations ->
          skipUnref:SkipUnrefInterfaces ->
            visitor:(TypedTree.TType -> 'a -> 'a) ->
              g:TcGlobals.TcGlobals ->
                amap:Import.ImportMap ->
                  m:Range.range -> ty:TypedTree.TType -> acc:'a -> 'a
    val FoldPrimaryHierarchyOfType :
      f:(TypedTree.TType -> 'a -> 'a) ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              allowMultiIntfInst:AllowMultiIntfInstantiations ->
                ty:TypedTree.TType -> acc:'a -> 'a
    val FoldEntireHierarchyOfType :
      f:(TypedTree.TType -> 'a -> 'a) ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              allowMultiIntfInst:AllowMultiIntfInstantiations ->
                ty:TypedTree.TType -> acc:'a -> 'a
    val IterateEntireHierarchyOfType :
      f:(TypedTree.TType -> unit) ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              allowMultiIntfInst:AllowMultiIntfInstantiations ->
                ty:TypedTree.TType -> unit
    val ExistsInEntireHierarchyOfType :
      f:(TypedTree.TType -> bool) ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              allowMultiIntfInst:AllowMultiIntfInstantiations ->
                ty:TypedTree.TType -> bool
    val SearchEntireHierarchyOfType :
      f:(TypedTree.TType -> bool) ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range -> ty:TypedTree.TType -> TypedTree.TType option
    val AllSuperTypesOfType :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            allowMultiIntfInst:AllowMultiIntfInstantiations ->
              ty:TypedTree.TType -> TypedTree.TType list
    val AllInterfacesOfType :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            allowMultiIntfInst:AllowMultiIntfInstantiations ->
              ty:TypedTree.TType -> TypedTree.TType list
    val HaveSameHeadType :
      g:TcGlobals.TcGlobals ->
        ty1:TypedTree.TType -> ty2:TypedTree.TType -> bool
    val HasHeadType :
      g:TcGlobals.TcGlobals ->
        tcref:TypedTree.TyconRef -> ty2:TypedTree.TType -> bool
    val ExistsSameHeadTypeInHierarchy :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            typeToSearchFrom:TypedTree.TType ->
              typeToLookFor:TypedTree.TType -> bool
    val ExistsHeadTypeInEntireHierarchy :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            typeToSearchFrom:TypedTree.TType ->
              tcrefToLookFor:TypedTree.TyconRef -> bool
    val ImportILTypeFromMetadata :
      amap:Import.ImportMap ->
        m:Range.range ->
          scoref:AbstractIL.IL.ILScopeRef ->
            tinst:TypedTree.TType list ->
              minst:TypedTree.TType list ->
                ilty:AbstractIL.IL.ILType -> TypedTree.TType
    val ImportILTypeFromMetadataWithAttributes :
      amap:Import.ImportMap ->
        m:Range.range ->
          scoref:AbstractIL.IL.ILScopeRef ->
            tinst:TypedTree.TType list ->
              minst:TypedTree.TType list ->
                ilty:AbstractIL.IL.ILType ->
                  cattrs:AbstractIL.IL.ILAttributes -> TypedTree.TType
    val ImportParameterTypeFromMetadata :
      amap:Import.ImportMap ->
        m:Range.range ->
          ilty:AbstractIL.IL.ILType ->
            cattrs:AbstractIL.IL.ILAttributes ->
              scoref:AbstractIL.IL.ILScopeRef ->
                tinst:TypedTree.TType list ->
                  mist:TypedTree.TType list -> TypedTree.TType
    val ImportReturnTypeFromMetadata :
      amap:Import.ImportMap ->
        m:Range.range ->
          ilty:AbstractIL.IL.ILType ->
            cattrs:AbstractIL.IL.ILAttributes ->
              scoref:AbstractIL.IL.ILScopeRef ->
                tinst:TypedTree.TType list ->
                  minst:TypedTree.TType list -> TypedTree.TType option
    val CopyTyparConstraints :
      m:Range.range ->
        tprefInst:TypedTreeOps.TyparInst ->
          tporig:TypedTree.Typar -> TypedTree.TyparConstraint list
    val FixupNewTypars :
      m:Range.range ->
        formalEnclosingTypars:TypedTree.Typars ->
          tinst:TypedTree.TType list ->
            tpsorig:TypedTree.Typars ->
              tps:TypedTree.Typars -> TypedTreeOps.TyparInst * TypedTree.TTypes
    type ValRef with
      member IsFSharpEventProperty : g:TcGlobals.TcGlobals -> bool
    type ValRef with
      member IsVirtualMember : bool
    type ValRef with
      member IsDispatchSlotMember : bool
    type ValRef with
      member IsDefiniteFSharpOverrideMember : bool
    type ValRef with
      member
        IsFSharpExplicitInterfaceImplementation : g:TcGlobals.TcGlobals -> bool
    type ValRef with
      member ImplementedSlotSignatures : TypedTree.SlotSig list
    val GetCompiledReturnTyOfProvidedMethodInfo :
      amap:Import.ImportMap ->
        m:Range.range ->
          mi:Tainted<ExtensionTyping.ProvidedMethodBase> ->
            TypedTree.TType option
    val ReparentSlotSigToUseMethodTypars :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          ovByMethValRef:TypedTree.ValRef ->
            slotsig:TypedTree.SlotSig -> TypedTree.SlotSig
    val MakeSlotParam :
      ty:TypedTree.TType * argInfo:TypedTree.ArgReprInfo -> TypedTree.SlotParam
    val MakeSlotSig :
      nm:string * ty:TypedTree.TType * ctps:TypedTree.Typars *
      mtps:TypedTree.Typars * paraml:TypedTree.SlotParam list list *
      retTy:TypedTree.TType option -> TypedTree.SlotSig
    val private AnalyzeTypeOfMemberVal :
      isCSharpExt:bool ->
        g:TcGlobals.TcGlobals ->
          ty:TypedTree.TType * vref:TypedTree.ValRef ->
            TypedTree.Typar list * TypedTree.Typars * TypedTree.TType option *
            TypedTree.TType list
    val private GetObjTypeOfInstanceExtensionMethod :
      g:TcGlobals.TcGlobals -> vref:TypedTree.ValRef -> TypedTree.TType
    val private GetArgInfosOfMember :
      isCSharpExt:bool ->
        g:TcGlobals.TcGlobals ->
          vref:TypedTree.ValRef ->
            (TypedTree.TType * TypedTree.ArgReprInfo) list list
    val private CombineMethInsts :
      ttps:TypedTree.Typars ->
        mtps:TypedTree.Typars ->
          tinst:TypedTree.TTypes ->
            minst:TypedTree.TTypes -> (TypedTree.Typar * TypedTree.TType) list
    val private GetInstantiationForMemberVal :
      g:TcGlobals.TcGlobals ->
        isCSharpExt:bool ->
          ty:TypedTree.TType * vref:TypedTree.ValRef *
          methTyArgs:TypedTree.TypeInst ->
            (TypedTree.Typar * TypedTree.TType) list
    val private GetInstantiationForPropertyVal :
      g:TcGlobals.TcGlobals ->
        ty:TypedTree.TType * vref:TypedTree.ValRef ->
          (TypedTree.Typar * TypedTree.TType) list
    type ExtensionMethodPriority = uint64
    type OptionalArgCallerSideValue =
      | Constant of AbstractIL.IL.ILFieldInit
      | DefaultValue
      | MissingValue
      | WrapperForIDispatch
      | WrapperForIUnknown
      | PassByRef of TypedTree.TType * OptionalArgCallerSideValue
    type OptionalArgInfo =
      | NotOptional
      | CalleeSide
      | CallerSide of OptionalArgCallerSideValue
      with
        static member
          FieldInitForDefaultParameterValueAttrib : attrib:TypedTree.Attrib ->
                                                      AbstractIL.IL.ILFieldInit option
        static member
          FromILParameter : g:TcGlobals.TcGlobals ->
                              amap:Import.ImportMap ->
                                m:Range.range ->
                                  ilScope:AbstractIL.IL.ILScopeRef ->
                                    ilTypeInst:TypedTree.TType list ->
                                      ilParam:AbstractIL.IL.ILParameter ->
                                        OptionalArgInfo
        static member
          ValueOfDefaultParameterValueAttrib : TypedTree.Attrib ->
                                                 TypedTree.Expr option
        member IsOptional : bool
      end
    type CallerInfo =
      | NoCallerInfo
      | CallerLineNumber
      | CallerMemberName
      | CallerFilePath
      with
        override ToString : unit -> string
      end
    [<RequireQualifiedAccessAttribute ()>]
    type ReflectedArgInfo =
      | None
      | Quote of bool
      with
        member AutoQuote : bool
      end
    [<NoComparisonAttribute (); NoEqualityAttribute ()>]
    type ParamNameAndType =
      | ParamNameAndType of SyntaxTree.Ident option * TypedTree.TType
      with
        static member
          FromArgInfo : ty:TypedTree.TType * argInfo:TypedTree.ArgReprInfo ->
                          ParamNameAndType
        static member
          FromMember : isCSharpExtMem:bool ->
                         g:TcGlobals.TcGlobals ->
                           vref:TypedTree.ValRef -> ParamNameAndType list list
        static member
          Instantiate : inst:TypedTreeOps.TyparInst ->
                          p:ParamNameAndType -> ParamNameAndType
        static member
          InstantiateCurried : inst:TypedTreeOps.TyparInst ->
                                 paramTypes:ParamNameAndType list list ->
                                   ParamNameAndType list list
      end
    [<NoComparisonAttribute (); NoEqualityAttribute ()>]
    type ParamData =
      | ParamData of
        isParamArray: bool * isInArg: bool * isOut: bool *
        optArgInfo: OptionalArgInfo * callerInfo: CallerInfo *
        nameOpt: SyntaxTree.Ident option * reflArgInfo: ReflectedArgInfo *
        ttype: TypedTree.TType
    type ILFieldInit with
      static member
        FromProvidedObj : m:Range.range -> v:obj -> AbstractIL.IL.ILFieldInit
    val OptionalArgInfoOfProvidedParameter :
      amap:Import.ImportMap ->
        m:Range.range ->
          provParam:Tainted<ExtensionTyping.ProvidedParameterInfo> ->
            OptionalArgInfo
    val GetAndSanityCheckProviderMethod :
      m:Range.range ->
        mi:Tainted<'T> ->
          get:('T -> ExtensionTyping.ProvidedMethodInfo) ->
            err:(string * string -> int * string) ->
              Tainted<ExtensionTyping.ProvidedMethodBase>
        when 'T :> ExtensionTyping.ProvidedMemberInfo
    val ArbitraryMethodInfoOfPropertyInfo :
      pi:Tainted<ExtensionTyping.ProvidedPropertyInfo> ->
        m:Range.range -> Tainted<ExtensionTyping.ProvidedMethodBase>
    [<NoComparisonAttribute (); NoEqualityAttribute ()>]
    type ILTypeInfo =
      | ILTypeInfo of
        TcGlobals.TcGlobals * TypedTree.TType * AbstractIL.IL.ILTypeRef *
        AbstractIL.IL.ILTypeDef
      with
        static member
          FromType : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> ILTypeInfo
        member Instantiate : inst:TypedTreeOps.TyparInst -> ILTypeInfo
        member ILScopeRef : AbstractIL.IL.ILScopeRef
        member ILTypeRef : AbstractIL.IL.ILTypeRef
        member IsValueType : bool
        member Name : string
        member RawMetadata : AbstractIL.IL.ILTypeDef
        member TcGlobals : TcGlobals.TcGlobals
        member ToAppType : TypedTree.TType
        member ToType : TypedTree.TType
        member TyconRefOfRawMetadata : TypedTree.TyconRef
        member TypeInstOfRawMetadata : TypedTree.TypeInst
      end
    [<NoComparisonAttribute (); NoEqualityAttribute ()>]
    type ILMethInfo =
      | ILMethInfo of
        g: TcGlobals.TcGlobals * ilApparentType: TypedTree.TType *
        ilDeclaringTyconRefOpt: TypedTree.TyconRef option *
        ilMethodDef: AbstractIL.IL.ILMethodDef *
        ilGenericMethodTyArgs: TypedTree.Typars
      with
        member
          GetCompiledReturnTy : amap:Import.ImportMap * m:Range.range *
                                minst:TypedTree.TType list ->
                                  TypedTree.TType option
        member
          GetFSharpReturnTy : amap:Import.ImportMap * m:Range.range *
                              minst:TypedTree.TType list -> TypedTree.TType
        member
          GetObjArgTypes : amap:Import.ImportMap * m:Range.range *
                           minst:TypedTree.TType list -> TypedTree.TType list
        member
          GetParamNamesAndTypes : amap:Import.ImportMap * m:Range.range *
                                  minst:TypedTree.TType list ->
                                    ParamNameAndType list
        member
          GetParamTypes : amap:Import.ImportMap * m:Range.range *
                          minst:TypedTree.TType list -> TypedTree.TType list
        member
          GetRawArgTypes : amap:Import.ImportMap * m:Range.range *
                           minst:TypedTree.TType list -> TypedTree.TType list
        member IsDllImport : g:TcGlobals.TcGlobals -> bool
        member IsReadOnly : g:TcGlobals.TcGlobals -> bool
        member ApparentEnclosingAppType : TypedTree.TType
        member ApparentEnclosingType : TypedTree.TType
        member DeclaringTyconRef : TypedTree.TyconRef
        member DeclaringTypeInst : TypedTree.TType list
        member FormalMethodTypars : TypedTree.Typars
        member ILExtensionMethodDeclaringTyconRef : TypedTree.TyconRef option
        member ILMethodRef : AbstractIL.IL.ILMethodRef
        member ILName : string
        member IsAbstract : bool
        member IsClassConstructor : bool
        member IsConstructor : bool
        member IsFinal : bool
        member IsILExtensionMethod : bool
        member IsInstance : bool
        member IsNewSlot : bool
        member IsProtectedAccessibility : bool
        member IsStatic : bool
        member IsVirtual : bool
        member MetadataScope : AbstractIL.IL.ILScopeRef
        member NumParams : int
        member ParamMetadata : AbstractIL.IL.ILParameter list
        member RawMetadata : AbstractIL.IL.ILMethodDef
        member TcGlobals : TcGlobals.TcGlobals
      end
    [<NoComparisonAttribute (); NoEqualityAttribute ();
      System.Diagnostics.DebuggerDisplay ("{DebuggerDisplayName}")>]
    type MethInfo =
      | FSMeth of
        tcGlobals: TcGlobals.TcGlobals * enclosingType: TypedTree.TType *
        valRef: TypedTree.ValRef *
        extensionMethodPriority: ExtensionMethodPriority option
      | ILMeth of
        tcGlobals: TcGlobals.TcGlobals * ilMethInfo: ILMethInfo *
        extensionMethodPriority: ExtensionMethodPriority option
      | DefaultStructCtor of
        tcGlobals: TcGlobals.TcGlobals * structTy: TypedTree.TType
      | ProvidedMeth of
        amap: Import.ImportMap *
        methodBase: Tainted<ExtensionTyping.ProvidedMethodBase> *
        extensionMethodPriority: ExtensionMethodPriority option * m: Range.range
      with
        static member
          CreateILExtensionMeth : amap:Import.ImportMap * m:Range.range *
                                  apparentTy:TypedTree.TType *
                                  declaringTyconRef:TypedTree.TyconRef *
                                  extMethPri:ExtensionMethodPriority option *
                                  md:AbstractIL.IL.ILMethodDef -> MethInfo
        static member
          CreateILMeth : amap:Import.ImportMap * m:Range.range *
                         ty:TypedTree.TType * md:AbstractIL.IL.ILMethodDef ->
                           MethInfo
        static member
          MethInfosUseIdenticalDefinitions : x1:MethInfo -> x2:MethInfo -> bool
        member
          AdjustUserTypeInstForFSharpStyleIndexedExtensionMembers : tyargs:TypedTree.TType list ->
                                                                      TypedTree.TType list
        member ComputeHashCode : unit -> int
        member
          GetCompiledReturnTy : amap:Import.ImportMap * m:Range.range *
                                minst:TypedTree.TType list ->
                                  TypedTree.TType option
        member
          GetFSharpReturnTy : amap:Import.ImportMap * m:Range.range *
                              minst:TypedTree.TType list -> TypedTree.TType
        member
          GetFormalTyparsOfDeclaringType : m:Range.range -> TypedTree.Typar list
        member
          GetObjArgTypes : amap:Import.ImportMap * m:Range.range *
                           minst:TypedTree.TypeInst -> TypedTree.TType list
        member
          GetParamAttribs : amap:Import.ImportMap * m:Range.range ->
                              (bool * bool * bool * OptionalArgInfo * CallerInfo *
                               ReflectedArgInfo) list list
        member
          GetParamDatas : amap:Import.ImportMap * m:Range.range *
                          minst:TypedTree.TType list -> ParamData list list
        member
          GetParamTypes : amap:Import.ImportMap * m:Range.range *
                          minst:TypedTree.TType list ->
                            TypedTree.TType list list
        member
          GetSlotSig : amap:Import.ImportMap * m:Range.range ->
                         TypedTree.SlotSig
        member
          HasParamArrayArg : amap:Import.ImportMap * m:Range.range *
                             minst:TypedTree.TType list -> bool
        member
          Instantiate : amap:Import.ImportMap * m:Range.range *
                        inst:TypedTreeOps.TyparInst -> MethInfo
        member
          IsReadOnlyExtensionMember : amap:Import.ImportMap * m:Range.range ->
                                        bool
        member
          ObjArgNeedsAddress : amap:Import.ImportMap * m:Range.range -> bool
        override ToString : unit -> string
        member
          TryObjArgByrefType : amap:Import.ImportMap * m:Range.range *
                               minst:TypedTree.TypeInst ->
                                 TypedTree.TType option
        member ApparentEnclosingAppType : TypedTree.TType
        member ApparentEnclosingTyconRef : TypedTree.TyconRef
        member ApparentEnclosingType : TypedTree.TType
        member ArbitraryValRef : TypedTree.ValRef option
        member DebuggerDisplayName : string
        member DeclaringTyconRef : TypedTree.TyconRef
        member DeclaringTypeInst : TypedTree.TType list
        member DisplayName : string
        member ExtensionMemberPriority : ExtensionMethodPriority
        member ExtensionMemberPriorityOption : ExtensionMethodPriority option
        member FormalMethodInst : TypedTree.TypeInst
        member FormalMethodTyparInst : TypedTreeOps.TyparInst
        member FormalMethodTypars : TypedTree.Typars
        member GenericArity : int
        member HasDirectXmlComment : bool
        member ImplementedSlotSignatures : TypedTree.SlotSig list
        member IsAbstract : bool
        member IsCSharpStyleExtensionMember : bool
        member IsClassConstructor : bool
        member IsConstructor : bool
        member IsCurried : bool
        member IsDefiniteFSharpOverride : bool
        member IsDispatchSlot : bool
        member IsExtensionMember : bool
        member IsFSharpEventPropertyMethod : bool
        member IsFSharpExplicitInterfaceImplementation : bool
        member IsFSharpStyleExtensionMember : bool
        member IsFinal : bool
        member IsILMethod : bool
        member IsInstance : bool
        member IsNewSlot : bool
        member IsNullary : bool
        member IsProtectedAccessibility : bool
        member IsReadOnly : bool
        member IsStruct : bool
        member IsVirtual : bool
        member LogicalName : string
        member NumArgs : int list
        member
          ProvidedStaticParameterInfo : (Tainted<ExtensionTyping.ProvidedMethodBase> *
                                         Tainted<ExtensionTyping.ProvidedParameterInfo> []) option
        member TcGlobals : TcGlobals.TcGlobals
        member XmlDoc : XmlDoc.XmlDoc
      end
    [<NoComparisonAttribute (); NoEqualityAttribute ()>]
    type ILFieldInfo =
      | ILFieldInfo of
        ilTypeInfo: ILTypeInfo * ilFieldDef: AbstractIL.IL.ILFieldDef
      | ProvidedField of
        amap: Import.ImportMap *
        providedField: Tainted<ExtensionTyping.ProvidedFieldInfo> *
        range: Range.range
      with
        static member
          ILFieldInfosUseIdenticalDefinitions : x1:ILFieldInfo ->
                                                  x2:ILFieldInfo -> bool
        member ComputeHashCode : unit -> int
        member
          FieldType : amap:Import.ImportMap * m:Range.range -> TypedTree.TType
        override ToString : unit -> string
        member ApparentEnclosingAppType : TypedTree.TType
        member ApparentEnclosingTyconRef : TypedTree.TyconRef
        member ApparentEnclosingType : TypedTree.TType
        member DeclaringTyconRef : TypedTree.TyconRef
        member FieldName : string
        member ILFieldRef : AbstractIL.IL.ILFieldRef
        member ILFieldType : AbstractIL.IL.ILType
        member ILTypeRef : AbstractIL.IL.ILTypeRef
        member IsInitOnly : bool
        member IsSpecialName : bool
        member IsStatic : bool
        member IsValueType : bool
        member LiteralValue : AbstractIL.IL.ILFieldInit option
        member ScopeRef : AbstractIL.IL.ILScopeRef
        member TcGlobals : TcGlobals.TcGlobals
        member TypeInst : TypedTree.TypeInst
      end
    [<NoComparisonAttribute (); NoEqualityAttribute ()>]
    type RecdFieldInfo =
      | RecdFieldInfo of
        typeInst: TypedTree.TypeInst * recdFieldRef: TypedTree.RecdFieldRef
      with
        override ToString : unit -> string
        member DeclaringType : TypedTree.TType
        member FieldType : TypedTree.TType
        member IsStatic : bool
        member LiteralValue : TypedTree.Const option
        member Name : string
        member RecdField : TypedTree.RecdField
        member RecdFieldRef : TypedTree.RecdFieldRef
        member Tycon : TypedTree.Entity
        member TyconRef : TypedTree.TyconRef
        member TypeInst : TypedTree.TypeInst
      end
    [<NoComparisonAttribute (); NoEqualityAttribute ()>]
    type UnionCaseInfo =
      | UnionCaseInfo of TypedTree.TypeInst * TypedTree.UnionCaseRef
      with
        member GetTyparInst : m:Range.range -> TypedTreeOps.TyparInst
        override ToString : unit -> string
        member Name : string
        member Tycon : TypedTree.Entity
        member TyconRef : TypedTree.TyconRef
        member TypeInst : TypedTree.TypeInst
        member UnionCase : TypedTree.UnionCase
        member UnionCaseRef : TypedTree.UnionCaseRef
      end
    [<NoComparisonAttribute (); NoEqualityAttribute ()>]
    type ILPropInfo =
      | ILPropInfo of
        ilTypeInfo: ILTypeInfo * ilPropertyDef: AbstractIL.IL.ILPropertyDef
      with
        member
          GetParamNamesAndTypes : amap:Import.ImportMap * m:Range.range ->
                                    ParamNameAndType list
        member
          GetParamTypes : amap:Import.ImportMap * m:Range.range ->
                            TypedTree.TType list
        member
          GetPropertyType : amap:Import.ImportMap * m:Range.range ->
                              TypedTree.TType
        override ToString : unit -> string
        member ApparentEnclosingAppType : TypedTree.TType
        member ApparentEnclosingType : TypedTree.TType
        member GetterMethod : ILMethInfo
        member HasGetter : bool
        member HasSetter : bool
        member ILTypeInfo : ILTypeInfo
        member IsNewSlot : bool
        member IsStatic : bool
        member IsVirtual : bool
        member PropertyName : string
        member RawMetadata : AbstractIL.IL.ILPropertyDef
        member SetterMethod : ILMethInfo
        member TcGlobals : TcGlobals.TcGlobals
      end
    [<NoComparisonAttribute (); NoEqualityAttribute ()>]
    type PropInfo =
      | FSProp of
        tcGlobals: TcGlobals.TcGlobals * apparentEnclTy: TypedTree.TType *
        getter: TypedTree.ValRef option * setter: TypedTree.ValRef option
      | ILProp of ilPropInfo: ILPropInfo
      | ProvidedProp of
        amap: Import.ImportMap *
        providedProp: Tainted<ExtensionTyping.ProvidedPropertyInfo> *
        range: Range.range
      with
        static member
          PropInfosUseIdenticalDefinitions : x1:PropInfo -> x2:PropInfo -> bool
        member ComputeHashCode : unit -> int
        member DropGetter : unit -> PropInfo
        member DropSetter : unit -> PropInfo
        member
          GetParamDatas : amap:Import.ImportMap * m:Range.range ->
                            ParamData list
        member
          GetParamNamesAndTypes : amap:Import.ImportMap * m:Range.range ->
                                    ParamNameAndType list
        member
          GetParamTypes : amap:Import.ImportMap * m:Range.range ->
                            TypedTree.TType list
        member
          GetPropertyType : amap:Import.ImportMap * m:Range.range ->
                              TypedTree.TType
        override ToString : unit -> string
        member ApparentEnclosingAppType : TypedTree.TType
        member ApparentEnclosingTyconRef : TypedTree.TyconRef
        member ApparentEnclosingType : TypedTree.TType
        member ArbitraryValRef : TypedTree.ValRef option
        member DeclaringTyconRef : TypedTree.EntityRef
        member GetterMethod : MethInfo
        member HasDirectXmlComment : bool
        member HasGetter : bool
        member HasSetter : bool
        member ImplementedSlotSignatures : TypedTree.SlotSig list
        member IsDefiniteFSharpOverride : bool
        member IsDispatchSlot : bool
        member IsExtensionMember : bool
        member IsFSharpEventProperty : bool
        member IsFSharpExplicitInterfaceImplementation : bool
        member IsIndexer : bool
        member IsNewSlot : bool
        member IsStatic : bool
        member IsValueType : bool
        member IsVirtualProperty : bool
        member PropertyName : string
        member SetterMethod : MethInfo
        member TcGlobals : TcGlobals.TcGlobals
        member XmlDoc : XmlDoc.XmlDoc
      end
    [<NoComparisonAttribute (); NoEqualityAttribute ()>]
    type ILEventInfo =
      | ILEventInfo of
        ilTypeInfo: ILTypeInfo * ilEventDef: AbstractIL.IL.ILEventDef
      with
        override ToString : unit -> string
        member AddMethod : ILMethInfo
        member ApparentEnclosingAppType : TypedTree.TType
        member ApparentEnclosingType : TypedTree.TType
        member DeclaringTyconRef : TypedTree.TyconRef
        member ILTypeInfo : ILTypeInfo
        member IsStatic : bool
        member Name : string
        member RawMetadata : AbstractIL.IL.ILEventDef
        member RemoveMethod : ILMethInfo
        member TcGlobals : TcGlobals.TcGlobals
        member TypeRef : AbstractIL.IL.ILTypeRef
      end
    exception BadEventTransformation of Range.range
    val private tyConformsToIDelegateEvent :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val nonStandardEventError : nm:System.String -> m:Range.range -> exn
    val FindDelegateTypeOfPropertyEvent :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          nm:System.String ->
            m:Range.range -> ty:TypedTree.TType -> TypedTree.TType
    [<NoComparisonAttribute (); NoEqualityAttribute ()>]
    type EventInfo =
      | FSEvent of
        tcGlobals: TcGlobals.TcGlobals * propInfo: PropInfo *
        addMethod: TypedTree.ValRef * removeMethod: TypedTree.ValRef
      | ILEvent of ilEventInfo: ILEventInfo
      | ProvidedEvent of
        amap: Import.ImportMap *
        providedEvent: Tainted<ExtensionTyping.ProvidedEventInfo> *
        range: Range.range
      with
        static member
          EventInfosUseIdenticalDefinitions : x1:EventInfo ->
                                                x2:EventInfo -> bool
        member ComputeHashCode : unit -> int
        member
          GetDelegateType : amap:Import.ImportMap * m:Range.range ->
                              TypedTree.TType
        override ToString : unit -> string
        member AddMethod : MethInfo
        member ApparentEnclosingAppType : TypedTree.TType
        member ApparentEnclosingTyconRef : TypedTree.TyconRef
        member ApparentEnclosingType : TypedTree.TType
        member ArbitraryValRef : TypedTree.ValRef option
        member DeclaringTyconRef : TypedTree.EntityRef
        member EventName : string
        member HasDirectXmlComment : bool
        member IsExtensionMember : bool
        member IsStatic : bool
        member IsValueType : bool
        member RemoveMethod : MethInfo
        member TcGlobals : TcGlobals.TcGlobals
        member XmlDoc : XmlDoc.XmlDoc
      end
    val stripByrefTy :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> TypedTree.TType
    type CompiledSig =
      | CompiledSig of
        argTys: TypedTree.TType list list * returnTy: TypedTree.TType option *
        formalMethTypars: TypedTree.Typars *
        formalMethTyparInst: TypedTreeOps.TyparInst
    val CompiledSigOfMeth :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap -> m:Range.range -> minfo:MethInfo -> CompiledSig
    val MethInfosEquivByPartialSig :
      erasureFlag:TypedTreeOps.Erasure ->
        ignoreFinal:bool ->
          g:TcGlobals.TcGlobals ->
            amap:Import.ImportMap ->
              m:Range.range -> minfo:MethInfo -> minfo2:MethInfo -> bool
    val MethInfosEquivByNameAndPartialSig :
      erasureFlag:TypedTreeOps.Erasure ->
        ignoreFinal:bool ->
          g:TcGlobals.TcGlobals ->
            amap:Import.ImportMap ->
              m:Range.range -> minfo:MethInfo -> minfo2:MethInfo -> bool
    val PropInfosEquivByNameAndPartialSig :
      erasureFlag:TypedTreeOps.Erasure ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range -> pinfo:PropInfo -> pinfo2:PropInfo -> bool
    val MethInfosEquivByNameAndSig :
      erasureFlag:TypedTreeOps.Erasure ->
        ignoreFinal:bool ->
          g:TcGlobals.TcGlobals ->
            amap:Import.ImportMap ->
              m:Range.range -> minfo:MethInfo -> minfo2:MethInfo -> bool
    val PropInfosEquivByNameAndSig :
      erasureFlag:TypedTreeOps.Erasure ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range -> pinfo:PropInfo -> pinfo2:PropInfo -> bool
    val SettersOfPropInfos :
      pinfos:PropInfo list -> (MethInfo * PropInfo option) list
    val GettersOfPropInfos :
      pinfos:PropInfo list -> (MethInfo * PropInfo option) list
  end

namespace FSharp.Compiler
  module internal AccessibilityLogic = begin
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type AccessorDomain =
      | AccessibleFrom of
        cpaths: TypedTree.CompilationPath list *
        tyconRefOpt: TypedTree.TyconRef option
      | AccessibleFromEverywhere
      | AccessibleFromSomeFSharpCode
      | AccessibleFromSomewhere
      with
        static member
          CustomEquals : g:TcGlobals.TcGlobals * ad1:AccessorDomain *
                         ad2:AccessorDomain -> bool
        static member CustomGetHashCode : ad:AccessorDomain -> int
      end
    val IsAccessible :
      ad:AccessorDomain -> taccess:TypedTree.Accessibility -> bool
    val private IsILMemberAccessible :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            tcrefOfViewedItem:TypedTree.TyconRef ->
              ad:AccessorDomain -> access:AbstractIL.IL.ILMemberAccess -> bool
    val private IsILTypeDefAccessible :
      amap:Import.ImportMap ->
        m:Range.range ->
          ad:AccessorDomain ->
            encTyconRefOpt:TypedTree.TyconRef option ->
              tdef:AbstractIL.IL.ILTypeDef -> bool
    val private IsTyconAccessibleViaVisibleTo :
      ad:AccessorDomain -> tcrefOfViewedItem:TypedTree.TyconRef -> bool
    val private IsILTypeInfoAccessible :
      amap:Import.ImportMap ->
        m:Range.range ->
          ad:AccessorDomain -> tcrefOfViewedItem:TypedTree.TyconRef -> bool
    val private IsILTypeAndMemberAccessible :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            adType:AccessorDomain ->
              ad:AccessorDomain ->
                ty:Infos.ILTypeInfo ->
                  access:AbstractIL.IL.ILMemberAccess -> bool
    val IsEntityAccessible :
      amap:Import.ImportMap ->
        m:Range.range -> ad:AccessorDomain -> tcref:TypedTree.TyconRef -> bool
    val CheckTyconAccessible :
      amap:Import.ImportMap ->
        m:Range.range -> ad:AccessorDomain -> tcref:TypedTree.TyconRef -> bool
    val IsTyconReprAccessible :
      amap:Import.ImportMap ->
        m:Range.range -> ad:AccessorDomain -> tcref:TypedTree.TyconRef -> bool
    val CheckTyconReprAccessible :
      amap:Import.ImportMap ->
        m:Range.range -> ad:AccessorDomain -> tcref:TypedTree.TyconRef -> bool
    val IsTypeAccessible :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range -> ad:AccessorDomain -> ty:TypedTree.TType -> bool
    val IsTypeInstAccessible :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range -> ad:AccessorDomain -> tinst:TypedTree.TypeInst -> bool
    val IsProvidedMemberAccessible :
      amap:Import.ImportMap ->
        m:Range.range ->
          ad:AccessorDomain ->
            ty:TypedTree.TType -> access:AbstractIL.IL.ILMemberAccess -> bool
    val ComputeILAccess :
      isPublic:bool ->
        isFamily:bool ->
          isFamilyOrAssembly:bool ->
            isFamilyAndAssembly:bool -> AbstractIL.IL.ILMemberAccess
    val IsILFieldInfoAccessible :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range -> ad:AccessorDomain -> x:Infos.ILFieldInfo -> bool
    val GetILAccessOfILEventInfo :
      Infos.ILEventInfo -> AbstractIL.IL.ILMemberAccess
    val IsILEventInfoAccessible :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range -> ad:AccessorDomain -> einfo:Infos.ILEventInfo -> bool
    val private IsILMethInfoAccessible :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            adType:AccessorDomain ->
              ad:AccessorDomain -> ilminfo:Infos.ILMethInfo -> bool
    val GetILAccessOfILPropInfo :
      Infos.ILPropInfo -> AbstractIL.IL.ILMemberAccess
    val IsILPropInfoAccessible :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range -> ad:AccessorDomain -> pinfo:Infos.ILPropInfo -> bool
    val IsValAccessible : ad:AccessorDomain -> vref:TypedTree.ValRef -> bool
    val CheckValAccessible :
      m:Range.range -> ad:AccessorDomain -> vref:TypedTree.ValRef -> unit
    val IsUnionCaseAccessible :
      amap:Import.ImportMap ->
        m:Range.range ->
          ad:AccessorDomain -> ucref:TypedTree.UnionCaseRef -> bool
    val CheckUnionCaseAccessible :
      amap:Import.ImportMap ->
        m:Range.range ->
          ad:AccessorDomain -> ucref:TypedTree.UnionCaseRef -> bool
    val IsRecdFieldAccessible :
      amap:Import.ImportMap ->
        m:Range.range ->
          ad:AccessorDomain -> rfref:TypedTree.RecdFieldRef -> bool
    val CheckRecdFieldAccessible :
      amap:Import.ImportMap ->
        m:Range.range ->
          ad:AccessorDomain -> rfref:TypedTree.RecdFieldRef -> bool
    val CheckRecdFieldInfoAccessible :
      amap:Import.ImportMap ->
        m:Range.range -> ad:AccessorDomain -> rfinfo:Infos.RecdFieldInfo -> unit
    val CheckILFieldInfoAccessible :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range -> ad:AccessorDomain -> finfo:Infos.ILFieldInfo -> unit
    val IsTypeAndMethInfoAccessible :
      amap:Import.ImportMap ->
        m:Range.range ->
          accessDomainTy:AccessorDomain ->
            ad:AccessorDomain -> _arg1:Infos.MethInfo -> bool
    val IsMethInfoAccessible :
      amap:Import.ImportMap ->
        m:Range.range -> ad:AccessorDomain -> minfo:Infos.MethInfo -> bool
    val IsPropInfoAccessible :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range -> ad:AccessorDomain -> _arg1:Infos.PropInfo -> bool
    val IsFieldInfoAccessible :
      ad:AccessorDomain -> rfref:Infos.RecdFieldInfo -> bool
  end

namespace FSharp.Compiler
  module internal AttributeChecking = begin
    exception ObsoleteWarning of string * Range.range
    exception ObsoleteError of string * Range.range
    val fail : unit -> 'a
    val private evalILAttribElem : e:AbstractIL.IL.ILAttribElem -> obj
    val private evalFSharpAttribArg :
      g:TcGlobals.TcGlobals -> e:TypedTree.Expr -> obj
    type AttribInfo =
      | FSAttribInfo of TcGlobals.TcGlobals * TypedTree.Attrib
      | ILAttribInfo of
        TcGlobals.TcGlobals * Import.ImportMap * AbstractIL.IL.ILScopeRef *
        AbstractIL.IL.ILAttribute * Range.range
      with
        member ConstructorArguments : (TypedTree.TType * obj) list
        member NamedArguments : (TypedTree.TType * string * bool * obj) list
        member Range : Range.range
        member TyconRef : TypedTree.TyconRef
      end
    val AttribInfosOfIL :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          scoref:AbstractIL.IL.ILScopeRef ->
            m:Range.range ->
              attribs:AbstractIL.IL.ILAttributes -> AttribInfo list
    val AttribInfosOfFS :
      g:TcGlobals.TcGlobals -> attribs:TypedTree.Attrib list -> AttribInfo list
    val GetAttribInfosOfEntity :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range -> tcref:TypedTree.TyconRef -> AttribInfo list
    val GetAttribInfosOfMethod :
      amap:Import.ImportMap ->
        m:Range.range -> minfo:Infos.MethInfo -> AttribInfo list
    val GetAttribInfosOfProp :
      amap:Import.ImportMap ->
        m:Range.range -> pinfo:Infos.PropInfo -> AttribInfo list
    val GetAttribInfosOfEvent :
      amap:Import.ImportMap ->
        m:Range.range -> einfo:Infos.EventInfo -> AttribInfo list
    val TryBindTyconRefAttribute :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          TcGlobals.BuiltinAttribInfo ->
            tcref:TypedTree.TyconRef ->
              f1:(AbstractIL.IL.ILAttribElem list *
                  AbstractIL.IL.ILAttributeNamedArg list -> 'a option) ->
                f2:(TypedTree.Attrib -> 'a option) ->
                  f3:(obj option list * (string * obj option) list -> 'a option) ->
                    'a option
    val BindMethInfoAttributes :
      m:Range.range ->
        minfo:Infos.MethInfo ->
          f1:(AbstractIL.IL.ILAttributes -> 'a) ->
            f2:(TypedTree.Attrib list -> 'a) ->
              f3:(Tainted<ExtensionTyping.IProvidedCustomAttributeProvider> ->
                    'a) -> 'a
    val TryBindMethInfoAttribute :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          TcGlobals.BuiltinAttribInfo ->
            minfo:Infos.MethInfo ->
              f1:(AbstractIL.IL.ILAttribElem list *
                  AbstractIL.IL.ILAttributeNamedArg list -> 'a option) ->
                f2:(TypedTree.Attrib -> 'a option) ->
                  f3:(obj option list * (string * obj option) list -> 'a option) ->
                    'a option
    val TryFindMethInfoStringAttribute :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          attribSpec:TcGlobals.BuiltinAttribInfo ->
            minfo:Infos.MethInfo -> string option
    val MethInfoHasAttribute :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          attribSpec:TcGlobals.BuiltinAttribInfo -> minfo:Infos.MethInfo -> bool
    val private CheckILAttributes :
      g:TcGlobals.TcGlobals ->
        isByrefLikeTyconRef:bool ->
          cattrs:AbstractIL.IL.ILAttributes ->
            m:Range.range -> ErrorLogger.OperationResult<unit>
    val langVersionPrefix : string
    val CheckFSharpAttributes :
      g:TcGlobals.TcGlobals ->
        attribs:TypedTree.Attrib list ->
          m:Range.range -> ErrorLogger.OperationResult<unit>
    val private CheckProvidedAttributes :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          provAttribs:Tainted<ExtensionTyping.IProvidedCustomAttributeProvider> ->
            ErrorLogger.OperationResult<unit>
    val CheckILAttributesForUnseen :
      g:TcGlobals.TcGlobals ->
        cattrs:AbstractIL.IL.ILAttributes -> _m:'a -> bool
    val CheckFSharpAttributesForHidden :
      g:TcGlobals.TcGlobals -> attribs:TypedTree.Attrib list -> bool
    val CheckFSharpAttributesForObsolete :
      g:TcGlobals.TcGlobals -> attribs:TypedTree.Attrib list -> bool
    val CheckFSharpAttributesForUnseen :
      g:TcGlobals.TcGlobals -> attribs:TypedTree.Attrib list -> _m:'a -> bool
    val CheckProvidedAttributesForUnseen :
      provAttribs:Tainted<ExtensionTyping.IProvidedCustomAttributeProvider> ->
        m:Range.range -> bool
    val CheckPropInfoAttributes :
      pinfo:Infos.PropInfo -> m:Range.range -> ErrorLogger.OperationResult<unit>
    val CheckILFieldAttributes :
      g:TcGlobals.TcGlobals -> finfo:Infos.ILFieldInfo -> m:Range.range -> unit
    val CheckMethInfoAttributes :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          tyargsOpt:'a option ->
            minfo:Infos.MethInfo -> ErrorLogger.OperationResult<unit>
    val MethInfoIsUnseen :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> ty:TypedTree.TType -> minfo:Infos.MethInfo -> bool
    val PropInfoIsUnseen : m:'a -> pinfo:Infos.PropInfo -> bool
    val CheckEntityAttributes :
      g:TcGlobals.TcGlobals ->
        x:TypedTree.TyconRef ->
          m:Range.range -> ErrorLogger.OperationResult<unit>
    val CheckUnionCaseAttributes :
      g:TcGlobals.TcGlobals ->
        x:TypedTree.UnionCaseRef ->
          m:Range.range -> ErrorLogger.OperationResult<unit>
    val CheckRecdFieldAttributes :
      g:TcGlobals.TcGlobals ->
        x:TypedTree.RecdFieldRef ->
          m:Range.range -> ErrorLogger.OperationResult<unit>
    val CheckValAttributes :
      g:TcGlobals.TcGlobals ->
        x:TypedTree.ValRef -> m:Range.range -> ErrorLogger.OperationResult<unit>
    val CheckRecdFieldInfoAttributes :
      g:TcGlobals.TcGlobals ->
        x:Infos.RecdFieldInfo ->
          m:Range.range -> ErrorLogger.OperationResult<unit>
    val IsSecurityAttribute :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          casmap:System.Collections.Generic.Dictionary<TypedTree.Stamp,bool> ->
            TypedTree.Attrib -> m:Range.range -> bool
    val IsSecurityCriticalAttribute :
      g:TcGlobals.TcGlobals -> TypedTree.Attrib -> bool
  end

namespace FSharp.Compiler
  module internal TypeRelations = begin
    val TypeDefinitelySubsumesTypeNoCoercion :
      ndeep:int ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range -> ty1:TypedTree.TType -> ty2:TypedTree.TType -> bool
    type CanCoerce =
      | CanCoerce
      | NoCoerce
    val TypesFeasiblyEquivalent :
      stripMeasures:bool ->
        ndeep:int ->
          g:TcGlobals.TcGlobals ->
            amap:'a ->
              m:Range.range ->
                ty1:TypedTree.TType -> ty2:TypedTree.TType -> bool
    val TypesFeasiblyEquiv :
      ndeep:int ->
        g:TcGlobals.TcGlobals ->
          amap:'a ->
            m:Range.range -> ty1:TypedTree.TType -> ty2:TypedTree.TType -> bool
    val TypesFeasiblyEquivStripMeasures :
      g:TcGlobals.TcGlobals ->
        amap:'a ->
          m:Range.range -> ty1:TypedTree.TType -> ty2:TypedTree.TType -> bool
    val TypeFeasiblySubsumesType :
      ndeep:int ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              ty1:TypedTree.TType ->
                canCoerce:CanCoerce -> ty2:TypedTree.TType -> bool
    val ChooseTyparSolutionAndRange :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          tp:TypedTree.Typar -> TypedTree.TType * Range.range
    val ChooseTyparSolution :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap -> tp:TypedTree.Typar -> TypedTree.TType
    val IterativelySubstituteTyparSolutions :
      g:TcGlobals.TcGlobals ->
        tps:TypedTree.Typars -> solutions:TypedTree.TTypes -> TypedTree.TypeInst
    val ChooseTyparSolutionsForFreeChoiceTypars :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap -> e:TypedTree.Expr -> TypedTree.Expr
    val tryDestTopLambda :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          TypedTree.ValReprInfo ->
            e:TypedTree.Expr * ty:TypedTree.TType ->
              (TypedTree.Typars * TypedTree.Val option * TypedTree.Val option *
               TypedTree.Val list list * TypedTree.Expr * TypedTree.TType) option
    val destTopLambda :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          topValInfo:TypedTree.ValReprInfo ->
            e:TypedTree.Expr * ty:TypedTree.TType ->
              TypedTree.Typars * TypedTree.Val option * TypedTree.Val option *
              TypedTree.Val list list * TypedTree.Expr * TypedTree.TType
    val IteratedAdjustArityOfLambdaBody :
      g:TcGlobals.TcGlobals ->
        arities:int list ->
          vsl:TypedTree.Val list list ->
            body:TypedTree.Expr -> TypedTree.Val list list * TypedTree.Expr
    val IteratedAdjustArityOfLambda :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          topValInfo:TypedTree.ValReprInfo ->
            e:TypedTree.Expr ->
              TypedTree.Typars * TypedTree.Val option * TypedTree.Val option *
              TypedTree.Val list list * TypedTree.Expr * TypedTree.TType
    val FindUniqueFeasibleSupertype :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            ty1:TypedTree.TType -> ty2:TypedTree.TType -> TypedTree.TType option
  end

namespace FSharp.Compiler
  module internal InfoReader = begin
    val SelectImmediateMemberVals :
      g:TcGlobals.TcGlobals ->
        optFilter:string option ->
          f:(TypedTree.ValMemberInfo -> TypedTree.ValRef -> 'a option) ->
            tcref:TypedTree.TyconRef -> 'a list
    val private checkFilter : optFilter:string option -> nm:string -> bool
    val TrySelectMemberVal :
      g:TcGlobals.TcGlobals ->
        optFilter:string option ->
          ty:TypedTree.TType ->
            pri:Infos.ExtensionMethodPriority option ->
              _membInfo:'a -> vref:TypedTree.ValRef -> Infos.MethInfo option
    val GetImmediateIntrinsicMethInfosOfTypeAux :
      optFilter:string option * ad:AccessibilityLogic.AccessorDomain ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              origTy:TypedTree.TType ->
                metadataTy:TypedTree.TType -> Infos.MethInfo list
    val GetImmediateIntrinsicMethInfosOfType :
      optFilter:string option * ad:AccessibilityLogic.AccessorDomain ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range -> ty:TypedTree.TType -> Infos.MethInfo list
    type PropertyCollector =
      class
        new : g:TcGlobals.TcGlobals * amap:Import.ImportMap * m:Range.range *
              ty:TypedTree.TType * optFilter:string option *
              ad:AccessibilityLogic.AccessorDomain -> PropertyCollector
        member Close : unit -> Infos.PropInfo list
        member
          Collect : membInfo:TypedTree.ValMemberInfo * vref:TypedTree.ValRef ->
                      unit
      end
    val GetImmediateIntrinsicPropInfosOfTypeAux :
      optFilter:string option * ad:AccessibilityLogic.AccessorDomain ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              origTy:TypedTree.TType ->
                metadataTy:TypedTree.TType -> Infos.PropInfo list
    val GetImmediateIntrinsicPropInfosOfType :
      optFilter:string option * ad:AccessibilityLogic.AccessorDomain ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range -> ty:TypedTree.TType -> Infos.PropInfo list
    val IsIndexerType :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap -> ty:TypedTree.TType -> bool
    val GetMostSpecificItemsByType :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          f:('a -> (TypedTree.TType * Range.range) option) ->
            xs:'a list -> 'a list
    val GetMostSpecificMethodInfosByMethInfoSig :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            ty:TypedTree.TType * minfo:Infos.MethInfo ->
              minfos:(TypedTree.TType * Infos.MethInfo) list ->
                (TypedTree.TType * Infos.MethInfo) list
    val FilterMostSpecificMethInfoSets :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            minfoSets:AbstractIL.Internal.Library.NameMultiMap<TypedTree.TType *
                                                               Infos.MethInfo> ->
              AbstractIL.Internal.Library.NameMultiMap<TypedTree.TType *
                                                       Infos.MethInfo>
    type HierarchyItem =
      | MethodItem of Infos.MethInfo list list
      | PropertyItem of Infos.PropInfo list list
      | RecdFieldItem of Infos.RecdFieldInfo
      | EventItem of Infos.EventInfo list
      | ILFieldItem of Infos.ILFieldInfo list
    type InfoReader =
      class
        new : g:TcGlobals.TcGlobals * amap:Import.ImportMap -> InfoReader
        member
          GetEntireTypeHierarchy : allowMultiIntfInst:Infos.AllowMultiIntfInstantiations *
                                   m:Range.range * ty:TypedTree.TType ->
                                     TypedTree.TType list
        member
          GetEventInfosOfType : optFilter:string option *
                                ad:AccessibilityLogic.AccessorDomain *
                                m:Range.range * ty:TypedTree.TType ->
                                  Infos.EventInfo list
        member
          GetILFieldInfosOfType : optFilter:string option *
                                  ad:AccessibilityLogic.AccessorDomain *
                                  m:Range.range * ty:TypedTree.TType ->
                                    Infos.ILFieldInfo list
        member
          GetImmediateIntrinsicEventsOfType : optFilter:string option *
                                              ad:AccessibilityLogic.AccessorDomain *
                                              m:Range.range * ty:TypedTree.TType ->
                                                Infos.EventInfo list
        member
          GetIntrinsicMostSpecificOverrideMethodSetsOfType : optFilter:string option *
                                                             ad:AccessibilityLogic.AccessorDomain *
                                                             allowMultiIntfInst:Infos.AllowMultiIntfInstantiations *
                                                             m:Range.range *
                                                             ty:TypedTree.TType ->
                                                               AbstractIL.Internal.Library.NameMultiMap<TypedTree.TType *
                                                                                                        Infos.MethInfo>
        member
          GetPrimaryTypeHierarchy : allowMultiIntfInst:Infos.AllowMultiIntfInstantiations *
                                    m:Range.range * ty:TypedTree.TType ->
                                      TypedTree.TType list
        member
          GetRawIntrinsicMethodSetsOfType : optFilter:string option *
                                            ad:AccessibilityLogic.AccessorDomain *
                                            allowMultiIntfInst:Infos.AllowMultiIntfInstantiations *
                                            m:Range.range * ty:TypedTree.TType ->
                                              Infos.MethInfo list list
        member
          GetRawIntrinsicPropertySetsOfType : optFilter:string option *
                                              ad:AccessibilityLogic.AccessorDomain *
                                              allowMultiIntfInst:Infos.AllowMultiIntfInstantiations *
                                              m:Range.range * ty:TypedTree.TType ->
                                                Infos.PropInfo list list
        member
          GetRecordOrClassFieldsOfType : optFilter:string option *
                                         ad:AccessibilityLogic.AccessorDomain *
                                         m:Range.range * ty:TypedTree.TType ->
                                           Infos.RecdFieldInfo list
        member
          IsLanguageFeatureRuntimeSupported : langFeature:Features.LanguageFeature ->
                                                bool
        member
          TryFindNamedItemOfType : nm:string *
                                   ad:AccessibilityLogic.AccessorDomain *
                                   m:Range.range * ty:TypedTree.TType ->
                                     HierarchyItem option
        member
          TryFindRecdOrClassFieldInfoOfType : nm:string * m:Range.range *
                                              ty:TypedTree.TType ->
                                                Infos.RecdFieldInfo voption
        member amap : Import.ImportMap
        member g : TcGlobals.TcGlobals
      end
    val private tryLanguageFeatureRuntimeErrorAux :
      infoReader:InfoReader ->
        langFeature:Features.LanguageFeature ->
          m:Range.range -> error:(exn -> unit) -> bool
    val checkLanguageFeatureRuntimeError :
      infoReader:InfoReader ->
        langFeature:Features.LanguageFeature -> m:Range.range -> unit
    val checkLanguageFeatureRuntimeErrorRecover :
      infoReader:InfoReader ->
        langFeature:Features.LanguageFeature -> m:Range.range -> unit
    val tryLanguageFeatureRuntimeErrorRecover :
      infoReader:InfoReader ->
        langFeature:Features.LanguageFeature -> m:Range.range -> bool
    val GetIntrinsicConstructorInfosOfTypeAux :
      infoReader:InfoReader ->
        m:Range.range ->
          origTy:TypedTree.TType ->
            metadataTy:TypedTree.TType -> Infos.MethInfo list
    val GetIntrinsicConstructorInfosOfType :
      infoReader:InfoReader ->
        m:Range.range -> ty:TypedTree.TType -> Infos.MethInfo list
    type FindMemberFlag =
      | IgnoreOverrides
      | PreferOverrides
    type private IndexedList<'T> =
      class
        new : itemLists:'T list list *
              itemsByName:AbstractIL.Internal.Library.NameMultiMap<'T> ->
                IndexedList<'T>
        member AddItems : items:'T list * nmf:('T -> string) -> IndexedList<'T>
        member
          FilterNewItems : keepTest:('a -> 'T -> bool) ->
                             nmf:('a -> string) -> itemsToAdd:'a list -> 'a list
        member ItemsWithName : nm:string -> 'T list
        member Items : 'T list list
        static member Empty : IndexedList<'T>
      end
    val private FilterItemsInSubTypesBasedOnItemsInSuperTypes :
      nmf:('a -> string) ->
        keepTest:('a -> 'a -> bool) -> itemLists:'a list list -> 'a list list
    val private FilterItemsInSuperTypesBasedOnItemsInSubTypes :
      nmf:('a -> string) ->
        keepTest:('a -> 'a list -> bool) ->
          itemLists:'a list list -> 'a list list
    val private ExcludeItemsInSuperTypesBasedOnEquivTestWithItemsInSubTypes :
      nmf:('a -> string) ->
        equivTest:('a -> 'a -> bool) -> itemLists:'a list list -> 'a list list
    val private FilterOverrides :
      findFlag:FindMemberFlag ->
        isVirt:('a -> bool) * isNewSlot:('a -> bool) *
        isDefiniteOverride:('a -> bool) * isFinal:('a -> bool) *
        equivSigs:('a -> 'a -> bool) * nmf:('a -> string) ->
          items:'a list list -> 'a list list
    val private FilterOverridesOfMethInfos :
      findFlag:FindMemberFlag ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              minfos:Infos.MethInfo list list -> Infos.MethInfo list list
    val private FilterOverridesOfPropInfos :
      findFlag:FindMemberFlag ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              props:Infos.PropInfo list list -> Infos.PropInfo list list
    val ExcludeHiddenOfMethInfos :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            minfos:Infos.MethInfo list list -> Infos.MethInfo list
    val ExcludeHiddenOfPropInfos :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            pinfos:Infos.PropInfo list list -> Infos.PropInfo list
    val GetIntrinsicMethInfoSetsOfType :
      infoReader:InfoReader ->
        optFilter:string option ->
          ad:AccessibilityLogic.AccessorDomain ->
            allowMultiIntfInst:Infos.AllowMultiIntfInstantiations ->
              findFlag:FindMemberFlag ->
                m:Range.range -> ty:TypedTree.TType -> Infos.MethInfo list list
    val GetIntrinsicPropInfoSetsOfType :
      infoReader:InfoReader ->
        optFilter:string option ->
          ad:AccessibilityLogic.AccessorDomain ->
            allowMultiIntfInst:Infos.AllowMultiIntfInstantiations ->
              findFlag:FindMemberFlag ->
                m:Range.range -> ty:TypedTree.TType -> Infos.PropInfo list list
    val GetIntrinsicMethInfosOfType :
      infoReader:InfoReader ->
        optFilter:string option ->
          ad:AccessibilityLogic.AccessorDomain ->
            allowMultiIntfInst:Infos.AllowMultiIntfInstantiations ->
              findFlag:FindMemberFlag ->
                m:Range.range -> ty:TypedTree.TType -> Infos.MethInfo list
    val GetIntrinsicPropInfosOfType :
      infoReader:InfoReader ->
        optFilter:string option ->
          ad:AccessibilityLogic.AccessorDomain ->
            allowMultiIntfInst:Infos.AllowMultiIntfInstantiations ->
              findFlag:FindMemberFlag ->
                m:Range.range -> ty:TypedTree.TType -> Infos.PropInfo list
    val TryFindIntrinsicNamedItemOfType :
      infoReader:InfoReader ->
        nm:string * ad:AccessibilityLogic.AccessorDomain ->
          findFlag:FindMemberFlag ->
            m:Range.range -> ty:TypedTree.TType -> HierarchyItem option
    val TryFindIntrinsicMethInfo :
      infoReader:InfoReader ->
        m:Range.range ->
          ad:AccessibilityLogic.AccessorDomain ->
            nm:string -> ty:TypedTree.TType -> Infos.MethInfo list
    val TryFindPropInfo :
      infoReader:InfoReader ->
        m:Range.range ->
          ad:AccessibilityLogic.AccessorDomain ->
            nm:string -> ty:TypedTree.TType -> Infos.PropInfo list
    val GetIntrinisicMostSpecificOverrideMethInfoSetsOfType :
      infoReader:InfoReader ->
        m:Range.range ->
          ty:TypedTree.TType ->
            AbstractIL.Internal.Library.NameMultiMap<TypedTree.TType *
                                                     Infos.MethInfo>
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type SigOfFunctionForDelegate =
      | SigOfFunctionForDelegate of
        Infos.MethInfo * TypedTree.TType list * TypedTree.TType *
        TypedTree.TType
    val GetSigOfFunctionForDelegate :
      infoReader:InfoReader ->
        delty:TypedTree.TType ->
          m:Range.range ->
            ad:AccessibilityLogic.AccessorDomain -> SigOfFunctionForDelegate
    val TryDestStandardDelegateType :
      infoReader:InfoReader ->
        m:Range.range ->
          ad:AccessibilityLogic.AccessorDomain ->
            delTy:TypedTree.TType -> (TypedTree.TType * TypedTree.TType) option
    val IsStandardEventInfo :
      infoReader:InfoReader ->
        m:Range.range ->
          ad:AccessibilityLogic.AccessorDomain -> einfo:Infos.EventInfo -> bool
    val ArgsTypOfEventInfo :
      infoReader:InfoReader ->
        m:Range.range ->
          ad:AccessibilityLogic.AccessorDomain ->
            einfo:Infos.EventInfo -> TypedTree.TType
    val PropTypOfEventInfo :
      infoReader:InfoReader ->
        m:Range.range ->
          ad:AccessibilityLogic.AccessorDomain ->
            einfo:Infos.EventInfo -> TypedTree.TType
  end

namespace FSharp.Compiler
  module internal NicePrint = begin
    module PrintUtilities = begin
      val bracketIfL :
        x:bool ->
          lyt:Internal.Utilities.StructuredFormat.Layout ->
            Internal.Utilities.StructuredFormat.Layout
      val squareAngleL :
        x:Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
      val angleL :
        x:Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
      val braceL :
        x:Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
      val braceBarL :
        x:Internal.Utilities.StructuredFormat.Layout ->
          Internal.Utilities.StructuredFormat.Layout
      val comment : str:string -> Internal.Utilities.StructuredFormat.Layout
      val layoutsL : ls:Layout.layout list -> Layout.layout
      val suppressInheritanceAndInterfacesForTyInSimplifiedDisplays :
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap -> m:Range.range -> ty:TypedTree.TType -> bool
      val applyMaxMembers :
        maxMembers:int option ->
          allDecls:Internal.Utilities.StructuredFormat.Layout list ->
            Internal.Utilities.StructuredFormat.Layout list
      val adjustILName : n:string -> string
      val shrinkOverloads :
        layoutFunction:('a -> Internal.Utilities.StructuredFormat.Layout) ->
          resultFunction:('a -> Internal.Utilities.StructuredFormat.Layout -> 'b) ->
            group:'a list -> 'b list
      val layoutTyconRefImpl :
        isAttribute:bool ->
          denv:TypedTreeOps.DisplayEnv ->
            tcref:TypedTree.TyconRef ->
              Internal.Utilities.StructuredFormat.Layout
      val layoutBuiltinAttribute :
        denv:TypedTreeOps.DisplayEnv ->
          attrib:TcGlobals.BuiltinAttribInfo ->
            Internal.Utilities.StructuredFormat.Layout
    end
    module private PrintIL = begin
      val fullySplitILTypeRef : tref:AbstractIL.IL.ILTypeRef -> string list
      val layoutILTypeRefName :
        denv:TypedTreeOps.DisplayEnv ->
          path:string list -> Internal.Utilities.StructuredFormat.Layout
      val layoutILTypeRef :
        denv:TypedTreeOps.DisplayEnv ->
          tref:AbstractIL.IL.ILTypeRef ->
            Internal.Utilities.StructuredFormat.Layout
      val layoutILArrayShape :
        AbstractIL.IL.ILArrayShape -> Internal.Utilities.StructuredFormat.Layout
      val paramsL : ps:Layout.layout list -> Layout.layout
      val pruneParams :
        className:string ->
          ilTyparSubst:Layout.layout list -> Layout.layout list
      val layoutILType :
        denv:TypedTreeOps.DisplayEnv ->
          ilTyparSubst:Layout.layout list ->
            ty:AbstractIL.IL.ILType -> Layout.layout
      val layoutILCallingSignature :
        denv:TypedTreeOps.DisplayEnv ->
          ilTyparSubst:Layout.layout list ->
            cons:string option ->
              signature:AbstractIL.IL.ILCallingSignature -> Layout.layout
      val layoutILFieldInit :
        x:AbstractIL.IL.ILFieldInit option ->
          Internal.Utilities.StructuredFormat.Layout
      val layoutILEnumDefParts :
        nm:string ->
          litVal:AbstractIL.IL.ILFieldInit option ->
            Internal.Utilities.StructuredFormat.Layout
    end
    module private PrintTypes = begin
      val layoutConst :
        g:TcGlobals.TcGlobals ->
          ty:TypedTree.TType ->
            c:TypedTree.Const -> Internal.Utilities.StructuredFormat.Layout
      val layoutAccessibility :
        denv:TypedTreeOps.DisplayEnv ->
          accessibility:TypedTree.Accessibility ->
            itemL:Internal.Utilities.StructuredFormat.Layout ->
              Internal.Utilities.StructuredFormat.Layout
      val layoutTyconRef :
        denv:TypedTreeOps.DisplayEnv ->
          tycon:TypedTree.TyconRef -> Internal.Utilities.StructuredFormat.Layout
      val layoutMemberFlags :
        memFlags:SyntaxTree.MemberFlags ->
          Internal.Utilities.StructuredFormat.Layout
      val layoutAttribArg :
        denv:TypedTreeOps.DisplayEnv ->
          arg:TypedTree.Expr -> Internal.Utilities.StructuredFormat.Layout
      val layoutAttribArgs :
        denv:TypedTreeOps.DisplayEnv ->
          args:TypedTree.AttribExpr list ->
            Internal.Utilities.StructuredFormat.Layout
      val layoutAttrib :
        denv:TypedTreeOps.DisplayEnv ->
          TypedTree.Attrib -> Internal.Utilities.StructuredFormat.Layout
      val layoutILAttribElement :
        denv:TypedTreeOps.DisplayEnv ->
          arg:AbstractIL.IL.ILAttribElem ->
            Internal.Utilities.StructuredFormat.Layout
      val layoutILAttrib :
        denv:TypedTreeOps.DisplayEnv ->
          ty:AbstractIL.IL.ILType * args:AbstractIL.IL.ILAttribElem list ->
            Internal.Utilities.StructuredFormat.Layout
      val layoutAttribs :
        denv:TypedTreeOps.DisplayEnv ->
          isValue:bool ->
            ty:TypedTree.TType ->
              kind:TypedTree.TyparKind ->
                attrs:TypedTree.Attrib list ->
                  restL:Internal.Utilities.StructuredFormat.Layout ->
                    Internal.Utilities.StructuredFormat.Layout
      val layoutTyparAttribs :
        denv:TypedTreeOps.DisplayEnv ->
          kind:TypedTree.TyparKind ->
            attrs:TypedTree.Attrib list ->
              restL:Internal.Utilities.StructuredFormat.Layout ->
                Internal.Utilities.StructuredFormat.Layout
      val layoutTyparRef :
        denv:TypedTreeOps.DisplayEnv ->
          typar:TypedTree.Typar -> Internal.Utilities.StructuredFormat.Layout
      val layoutTyparRefWithInfo :
        denv:TypedTreeOps.DisplayEnv ->
          env:TypedTreeOps.SimplifyTypes.TypeSimplificationInfo ->
            typar:TypedTree.Typar -> Internal.Utilities.StructuredFormat.Layout
      val layoutConstraintsWithInfo :
        denv:TypedTreeOps.DisplayEnv ->
          env:TypedTreeOps.SimplifyTypes.TypeSimplificationInfo ->
            cxs:(TypedTree.Typar * TypedTree.TyparConstraint) list ->
              Internal.Utilities.StructuredFormat.Layout
      val layoutConstraintWithInfo :
        denv:TypedTreeOps.DisplayEnv ->
          env:TypedTreeOps.SimplifyTypes.TypeSimplificationInfo ->
            tp:TypedTree.Typar * tpc:TypedTree.TyparConstraint ->
              Internal.Utilities.StructuredFormat.Layout list
      val layoutTraitWithInfo :
        denv:TypedTreeOps.DisplayEnv ->
          env:TypedTreeOps.SimplifyTypes.TypeSimplificationInfo ->
            TypedTree.TraitConstraintInfo ->
              Internal.Utilities.StructuredFormat.Layout
      val layoutMeasure :
        denv:TypedTreeOps.DisplayEnv ->
          unt:TypedTree.Measure -> Internal.Utilities.StructuredFormat.Layout
      val layoutTypeAppWithInfoAndPrec :
        denv:TypedTreeOps.DisplayEnv ->
          env:TypedTreeOps.SimplifyTypes.TypeSimplificationInfo ->
            tcL:Internal.Utilities.StructuredFormat.Layout ->
              prec:int ->
                prefix:bool ->
                  args:TypedTree.TType list ->
                    Internal.Utilities.StructuredFormat.Layout
      val layoutTypeWithInfoAndPrec :
        denv:TypedTreeOps.DisplayEnv ->
          env:TypedTreeOps.SimplifyTypes.TypeSimplificationInfo ->
            prec:int ->
              ty:TypedTree.TType -> Internal.Utilities.StructuredFormat.Layout
      val layoutTypesWithInfoAndPrec :
        denv:TypedTreeOps.DisplayEnv ->
          env:TypedTreeOps.SimplifyTypes.TypeSimplificationInfo ->
            prec:int ->
              sep:Internal.Utilities.StructuredFormat.Layout ->
                typl:TypedTree.TType list ->
                  Internal.Utilities.StructuredFormat.Layout
      val layoutReturnType :
        denv:TypedTreeOps.DisplayEnv ->
          env:TypedTreeOps.SimplifyTypes.TypeSimplificationInfo ->
            rty:TypedTree.TType -> Internal.Utilities.StructuredFormat.Layout
      val layoutTypeWithInfo :
        denv:TypedTreeOps.DisplayEnv ->
          env:TypedTreeOps.SimplifyTypes.TypeSimplificationInfo ->
            ty:TypedTree.TType -> Internal.Utilities.StructuredFormat.Layout
      val layoutType :
        denv:TypedTreeOps.DisplayEnv ->
          ty:TypedTree.TType -> Internal.Utilities.StructuredFormat.Layout
      val layoutArgInfos :
        denv:TypedTreeOps.DisplayEnv ->
          env:TypedTreeOps.SimplifyTypes.TypeSimplificationInfo ->
            argInfos:(TypedTree.TType * TypedTree.ArgReprInfo) list list ->
              Internal.Utilities.StructuredFormat.Layout list
      val layoutGenericParameterTypes :
        denv:TypedTreeOps.DisplayEnv ->
          env:TypedTreeOps.SimplifyTypes.TypeSimplificationInfo ->
            _arg1:TypedTree.TType list ->
              Internal.Utilities.StructuredFormat.Layout
      val layoutTopType :
        denv:TypedTreeOps.DisplayEnv ->
          env:TypedTreeOps.SimplifyTypes.TypeSimplificationInfo ->
            argInfos:(TypedTree.TType * TypedTree.ArgReprInfo) list list ->
              rty:TypedTree.TType ->
                cxs:(TypedTree.Typar * TypedTree.TyparConstraint) list ->
                  Internal.Utilities.StructuredFormat.Layout
      val layoutTyparDecls :
        denv:TypedTreeOps.DisplayEnv ->
          nmL:Internal.Utilities.StructuredFormat.Layout ->
            prefix:bool ->
              typars:TypedTree.Typars ->
                Internal.Utilities.StructuredFormat.Layout
      val layoutTyparConstraint :
        denv:TypedTreeOps.DisplayEnv ->
          tp:TypedTree.Typar * tpc:TypedTree.TyparConstraint ->
            Internal.Utilities.StructuredFormat.Layout
      val prettyLayoutOfInstAndSig :
        denv:TypedTreeOps.DisplayEnv ->
          typarInst:TypedTreeOps.TyparInst * tys:TypedTree.TTypes *
          retTy:TypedTree.TType ->
            TypedTreeOps.TyparInst * (TypedTree.TTypes * TypedTree.TType) *
            (Internal.Utilities.StructuredFormat.Layout list *
             Internal.Utilities.StructuredFormat.Layout) *
            Internal.Utilities.StructuredFormat.Layout
      val prettyLayoutOfTopTypeInfoAux :
        denv:TypedTreeOps.DisplayEnv ->
          prettyArgInfos:(TypedTree.TType * TypedTree.ArgReprInfo) list list ->
            prettyRetTy:TypedTree.TType ->
              cxs:TypedTreeOps.TyparConstraintsWithTypars ->
                Internal.Utilities.StructuredFormat.Layout
      val prettyLayoutOfUncurriedSig :
        denv:TypedTreeOps.DisplayEnv ->
          typarInst:TypedTreeOps.TyparInst ->
            argInfos:TypedTreeOps.UncurriedArgInfos ->
              retTy:TypedTree.TType ->
                TypedTreeOps.TyparInst *
                Internal.Utilities.StructuredFormat.Layout
      val prettyLayoutOfCurriedMemberSig :
        denv:TypedTreeOps.DisplayEnv ->
          typarInst:TypedTreeOps.TyparInst ->
            argInfos:TypedTreeOps.CurriedArgInfos ->
              retTy:TypedTree.TType ->
                parentTyparTys:TypedTree.TTypes ->
                  TypedTreeOps.TyparInst *
                  Internal.Utilities.StructuredFormat.Layout
      val prettyArgInfos :
        denv:TypedTreeOps.DisplayEnv ->
          allTyparInst:TypedTreeOps.TyparInst ->
            _arg1:(TypedTree.TType * TypedTree.ArgReprInfo) list ->
              (TypedTree.TType * TypedTree.ArgReprInfo) list
      val prettyLayoutOfMemberSigCore :
        denv:TypedTreeOps.DisplayEnv ->
          memberToParentInst:(TypedTree.Typar * TypedTree.TType) list ->
            typarInst:TypedTreeOps.TyparInst * methTypars:TypedTree.Typars *
            argInfos:(TypedTree.TType * TypedTree.ArgReprInfo) list list *
            retTy:TypedTree.TType ->
              TypedTreeOps.TyparInst * TypedTree.Typars *
              Internal.Utilities.StructuredFormat.Layout
      val prettyLayoutOfMemberType :
        denv:TypedTreeOps.DisplayEnv ->
          v:TypedTree.ValRef ->
            typarInst:TypedTreeOps.TyparInst ->
              argInfos:(TypedTree.TType * TypedTree.ArgReprInfo) list list ->
                retTy:TypedTree.TType ->
                  TypedTreeOps.TyparInst * TypedTree.Typars *
                  Internal.Utilities.StructuredFormat.Layout
      val prettyLayoutOfMemberSig :
        denv:TypedTreeOps.DisplayEnv ->
          memberToParentInst:(TypedTree.Typar * TypedTree.TType) list *
          nm:string * methTypars:TypedTree.Typars *
          argInfos:(TypedTree.TType * TypedTree.ArgReprInfo) list list *
          retTy:TypedTree.TType -> Internal.Utilities.StructuredFormat.Layout
      val prettyLayoutsOfUnresolvedOverloading :
        denv:TypedTreeOps.DisplayEnv ->
          argInfos:(TypedTree.TType * TypedTree.ArgReprInfo) list ->
            retTy:TypedTree.TType ->
              genParamTys:seq<TypedTree.TType> ->
                Internal.Utilities.StructuredFormat.Layout *
                Internal.Utilities.StructuredFormat.Layout *
                Internal.Utilities.StructuredFormat.Layout
      val prettyLayoutOfType :
        denv:TypedTreeOps.DisplayEnv ->
          ty:TypedTree.TType -> Internal.Utilities.StructuredFormat.Layout
      val prettyLayoutOfTypeNoConstraints :
        denv:TypedTreeOps.DisplayEnv ->
          ty:TypedTree.TType -> Internal.Utilities.StructuredFormat.Layout
      val layoutAssemblyName : _denv:'a -> ty:TypedTree.TType -> string
    end
    module private PrintTastMemberOrVals = begin
      val prettyLayoutOfMemberShortOption :
        denv:TypedTreeOps.DisplayEnv ->
          typarInst:TypedTreeOps.TyparInst ->
            v:TypedTree.Val ->
              short:bool ->
                TypedTreeOps.TyparInst *
                Internal.Utilities.StructuredFormat.Layout
      val prettyLayoutOfMember :
        denv:TypedTreeOps.DisplayEnv ->
          typarInst:TypedTreeOps.TyparInst ->
            v:TypedTree.Val ->
              TypedTreeOps.TyparInst *
              Internal.Utilities.StructuredFormat.Layout
      val prettyLayoutOfMemberNoInstShort :
        denv:TypedTreeOps.DisplayEnv ->
          v:TypedTree.Val -> Internal.Utilities.StructuredFormat.Layout
      val layoutOfLiteralValue :
        literalValue:TypedTree.Const ->
          Internal.Utilities.StructuredFormat.Layout
      val layoutNonMemberVal :
        denv:TypedTreeOps.DisplayEnv ->
          tps:TypedTree.Typar list * v:TypedTree.Val * tau:TypedTree.TType *
          cxs:TypedTreeOps.TyparConstraintsWithTypars ->
            Internal.Utilities.StructuredFormat.Layout
      val prettyLayoutOfValOrMember :
        denv:TypedTreeOps.DisplayEnv ->
          typarInst:TypedTreeOps.TyparInst ->
            v:TypedTree.Val ->
              TypedTreeOps.TyparInst *
              Internal.Utilities.StructuredFormat.Layout
      val prettyLayoutOfValOrMemberNoInst :
        denv:TypedTreeOps.DisplayEnv ->
          v:TypedTree.Val -> Internal.Utilities.StructuredFormat.Layout
    end
    val layoutTyparConstraint :
      denv:TypedTreeOps.DisplayEnv ->
        TypedTree.Typar * TypedTree.TyparConstraint ->
          Internal.Utilities.StructuredFormat.Layout
    val outputType :
      denv:TypedTreeOps.DisplayEnv ->
        os:System.Text.StringBuilder -> x:TypedTree.TType -> unit
    val layoutType :
      denv:TypedTreeOps.DisplayEnv ->
        x:TypedTree.TType -> Internal.Utilities.StructuredFormat.Layout
    val outputTypars :
      denv:TypedTreeOps.DisplayEnv ->
        nm:Layout.TaggedText ->
          os:System.Text.StringBuilder -> x:TypedTree.Typars -> unit
    val outputTyconRef :
      denv:TypedTreeOps.DisplayEnv ->
        os:System.Text.StringBuilder -> x:TypedTree.TyconRef -> unit
    val layoutTyconRef :
      denv:TypedTreeOps.DisplayEnv ->
        x:TypedTree.TyconRef -> Internal.Utilities.StructuredFormat.Layout
    val layoutConst :
      g:TcGlobals.TcGlobals ->
        ty:TypedTree.TType ->
          c:TypedTree.Const -> Internal.Utilities.StructuredFormat.Layout
    val prettyLayoutOfMemberSig :
      denv:TypedTreeOps.DisplayEnv ->
        (TypedTree.Typar * TypedTree.TType) list * string * TypedTree.Typars *
        (TypedTree.TType * TypedTree.ArgReprInfo) list list * TypedTree.TType ->
          Internal.Utilities.StructuredFormat.Layout
    val prettyLayoutOfUncurriedSig :
      denv:TypedTreeOps.DisplayEnv ->
        argInfos:TypedTreeOps.TyparInst ->
          tau:TypedTreeOps.UncurriedArgInfos ->
            (TypedTree.TType ->
               TypedTreeOps.TyparInst *
               Internal.Utilities.StructuredFormat.Layout)
    val prettyLayoutsOfUnresolvedOverloading :
      denv:TypedTreeOps.DisplayEnv ->
        argInfos:(TypedTree.TType * TypedTree.ArgReprInfo) list ->
          retTy:TypedTree.TType ->
            genericParameters:seq<TypedTree.TType> ->
              Internal.Utilities.StructuredFormat.Layout *
              Internal.Utilities.StructuredFormat.Layout *
              Internal.Utilities.StructuredFormat.Layout
    module InfoMemberPrinting = begin
      val layoutParamData :
        denv:TypedTreeOps.DisplayEnv ->
          Infos.ParamData -> Internal.Utilities.StructuredFormat.Layout
      val formatParamDataToBuffer :
        denv:TypedTreeOps.DisplayEnv ->
          os:System.Text.StringBuilder -> pd:Infos.ParamData -> unit
      val private layoutMethInfoFSharpStyleCore :
        amap:Import.ImportMap ->
          m:Range.range ->
            denv:TypedTreeOps.DisplayEnv ->
              minfo:Infos.MethInfo ->
                minst:TypedTree.TType list ->
                  Internal.Utilities.StructuredFormat.Layout
      val private layoutMethInfoCSharpStyle :
        amap:Import.ImportMap ->
          m:Range.range ->
            denv:TypedTreeOps.DisplayEnv ->
              minfo:Infos.MethInfo ->
                minst:TypedTree.TType list ->
                  Internal.Utilities.StructuredFormat.Layout
      val prettifyILMethInfo :
        amap:Import.ImportMap ->
          m:Range.range ->
            minfo:Infos.MethInfo ->
              typarInst:TypedTreeOps.TyparInst ->
                ilMethInfo:Infos.ILMethInfo ->
                  TypedTreeOps.TyparInst * Infos.MethInfo * TypedTree.TType list
      val prettyLayoutOfMethInfoFreeStyle :
        amap:Import.ImportMap ->
          m:Range.range ->
            denv:TypedTreeOps.DisplayEnv ->
              typarInst:TypedTreeOps.TyparInst ->
                methInfo:Infos.MethInfo ->
                  TypedTreeOps.TyparInst *
                  Internal.Utilities.StructuredFormat.Layout
      val prettyLayoutOfPropInfoFreeStyle :
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              denv:TypedTreeOps.DisplayEnv ->
                pinfo:Infos.PropInfo ->
                  Internal.Utilities.StructuredFormat.Layout
      val formatMethInfoToBufferFreeStyle :
        amap:Import.ImportMap ->
          m:Range.range ->
            denv:TypedTreeOps.DisplayEnv ->
              os:System.Text.StringBuilder -> minfo:Infos.MethInfo -> unit
      val layoutMethInfoFSharpStyle :
        amap:Import.ImportMap ->
          m:Range.range ->
            denv:TypedTreeOps.DisplayEnv ->
              minfo:Infos.MethInfo -> Internal.Utilities.StructuredFormat.Layout
    end
    module private TastDefinitionPrinting = begin
      val layoutExtensionMember :
        denv:TypedTreeOps.DisplayEnv ->
          v:TypedTree.Val -> Internal.Utilities.StructuredFormat.Layout
      val layoutExtensionMembers :
        denv:TypedTreeOps.DisplayEnv ->
          vs:TypedTree.Val list -> Internal.Utilities.StructuredFormat.Layout
      val layoutRecdField :
        addAccess:bool ->
          denv:TypedTreeOps.DisplayEnv ->
            fld:TypedTree.RecdField ->
              Internal.Utilities.StructuredFormat.Layout
      val layoutUnionOrExceptionField :
        denv:TypedTreeOps.DisplayEnv ->
          isGenerated:('a -> TypedTree.RecdField -> bool) ->
            i:'a ->
              fld:TypedTree.RecdField ->
                Internal.Utilities.StructuredFormat.Layout
      val isGeneratedUnionCaseField : pos:int -> f:TypedTree.RecdField -> bool
      val isGeneratedExceptionField : pos:'a -> f:TypedTree.RecdField -> bool
      val layoutUnionCaseFields :
        denv:TypedTreeOps.DisplayEnv ->
          isUnionCase:bool ->
            fields:TypedTree.RecdField list ->
              Internal.Utilities.StructuredFormat.Layout
      val layoutUnionCase :
        denv:TypedTreeOps.DisplayEnv ->
          prefixL:Internal.Utilities.StructuredFormat.Layout ->
            ucase:TypedTree.UnionCase ->
              Internal.Utilities.StructuredFormat.Layout
      val layoutUnionCases :
        denv:TypedTreeOps.DisplayEnv ->
          ucases:TypedTree.UnionCase list ->
            Internal.Utilities.StructuredFormat.Layout list
      val breakTypeDefnEqn : repr:TypedTree.TyconRepresentation -> bool
      val layoutILFieldInfo :
        denv:TypedTreeOps.DisplayEnv ->
          amap:Import.ImportMap ->
            m:Range.range ->
              e:Infos.ILFieldInfo -> Internal.Utilities.StructuredFormat.Layout
      val layoutEventInfo :
        denv:TypedTreeOps.DisplayEnv ->
          amap:Import.ImportMap ->
            m:Range.range ->
              e:Infos.EventInfo -> Internal.Utilities.StructuredFormat.Layout
      val layoutPropInfo :
        denv:TypedTreeOps.DisplayEnv ->
          amap:Import.ImportMap ->
            m:Range.range ->
              p:Infos.PropInfo -> Internal.Utilities.StructuredFormat.Layout
      val layoutTycon :
        denv:TypedTreeOps.DisplayEnv ->
          infoReader:InfoReader.InfoReader ->
            ad:AccessibilityLogic.AccessorDomain ->
              m:Range.range ->
                simplified:bool ->
                  typewordL:Internal.Utilities.StructuredFormat.Layout ->
                    tycon:TypedTree.Tycon ->
                      Internal.Utilities.StructuredFormat.Layout
      val layoutExnDefn :
        denv:TypedTreeOps.DisplayEnv ->
          exnc:TypedTree.Entity -> Internal.Utilities.StructuredFormat.Layout
      val layoutTyconDefns :
        denv:TypedTreeOps.DisplayEnv ->
          infoReader:InfoReader.InfoReader ->
            ad:AccessibilityLogic.AccessorDomain ->
              m:Range.range ->
                tycons:TypedTree.Tycon list ->
                  Internal.Utilities.StructuredFormat.Layout
    end
    module private InferredSigPrinting = begin
      val layoutInferredSigOfModuleExpr :
        showHeader:bool ->
          denv:TypedTreeOps.DisplayEnv ->
            infoReader:InfoReader.InfoReader ->
              ad:AccessibilityLogic.AccessorDomain ->
                m:Range.range ->
                  expr:TypedTree.ModuleOrNamespaceExprWithSig ->
                    Internal.Utilities.StructuredFormat.Layout
    end
    module private PrintData = begin
      val dataExprL :
        denv:TypedTreeOps.DisplayEnv ->
          expr:TypedTree.Expr -> Internal.Utilities.StructuredFormat.Layout
      val dataExprWrapL :
        denv:TypedTreeOps.DisplayEnv ->
          isAtomic:bool ->
            expr:TypedTree.Expr -> Internal.Utilities.StructuredFormat.Layout
      val dataExprsL :
        denv:TypedTreeOps.DisplayEnv ->
          xs:TypedTree.Exprs -> Internal.Utilities.StructuredFormat.Layout list
    end
    val dataExprL :
      denv:TypedTreeOps.DisplayEnv ->
        expr:TypedTree.Expr -> Internal.Utilities.StructuredFormat.Layout
    val outputValOrMember :
      denv:TypedTreeOps.DisplayEnv ->
        os:System.Text.StringBuilder -> x:TypedTree.Val -> unit
    val stringValOrMember :
      denv:TypedTreeOps.DisplayEnv -> x:TypedTree.Val -> string
    val layoutQualifiedValOrMember :
      denv:TypedTreeOps.DisplayEnv ->
        typarInst:TypedTreeOps.TyparInst ->
          v:TypedTree.Val ->
            TypedTreeOps.TyparInst * Internal.Utilities.StructuredFormat.Layout
    val outputQualifiedValOrMember :
      denv:TypedTreeOps.DisplayEnv ->
        os:System.Text.StringBuilder -> v:TypedTree.Val -> unit
    val outputQualifiedValSpec :
      denv:TypedTreeOps.DisplayEnv ->
        os:System.Text.StringBuilder -> v:TypedTree.Val -> unit
    val stringOfQualifiedValOrMember :
      denv:TypedTreeOps.DisplayEnv -> v:TypedTree.Val -> string
    val formatMethInfoToBufferFreeStyle :
      amap:Import.ImportMap ->
        m:Range.range ->
          denv:TypedTreeOps.DisplayEnv ->
            buf:System.Text.StringBuilder -> d:Infos.MethInfo -> unit
    val prettyLayoutOfMethInfoFreeStyle :
      amap:Import.ImportMap ->
        m:Range.range ->
          denv:TypedTreeOps.DisplayEnv ->
            typarInst:TypedTreeOps.TyparInst ->
              minfo:Infos.MethInfo ->
                TypedTreeOps.TyparInst *
                Internal.Utilities.StructuredFormat.Layout
    val prettyLayoutOfPropInfoFreeStyle :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            denv:TypedTreeOps.DisplayEnv ->
              d:Infos.PropInfo -> Internal.Utilities.StructuredFormat.Layout
    val stringOfMethInfo :
      amap:Import.ImportMap ->
        m:Range.range ->
          denv:TypedTreeOps.DisplayEnv -> d:Infos.MethInfo -> string
    val stringOfParamData :
      denv:TypedTreeOps.DisplayEnv -> paramData:Infos.ParamData -> string
    val layoutOfParamData :
      denv:TypedTreeOps.DisplayEnv ->
        paramData:Infos.ParamData -> Internal.Utilities.StructuredFormat.Layout
    val layoutExnDef :
      denv:TypedTreeOps.DisplayEnv ->
        x:TypedTree.Entity -> Internal.Utilities.StructuredFormat.Layout
    val stringOfTyparConstraints :
      denv:TypedTreeOps.DisplayEnv ->
        x:(TypedTree.Typar * TypedTree.TyparConstraint) list -> string
    val layoutTycon :
      denv:TypedTreeOps.DisplayEnv ->
        infoReader:InfoReader.InfoReader ->
          ad:AccessibilityLogic.AccessorDomain ->
            m:Range.range ->
              x:TypedTree.Tycon -> Internal.Utilities.StructuredFormat.Layout
    val layoutUnionCases :
      denv:TypedTreeOps.DisplayEnv ->
        x:TypedTree.RecdField list -> Internal.Utilities.StructuredFormat.Layout
    val isGeneratedUnionCaseField : pos:int -> f:TypedTree.RecdField -> bool
    val isGeneratedExceptionField : pos:'a -> f:TypedTree.RecdField -> bool
    val stringOfTyparConstraint :
      denv:TypedTreeOps.DisplayEnv ->
        TypedTree.Typar * TypedTree.TyparConstraint -> string
    val stringOfTy : denv:TypedTreeOps.DisplayEnv -> x:TypedTree.TType -> string
    val prettyLayoutOfType :
      denv:TypedTreeOps.DisplayEnv ->
        x:TypedTree.TType -> Internal.Utilities.StructuredFormat.Layout
    val prettyLayoutOfTypeNoCx :
      denv:TypedTreeOps.DisplayEnv ->
        x:TypedTree.TType -> Internal.Utilities.StructuredFormat.Layout
    val prettyStringOfTy :
      denv:TypedTreeOps.DisplayEnv -> x:TypedTree.TType -> string
    val prettyStringOfTyNoCx :
      denv:TypedTreeOps.DisplayEnv -> x:TypedTree.TType -> string
    val stringOfRecdField :
      denv:TypedTreeOps.DisplayEnv -> x:TypedTree.RecdField -> string
    val stringOfUnionCase :
      denv:TypedTreeOps.DisplayEnv -> x:TypedTree.UnionCase -> string
    val stringOfExnDef :
      denv:TypedTreeOps.DisplayEnv -> x:TypedTree.Entity -> string
    val stringOfFSAttrib :
      denv:TypedTreeOps.DisplayEnv -> x:TypedTree.Attrib -> string
    val stringOfILAttrib :
      denv:TypedTreeOps.DisplayEnv ->
        AbstractIL.IL.ILType * AbstractIL.IL.ILAttribElem list -> string
    val layoutInferredSigOfModuleExpr :
      showHeader:bool ->
        denv:TypedTreeOps.DisplayEnv ->
          infoReader:InfoReader.InfoReader ->
            ad:AccessibilityLogic.AccessorDomain ->
              m:Range.range ->
                expr:TypedTree.ModuleOrNamespaceExprWithSig ->
                  Internal.Utilities.StructuredFormat.Layout
    val prettyLayoutOfValOrMember :
      denv:TypedTreeOps.DisplayEnv ->
        typarInst:TypedTreeOps.TyparInst ->
          v:TypedTree.Val ->
            TypedTreeOps.TyparInst * Internal.Utilities.StructuredFormat.Layout
    val prettyLayoutOfValOrMemberNoInst :
      denv:TypedTreeOps.DisplayEnv ->
        v:TypedTree.Val -> Internal.Utilities.StructuredFormat.Layout
    val prettyLayoutOfMemberNoInstShort :
      denv:TypedTreeOps.DisplayEnv ->
        v:TypedTree.Val -> Internal.Utilities.StructuredFormat.Layout
    val prettyLayoutOfInstAndSig :
      denv:TypedTreeOps.DisplayEnv ->
        TypedTreeOps.TyparInst * TypedTree.TTypes * TypedTree.TType ->
          TypedTreeOps.TyparInst * (TypedTree.TTypes * TypedTree.TType) *
          (Internal.Utilities.StructuredFormat.Layout list *
           Internal.Utilities.StructuredFormat.Layout) *
          Internal.Utilities.StructuredFormat.Layout
    val minimalStringsOfTwoTypes :
      denv:TypedTreeOps.DisplayEnv ->
        t1:TypedTree.TType -> t2:TypedTree.TType -> string * string * string
    val minimalStringsOfTwoValues :
      denv:TypedTreeOps.DisplayEnv ->
        v1:TypedTree.Val -> v2:TypedTree.Val -> string * string
    val minimalStringOfType :
      denv:TypedTreeOps.DisplayEnv -> ty:TypedTree.TType -> string
  end

namespace FSharp.Compiler
  module internal AugmentWithHashCompare = begin
    val mkIComparableCompareToSlotSig :
      g:TcGlobals.TcGlobals -> TypedTree.SlotSig
    val mkGenericIComparableCompareToSlotSig :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> TypedTree.SlotSig
    val mkIStructuralComparableCompareToSlotSig :
      g:TcGlobals.TcGlobals -> TypedTree.SlotSig
    val mkGenericIEquatableEqualsSlotSig :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> TypedTree.SlotSig
    val mkIStructuralEquatableEqualsSlotSig :
      g:TcGlobals.TcGlobals -> TypedTree.SlotSig
    val mkIStructuralEquatableGetHashCodeSlotSig :
      g:TcGlobals.TcGlobals -> TypedTree.SlotSig
    val mkGetHashCodeSlotSig : g:TcGlobals.TcGlobals -> TypedTree.SlotSig
    val mkEqualsSlotSig : g:TcGlobals.TcGlobals -> TypedTree.SlotSig
    val mkThisTy :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> TypedTree.TType
    val mkCompareObjTy :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> TypedTree.TType
    val mkCompareTy :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> TypedTree.TType
    val mkCompareWithComparerTy :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> TypedTree.TType
    val mkEqualsObjTy :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> TypedTree.TType
    val mkEqualsTy :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> TypedTree.TType
    val mkEqualsWithComparerTy :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> TypedTree.TType
    val mkHashTy :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> TypedTree.TType
    val mkHashWithComparerTy :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> TypedTree.TType
    val mkRelBinOp :
      g:TcGlobals.TcGlobals ->
        op:AbstractIL.IL.ILInstr ->
          m:Range.range ->
            e1:TypedTree.Expr -> e2:TypedTree.Expr -> TypedTree.Expr
    val mkClt :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          e1:TypedTree.Expr -> e2:TypedTree.Expr -> TypedTree.Expr
    val mkCgt :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          e1:TypedTree.Expr -> e2:TypedTree.Expr -> TypedTree.Expr
    val mkILLangPrimTy : g:TcGlobals.TcGlobals -> AbstractIL.IL.ILType
    val mkILCallGetComparer :
      g:TcGlobals.TcGlobals -> m:Range.range -> TypedTree.Expr
    val mkILCallGetEqualityComparer :
      g:TcGlobals.TcGlobals -> m:Range.range -> TypedTree.Expr
    val mkThisVar :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> ty:TypedTree.TType -> TypedTree.Val * TypedTree.Expr
    val mkShl :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> acce:TypedTree.Expr -> n:int -> TypedTree.Expr
    val mkShr :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> acce:TypedTree.Expr -> n:int -> TypedTree.Expr
    val mkAdd :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          e1:TypedTree.Expr -> e2:TypedTree.Expr -> TypedTree.Expr
    val mkAddToHashAcc :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          e:TypedTree.Expr ->
            accv:TypedTree.ValRef -> acce:TypedTree.Expr -> TypedTree.Expr
    val mkCombineHashGenerators :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          exprs:TypedTree.Expr list ->
            accv:TypedTree.ValRef -> acce:TypedTree.Expr -> TypedTree.Expr
    val mkThatAddrLocal :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> ty:TypedTree.TType -> TypedTree.Val * TypedTree.Expr
    val mkThatAddrLocalIfNeeded :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          tcve:TypedTree.Expr ->
            ty:TypedTree.TType -> TypedTree.Val option * TypedTree.Expr
    val mkThisVarThatVar :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          ty:TypedTree.TType ->
            TypedTree.Val * TypedTree.Val * TypedTree.Expr * TypedTree.Expr
    val mkThatVarBind :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          ty:TypedTree.TType ->
            thataddrv:TypedTree.Val ->
              expr:TypedTree.Expr -> TypedTree.Val * TypedTree.Expr
    val mkBindThatAddr :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          ty:TypedTree.TType ->
            thataddrv:TypedTree.Val ->
              thatv:TypedTree.Val ->
                thate:TypedTree.Expr -> expr:TypedTree.Expr -> TypedTree.Expr
    val mkBindThatAddrIfNeeded :
      m:Range.range ->
        thataddrvOpt:TypedTree.Val option ->
          thatv:TypedTree.Val -> expr:TypedTree.Expr -> TypedTree.Expr
    val mkDerefThis :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          thisv:TypedTree.Val -> thise:TypedTree.Expr -> TypedTree.Expr
    val mkCompareTestConjuncts :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> exprs:TypedTree.Expr list -> TypedTree.Expr
    val mkEqualsTestConjuncts :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> exprs:TypedTree.Expr list -> TypedTree.Expr
    val mkMinimalTy :
      g:TcGlobals.TcGlobals ->
        tcref:TypedTree.TyconRef -> TypedTree.TType list * TypedTree.TType
    val mkBindNullComparison :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          thise:TypedTree.Expr ->
            thate:TypedTree.Expr -> expr:TypedTree.Expr -> TypedTree.Expr
    val mkBindThisNullEquals :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          thise:TypedTree.Expr ->
            thate:TypedTree.Expr -> expr:TypedTree.Expr -> TypedTree.Expr
    val mkBindThatNullEquals :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          thise:TypedTree.Expr ->
            thate:TypedTree.Expr -> expr:TypedTree.Expr -> TypedTree.Expr
    val mkBindNullHash :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          thise:TypedTree.Expr -> expr:TypedTree.Expr -> TypedTree.Expr
    val mkRecdCompare :
      g:TcGlobals.TcGlobals ->
        tcref:TypedTree.TyconRef ->
          tycon:TypedTree.Tycon ->
            TypedTree.Val * TypedTree.Val * TypedTree.Expr
    val mkRecdCompareWithComparer :
      g:TcGlobals.TcGlobals ->
        tcref:TypedTree.TyconRef ->
          tycon:TypedTree.Tycon ->
            _thisv:'a * thise:TypedTree.Expr ->
              'b * thate:TypedTree.Expr ->
                compe:TypedTree.Expr -> TypedTree.Expr
    val mkRecdEquality :
      g:TcGlobals.TcGlobals ->
        tcref:TypedTree.TyconRef ->
          tycon:TypedTree.Tycon ->
            TypedTree.Val * TypedTree.Val * TypedTree.Expr
    val mkRecdEqualityWithComparer :
      g:TcGlobals.TcGlobals ->
        tcref:TypedTree.TyconRef ->
          tycon:TypedTree.Tycon ->
            _thisv:'a * thise:TypedTree.Expr ->
              thatobje:TypedTree.Expr ->
                thatv:TypedTree.Val * thate:TypedTree.Expr ->
                  compe:TypedTree.Expr -> TypedTree.Expr
    val mkExnEquality :
      g:TcGlobals.TcGlobals ->
        exnref:TypedTree.TyconRef ->
          exnc:TypedTree.Tycon -> TypedTree.Val * TypedTree.Val * TypedTree.Expr
    val mkExnEqualityWithComparer :
      g:TcGlobals.TcGlobals ->
        exnref:TypedTree.TyconRef ->
          exnc:TypedTree.Tycon ->
            _thisv:'a * thise:TypedTree.Expr ->
              thatobje:TypedTree.Expr ->
                thatv:TypedTree.Val * thate:TypedTree.Expr ->
                  compe:TypedTree.Expr -> TypedTree.Expr
    val mkUnionCompare :
      g:TcGlobals.TcGlobals ->
        tcref:TypedTree.TyconRef ->
          tycon:TypedTree.Tycon ->
            TypedTree.Val * TypedTree.Val * TypedTree.Expr
    val mkUnionCompareWithComparer :
      g:TcGlobals.TcGlobals ->
        tcref:TypedTree.TyconRef ->
          tycon:TypedTree.Tycon ->
            _thisv:'a * thise:TypedTree.Expr ->
              _thatobjv:'b * thatcaste:TypedTree.Expr ->
                compe:TypedTree.Expr -> TypedTree.Expr
    val mkUnionEquality :
      g:TcGlobals.TcGlobals ->
        tcref:TypedTree.TyconRef ->
          tycon:TypedTree.Tycon ->
            TypedTree.Val * TypedTree.Val * TypedTree.Expr
    val mkUnionEqualityWithComparer :
      g:TcGlobals.TcGlobals ->
        tcref:TypedTree.TyconRef ->
          tycon:TypedTree.Tycon ->
            _thisv:'a * thise:TypedTree.Expr ->
              thatobje:TypedTree.Expr ->
                thatv:TypedTree.Val * thate:TypedTree.Expr ->
                  compe:TypedTree.Expr -> TypedTree.Expr
    val mkRecdHashWithComparer :
      g:TcGlobals.TcGlobals ->
        tcref:TypedTree.TyconRef ->
          tycon:TypedTree.Tycon ->
            compe:TypedTree.Expr -> TypedTree.Val * TypedTree.Expr
    val mkExnHashWithComparer :
      g:TcGlobals.TcGlobals ->
        exnref:TypedTree.TyconRef ->
          exnc:TypedTree.Tycon ->
            compe:TypedTree.Expr -> TypedTree.Val * TypedTree.Expr
    val mkUnionHashWithComparer :
      g:TcGlobals.TcGlobals ->
        tcref:TypedTree.TyconRef ->
          tycon:TypedTree.Tycon ->
            compe:TypedTree.Expr -> TypedTree.Val * TypedTree.Expr
    val isNominalExnc : exnc:TypedTree.Tycon -> bool
    val isTrueFSharpStructTycon : _g:'a -> tycon:TypedTree.Tycon -> bool
    val canBeAugmentedWithEquals : g:'a -> tycon:TypedTree.Tycon -> bool
    val canBeAugmentedWithCompare : g:'a -> tycon:TypedTree.Tycon -> bool
    val getAugmentationAttribs :
      g:TcGlobals.TcGlobals ->
        tycon:TypedTree.Tycon ->
          bool * bool * bool option * bool option * bool option * bool option *
          bool option * bool option * bool option
    val CheckAugmentationAttribs :
      bool -> TcGlobals.TcGlobals -> Import.ImportMap -> TypedTree.Tycon -> unit
    val TyconIsCandidateForAugmentationWithCompare :
      TcGlobals.TcGlobals -> TypedTree.Tycon -> bool
    val TyconIsCandidateForAugmentationWithEquals :
      TcGlobals.TcGlobals -> TypedTree.Tycon -> bool
    val TyconIsCandidateForAugmentationWithHash :
      TcGlobals.TcGlobals -> TypedTree.Tycon -> bool
    val slotImplMethod :
      final:bool * c:TypedTree.TyconRef * slotsig:TypedTree.SlotSig ->
        TypedTree.ValMemberInfo
    val nonVirtualMethod : c:TypedTree.TyconRef -> TypedTree.ValMemberInfo
    val unitArg : TypedTree.ArgReprInfo list list
    val unaryArg : TypedTree.ArgReprInfo list list
    val tupArg : TypedTree.ArgReprInfo list list
    val mkValSpec :
      g:TcGlobals.TcGlobals ->
        tcref:TypedTree.TyconRef ->
          tmty:TypedTree.TType ->
            vis:TypedTree.Accessibility ->
              slotsig:TypedTree.SlotSig option ->
                methn:string ->
                  ty:TypedTree.TType ->
                    argData:TypedTree.ArgReprInfo list list -> TypedTree.Val
    val MakeValsForCompareAugmentation :
      TcGlobals.TcGlobals -> TypedTree.TyconRef -> TypedTree.Val * TypedTree.Val
    val MakeValsForCompareWithComparerAugmentation :
      TcGlobals.TcGlobals -> TypedTree.TyconRef -> TypedTree.Val
    val MakeValsForEqualsAugmentation :
      TcGlobals.TcGlobals -> TypedTree.TyconRef -> TypedTree.Val * TypedTree.Val
    val MakeValsForEqualityWithComparerAugmentation :
      TcGlobals.TcGlobals ->
        TypedTree.TyconRef -> TypedTree.Val * TypedTree.Val * TypedTree.Val
    val MakeBindingsForCompareAugmentation :
      TcGlobals.TcGlobals -> TypedTree.Tycon -> TypedTree.Binding list
    val MakeBindingsForCompareWithComparerAugmentation :
      TcGlobals.TcGlobals -> TypedTree.Tycon -> TypedTree.Binding list
    val MakeBindingsForEqualityWithComparerAugmentation :
      TcGlobals.TcGlobals -> TypedTree.Tycon -> TypedTree.Binding list
    val MakeBindingsForEqualsAugmentation :
      TcGlobals.TcGlobals -> TypedTree.Tycon -> TypedTree.Binding list
    val TypeDefinitelyHasEquality :
      TcGlobals.TcGlobals -> TypedTree.TType -> bool
  end

namespace FSharp.Compiler
  module internal NameResolution = begin
    type NameResolver =
      class
        new : g:TcGlobals.TcGlobals * amap:Import.ImportMap *
              infoReader:InfoReader.InfoReader *
              instantiationGenerator:(Range.range -> TypedTree.Typars ->
                                        TypedTree.TypeInst) -> NameResolver
        member InfoReader : InfoReader.InfoReader
        member
          InstantiationGenerator : (Range.range -> TypedTree.Typars ->
                                      TypedTree.TypeInst)
        member amap : Import.ImportMap
        member g : TcGlobals.TcGlobals
        member languageSupportsNameOf : bool
      end
    val UnionCaseRefsInTycon :
      modref:TypedTree.ModuleOrNamespaceRef ->
        tycon:TypedTree.Tycon -> TypedTree.UnionCaseRef list
    val UnionCaseRefsInModuleOrNamespace :
      modref:TypedTree.ModuleOrNamespaceRef -> TypedTree.UnionCaseRef list
    val TryFindTypeWithUnionCase :
      modref:TypedTree.ModuleOrNamespaceRef ->
        id:SyntaxTree.Ident -> TypedTree.Entity option
    val TryFindTypeWithRecdField :
      modref:TypedTree.ModuleOrNamespaceRef ->
        id:SyntaxTree.Ident -> TypedTree.Entity option
    val ActivePatternElemsOfValRef :
      vref:TypedTree.ValRef -> TypedTree.ActivePatternElemRef list
    val TryMkValRefInModRef :
      modref:TypedTree.EntityRef ->
        vspec:TypedTree.Val -> TypedTree.ValRef option
    val ActivePatternElemsOfVal :
      modref:TypedTree.EntityRef ->
        vspec:TypedTree.Val -> TypedTree.ActivePatternElemRef list
    val ActivePatternElemsOfModuleOrNamespace :
      TypedTree.ModuleOrNamespaceRef ->
        AbstractIL.Internal.Library.NameMap<TypedTree.ActivePatternElemRef>
    val ( |AbbrevOrAppTy|_| ) : TypedTree.TType -> TypedTree.TyconRef option
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    type ArgumentContainer =
      | Method of Infos.MethInfo
      | Type of TypedTree.TyconRef
    val emptyTypeInst : TypedTree.TypeInst
    type EnclosingTypeInst = TypedTree.TypeInst
    val emptyEnclosingTypeInst : EnclosingTypeInst
    [<NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    type Item =
      | Value of TypedTree.ValRef
      | UnionCase of Infos.UnionCaseInfo * hasRequireQualifiedAccessAttr: bool
      | ActivePatternResult of
        PrettyNaming.ActivePatternInfo * TypedTree.TType * int * Range.range
      | ActivePatternCase of TypedTree.ActivePatternElemRef
      | ExnCase of TypedTree.TyconRef
      | RecdField of Infos.RecdFieldInfo
      | UnionCaseField of Infos.UnionCaseInfo * fieldIndex: int
      | AnonRecdField of
        TypedTree.AnonRecdTypeInfo * TypedTree.TTypes * int * Range.range
      | NewDef of SyntaxTree.Ident
      | ILField of Infos.ILFieldInfo
      | Event of Infos.EventInfo
      | Property of string * Infos.PropInfo list
      | MethodGroup of
        displayName: string * methods: Infos.MethInfo list *
        uninstantiatedMethodOpt: Infos.MethInfo option
      | CtorGroup of string * Infos.MethInfo list
      | FakeInterfaceCtor of TypedTree.TType
      | DelegateCtor of TypedTree.TType
      | Types of string * TypedTree.TType list
      | CustomOperation of
        string * (unit -> string option) * Infos.MethInfo option
      | CustomBuilder of string * TypedTree.ValRef
      | TypeVar of string * TypedTree.Typar
      | ModuleOrNamespaces of TypedTree.ModuleOrNamespaceRef list
      | ImplicitOp of SyntaxTree.Ident * TypedTree.TraitConstraintSln option ref
      | ArgName of SyntaxTree.Ident * TypedTree.TType * ArgumentContainer option
      | SetterArg of SyntaxTree.Ident * Item
      | UnqualifiedType of TypedTree.TyconRef list
      with
        static member
          MakeCtorGroup : nm:string * minfos:Infos.MethInfo list -> Item
        static member
          MakeMethGroup : nm:string * minfos:Infos.MethInfo list -> Item
        member DisplayName : string
      end
    val valRefHash : vref:TypedTree.ValRef -> int
    [<RequireQualifiedAccessAttribute ()>]
    type ItemWithInst =
      { Item: Item
        TyparInst: TypedTreeOps.TyparInst }
    val ItemWithNoInst : Item -> ItemWithInst
    val ( |ItemWithInst| ) : ItemWithInst -> Item * TypedTreeOps.TyparInst
    type FieldResolution = | FieldResolution of Infos.RecdFieldInfo * bool
    type ExtensionMember =
      | FSExtMem of TypedTree.ValRef * Infos.ExtensionMethodPriority
      | ILExtMem of
        TypedTree.TyconRef * Infos.MethInfo * Infos.ExtensionMethodPriority
      with
        static member
          Comparer : g:TcGlobals.TcGlobals ->
                       System.Collections.Generic.IEqualityComparer<ExtensionMember>
        static member
          Equality : g:TcGlobals.TcGlobals ->
                       e1:ExtensionMember -> e2:ExtensionMember -> bool
        static member Hash : e1:ExtensionMember -> int
        member Priority : Infos.ExtensionMethodPriority
      end
    type FullyQualifiedFlag =
      | FullyQualified
      | OpenQualified
    type UnqualifiedItems = AbstractIL.Internal.Library.LayeredMap<string,Item>
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type NameResolutionEnv =
      { eDisplayEnv: TypedTreeOps.DisplayEnv
        eUnqualifiedItems: UnqualifiedItems
        eUnqualifiedEnclosingTypeInsts:
          TypedTreeOps.TyconRefMap<EnclosingTypeInst>
        ePatItems: AbstractIL.Internal.Library.NameMap<Item>
        eModulesAndNamespaces:
          AbstractIL.Internal.Library.NameMultiMap<TypedTree.ModuleOrNamespaceRef>
        eFullyQualifiedModulesAndNamespaces:
          AbstractIL.Internal.Library.NameMultiMap<TypedTree.ModuleOrNamespaceRef>
        eFieldLabels:
          AbstractIL.Internal.Library.NameMultiMap<TypedTree.RecdFieldRef>
        eUnqualifiedRecordOrUnionTypeInsts:
          TypedTreeOps.TyconRefMap<TypedTree.TypeInst>
        eTyconsByAccessNames:
          AbstractIL.Internal.Library.LayeredMultiMap<string,TypedTree.TyconRef>
        eFullyQualifiedTyconsByAccessNames:
          AbstractIL.Internal.Library.LayeredMultiMap<string,TypedTree.TyconRef>
        eTyconsByDemangledNameAndArity:
          AbstractIL.Internal.Library.LayeredMap<PrettyNaming.NameArityPair,
                                                 TypedTree.TyconRef>
        eFullyQualifiedTyconsByDemangledNameAndArity:
          AbstractIL.Internal.Library.LayeredMap<PrettyNaming.NameArityPair,
                                                 TypedTree.TyconRef>
        eIndexedExtensionMembers: TypedTreeOps.TyconRefMultiMap<ExtensionMember>
        eUnindexedExtensionMembers: ExtensionMember list
        eTypars: AbstractIL.Internal.Library.NameMap<TypedTree.Typar> }
      with
        static member Empty : g:TcGlobals.TcGlobals -> NameResolutionEnv
        member FindUnqualifiedItem : string -> Item
        member
          ModulesAndNamespaces : fq:FullyQualifiedFlag ->
                                   AbstractIL.Internal.Library.NameMultiMap<TypedTree.ModuleOrNamespaceRef>
        member
          TyconsByAccessNames : fq:FullyQualifiedFlag ->
                                  AbstractIL.Internal.Library.LayeredMultiMap<string,
                                                                              TypedTree.TyconRef>
        member
          TyconsByDemangledNameAndArity : fq:FullyQualifiedFlag ->
                                            AbstractIL.Internal.Library.LayeredMap<PrettyNaming.NameArityPair,
                                                                                   TypedTree.TyconRef>
        member DisplayEnv : TypedTreeOps.DisplayEnv
      end
    [<RequireQualifiedAccessAttribute ()>]
    type ResultCollectionSettings =
      | AllResults
      | AtMostOneResult
    val NextExtensionMethodPriority : unit -> uint64
    val IsTyconRefUsedForCSharpStyleExtensionMembers :
      g:TcGlobals.TcGlobals -> m:Range.range -> tcref:TypedTree.TyconRef -> bool
    val IsTypeUsedForCSharpStyleExtensionMembers :
      g:TcGlobals.TcGlobals -> m:Range.range -> ty:TypedTree.TType -> bool
    val IsMethInfoPlainCSharpStyleExtensionMember :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> isEnclExtTy:bool -> minfo:Infos.MethInfo -> bool
    val private GetCSharpStyleIndexedExtensionMembersForTyconRef :
      amap:Import.ImportMap ->
        m:Range.range ->
          tcrefOfStaticClass:TypedTree.TyconRef ->
            Choice<(TypedTree.TyconRef * ExtensionMember),ExtensionMember> list
    val IntrinsicPropInfosOfTypeInScope :
      infoReader:InfoReader.InfoReader ->
        optFilter:string option ->
          ad:AccessibilityLogic.AccessorDomain ->
            findFlag:InfoReader.FindMemberFlag ->
              m:Range.range -> ty:TypedTree.TType -> Infos.PropInfo list
    val SelectPropInfosFromExtMembers :
      infoReader:InfoReader.InfoReader ->
        ad:AccessibilityLogic.AccessorDomain ->
          optFilter:string option ->
            declaringTy:TypedTree.TType ->
              m:Range.range ->
                extMemInfos:seq<ExtensionMember> -> Infos.PropInfo list
    val ExtensionPropInfosOfTypeInScope :
      ResultCollectionSettings ->
        InfoReader.InfoReader ->
          NameResolutionEnv ->
            string option ->
              AccessibilityLogic.AccessorDomain ->
                Range.range -> TypedTree.TType -> Infos.PropInfo list
    val AllPropInfosOfTypeInScope :
      ResultCollectionSettings ->
        InfoReader.InfoReader ->
          NameResolutionEnv ->
            string option ->
              AccessibilityLogic.AccessorDomain ->
                InfoReader.FindMemberFlag ->
                  Range.range -> TypedTree.TType -> Infos.PropInfo list
    val IntrinsicMethInfosOfType :
      infoReader:InfoReader.InfoReader ->
        optFilter:string option ->
          ad:AccessibilityLogic.AccessorDomain ->
            allowMultiIntfInst:Infos.AllowMultiIntfInstantiations ->
              findFlag:InfoReader.FindMemberFlag ->
                m:Range.range -> ty:TypedTree.TType -> Infos.MethInfo list
    val TrySelectExtensionMethInfoOfILExtMem :
      Range.range ->
        Import.ImportMap ->
          TypedTree.TType ->
            TypedTree.TyconRef * Infos.MethInfo * Infos.ExtensionMethodPriority ->
              Infos.MethInfo option
    val SelectMethInfosFromExtMembers :
      infoReader:InfoReader.InfoReader ->
        optFilter:string option ->
          apparentTy:TypedTree.TType ->
            m:Range.range ->
              extMemInfos:seq<ExtensionMember> -> Infos.MethInfo list
    val ExtensionMethInfosOfTypeInScope :
      collectionSettings:ResultCollectionSettings ->
        infoReader:InfoReader.InfoReader ->
          nenv:NameResolutionEnv ->
            optFilter:string option ->
              m:Range.range -> ty:TypedTree.TType -> Infos.MethInfo list
    val AllMethInfosOfTypeInScope :
      ResultCollectionSettings ->
        InfoReader.InfoReader ->
          NameResolutionEnv ->
            string option ->
              AccessibilityLogic.AccessorDomain ->
                InfoReader.FindMemberFlag ->
                  Range.range -> TypedTree.TType -> Infos.MethInfo list
    [<RequireQualifiedAccessAttribute ()>]
    type BulkAdd =
      | Yes
      | No
    val AddValRefsToItems :
      bulkAddMode:BulkAdd ->
        eUnqualifiedItems:UnqualifiedItems ->
          vrefs:TypedTree.ValRef [] -> UnqualifiedItems
    val AddValRefToExtensionMembers :
      pri:Infos.ExtensionMethodPriority ->
        eIndexedExtensionMembers:TypedTreeOps.TyconRefMultiMap<ExtensionMember> ->
          vref:TypedTree.ValRef ->
            TypedTreeOps.TyconRefMultiMap<ExtensionMember>
    val AddFakeNamedValRefToNameEnv :
      string -> NameResolutionEnv -> TypedTree.ValRef -> NameResolutionEnv
    val AddFakeNameToNameEnv :
      string -> NameResolutionEnv -> Item -> NameResolutionEnv
    val AddValRefsToActivePatternsNameEnv :
      ePatItems:Map<string,Item> -> vref:TypedTree.ValRef -> Map<string,Item>
    val AddValRefsToNameEnvWithPriority :
      bulkAddMode:BulkAdd ->
        pri:Infos.ExtensionMethodPriority ->
          nenv:NameResolutionEnv ->
            vrefs:TypedTree.ValRef [] -> NameResolutionEnv
    val AddValRefToNameEnv :
      NameResolutionEnv -> TypedTree.ValRef -> NameResolutionEnv
    val AddActivePatternResultTagsToNameEnv :
      PrettyNaming.ActivePatternInfo ->
        NameResolutionEnv -> TypedTree.TType -> Range.range -> NameResolutionEnv
    val GeneralizeUnionCaseRef :
      ucref:TypedTree.UnionCaseRef -> Infos.UnionCaseInfo
    val AddTyconsByDemangledNameAndArity :
      bulkAddMode:BulkAdd ->
        tcrefs:TypedTree.TyconRef [] ->
          tab:AbstractIL.Internal.Library.LayeredMap<PrettyNaming.NameArityPair,
                                                     TypedTree.TyconRef> ->
            AbstractIL.Internal.Library.LayeredMap<PrettyNaming.NameArityPair,
                                                   TypedTree.TyconRef>
    val AddTyconByAccessNames :
      bulkAddMode:BulkAdd ->
        tcrefs:TypedTree.TyconRef [] ->
          tab:AbstractIL.Internal.Library.LayeredMultiMap<string,
                                                          TypedTree.TyconRef> ->
            AbstractIL.Internal.Library.LayeredMultiMap<string,
                                                        TypedTree.TyconRef>
    val AddRecdField :
      rfref:TypedTree.RecdFieldRef ->
        tab:AbstractIL.Internal.Library.NameMultiMap<TypedTree.RecdFieldRef> ->
          Map<string,TypedTree.RecdFieldRef list>
    val AddUnionCases1 :
      tab:Map<string,Item> ->
        ucrefs:TypedTree.UnionCaseRef list -> Map<string,Item>
    val AddUnionCases2 :
      bulkAddMode:BulkAdd ->
        eUnqualifiedItems:UnqualifiedItems ->
          ucrefs:TypedTree.UnionCaseRef list -> Map<string,Item>
    type TypeNameResolutionFlag =
      | ResolveTypeNamesToCtors
      | ResolveTypeNamesToTypeRefs
    [<SealedAttribute (); NoEqualityAttribute (); NoComparisonAttribute ();
      RequireQualifiedAccessAttribute ()>]
    type TypeNameResolutionStaticArgsInfo =
      | Indefinite
      | Definite of int
      with
        static member
          FromTyArgs : numTyArgs:int -> TypeNameResolutionStaticArgsInfo
        member MangledNameForType : nm:string -> string
        member HasNoStaticArgsInfo : bool
        member NumStaticArgs : int
        static member DefiniteEmpty : TypeNameResolutionStaticArgsInfo
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type TypeNameResolutionInfo =
      | TypeNameResolutionInfo of
        TypeNameResolutionFlag * TypeNameResolutionStaticArgsInfo
      with
        static member
          ResolveToTypeRefs : TypeNameResolutionStaticArgsInfo ->
                                TypeNameResolutionInfo
        member DropStaticArgsInfo : TypeNameResolutionInfo
        member ResolutionFlag : TypeNameResolutionFlag
        member StaticArgsInfo : TypeNameResolutionStaticArgsInfo
        static member Default : TypeNameResolutionInfo
      end
    [<RequireQualifiedAccessAttribute ()>]
    type PermitDirectReferenceToGeneratedType =
      | Yes
      | No
    val CheckForDirectReferenceToGeneratedType :
      tcref:TypedTree.TyconRef * genOk:PermitDirectReferenceToGeneratedType *
      m:Range.range -> unit
    val AddEntityForProvidedType :
      amap:Import.ImportMap * modref:TypedTree.ModuleOrNamespaceRef *
      resolutionEnvironment:ExtensionTyping.ResolutionEnvironment *
      st:Tainted<ExtensionTyping.ProvidedType> * m:Range.range ->
        TypedTree.EntityRef
    val ResolveProvidedTypeNameInEntity :
      amap:Import.ImportMap * m:Range.range * typeName:string *
      modref:TypedTree.ModuleOrNamespaceRef -> TypedTree.EntityRef list
    val LookupTypeNameInEntityHaveArity :
      nm:string ->
        staticResInfo:TypeNameResolutionStaticArgsInfo ->
          mty:TypedTree.ModuleOrNamespaceType -> TypedTree.Tycon option
    val LookupTypeNameNoArity :
      nm:string ->
        byDemangledNameAndArity:AbstractIL.Internal.Library.LayeredMap<PrettyNaming.NameArityPair,
                                                                       'a> ->
          byAccessNames:AbstractIL.Internal.Library.LayeredMultiMap<string,'a> ->
            'a list
    val LookupTypeNameInEntityNoArity :
      _m:'a ->
        nm:string ->
          mtyp:TypedTree.ModuleOrNamespaceType -> TypedTree.Tycon list
    val LookupTypeNameInEntityMaybeHaveArity :
      amap:Import.ImportMap * m:Range.range *
      ad:AccessibilityLogic.AccessorDomain * nm:string *
      staticResInfo:TypeNameResolutionStaticArgsInfo *
      modref:TypedTree.ModuleOrNamespaceRef -> TypedTree.EntityRef list
    val GetNestedTyconRefsOfType :
      infoReader:InfoReader.InfoReader ->
        amap:Import.ImportMap ->
          ad:AccessibilityLogic.AccessorDomain * optFilter:string option *
          staticResInfo:TypeNameResolutionStaticArgsInfo *
          checkForGenerated:bool * m:Range.range ->
            ty:TypedTree.TType -> TypedTree.TypeInst * TypedTree.EntityRef list
    val MakeNestedType :
      ncenv:NameResolver ->
        tinst:TypedTree.TType list ->
          m:Range.range -> tcrefNested:TypedTree.TyconRef -> TypedTree.TType
    val GetNestedTypesOfType :
      ad:AccessibilityLogic.AccessorDomain * ncenv:NameResolver *
      optFilter:string option * staticResInfo:TypeNameResolutionStaticArgsInfo *
      checkForGenerated:bool * m:Range.range ->
        ty:TypedTree.TType -> TypedTree.TType list
    val ChooseMethInfosForNameEnv :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          ty:TypedTree.TType ->
            minfos:Infos.MethInfo list ->
              System.Collections.Generic.KeyValuePair<string,Item> list
    val ChoosePropInfosForNameEnv :
      g:TcGlobals.TcGlobals ->
        ty:TypedTree.TType ->
          pinfos:Infos.PropInfo list ->
            System.Collections.Generic.KeyValuePair<string,Item> list
    val ChooseFSharpFieldInfosForNameEnv :
      g:TcGlobals.TcGlobals ->
        ty:TypedTree.TType ->
          rfinfos:Infos.RecdFieldInfo list ->
            System.Collections.Generic.KeyValuePair<string,Item> list
    val ChooseILFieldInfosForNameEnv :
      g:TcGlobals.TcGlobals ->
        ty:TypedTree.TType ->
          finfos:Infos.ILFieldInfo list ->
            System.Collections.Generic.KeyValuePair<string,Item> list
    val ChooseEventInfosForNameEnv :
      g:TcGlobals.TcGlobals ->
        ty:TypedTree.TType ->
          einfos:Infos.EventInfo list ->
            System.Collections.Generic.KeyValuePair<string,Item> list
    val AddStaticContentOfTypeToNameEnv :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          ad:AccessibilityLogic.AccessorDomain ->
            m:Range.range ->
              nenv:NameResolutionEnv -> ty:TypedTree.TType -> NameResolutionEnv
    val private AddNestedTypesOfTypeToNameEnv :
      infoReader:InfoReader.InfoReader ->
        amap:Import.ImportMap ->
          ad:AccessibilityLogic.AccessorDomain ->
            m:Range.range ->
              nenv:NameResolutionEnv -> ty:TypedTree.TType -> NameResolutionEnv
    val private AddTyconRefsWithEnclosingTypeInstToNameEnv :
      bulkAddMode:BulkAdd ->
        ownDefinition:bool ->
          g:TcGlobals.TcGlobals ->
            amap:Import.ImportMap ->
              ad:AccessibilityLogic.AccessorDomain ->
                m:Range.range ->
                  root:bool ->
                    nenv:NameResolutionEnv ->
                      tinstEnclosing:TypedTree.TypeInst *
                      tcrefs:TypedTree.TyconRef list -> NameResolutionEnv
    val private AddStaticPartsOfTypeToNameEnv :
      amap:Import.ImportMap ->
        m:Range.range ->
          nenv:NameResolutionEnv -> ty:TypedTree.TType -> NameResolutionEnv
    val private AddStaticPartsOfTyconRefToNameEnv :
      bulkAddMode:BulkAdd ->
        ownDefinition:bool ->
          g:TcGlobals.TcGlobals ->
            amap:Import.ImportMap ->
              m:Range.range ->
                nenv:NameResolutionEnv ->
                  tinstOpt:TypedTree.TypeInst option ->
                    tcref:TypedTree.TyconRef -> NameResolutionEnv
    val private CanAutoOpenTyconRef :
      g:TcGlobals.TcGlobals -> m:Range.range -> tcref:TypedTree.TyconRef -> bool
    val private AddPartsOfTyconRefToNameEnv :
      bulkAddMode:BulkAdd ->
        ownDefinition:bool ->
          g:TcGlobals.TcGlobals ->
            amap:Import.ImportMap ->
              ad:AccessibilityLogic.AccessorDomain ->
                m:Range.range ->
                  nenv:NameResolutionEnv ->
                    tcref:TypedTree.TyconRef -> NameResolutionEnv
    val AddTyconRefsToNameEnv :
      BulkAdd ->
        bool ->
          TcGlobals.TcGlobals ->
            Import.ImportMap ->
              AccessibilityLogic.AccessorDomain ->
                Range.range ->
                  bool ->
                    NameResolutionEnv ->
                      TypedTree.TyconRef list -> NameResolutionEnv
    val AddExceptionDeclsToNameEnv :
      BulkAdd -> NameResolutionEnv -> TypedTree.TyconRef -> NameResolutionEnv
    val AddModuleAbbrevToNameEnv :
      SyntaxTree.Ident ->
        NameResolutionEnv ->
          TypedTree.ModuleOrNamespaceRef list -> NameResolutionEnv
    val MakeNestedModuleRefs :
      modref:TypedTree.ModuleOrNamespaceRef -> TypedTree.EntityRef list
    val AddModuleOrNamespaceRefsToNameEnv :
      TcGlobals.TcGlobals ->
        Import.ImportMap ->
          Range.range ->
            bool ->
              AccessibilityLogic.AccessorDomain ->
                NameResolutionEnv ->
                  TypedTree.ModuleOrNamespaceRef list -> NameResolutionEnv
    val AddModuleOrNamespaceContentsToNameEnv :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          ad:AccessibilityLogic.AccessorDomain ->
            m:Range.range ->
              root:bool ->
                nenv:NameResolutionEnv ->
                  modref:TypedTree.ModuleOrNamespaceRef -> NameResolutionEnv
    val AddModuleOrNamespaceRefsContentsToNameEnv :
      TcGlobals.TcGlobals ->
        Import.ImportMap ->
          AccessibilityLogic.AccessorDomain ->
            Range.range ->
              bool ->
                NameResolutionEnv ->
                  TypedTree.EntityRef list -> NameResolutionEnv
    val AddTypeContentsToNameEnv :
      TcGlobals.TcGlobals ->
        Import.ImportMap ->
          AccessibilityLogic.AccessorDomain ->
            Range.range ->
              NameResolutionEnv -> TypedTree.TType -> NameResolutionEnv
    val AddModuleOrNamespaceRefContentsToNameEnv :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          ad:AccessibilityLogic.AccessorDomain ->
            m:Range.range ->
              root:bool ->
                nenv:NameResolutionEnv ->
                  modref:TypedTree.EntityRef -> NameResolutionEnv
    val AddModuleOrNamespaceRefToNameEnv :
      TcGlobals.TcGlobals ->
        Import.ImportMap ->
          Range.range ->
            bool ->
              AccessibilityLogic.AccessorDomain ->
                NameResolutionEnv -> TypedTree.EntityRef -> NameResolutionEnv
    type CheckForDuplicateTyparFlag =
      | CheckForDuplicateTypars
      | NoCheckForDuplicateTypars
    val AddDeclaredTyparsToNameEnv :
      CheckForDuplicateTyparFlag ->
        NameResolutionEnv -> TypedTree.Typar list -> NameResolutionEnv
    val FreshenTycon :
      ncenv:NameResolver ->
        m:Range.range -> tcref:TypedTree.TyconRef -> TypedTree.TType
    val FreshenTyconWithEnclosingTypeInst :
      ncenv:NameResolver ->
        m:Range.range ->
          tinstEnclosing:TypedTree.TypeInst ->
            tcref:TypedTree.TyconRef -> TypedTree.TType
    val FreshenUnionCaseRef :
      ncenv:NameResolver ->
        m:Range.range -> ucref:TypedTree.UnionCaseRef -> Infos.UnionCaseInfo
    val FreshenRecdFieldRef :
      NameResolver ->
        Range.range -> TypedTree.RecdFieldRef -> Infos.RecdFieldInfo
    val ResolveUnqualifiedItem :
      ncenv:NameResolver ->
        nenv:NameResolutionEnv -> m:Range.range -> res:Item -> Item
    val OneResult :
      res:AbstractIL.Internal.Library.ResultOrException<'a> ->
        AbstractIL.Internal.Library.ResultOrException<'a list>
    val OneSuccess :
      x:'a -> AbstractIL.Internal.Library.ResultOrException<'a list>
    val AddResults :
      res1:AbstractIL.Internal.Library.ResultOrException<'a list> ->
        res2:AbstractIL.Internal.Library.ResultOrException<'a list> ->
          AbstractIL.Internal.Library.ResultOrException<'a list>
    val NoResultsOrUsefulErrors :
      AbstractIL.Internal.Library.ResultOrException<'a list>
    val CollectResults :
      f:('a -> AbstractIL.Internal.Library.ResultOrException<'b>) ->
        _arg1:'a list -> AbstractIL.Internal.Library.ResultOrException<'b list>
    val CollectAtMostOneResult :
      f:('a -> AbstractIL.Internal.Library.ResultOrException<'b>) ->
        inputs:'a list -> AbstractIL.Internal.Library.ResultOrException<'b list>
    val CollectResults2 :
      resultCollectionSettings:ResultCollectionSettings ->
        f:('a -> AbstractIL.Internal.Library.ResultOrException<'b>) ->
          ('a list -> AbstractIL.Internal.Library.ResultOrException<'b list>)
    val MapResults :
      f:('a -> 'b) ->
        _arg1:AbstractIL.Internal.Library.ResultOrException<'a list> ->
          AbstractIL.Internal.Library.ResultOrException<'b list>
    val AtMostOneResult :
      m:Range.range ->
        res:AbstractIL.Internal.Library.ResultOrException<'a list> ->
          AbstractIL.Internal.Library.ResultOrException<'a>
    val AtMostOneResultQuery :
      query2:(unit -> AbstractIL.Internal.Library.ResultOrException<'a list>) ->
        res1:AbstractIL.Internal.Library.ResultOrException<'a list> ->
          AbstractIL.Internal.Library.ResultOrException<'a list>
    val inline ( +++ ) :
      res1:AbstractIL.Internal.Library.ResultOrException<'a list> ->
        query2:(unit -> AbstractIL.Internal.Library.ResultOrException<'a list>) ->
          AbstractIL.Internal.Library.ResultOrException<'a list>
    val LookupTypeNameInEnvHaveArity :
      fq:FullyQualifiedFlag ->
        nm:string ->
          numTyArgs:int -> nenv:NameResolutionEnv -> TypedTree.TyconRef option
    val LookupTypeNameInEnvNoArity :
      FullyQualifiedFlag ->
        string -> NameResolutionEnv -> TypedTree.TyconRef list
    val LookupTypeNameInEnvMaybeHaveArity :
      fq:FullyQualifiedFlag ->
        nm:string ->
          typeNameResInfo:TypeNameResolutionInfo ->
            nenv:NameResolutionEnv -> TypedTree.TyconRef list
    [<RequireQualifiedAccessAttribute (); StructAttribute ()>]
    type ItemOccurence =
      | Binding
      | Use
      | UseInType
      | UseInAttribute
      | Pattern
      | Implemented
      | RelatedText
      | Open
    type OpenDeclaration =
      { Target: SyntaxTree.SynOpenDeclTarget
        Range: Range.range option
        Modules: TypedTree.ModuleOrNamespaceRef list
        Types: TypedTree.TType list
        AppliedScope: Range.range
        IsOwnNamespace: bool }
      with
        static member
          Create : target:SyntaxTree.SynOpenDeclTarget *
                   modules:TypedTree.ModuleOrNamespaceRef list *
                   types:TypedTree.TType list * appliedScope:Range.range *
                   isOwnNamespace:bool -> OpenDeclaration
      end
    type FormatStringCheckContext =
      { SourceText: Text.ISourceText
        LineStartPositions: int [] }
    type ITypecheckResultsSink =
      interface
        abstract member
          NotifyEnvWithScope : Range.range * NameResolutionEnv *
                               AccessibilityLogic.AccessorDomain -> unit
        abstract member
          NotifyExprHasType : TypedTree.TType * NameResolutionEnv *
                              AccessibilityLogic.AccessorDomain * Range.range ->
                                unit
        abstract member
          NotifyFormatSpecifierLocation : Range.range * int -> unit
        abstract member
          NotifyMethodGroupNameResolution : Range.pos * Item * Item *
                                            TypedTreeOps.TyparInst *
                                            ItemOccurence * NameResolutionEnv *
                                            AccessibilityLogic.AccessorDomain *
                                            Range.range * bool -> unit
        abstract member
          NotifyNameResolution : Range.pos * Item * TypedTreeOps.TyparInst *
                                 ItemOccurence * NameResolutionEnv *
                                 AccessibilityLogic.AccessorDomain * Range.range *
                                 bool -> unit
        abstract member NotifyOpenDeclaration : OpenDeclaration -> unit
        abstract member CurrentSourceText : Text.ISourceText option
        abstract member
          FormatStringCheckContext : FormatStringCheckContext option
      end
    val ( |ValRefOfProp|_| ) : pi:Infos.PropInfo -> TypedTree.ValRef option
    val ( |ValRefOfMeth|_| ) : mi:Infos.MethInfo -> TypedTree.ValRef option
    val ( |ValRefOfEvent|_| ) : evt:Infos.EventInfo -> TypedTree.ValRef option
    val ( |RecordFieldUse|_| ) :
      item:Item -> (string * TypedTree.TyconRef) option
    val ( |UnionCaseFieldUse|_| ) :
      item:Item -> (int * TypedTree.UnionCaseRef) option
    val ( |ILFieldUse|_| ) : item:Item -> Infos.ILFieldInfo option
    val ( |PropertyUse|_| ) : item:Item -> Infos.PropInfo option
    val ( |FSharpPropertyUse|_| ) : item:Item -> TypedTree.ValRef option
    val ( |MethodUse|_| ) : item:Item -> Infos.MethInfo option
    val ( |FSharpMethodUse|_| ) : item:Item -> TypedTree.ValRef option
    val ( |EntityUse|_| ) : item:Item -> TypedTree.TyconRef option
    val ( |EventUse|_| ) : item:Item -> Infos.EventInfo option
    val ( |FSharpEventUse|_| ) : item:Item -> TypedTree.ValRef option
    val ( |UnionCaseUse|_| ) : item:Item -> TypedTree.UnionCaseRef option
    val ( |ValUse|_| ) : item:Item -> TypedTree.ValRef option
    val ( |ActivePatternCaseUse|_| ) :
      item:Item -> (Range.range * Range.range * int) option
    val tyconRefDefnHash :
      _g:TcGlobals.TcGlobals -> eref1:TypedTree.EntityRef -> int
    val tyconRefDefnEq :
      g:TcGlobals.TcGlobals ->
        eref1:TypedTree.EntityRef -> eref2:TypedTree.EntityRef -> bool
    val valRefDefnHash : _g:TcGlobals.TcGlobals -> vref1:TypedTree.ValRef -> int
    val valRefDefnEq :
      g:TcGlobals.TcGlobals ->
        vref1:TypedTree.ValRef -> vref2:TypedTree.ValRef -> bool
    val unionCaseRefDefnEq :
      g:TcGlobals.TcGlobals ->
        uc1:TypedTree.UnionCaseRef -> uc2:TypedTree.UnionCaseRef -> bool
    val ItemsAreEffectivelyEqual : TcGlobals.TcGlobals -> Item -> Item -> bool
    val ItemsAreEffectivelyEqualHash : TcGlobals.TcGlobals -> Item -> int
    [<ClassAttribute ();
      System.Diagnostics.DebuggerDisplay ("{DebugToString()}")>]
    type CapturedNameResolution =
      class
        new : i:Item * tpinst:TypedTreeOps.TyparInst * io:ItemOccurence *
              nre:NameResolutionEnv * ad:AccessibilityLogic.AccessorDomain *
              m:Range.range -> CapturedNameResolution
        member DebugToString : unit -> string
        member AccessorDomain : AccessibilityLogic.AccessorDomain
        member DisplayEnv : TypedTreeOps.DisplayEnv
        member Item : Item
        member ItemOccurence : ItemOccurence
        member ItemWithInst : ItemWithInst
        member NameResolutionEnv : NameResolutionEnv
        member Pos : Range.pos
        member Range : Range.range
      end
    [<ClassAttribute ()>]
    type TcResolutions =
      class
        new : capturedEnvs:ResizeArray<Range.range * NameResolutionEnv *
                                       AccessibilityLogic.AccessorDomain> *
              capturedExprTypes:ResizeArray<TypedTree.TType * NameResolutionEnv *
                                            AccessibilityLogic.AccessorDomain *
                                            Range.range> *
              capturedNameResolutions:ResizeArray<CapturedNameResolution> *
              capturedMethodGroupResolutions:ResizeArray<CapturedNameResolution> ->
                TcResolutions
        member
          CapturedEnvs : ResizeArray<Range.range * NameResolutionEnv *
                                     AccessibilityLogic.AccessorDomain>
        member
          CapturedExpressionTypings : ResizeArray<TypedTree.TType *
                                                  NameResolutionEnv *
                                                  AccessibilityLogic.AccessorDomain *
                                                  Range.range>
        member
          CapturedMethodGroupResolutions : ResizeArray<CapturedNameResolution>
        member CapturedNameResolutions : ResizeArray<CapturedNameResolution>
        static member Empty : TcResolutions
      end
    [<StructAttribute ()>]
    type TcSymbolUseData =
      { Item: Item
        ItemOccurence: ItemOccurence
        DisplayEnv: TypedTreeOps.DisplayEnv
        Range: Range.range }
    [<ClassAttribute ()>]
    type TcSymbolUses =
      class
        new : g:TcGlobals.TcGlobals *
              capturedNameResolutions:ResizeArray<CapturedNameResolution> *
              formatSpecifierLocations:(Range.range * int) [] -> TcSymbolUses
        member
          GetFormatSpecifierLocationsAndArity : unit -> (Range.range * int) []
        member GetUsesOfSymbol : Item -> TcSymbolUseData []
        member AllUsesOfSymbols : TcSymbolUseData [] []
        static member Empty : TcSymbolUses
      end
    type TcResultsSinkImpl =
      class
        interface ITypecheckResultsSink
        new : tcGlobals:TcGlobals.TcGlobals * ?sourceText:Text.ISourceText ->
                TcResultsSinkImpl
        member GetFormatSpecifierLocations : unit -> (Range.range * int) []
        member GetOpenDeclarations : unit -> OpenDeclaration []
        member GetResolutions : unit -> TcResolutions
        member GetSymbolUses : unit -> TcSymbolUses
      end
    type TcResultsSink =
      { mutable CurrentSink: ITypecheckResultsSink option }
      with
        static member WithSink : ITypecheckResultsSink -> TcResultsSink
        static member NoSink : TcResultsSink
      end
    val WithNewTypecheckResultsSink :
      ITypecheckResultsSink * TcResultsSink -> System.IDisposable
    val TemporarilySuspendReportingTypecheckResultsToSink :
      TcResultsSink -> System.IDisposable
    val CallEnvSink :
      TcResultsSink ->
        Range.range * NameResolutionEnv * AccessibilityLogic.AccessorDomain ->
          unit
    val CallNameResolutionSink :
      TcResultsSink ->
        Range.range * NameResolutionEnv * Item * TypedTreeOps.TyparInst *
        ItemOccurence * AccessibilityLogic.AccessorDomain -> unit
    val CallMethodGroupNameResolutionSink :
      TcResultsSink ->
        Range.range * NameResolutionEnv * Item * Item * TypedTreeOps.TyparInst *
        ItemOccurence * AccessibilityLogic.AccessorDomain -> unit
    val CallNameResolutionSinkReplacing :
      TcResultsSink ->
        Range.range * NameResolutionEnv * Item * TypedTreeOps.TyparInst *
        ItemOccurence * AccessibilityLogic.AccessorDomain -> unit
    val CallExprHasTypeSink :
      TcResultsSink ->
        Range.range * NameResolutionEnv * TypedTree.TType *
        AccessibilityLogic.AccessorDomain -> unit
    val CallOpenDeclarationSink : TcResultsSink -> OpenDeclaration -> unit
    type ResultTyparChecker = | ResultTyparChecker of (unit -> bool)
    val CheckAllTyparsInferrable :
      amap:Import.ImportMap -> m:Range.range -> item:Item -> bool
    type ResolutionInfo =
      | ResolutionInfo of
        (Range.range * TypedTree.EntityRef) list * (ResultTyparChecker -> unit) *
        tinstEnclosing: EnclosingTypeInst
      with
        static member
          SendEntityPathToSink : sink:TcResultsSink * ncenv:NameResolver *
                                 nenv:NameResolutionEnv * occ:ItemOccurence *
                                 ad:AccessibilityLogic.AccessorDomain *
                                 ResolutionInfo *
                                 typarChecker:ResultTyparChecker -> unit
        member
          AddEntity : info:(Range.range * TypedTree.EntityRef) -> ResolutionInfo
        member AddWarning : f:(ResultTyparChecker -> unit) -> ResolutionInfo
        member
          WithEnclosingTypeInst : tinstEnclosing:EnclosingTypeInst ->
                                    ResolutionInfo
        member EnclosingTypeInst : EnclosingTypeInst
        static member Empty : ResolutionInfo
      end
    val CheckForTypeLegitimacyAndMultipleGenericTypeAmbiguities :
      tcrefs:(ResolutionInfo * TypedTree.TyconRef) list *
      typeNameResInfo:TypeNameResolutionInfo *
      genOk:PermitDirectReferenceToGeneratedType * m:Range.range ->
        (ResolutionInfo * TypedTree.TyconRef) list
    val ResolveLongIdentAsModuleOrNamespace :
      TcResultsSink ->
        ResultCollectionSettings ->
          Import.ImportMap ->
            Range.range ->
              first:bool ->
                FullyQualifiedFlag ->
                  NameResolutionEnv ->
                    AccessibilityLogic.AccessorDomain ->
                      SyntaxTree.Ident ->
                        SyntaxTree.Ident list ->
                          isOpenDecl:bool ->
                            AbstractIL.Internal.Library.ResultOrException<(int *
                                                                           TypedTree.ModuleOrNamespaceRef *
                                                                           TypedTree.ModuleOrNamespaceType) list>
    val ResolveLongIdentAsModuleOrNamespaceThen :
      sink:TcResultsSink ->
        atMostOne:ResultCollectionSettings ->
          amap:Import.ImportMap ->
            m:Range.range ->
              fullyQualified:FullyQualifiedFlag ->
                nenv:NameResolutionEnv ->
                  ad:AccessibilityLogic.AccessorDomain ->
                    id:SyntaxTree.Ident ->
                      rest:SyntaxTree.Ident list ->
                        isOpenDecl:bool ->
                          f:(ResolutionInfo -> int -> Range.range ->
                               TypedTree.ModuleOrNamespaceRef ->
                               TypedTree.ModuleOrNamespaceType ->
                               SyntaxTree.Ident -> SyntaxTree.Ident list ->
                               AbstractIL.Internal.Library.ResultOrException<'a>) ->
                            AbstractIL.Internal.Library.ResultOrException<'a list>
    val private ResolveObjectConstructorPrim :
      ncenv:NameResolver ->
        edenv:TypedTreeOps.DisplayEnv ->
          resInfo:'a ->
            m:Range.range ->
              ad:AccessibilityLogic.AccessorDomain ->
                ty:TypedTree.TType ->
                  AbstractIL.Internal.Library.ResultOrException<'a * Item>
    val ResolveObjectConstructor :
      NameResolver ->
        TypedTreeOps.DisplayEnv ->
          Range.range ->
            AccessibilityLogic.AccessorDomain ->
              TypedTree.TType ->
                AbstractIL.Internal.Library.ResultOrException<Item>
    exception IndeterminateType of Range.range
    [<RequireQualifiedAccessAttribute ()>]
    type LookupKind =
      | RecdField
      | Pattern
      | Expr
      | Type
      | Ctor
    val TryFindUnionCaseOfType :
      g:TcGlobals.TcGlobals ->
        ty:TypedTree.TType -> nm:string -> Infos.UnionCaseInfo voption
    val TryFindAnonRecdFieldOfType :
      TcGlobals.TcGlobals -> TypedTree.TType -> string -> Item option
    val CoreDisplayName : pinfo:Infos.PropInfo -> string
    val DecodeFSharpEvent :
      pinfos:Infos.PropInfo list ->
        ad:AccessibilityLogic.AccessorDomain ->
          g:TcGlobals.TcGlobals ->
            ncenv:NameResolver -> m:Range.range -> Item option
    val GetRecordLabelsForType :
      g:TcGlobals.TcGlobals ->
        nenv:NameResolutionEnv ->
          ty:TypedTree.TType -> System.Collections.Generic.HashSet<string>
    val CheckNestedTypesOfType :
      ncenv:NameResolver ->
        resInfo:ResolutionInfo ->
          ad:AccessibilityLogic.AccessorDomain ->
            nm:string ->
              typeNameResInfo:TypeNameResolutionInfo ->
                m:Range.range -> ty:TypedTree.TType -> TypedTree.TType list
    val ResolveLongIdentInTypePrim :
      ncenv:NameResolver ->
        nenv:NameResolutionEnv ->
          lookupKind:LookupKind ->
            resInfo:ResolutionInfo ->
              depth:int ->
                m:Range.range ->
                  ad:AccessibilityLogic.AccessorDomain ->
                    id:SyntaxTree.Ident ->
                      rest:SyntaxTree.Ident list ->
                        findFlag:InfoReader.FindMemberFlag ->
                          typeNameResInfo:TypeNameResolutionInfo ->
                            ty:TypedTree.TType ->
                              AbstractIL.Internal.Library.ResultOrException<(ResolutionInfo *
                                                                             Item *
                                                                             SyntaxTree.Ident list) list>
    val ResolveLongIdentInNestedTypes :
      ncenv:NameResolver ->
        nenv:NameResolutionEnv ->
          lookupKind:LookupKind ->
            resInfo:ResolutionInfo ->
              depth:int ->
                id:SyntaxTree.Ident ->
                  m:Range.range ->
                    ad:AccessibilityLogic.AccessorDomain ->
                      id2:SyntaxTree.Ident ->
                        rest:SyntaxTree.Ident list ->
                          findFlag:InfoReader.FindMemberFlag ->
                            typeNameResInfo:TypeNameResolutionInfo ->
                              tys:TypedTree.TType list ->
                                AbstractIL.Internal.Library.ResultOrException<(ResolutionInfo *
                                                                               Item *
                                                                               SyntaxTree.Ident list) list>
    val ResolveLongIdentInType :
      TcResultsSink ->
        NameResolver ->
          NameResolutionEnv ->
            LookupKind ->
              Range.range ->
                AccessibilityLogic.AccessorDomain ->
                  SyntaxTree.Ident ->
                    InfoReader.FindMemberFlag ->
                      TypeNameResolutionInfo ->
                        TypedTree.TType -> Item * SyntaxTree.Ident list
    val private ResolveLongIdentInTyconRef :
      ncenv:NameResolver ->
        nenv:NameResolutionEnv ->
          lookupKind:LookupKind ->
            resInfo:ResolutionInfo ->
              depth:int ->
                m:Range.range ->
                  ad:AccessibilityLogic.AccessorDomain ->
                    id:SyntaxTree.Ident ->
                      rest:SyntaxTree.Ident list ->
                        typeNameResInfo:TypeNameResolutionInfo ->
                          tcref:TypedTree.TyconRef ->
                            AbstractIL.Internal.Library.ResultOrException<(ResolutionInfo *
                                                                           Item *
                                                                           SyntaxTree.Ident list) list>
    val private ResolveLongIdentInTyconRefs :
      atMostOne:ResultCollectionSettings ->
        ncenv:NameResolver ->
          nenv:NameResolutionEnv ->
            lookupKind:LookupKind ->
              depth:int ->
                m:Range.range ->
                  ad:AccessibilityLogic.AccessorDomain ->
                    id:SyntaxTree.Ident ->
                      rest:SyntaxTree.Ident list ->
                        typeNameResInfo:TypeNameResolutionInfo ->
                          idRange:Range.range ->
                            tcrefs:(ResolutionInfo * TypedTree.EntityRef) list ->
                              AbstractIL.Internal.Library.ResultOrException<(ResolutionInfo *
                                                                             Item *
                                                                             SyntaxTree.Ident list) list>
    val ( |AccessibleEntityRef|_| ) :
      amap:Import.ImportMap ->
        m:Range.range ->
          ad:AccessibilityLogic.AccessorDomain ->
            modref:TypedTree.ModuleOrNamespaceRef ->
              mspec:TypedTree.Entity -> TypedTree.EntityRef option
    val ResolveExprLongIdentInModuleOrNamespace :
      ncenv:NameResolver ->
        nenv:NameResolutionEnv ->
          typeNameResInfo:TypeNameResolutionInfo ->
            ad:AccessibilityLogic.AccessorDomain ->
              resInfo:ResolutionInfo ->
                depth:int ->
                  m:Range.range ->
                    modref:TypedTree.EntityRef ->
                      mty:TypedTree.ModuleOrNamespaceType ->
                        id:SyntaxTree.Ident ->
                          rest:SyntaxTree.Ident list ->
                            AbstractIL.Internal.Library.ResultOrException<ResolutionInfo *
                                                                          Item *
                                                                          SyntaxTree.Ident list>
    val ChooseTyconRefInExpr :
      ncenv:NameResolver * m:Range.range * ad:AccessibilityLogic.AccessorDomain *
      nenv:NameResolutionEnv * id:SyntaxTree.Ident *
      typeNameResInfo:TypeNameResolutionInfo *
      tcrefs:(ResolutionInfo * TypedTree.TyconRef) list ->
        AbstractIL.Internal.Library.ResultOrException<(ResolutionInfo * Item) list>
    val ResolveUnqualifiedTyconRefs :
      nenv:NameResolutionEnv ->
        tcrefs:TypedTree.TyconRef list ->
          (ResolutionInfo * TypedTree.TyconRef) list
    val ResolveExprLongIdentPrim :
      sink:TcResultsSink ->
        ncenv:NameResolver ->
          first:bool ->
            fullyQualified:FullyQualifiedFlag ->
              m:Range.range ->
                ad:AccessibilityLogic.AccessorDomain ->
                  nenv:NameResolutionEnv ->
                    typeNameResInfo:TypeNameResolutionInfo ->
                      id:SyntaxTree.Ident ->
                        rest:SyntaxTree.Ident list ->
                          isOpenDecl:bool ->
                            AbstractIL.Internal.Library.ResultOrException<EnclosingTypeInst *
                                                                          Item *
                                                                          SyntaxTree.Ident list>
    val ResolveExprLongIdent :
      TcResultsSink ->
        NameResolver ->
          Range.range ->
            AccessibilityLogic.AccessorDomain ->
              NameResolutionEnv ->
                TypeNameResolutionInfo ->
                  SyntaxTree.Ident list ->
                    AbstractIL.Internal.Library.ResultOrException<EnclosingTypeInst *
                                                                  Item *
                                                                  SyntaxTree.Ident list>
    val ResolvePatternLongIdentInModuleOrNamespace :
      ncenv:NameResolver ->
        nenv:NameResolutionEnv ->
          numTyArgsOpt:TypeNameResolutionInfo ->
            ad:AccessibilityLogic.AccessorDomain ->
              resInfo:ResolutionInfo ->
                depth:int ->
                  m:Range.range ->
                    modref:TypedTree.ModuleOrNamespaceRef ->
                      mty:TypedTree.ModuleOrNamespaceType ->
                        id:SyntaxTree.Ident ->
                          rest:SyntaxTree.Ident list ->
                            AbstractIL.Internal.Library.ResultOrException<ResolutionInfo *
                                                                          Item *
                                                                          SyntaxTree.Ident list>
    exception UpperCaseIdentifierInPattern of Range.range
    type WarnOnUpperFlag =
      | WarnOnUpperCase
      | AllIdsOK
    val ResolvePatternLongIdentPrim :
      sink:TcResultsSink ->
        ncenv:NameResolver ->
          fullyQualified:FullyQualifiedFlag ->
            warnOnUpper:WarnOnUpperFlag ->
              newDef:bool ->
                m:Range.range ->
                  ad:AccessibilityLogic.AccessorDomain ->
                    nenv:NameResolutionEnv ->
                      numTyArgsOpt:TypeNameResolutionInfo ->
                        id:SyntaxTree.Ident ->
                          rest:SyntaxTree.Ident list -> Item
    val ResolvePatternLongIdent :
      TcResultsSink ->
        NameResolver ->
          WarnOnUpperFlag ->
            bool ->
              Range.range ->
                AccessibilityLogic.AccessorDomain ->
                  NameResolutionEnv ->
                    TypeNameResolutionInfo -> SyntaxTree.Ident list -> Item
    val ResolveNestedTypeThroughAbbreviation :
      ncenv:NameResolver ->
        tcref:TypedTree.TyconRef -> m:Range.range -> TypedTree.TyconRef
    val ResolveTypeLongIdentInTyconRefPrim :
      ncenv:NameResolver ->
        typeNameResInfo:TypeNameResolutionInfo ->
          ad:AccessibilityLogic.AccessorDomain ->
            resInfo:ResolutionInfo ->
              genOk:PermitDirectReferenceToGeneratedType ->
                depth:int ->
                  m:Range.range ->
                    tcref:TypedTree.TyconRef ->
                      id:SyntaxTree.Ident ->
                        rest:SyntaxTree.Ident list ->
                          AbstractIL.Internal.Library.ResultOrException<ResolutionInfo *
                                                                        TypedTree.TyconRef>
    val ResolveTypeLongIdentInTyconRef :
      TcResultsSink ->
        NameResolver ->
          NameResolutionEnv ->
            TypeNameResolutionInfo ->
              AccessibilityLogic.AccessorDomain ->
                Range.range ->
                  TypedTree.TyconRef ->
                    SyntaxTree.Ident list -> TypedTree.TyconRef
    val SuggestTypeLongIdentInModuleOrNamespace :
      depth:int ->
        modref:TypedTree.ModuleOrNamespaceRef ->
          amap:Import.ImportMap ->
            ad:AccessibilityLogic.AccessorDomain ->
              m:Range.range -> id:SyntaxTree.Ident -> exn
    val private ResolveTypeLongIdentInModuleOrNamespace :
      sink:TcResultsSink ->
        nenv:NameResolutionEnv ->
          ncenv:NameResolver ->
            typeNameResInfo:TypeNameResolutionInfo ->
              ad:AccessibilityLogic.AccessorDomain ->
                genOk:PermitDirectReferenceToGeneratedType ->
                  resInfo:ResolutionInfo ->
                    depth:int ->
                      m:Range.range ->
                        modref:TypedTree.ModuleOrNamespaceRef ->
                          _mty:TypedTree.ModuleOrNamespaceType ->
                            id:SyntaxTree.Ident ->
                              rest:SyntaxTree.Ident list ->
                                AbstractIL.Internal.Library.ResultOrException<(ResolutionInfo *
                                                                               TypedTree.EntityRef) list>
    val ResolveTypeLongIdentPrim :
      sink:TcResultsSink ->
        ncenv:NameResolver ->
          occurence:ItemOccurence ->
            first:bool ->
              fullyQualified:FullyQualifiedFlag ->
                m:Range.range ->
                  nenv:NameResolutionEnv ->
                    ad:AccessibilityLogic.AccessorDomain ->
                      id:SyntaxTree.Ident ->
                        rest:SyntaxTree.Ident list ->
                          staticResInfo:TypeNameResolutionStaticArgsInfo ->
                            genOk:PermitDirectReferenceToGeneratedType ->
                              AbstractIL.Internal.Library.ResultOrException<ResolutionInfo *
                                                                            TypedTree.TyconRef>
    val ResolveTypeLongIdentAux :
      sink:TcResultsSink ->
        ncenv:NameResolver ->
          occurence:ItemOccurence ->
            fullyQualified:FullyQualifiedFlag ->
              nenv:NameResolutionEnv ->
                ad:AccessibilityLogic.AccessorDomain ->
                  lid:SyntaxTree.Ident list ->
                    staticResInfo:TypeNameResolutionStaticArgsInfo ->
                      genOk:PermitDirectReferenceToGeneratedType ->
                        AbstractIL.Internal.Library.ResultOrException<ResolutionInfo *
                                                                      TypedTree.TyconRef>
    val ResolveTypeLongIdent :
      TcResultsSink ->
        NameResolver ->
          ItemOccurence ->
            FullyQualifiedFlag ->
              NameResolutionEnv ->
                AccessibilityLogic.AccessorDomain ->
                  SyntaxTree.Ident list ->
                    TypeNameResolutionStaticArgsInfo ->
                      PermitDirectReferenceToGeneratedType ->
                        AbstractIL.Internal.Library.ResultOrException<EnclosingTypeInst *
                                                                      TypedTree.TyconRef>
    val ResolveFieldInModuleOrNamespace :
      ncenv:NameResolver ->
        nenv:NameResolutionEnv ->
          ad:AccessibilityLogic.AccessorDomain ->
            resInfo:ResolutionInfo ->
              depth:int ->
                m:Range.range ->
                  modref:TypedTree.ModuleOrNamespaceRef ->
                    _mty:TypedTree.ModuleOrNamespaceType ->
                      id:SyntaxTree.Ident ->
                        rest:SyntaxTree.Ident list ->
                          AbstractIL.Internal.Library.ResultOrException<ResolutionInfo *
                                                                        FieldResolution *
                                                                        SyntaxTree.Ident list>
    val SuggestOtherLabelsOfSameRecordType :
      g:TcGlobals.TcGlobals ->
        nenv:NameResolutionEnv ->
          ty:TypedTree.TType ->
            id:SyntaxTree.Ident ->
              allFields:SyntaxTree.Ident list ->
                System.Collections.Generic.HashSet<string>
    val SuggestLabelsOfRelatedRecords :
      g:TcGlobals.TcGlobals ->
        nenv:NameResolutionEnv ->
          id:SyntaxTree.Ident -> allFields:SyntaxTree.Ident list -> exn
    val ResolveFieldPrim :
      sink:TcResultsSink ->
        ncenv:NameResolver ->
          nenv:NameResolutionEnv ->
            ad:AccessibilityLogic.AccessorDomain ->
              ty:TypedTree.TType ->
                mp:SyntaxTree.Ident list * id:SyntaxTree.Ident ->
                  allFields:SyntaxTree.Ident list ->
                    (ResolutionInfo * FieldResolution) list
    val ResolveField :
      TcResultsSink ->
        NameResolver ->
          NameResolutionEnv ->
            AccessibilityLogic.AccessorDomain ->
              TypedTree.TType ->
                SyntaxTree.Ident list * SyntaxTree.Ident ->
                  SyntaxTree.Ident list -> FieldResolution list
    val private ResolveExprDotLongIdent :
      ncenv:NameResolver ->
        m:Range.range ->
          ad:AccessibilityLogic.AccessorDomain ->
            nenv:NameResolutionEnv ->
              ty:TypedTree.TType ->
                id:SyntaxTree.Ident ->
                  rest:SyntaxTree.Ident list ->
                    typeNameResInfo:TypeNameResolutionInfo ->
                      findFlag:InfoReader.FindMemberFlag ->
                        ResolutionInfo * Item * SyntaxTree.Ident list
    val ComputeItemRange :
      wholem:Range.range ->
        lid:SyntaxTree.Ident list -> rest:'a list -> Range.range
    val FilterMethodGroups :
      ncenv:NameResolver ->
        itemRange:Range.range -> item:Item -> staticOnly:bool -> Item
    val NeedsWorkAfterResolution : namedItem:Item -> bool
    [<RequireQualifiedAccessAttribute ()>]
    type AfterResolution =
      | DoNothing
      | RecordResolution of
        Item option * (TypedTreeOps.TyparInst -> unit) *
        (Infos.MethInfo * Infos.PropInfo option * TypedTreeOps.TyparInst -> unit) *
        (unit -> unit)
    val ResolveLongIdentAsExprAndComputeRange :
      TcResultsSink ->
        NameResolver ->
          Range.range ->
            AccessibilityLogic.AccessorDomain ->
              NameResolutionEnv ->
                TypeNameResolutionInfo ->
                  SyntaxTree.Ident list ->
                    AbstractIL.Internal.Library.ResultOrException<EnclosingTypeInst *
                                                                  Item *
                                                                  Range.range *
                                                                  SyntaxTree.Ident list *
                                                                  AfterResolution>
    val ( |NonOverridable|_| ) : namedItem:Item -> unit option
    val ResolveExprDotLongIdentAndComputeRange :
      TcResultsSink ->
        NameResolver ->
          Range.range ->
            AccessibilityLogic.AccessorDomain ->
              NameResolutionEnv ->
                TypedTree.TType ->
                  SyntaxTree.Ident list ->
                    TypeNameResolutionInfo ->
                      InfoReader.FindMemberFlag ->
                        bool ->
                          Item * Range.range * SyntaxTree.Ident list *
                          AfterResolution
    val FakeInstantiationGenerator :
      Range.range -> TypedTree.Typar list -> TypedTree.TType list
    val ItemForModuleOrNamespaceRef : v:TypedTree.ModuleOrNamespaceRef -> Item
    val ItemForPropInfo : pinfo:Infos.PropInfo -> Item
    val IsTyconUnseenObsoleteSpec :
      ad:AccessibilityLogic.AccessorDomain ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range -> x:TypedTree.TyconRef -> allowObsolete:bool -> bool
    val IsTyconUnseen :
      ad:AccessibilityLogic.AccessorDomain ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap -> m:Range.range -> x:TypedTree.TyconRef -> bool
    val IsValUnseen :
      ad:AccessibilityLogic.AccessorDomain ->
        g:TcGlobals.TcGlobals -> m:'a -> v:TypedTree.ValRef -> bool
    val IsUnionCaseUnseen :
      ad:AccessibilityLogic.AccessorDomain ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range -> ucref:TypedTree.UnionCaseRef -> bool
    val ItemIsUnseen :
      ad:AccessibilityLogic.AccessorDomain ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap -> m:Range.range -> item:Item -> bool
    val ItemOfTyconRef :
      ncenv:NameResolver -> m:Range.range -> x:TypedTree.TyconRef -> Item
    val ItemOfTy : g:TcGlobals.TcGlobals -> x:TypedTree.TType -> Item
    val IsInterestingModuleName : nm:string -> bool
    val PartialResolveLookupInModuleOrNamespaceAsModuleOrNamespaceThen :
      f:(TypedTree.ModuleOrNamespaceRef -> 'a list) ->
        plid:string list -> modref:TypedTree.ModuleOrNamespaceRef -> 'a list
    val PartialResolveLongIdentAsModuleOrNamespaceThen :
      nenv:NameResolutionEnv ->
        plid:string list ->
          f:(TypedTree.ModuleOrNamespaceRef -> 'a list) -> 'a list
    val ResolveRecordOrClassFieldsOfType :
      NameResolver ->
        Range.range ->
          AccessibilityLogic.AccessorDomain ->
            TypedTree.TType -> bool -> Item list
    [<RequireQualifiedAccessAttribute ()>]
    type ResolveCompletionTargets =
      | All of (Infos.MethInfo -> TypedTree.TType -> bool)
      | SettablePropertiesAndFields
      with
        member ResolveAll : bool
      end
    val ResolveCompletionsInType :
      NameResolver ->
        NameResolutionEnv ->
          ResolveCompletionTargets ->
            Range.range ->
              AccessibilityLogic.AccessorDomain ->
                bool -> TypedTree.TType -> Item list
    val ResolvePartialLongIdentInType :
      ncenv:NameResolver ->
        nenv:NameResolutionEnv ->
          isApplicableMeth:ResolveCompletionTargets ->
            m:Range.range ->
              ad:AccessibilityLogic.AccessorDomain ->
                statics:bool ->
                  plid:string list -> ty:TypedTree.TType -> Item list
    val InfosForTyconConstructors :
      ncenv:NameResolver ->
        m:Range.range ->
          ad:AccessibilityLogic.AccessorDomain ->
            tcref:TypedTree.TyconRef -> Item list
    val inline notFakeContainerModule :
      tyconNames:System.Collections.Generic.HashSet<'a> -> nm:'a -> bool
    val getFakeContainerModulesFromTycons :
      tycons:#seq<TypedTree.Tycon> -> System.Collections.Generic.HashSet<string>
    val getFakeContainerModulesFromTyconRefs :
      tyconRefs:#seq<TypedTree.TyconRef> ->
        System.Collections.Generic.HashSet<string>
    val private EntityRefContainsSomethingAccessible :
      ncenv:NameResolver ->
        m:Range.range ->
          ad:AccessibilityLogic.AccessorDomain ->
            modref:TypedTree.ModuleOrNamespaceRef -> bool
    val ResolvePartialLongIdentInModuleOrNamespace :
      ncenv:NameResolver ->
        nenv:NameResolutionEnv ->
          isApplicableMeth:ResolveCompletionTargets ->
            m:Range.range ->
              ad:AccessibilityLogic.AccessorDomain ->
                modref:TypedTree.ModuleOrNamespaceRef ->
                  plid:string list -> allowObsolete:bool -> Item list
    val TryToResolveLongIdentAsType :
      NameResolver ->
        NameResolutionEnv ->
          Range.range -> string list -> TypedTree.TType option
    val ResolvePartialLongIdentPrim :
      ncenv:NameResolver ->
        nenv:NameResolutionEnv ->
          isApplicableMeth:ResolveCompletionTargets ->
            fullyQualified:FullyQualifiedFlag ->
              m:Range.range ->
                ad:AccessibilityLogic.AccessorDomain ->
                  plid:string list -> allowObsolete:bool -> Item list
    val ResolvePartialLongIdent :
      NameResolver ->
        NameResolutionEnv ->
          (Infos.MethInfo -> TypedTree.TType -> bool) ->
            Range.range ->
              AccessibilityLogic.AccessorDomain ->
                string list -> bool -> Item list
    val ResolvePartialLongIdentInModuleOrNamespaceForRecordFields :
      ncenv:NameResolver ->
        nenv:'a ->
          m:Range.range ->
            ad:AccessibilityLogic.AccessorDomain ->
              modref:TypedTree.ModuleOrNamespaceRef ->
                plid:string list -> allowObsolete:bool -> Item list
    val ResolvePartialLongIdentToClassOrRecdFields :
      NameResolver ->
        NameResolutionEnv ->
          Range.range ->
            AccessibilityLogic.AccessorDomain ->
              string list -> bool -> Item list
    val ResolvePartialLongIdentToClassOrRecdFieldsImpl :
      ncenv:NameResolver ->
        nenv:NameResolutionEnv ->
          fullyQualified:FullyQualifiedFlag ->
            m:Range.range ->
              ad:AccessibilityLogic.AccessorDomain ->
                plid:string list -> allowObsolete:bool -> Item list
    val ResolveCompletionsInTypeForItem :
      ncenv:NameResolver ->
        nenv:NameResolutionEnv ->
          m:Range.range ->
            ad:AccessibilityLogic.AccessorDomain ->
              statics:bool -> ty:TypedTree.TType -> item:Item -> seq<Item>
    val ResolvePartialLongIdentInTypeForItem :
      ncenv:NameResolver ->
        nenv:NameResolutionEnv ->
          m:Range.range ->
            ad:AccessibilityLogic.AccessorDomain ->
              statics:bool ->
                plid:string list -> item:Item -> ty:TypedTree.TType -> seq<Item>
    val ResolvePartialLongIdentInModuleOrNamespaceForItem :
      ncenv:NameResolver ->
        nenv:NameResolutionEnv ->
          m:Range.range ->
            ad:AccessibilityLogic.AccessorDomain ->
              modref:TypedTree.ModuleOrNamespaceRef ->
                plid:string list -> item:Item -> seq<Item>
    val PartialResolveLookupInModuleOrNamespaceAsModuleOrNamespaceThenLazy :
      f:(TypedTree.ModuleOrNamespaceRef -> seq<'a>) ->
        plid:string list -> modref:TypedTree.ModuleOrNamespaceRef -> seq<'a>
    val PartialResolveLongIdentAsModuleOrNamespaceThenLazy :
      nenv:NameResolutionEnv ->
        plid:string list ->
          f:(TypedTree.ModuleOrNamespaceRef -> seq<'a>) -> seq<'a>
    val GetCompletionForItem :
      ncenv:NameResolver ->
        nenv:NameResolutionEnv ->
          m:Range.range ->
            ad:AccessibilityLogic.AccessorDomain ->
              plid:string list -> item:Item -> seq<Item>
    val IsItemResolvable :
      NameResolver ->
        NameResolutionEnv ->
          Range.range ->
            AccessibilityLogic.AccessorDomain -> string list -> Item -> bool
    val GetVisibleNamespacesAndModulesAtPoint :
      NameResolver ->
        NameResolutionEnv ->
          Range.range ->
            AccessibilityLogic.AccessorDomain ->
              TypedTree.ModuleOrNamespaceRef list
  end

namespace FSharp.Compiler
  module internal SignatureConformance = begin
    exception RequiredButNotSpecified of
                                        TypedTreeOps.DisplayEnv *
                                        TypedTree.ModuleOrNamespaceRef * string *
                                        (System.Text.StringBuilder -> unit) *
                                        Range.range
    exception ValueNotContained of
                                  TypedTreeOps.DisplayEnv *
                                  TypedTree.ModuleOrNamespaceRef * TypedTree.Val *
                                  TypedTree.Val *
                                  (string * string * string -> string)
    exception ConstrNotContained of
                                   TypedTreeOps.DisplayEnv * TypedTree.UnionCase *
                                   TypedTree.UnionCase *
                                   (string * string -> string)
    exception ExnconstrNotContained of
                                      TypedTreeOps.DisplayEnv * TypedTree.Tycon *
                                      TypedTree.Tycon *
                                      (string * string -> string)
    exception FieldNotContained of
                                  TypedTreeOps.DisplayEnv * TypedTree.RecdField *
                                  TypedTree.RecdField *
                                  (string * string -> string)
    exception InterfaceNotRevealed of
                                     TypedTreeOps.DisplayEnv * TypedTree.TType *
                                     Range.range
    type Checker =
      class
        new : g:TcGlobals.TcGlobals * amap:Import.ImportMap *
              denv:TypedTreeOps.DisplayEnv *
              remapInfo:TypedTreeOps.SignatureRepackageInfo * checkingSig:bool ->
                Checker
        member
          CheckSignature : aenv:TypedTreeOps.TypeEquivEnv ->
                             implModRef:TypedTree.ModuleOrNamespaceRef ->
                               signModType:TypedTree.ModuleOrNamespaceType ->
                                 bool
        member
          CheckTypars : m:Range.range ->
                          aenv:TypedTreeOps.TypeEquivEnv ->
                            implTypars:TypedTree.Typars ->
                              signTypars:TypedTree.Typars -> bool
      end
    val CheckNamesOfModuleOrNamespaceContents :
      denv:TypedTreeOps.DisplayEnv ->
        implModRef:TypedTree.ModuleOrNamespaceRef ->
          signModType:TypedTree.ModuleOrNamespaceType -> bool
    val CheckNamesOfModuleOrNamespace :
      denv:TypedTreeOps.DisplayEnv ->
        implModRef:TypedTree.ModuleOrNamespaceRef ->
          signModType:TypedTree.ModuleOrNamespaceType -> bool
  end

namespace FSharp.Compiler
  module internal MethodOverrides = begin
    type OverrideCanImplement =
      | CanImplementAnyInterfaceSlot
      | CanImplementAnyClassHierarchySlot
      | CanImplementAnySlot
      | CanImplementNoSlots
    type OverrideInfo =
      | Override of
        OverrideCanImplement * TypedTree.TyconRef * SyntaxTree.Ident *
        (TypedTree.Typars * TypedTreeOps.TyparInst) * TypedTree.TType list list *
        TypedTree.TType option * bool * bool
      with
        member ArgTypes : TypedTree.TType list list
        member BoundingTyconRef : TypedTree.TyconRef
        member CanImplement : OverrideCanImplement
        member IsCompilerGenerated : bool
        member IsFakeEventProperty : bool
        member LogicalName : string
        member Range : Range.range
        member ReturnType : TypedTree.TType option
      end
    type RequiredSlot =
      | RequiredSlot of Infos.MethInfo * isOptional: bool
      | DefaultInterfaceImplementationSlot of
        Infos.MethInfo * isOptional: bool * possiblyNoMostSpecific: bool
      with
        member HasDefaultInterfaceImplementation : bool
        member IsOptional : bool
        member MethodInfo : Infos.MethInfo
        member PossiblyNoMostSpecificImplementation : bool
      end
    type SlotImplSet =
      | SlotImplSet of
        RequiredSlot list *
        AbstractIL.Internal.Library.NameMultiMap<RequiredSlot> *
        OverrideInfo list * Infos.PropInfo list
    exception TypeIsImplicitlyAbstract of Range.range
    exception OverrideDoesntOverride of
                                       TypedTreeOps.DisplayEnv * OverrideInfo *
                                       Infos.MethInfo option *
                                       TcGlobals.TcGlobals * Import.ImportMap *
                                       Range.range
    module DispatchSlotChecking = begin
      val PrintOverrideToBuffer :
        denv:TypedTreeOps.DisplayEnv ->
          os:System.Text.StringBuilder -> OverrideInfo -> unit
      val PrintMethInfoSigToBuffer :
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              denv:TypedTreeOps.DisplayEnv ->
                os:System.Text.StringBuilder -> minfo:Infos.MethInfo -> unit
      val FormatOverride :
        denv:TypedTreeOps.DisplayEnv -> d:OverrideInfo -> string
      val FormatMethInfoSig :
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              denv:TypedTreeOps.DisplayEnv -> d:Infos.MethInfo -> string
      val GetInheritedMemberOverrideInfo :
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              parentType:OverrideCanImplement ->
                minfo:Infos.MethInfo -> OverrideInfo
      val GetTypeMemberOverrideInfo :
        g:TcGlobals.TcGlobals ->
          reqdTy:TypedTree.TType -> overrideBy:TypedTree.ValRef -> OverrideInfo
      val GetObjectExprOverrideInfo :
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            implty:TypedTree.TType * id:SyntaxTree.Ident *
            memberFlags:SyntaxTree.MemberFlags * ty:TypedTree.TType *
            arityInfo:TypedTree.ValReprInfo * bindingAttribs:TypedTree.Attribs *
            rhsExpr:TypedTree.Expr ->
              OverrideInfo *
              (TypedTree.Val option * TypedTree.Val * TypedTree.Val list list *
               TypedTree.Attribs * TypedTree.Expr)
      val IsNameMatch :
        dispatchSlot:Infos.MethInfo -> overrideBy:OverrideInfo -> bool
      val IsImplMatch :
        g:TcGlobals.TcGlobals ->
          dispatchSlot:Infos.MethInfo -> overrideBy:OverrideInfo -> bool
      val IsTyparKindMatch : Infos.CompiledSig -> OverrideInfo -> bool
      val IsSigPartialMatch :
        g:TcGlobals.TcGlobals ->
          dispatchSlot:Infos.MethInfo ->
            compiledSig:Infos.CompiledSig -> OverrideInfo -> bool
      val IsPartialMatch :
        g:TcGlobals.TcGlobals ->
          dispatchSlot:Infos.MethInfo ->
            compiledSig:Infos.CompiledSig -> overrideBy:OverrideInfo -> bool
      val ReverseTyparRenaming :
        g:TcGlobals.TcGlobals ->
          tinst:(TypedTree.Typar * TypedTree.TType) list ->
            (TypedTree.Typar * TypedTree.TType) list
      val ComposeTyparInsts :
        inst1:('a * TypedTree.TType) list ->
          inst2:TypedTreeOps.TyparInst -> ('a * TypedTree.TType) list
      val IsSigExactMatch :
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range -> dispatchSlot:Infos.MethInfo -> OverrideInfo -> bool
      val IsExactMatch :
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              dispatchSlot:Infos.MethInfo -> overrideBy:OverrideInfo -> bool
      val OverrideImplementsDispatchSlot :
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              dispatchSlot:Infos.MethInfo ->
                availPriorOverride:OverrideInfo -> bool
      val DispatchSlotIsAlreadyImplemented :
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              availPriorOverridesKeyed:AbstractIL.Internal.Library.NameMultiMap<OverrideInfo> ->
                dispatchSlot:Infos.MethInfo -> bool
      val CheckDispatchSlotsAreImplemented :
        denv:TypedTreeOps.DisplayEnv * infoReader:InfoReader.InfoReader *
        m:Range.range * nenv:NameResolution.NameResolutionEnv *
        sink:NameResolution.TcResultsSink * isOverallTyAbstract:bool *
        reqdTy:TypedTree.TType * dispatchSlots:RequiredSlot list *
        availPriorOverrides:OverrideInfo list * overrides:OverrideInfo list ->
          bool
      val GetMostSpecificOverrideInterfaceMethodSets :
        infoReader:InfoReader.InfoReader ->
          allReqdTys:(TypedTree.TType * Range.range) list ->
            Map<string,(TypedTree.TType * Infos.MethInfo) list>
      val GetMostSpecificOverrideInterfaceMethodsByMethod :
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              mostSpecificOverrides:AbstractIL.Internal.Library.NameMultiMap<TypedTree.TType *
                                                                             Infos.MethInfo> ->
                minfo:Infos.MethInfo -> (TypedTree.TType * Infos.MethInfo) list
      val GetInterfaceDispatchSlots :
        infoReader:InfoReader.InfoReader ->
          ad:AccessibilityLogic.AccessorDomain ->
            m:Range.range ->
              availImpliedInterfaces:TypedTree.TType list ->
                mostSpecificOverrides:AbstractIL.Internal.Library.NameMultiMap<TypedTree.TType *
                                                                               Infos.MethInfo> ->
                  interfaceTy:TypedTree.TType -> RequiredSlot list
      val GetClassDispatchSlots :
        infoReader:InfoReader.InfoReader ->
          ad:AccessibilityLogic.AccessorDomain ->
            m:Range.range -> reqdTy:TypedTree.TType -> RequiredSlot list
      val GetDispatchSlotSet :
        infoReader:InfoReader.InfoReader ->
          ad:AccessibilityLogic.AccessorDomain ->
            m:Range.range ->
              availImpliedInterfaces:TypedTree.TType list ->
                mostSpecificOverrides:AbstractIL.Internal.Library.NameMultiMap<TypedTree.TType *
                                                                               Infos.MethInfo> ->
                  reqdTy:TypedTree.TType ->
                    impliedTys:seq<TypedTree.TType> ->
                      (TypedTree.TType * RequiredSlot list) list
      val CheckOverridesAreAllUsedOnce :
        denv:TypedTreeOps.DisplayEnv * g:TcGlobals.TcGlobals *
        amap:Import.ImportMap * isObjExpr:bool * reqdTy:TypedTree.TType *
        dispatchSlotsKeyed:AbstractIL.Internal.Library.NameMultiMap<RequiredSlot> *
        availPriorOverrides:OverrideInfo list * overrides:OverrideInfo list ->
          unit
      val GetSlotImplSets :
        infoReader:InfoReader.InfoReader ->
          denv:TypedTreeOps.DisplayEnv ->
            ad:AccessibilityLogic.AccessorDomain ->
              isObjExpr:bool ->
                allReqdTys:(TypedTree.TType * Range.range) list ->
                  SlotImplSet list
      val CheckImplementationRelationAtEndOfInferenceScope :
        infoReader:InfoReader.InfoReader * denv:TypedTreeOps.DisplayEnv *
        nenv:NameResolution.NameResolutionEnv *
        sink:NameResolution.TcResultsSink * tycon:TypedTree.Tycon *
        isImplementation:bool -> unit
    end
    val FinalTypeDefinitionChecksAtEndOfInferenceScope :
      infoReader:InfoReader.InfoReader * nenv:NameResolution.NameResolutionEnv *
      sink:NameResolution.TcResultsSink * isImplementation:bool *
      denv:TypedTreeOps.DisplayEnv -> tycon:TypedTree.Tycon -> unit
    val GetAbstractMethInfosForSynMethodDecl :
      infoReader:InfoReader.InfoReader * ad:AccessibilityLogic.AccessorDomain *
      memberName:SyntaxTree.Ident * bindm:Range.range *
      typToSearchForAbstractMembers:(TypedTree.TType * SlotImplSet option) *
      valSynData:SyntaxTree.SynValInfo ->
        Infos.MethInfo list * Infos.MethInfo list
    val GetAbstractPropInfosForSynPropertyDecl :
      infoReader:InfoReader.InfoReader * ad:AccessibilityLogic.AccessorDomain *
      memberName:SyntaxTree.Ident * bindm:Range.range *
      typToSearchForAbstractMembers:(TypedTree.TType * SlotImplSet option) *
      _k:'a * _valSynData:'b -> Infos.PropInfo list
  end

namespace FSharp.Compiler
  module internal MethodCalls = begin
    type CallerArg<'T> =
      | CallerArg of
        ty: TypedTree.TType * range: Range.range * isOpt: bool * exprInfo: 'T
      with
        member CallerArgumentType : TypedTree.TType
        member Expr : 'T
        member IsExplicitOptional : bool
        member Range : Range.range
      end
    type CalledArg =
      { Position: struct (int * int)
        IsParamArray: bool
        OptArgInfo: Infos.OptionalArgInfo
        CallerInfo: Infos.CallerInfo
        IsInArg: bool
        IsOutArg: bool
        ReflArgInfo: Infos.ReflectedArgInfo
        NameOpt: SyntaxTree.Ident option
        CalledArgumentType: TypedTree.TType }
    val CalledArg :
      pos:struct (int * int) * isParamArray:bool *
      optArgInfo:Infos.OptionalArgInfo * callerInfo:Infos.CallerInfo *
      isInArg:bool * isOutArg:bool * nameOpt:SyntaxTree.Ident option *
      reflArgInfo:Infos.ReflectedArgInfo * calledArgTy:TypedTree.TType ->
        CalledArg
    type AssignedCalledArg<'T> =
      { NamedArgIdOpt: SyntaxTree.Ident option
        CalledArg: CalledArg
        CallerArg: CallerArg<'T> }
      with
        member Position : struct (int * int)
      end
    type AssignedItemSetterTarget =
      | AssignedPropSetter of
        Infos.PropInfo * Infos.MethInfo * TypedTree.TypeInst
      | AssignedILFieldSetter of Infos.ILFieldInfo
      | AssignedRecdFieldSetter of Infos.RecdFieldInfo
    type AssignedItemSetter<'T> =
      | AssignedItemSetter of
        SyntaxTree.Ident * AssignedItemSetterTarget * CallerArg<'T>
    type CallerNamedArg<'T> =
      | CallerNamedArg of SyntaxTree.Ident * CallerArg<'T>
      with
        member CallerArg : CallerArg<'T>
        member Ident : SyntaxTree.Ident
        member Name : string
      end
    [<StructAttribute ()>]
    type CallerArgs<'T> =
      { Unnamed: CallerArg<'T> list list
        Named: CallerNamedArg<'T> list list }
      with
        member ArgumentNamesAndTypes : (string option * TypedTree.TType) list
        member CallerArgCounts : int * int
        member
          CurriedCallerArgs : (CallerArg<'T> list * CallerNamedArg<'T> list) list
        static member Empty : CallerArgs<'T>
      end
    val AdjustCalledArgTypeForLinqExpressionsAndAutoQuote :
      infoReader:InfoReader.InfoReader ->
        callerArgTy:TypedTree.TType ->
          calledArg:CalledArg -> m:Range.range -> TypedTree.TType
    val AdjustCalledArgTypeForOptionals :
      g:TcGlobals.TcGlobals ->
        enforceNullableOptionalsKnownTypes:bool ->
          calledArg:CalledArg ->
            calledArgTy:TypedTree.TType ->
              callerArg:CallerArg<'a> -> TypedTree.TType
    val AdjustCalledArgType :
      infoReader:InfoReader.InfoReader ->
        isConstraint:bool ->
          enforceNullableOptionalsKnownTypes:bool ->
            calledArg:CalledArg -> callerArg:CallerArg<'a> -> TypedTree.TType
    type CalledMethArgSet<'T> =
      { UnnamedCalledArgs: CalledArg list
        UnnamedCallerArgs: CallerArg<'T> list
        ParamArrayCalledArgOpt: CalledArg option
        ParamArrayCallerArgs: CallerArg<'T> list
        AssignedNamedArgs: AssignedCalledArg<'T> list }
      with
        member NumAssignedNamedArgs : int
        member NumUnnamedCalledArgs : int
        member NumUnnamedCallerArgs : int
      end
    val MakeCalledArgs :
      amap:Import.ImportMap ->
        m:Range.range ->
          minfo:Infos.MethInfo ->
            minst:TypedTree.TType list -> CalledArg list list
    type CalledMeth<'T> =
      class
        new : infoReader:InfoReader.InfoReader *
              nameEnv:NameResolution.NameResolutionEnv option *
              isCheckingAttributeCall:bool *
              freshenMethInfo:(Range.range -> Infos.MethInfo ->
                                 TypedTree.TypeInst) * m:Range.range *
              ad:AccessibilityLogic.AccessorDomain * minfo:Infos.MethInfo *
              calledTyArgs:TypedTree.TType list *
              callerTyArgs:TypedTree.TType list * pinfoOpt:Infos.PropInfo option *
              callerObjArgTys:TypedTree.TType list * callerArgs:CallerArgs<'T> *
              allowParamArgs:bool * allowOutAndOptArgs:bool *
              tyargsOpt:TypedTree.TType option -> CalledMeth<'T>
        static member GetMethod : x:CalledMeth<'T> -> Infos.MethInfo
        member CalledObjArgTys : m:Range.range -> TypedTree.TType list
        member GetParamArrayElementType : unit -> TypedTree.TType
        member HasCorrectObjArgs : m:Range.range -> bool
        member
          IsAccessible : m:Range.range * ad:AccessibilityLogic.AccessorDomain ->
                           bool
        member
          IsCandidate : m:Range.range * ad:AccessibilityLogic.AccessorDomain ->
                          bool
        override ToString : unit -> string
        member AllCalledArgs : CalledArg list list
        member AllUnnamedCalledArgs : CalledArg list
        member ArgSets : CalledMethArgSet<'T> list
        member AssignedItemSetters : AssignedItemSetter<'T> list
        member AssignedNamedArgs : AssignedCalledArg<'T> list list
        member AssignedUnnamedArgs : AssignedCalledArg<'T> list list
        member AssignsAllNamedArgs : bool
        member AssociatedPropertyInfo : Infos.PropInfo option
        member AttributeAssignedNamedArgs : CallerNamedArg<'T> list
        member CalledReturnTypeAfterByrefDeref : TypedTree.TType
        member CalledReturnTypeAfterOutArgTupling : TypedTree.TType
        member CalledTyArgs : TypedTree.TType list
        member CalledTyparInst : TypedTreeOps.TyparInst
        member CallerObjArgTys : TypedTree.TType list
        member CallerTyArgs : TypedTree.TType list
        member HasCorrectArity : bool
        member HasCorrectGenericArity : bool
        member HasOptArgs : bool
        member HasOutArgs : bool
        member Method : Infos.MethInfo
        member NumArgSets : int
        member NumAssignedProps : int
        member NumCalledTyArgs : int
        member NumCallerTyArgs : int
        member ParamArrayCalledArgOpt : CalledArg option
        member ParamArrayCallerArgs : CallerArg<'T> list option
        member TotalNumAssignedNamedArgs : int
        member TotalNumUnnamedCalledArgs : int
        member TotalNumUnnamedCallerArgs : int
        member UnassignedNamedArgs : CallerNamedArg<'T> list
        member UnnamedCalledOptArgs : CalledArg list
        member UnnamedCalledOutArgs : CalledArg list
        member UsesParamArrayConversion : bool
        member amap : Import.ImportMap
        member infoReader : InfoReader.InfoReader
      end
    val NamesOfCalledArgs : calledArgs:CalledArg list -> SyntaxTree.Ident list
    type ArgumentAnalysis =
      | NoInfo
      | ArgDoesNotMatch
      | CallerLambdaHasArgTypes of TypedTree.TType list
      | CalledArgMatchesType of TypedTree.TType
    val InferLambdaArgsForLambdaPropagation :
      origRhsExpr:SyntaxTree.SynExpr -> int
    val ExamineArgumentForLambdaPropagation :
      infoReader:InfoReader.InfoReader ->
        arg:AssignedCalledArg<SyntaxTree.SynExpr> -> ArgumentAnalysis
    val ExamineMethodForLambdaPropagation :
      x:CalledMeth<SyntaxTree.SynExpr> ->
        (ArgumentAnalysis list list *
         (SyntaxTree.Ident * ArgumentAnalysis) list list) option
    val IsBaseCall : objArgs:TypedTree.Expr list -> bool
    val ComputeConstrainedCallInfo :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            objArgs:TypedTree.Expr list * minfo:Infos.MethInfo ->
              TypedTree.TType option
    val TakeObjAddrForMethodCall :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          minfo:Infos.MethInfo ->
            isMutable:TypedTreeOps.Mutates ->
              m:Range.range ->
                objArgs:TypedTree.Expr list ->
                  f:(TypedTree.TType option -> TypedTree.Expr list ->
                       TypedTree.Expr * 'a) -> TypedTree.Expr * 'a
    val BuildILMethInfoCall :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            isProp:bool ->
              minfo:Infos.ILMethInfo ->
                valUseFlags:TypedTree.ValUseFlag ->
                  minst:TypedTree.TType list ->
                    direct:bool ->
                      args:TypedTree.Exprs -> TypedTree.Expr * TypedTree.TType
    val BuildFSharpMethodApp :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          vref:TypedTree.ValRef ->
            vexp:TypedTree.Expr ->
              vexprty:TypedTree.TType ->
                args:TypedTree.Exprs -> TypedTree.Expr * TypedTree.TType
    val BuildFSharpMethodCall :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          ty:TypedTree.TType * vref:TypedTree.ValRef ->
            valUseFlags:TypedTree.ValUseFlag ->
              minst:TypedTree.TType list ->
                args:TypedTree.Exprs -> TypedTree.Expr * TypedTree.TType
    val MakeMethInfoCall :
      amap:Import.ImportMap ->
        m:Range.range ->
          minfo:Infos.MethInfo ->
            minst:TypedTree.TType list -> args:TypedTree.Exprs -> TypedTree.Expr
    val TryImportProvidedMethodBaseAsLibraryIntrinsic :
      amap:Import.ImportMap * m:Range.range *
      mbase:Tainted<ExtensionTyping.ProvidedMethodBase> ->
        TypedTree.ValRef option
    val BuildMethodCall :
      tcVal:(TypedTree.ValRef -> TypedTree.ValUseFlag -> TypedTree.TType list ->
               Range.range -> TypedTree.Expr * TypedTree.TType) ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            isMutable:TypedTreeOps.Mutates ->
              m:Range.range ->
                isProp:bool ->
                  minfo:Infos.MethInfo ->
                    valUseFlags:TypedTree.ValUseFlag ->
                      minst:TypedTree.TType list ->
                        objArgs:TypedTree.Expr list ->
                          args:TypedTree.Expr list ->
                            TypedTree.Expr * TypedTree.TType
    val BuildObjCtorCall :
      g:TcGlobals.TcGlobals -> m:Range.range -> TypedTree.Expr
    val BuildNewDelegateExpr :
      eventInfoOpt:Infos.EventInfo option * g:TcGlobals.TcGlobals *
      amap:Import.ImportMap * delegateTy:TypedTree.TType *
      invokeMethInfo:Infos.MethInfo * delArgTys:TypedTree.TType list *
      f:TypedTree.Expr * fty:TypedTree.TType * m:Range.range -> TypedTree.Expr
    val CoerceFromFSharpFuncToDelegate :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          infoReader:InfoReader.InfoReader ->
            ad:AccessibilityLogic.AccessorDomain ->
              callerArgTy:TypedTree.TType ->
                m:Range.range ->
                  callerArgExpr:TypedTree.Expr ->
                    delegateTy:TypedTree.TType -> TypedTree.Expr
    val AdjustCallerArgExprForCoercions :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          infoReader:InfoReader.InfoReader ->
            ad:AccessibilityLogic.AccessorDomain ->
              isOutArg:bool ->
                calledArgTy:TypedTree.TType ->
                  reflArgInfo:Infos.ReflectedArgInfo ->
                    callerArgTy:TypedTree.TType ->
                      m:Range.range ->
                        callerArgExpr:TypedTree.Expr ->
                          'a option * TypedTree.Expr
    val emptyPreBinder : e:TypedTree.Expr -> TypedTree.Expr
    val GetDefaultExpressionForCallerSideOptionalArg :
      tcFieldInit:(Range.range -> AbstractIL.IL.ILFieldInit -> TypedTree.Const) ->
        g:TcGlobals.TcGlobals ->
          calledArg:CalledArg ->
            currCalledArgTy:TypedTree.TType ->
              currDfltVal:Infos.OptionalArgCallerSideValue ->
                eCallerMemberName:string option ->
                  mMethExpr:Range.range ->
                    (TypedTree.Expr -> TypedTree.Expr) * TypedTree.Expr
    val GetDefaultExpressionForCalleeSideOptionalArg :
      g:TcGlobals.TcGlobals ->
        calledArg:CalledArg ->
          eCallerMemberName:string option ->
            mMethExpr:Range.range -> TypedTree.Expr
    val GetDefaultExpressionForOptionalArg :
      tcFieldInit:(Range.range -> AbstractIL.IL.ILFieldInit -> TypedTree.Const) ->
        g:TcGlobals.TcGlobals ->
          calledArg:CalledArg ->
            eCallerMemberName:string option ->
              mItem:Range.range ->
                mMethExpr:Range.range ->
                  (TypedTree.Expr -> TypedTree.Expr) *
                  AssignedCalledArg<TypedTree.Expr>
    val MakeNullableExprIfNeeded :
      infoReader:InfoReader.InfoReader ->
        calledArgTy:TypedTree.TType ->
          callerArgTy:TypedTree.TType ->
            callerArgExpr:TypedTree.Expr -> m:Range.range -> TypedTree.Expr
    val AdjustCallerArgForOptional :
      tcFieldInit:(Range.range -> AbstractIL.IL.ILFieldInit -> TypedTree.Const) ->
        eCallerMemberName:string option ->
          infoReader:InfoReader.InfoReader ->
            assignedArg:AssignedCalledArg<TypedTree.Expr> ->
              AssignedCalledArg<TypedTree.Expr>
    val AdjustCallerArgsForOptionals :
      tcFieldInit:(Range.range -> AbstractIL.IL.ILFieldInit -> TypedTree.Const) ->
        eCallerMemberName:string option ->
          infoReader:InfoReader.InfoReader ->
            calledMeth:CalledMeth<TypedTree.Expr> ->
              mItem:Range.range ->
                mMethExpr:Range.range ->
                  AssignedCalledArg<TypedTree.Expr> list *
                  (TypedTree.Expr -> TypedTree.Expr) *
                  AssignedCalledArg<TypedTree.Expr> list *
                  AssignedCalledArg<TypedTree.Expr> list
    val AdjustOutCallerArgs :
      g:TcGlobals.TcGlobals ->
        calledMeth:CalledMeth<'a> ->
          mMethExpr:Range.range ->
            AssignedCalledArg<TypedTree.Expr> list * TypedTree.Expr list *
            TypedTree.Binding list
    val AdjustParamArrayCallerArgs :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          infoReader:InfoReader.InfoReader ->
            ad:AccessibilityLogic.AccessorDomain ->
              calledMeth:CalledMeth<TypedTree.Expr> ->
                mMethExpr:Range.range ->
                  'a option list * AssignedCalledArg<TypedTree.Expr> list
    val AdjustCallerArgs :
      tcFieldInit:(Range.range -> AbstractIL.IL.ILFieldInit -> TypedTree.Const) ->
        eCallerMemberName:string option ->
          infoReader:InfoReader.InfoReader ->
            ad:AccessibilityLogic.AccessorDomain ->
              calledMeth:CalledMeth<TypedTree.Expr> ->
                objArgs:TypedTree.Expr list ->
                  lambdaVars:'a option ->
                    mItem:Range.range ->
                      mMethExpr:Range.range ->
                        (TypedTree.Expr -> TypedTree.Expr) * TypedTree.Expr list *
                        'b option list * AssignedCalledArg<TypedTree.Expr> list *
                        TypedTree.Expr list * (TypedTree.Expr -> TypedTree.Expr) *
                        'c option list * TypedTree.Expr list *
                        TypedTree.Binding list
    module ProvidedMethodCalls = begin
      val private convertConstExpr :
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              constant:Tainted<obj * ExtensionTyping.ProvidedType> ->
                TypedTree.Expr
      val eraseSystemType :
        amap:Import.ImportMap * m:Range.range *
        inputType:Tainted<ExtensionTyping.ProvidedType> ->
          Tainted<ExtensionTyping.ProvidedType>
      val convertProvidedExpressionToExprAndWitness :
        tcVal:(TypedTree.ValRef -> TypedTree.ValUseFlag ->
                 TypedTree.TType list -> Range.range ->
                 TypedTree.Expr * TypedTree.TType) ->
          thisArg:TypedTree.Expr option * allArgs:TypedTree.Exprs *
          paramVars:Tainted<ExtensionTyping.ProvidedVar> [] *
          g:TcGlobals.TcGlobals * amap:Import.ImportMap *
          mut:TypedTreeOps.Mutates * isProp:bool *
          isSuperInit:TypedTree.ValUseFlag * m:Range.range *
          expr:Tainted<ExtensionTyping.ProvidedExpr> ->
            Tainted<ExtensionTyping.ProvidedMethodInfo> option *
            (TypedTree.Expr * TypedTree.TType)
      val TranslateInvokerExpressionForProvidedMethodCall :
        tcVal:(TypedTree.ValRef -> TypedTree.ValUseFlag ->
                 TypedTree.TType list -> Range.range ->
                 TypedTree.Expr * TypedTree.TType) ->
          g:TcGlobals.TcGlobals * amap:Import.ImportMap *
          mut:TypedTreeOps.Mutates * isProp:bool *
          isSuperInit:TypedTree.ValUseFlag *
          mi:Tainted<ExtensionTyping.ProvidedMethodBase> *
          objArgs:TypedTree.Expr list * allArgs:TypedTree.Exprs * m:Range.range ->
            Tainted<ExtensionTyping.ProvidedMethodInfo> option *
            (TypedTree.Expr * TypedTree.TType)
      val BuildInvokerExpressionForProvidedMethodCall :
        tcVal:(TypedTree.ValRef -> TypedTree.ValUseFlag ->
                 TypedTree.TType list -> Range.range ->
                 TypedTree.Expr * TypedTree.TType) ->
          g:TcGlobals.TcGlobals * amap:Import.ImportMap *
          mi:Tainted<ExtensionTyping.ProvidedMethodBase> *
          objArgs:TypedTree.Expr list * mut:TypedTreeOps.Mutates * isProp:bool *
          isSuperInit:TypedTree.ValUseFlag * allArgs:TypedTree.Exprs *
          m:Range.range ->
            Tainted<ExtensionTyping.ProvidedMethodInfo> option * TypedTree.Expr *
            TypedTree.TType
    end
    val RecdFieldInstanceChecks :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          ad:AccessibilityLogic.AccessorDomain ->
            m:Range.range -> rfinfo:Infos.RecdFieldInfo -> unit
    val ILFieldStaticChecks :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          infoReader:InfoReader.InfoReader ->
            ad:AccessibilityLogic.AccessorDomain ->
              m:Range.range -> finfo:Infos.ILFieldInfo -> unit
    val ILFieldInstanceChecks :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          ad:AccessibilityLogic.AccessorDomain ->
            m:Range.range -> finfo:Infos.ILFieldInfo -> unit
    val MethInfoChecks :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          isInstance:bool ->
            tyargsOpt:'a option ->
              objArgs:TypedTree.Expr list ->
                ad:AccessibilityLogic.AccessorDomain ->
                  m:Range.range -> minfo:Infos.MethInfo -> unit
    exception FieldNotMutable of
                                TypedTreeOps.DisplayEnv * TypedTree.RecdFieldRef *
                                Range.range
    val CheckRecdFieldMutation :
      m:Range.range ->
        denv:TypedTreeOps.DisplayEnv -> rfinfo:Infos.RecdFieldInfo -> unit
    val GenWitnessExpr :
      amap:Import.ImportMap ->
        g:TcGlobals.TcGlobals ->
          m:Range.range ->
            traitInfo:TypedTree.TraitConstraintInfo ->
              argExprs:TypedTree.Expr list -> TypedTree.Expr option
    val GenWitnessExprLambda :
      amap:Import.ImportMap ->
        g:TcGlobals.TcGlobals ->
          m:Range.range ->
            traitInfo:TypedTree.TraitConstraintInfo ->
              Choice<TypedTree.TraitConstraintInfo,TypedTree.Expr>
    val GenWitnessArgs :
      amap:Import.ImportMap ->
        g:TcGlobals.TcGlobals ->
          m:Range.range ->
            traitInfos:TypedTree.TraitConstraintInfo list ->
              Choice<TypedTree.TraitConstraintInfo,TypedTree.Expr> list
  end

namespace FSharp.Compiler
  module internal PatternMatchCompilation = begin
    exception MatchIncomplete of bool * (string * bool) option * Range.range
    exception RuleNeverMatched of Range.range
    exception EnumMatchIncomplete of bool * (string * bool) option * Range.range
    type ActionOnFailure =
      | ThrowIncompleteMatchException
      | IgnoreWithWarning
      | Throw
      | Rethrow
      | FailFilter
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type Pattern =
      | TPat_const of TypedTree.Const * Range.range
      | TPat_wild of Range.range
      | TPat_as of Pattern * PatternValBinding * Range.range
      | TPat_disjs of Pattern list * Range.range
      | TPat_conjs of Pattern list * Range.range
      | TPat_query of
        (TypedTree.Expr * TypedTree.TType list *
         (TypedTree.ValRef * TypedTree.TypeInst) option * int *
         PrettyNaming.ActivePatternInfo) * Pattern * Range.range
      | TPat_unioncase of
        TypedTree.UnionCaseRef * TypedTree.TypeInst * Pattern list * Range.range
      | TPat_exnconstr of TypedTree.TyconRef * Pattern list * Range.range
      | TPat_tuple of
        TypedTree.TupInfo * Pattern list * TypedTree.TType list * Range.range
      | TPat_array of Pattern list * TypedTree.TType * Range.range
      | TPat_recd of
        TypedTree.TyconRef * TypedTree.TypeInst * Pattern list * Range.range
      | TPat_range of char * char * Range.range
      | TPat_null of Range.range
      | TPat_isinst of
        TypedTree.TType * TypedTree.TType * PatternValBinding option *
        Range.range
      | TPat_error of Range.range
      with
        member Range : Range.range
      end
    and PatternValBinding = | PBind of TypedTree.Val * TypedTreeOps.TypeScheme
    and TypedMatchClause =
      | TClause of
        Pattern * TypedTree.Expr option * TypedTree.DecisionTreeTarget *
        Range.range
      with
        member BoundVals : TypedTree.Val list
        member GuardExpr : TypedTree.Expr option
        member Pattern : Pattern
        member Range : Range.range
        member Target : TypedTree.DecisionTreeTarget
      end
    val debug : bool
    type SubExprOfInput =
      | SubExpr of
        (TypedTreeOps.TyparInst -> TypedTree.Expr -> TypedTree.Expr) *
        (TypedTree.Expr * TypedTree.Val)
    val BindSubExprOfInput :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          gtps:TypedTree.Typar list ->
            PatternValBinding ->
              m:Range.range -> SubExprOfInput -> TypedTree.Val * TypedTree.Expr
    val GetSubExprOfInput :
      g:TcGlobals.TcGlobals ->
        gtps:'a list * tyargs:TypedTree.TType list *
        tinst:TypedTreeOps.TyparInst -> SubExprOfInput -> TypedTree.Expr
    type Path =
      | PathQuery of Path * CompilerGlobalState.Unique
      | PathConj of Path * int
      | PathTuple of Path * TypedTree.TypeInst * int
      | PathRecd of Path * TypedTree.TyconRef * TypedTree.TypeInst * int
      | PathUnionConstr of
        Path * TypedTree.UnionCaseRef * TypedTree.TypeInst * int
      | PathArray of Path * TypedTree.TType * int * int
      | PathExnConstr of Path * TypedTree.TyconRef * int
      | PathEmpty of TypedTree.TType
    val pathEq : p1:Path -> p2:Path -> bool
    type RefutedSet =
      | RefutedInvestigation of Path * TypedTree.DecisionTreeTest list
      | RefutedWhenClause
    val notNullText : string
    val otherSubtypeText : string
    val ilFieldToTastConst : AbstractIL.IL.ILFieldInit -> TypedTree.Const
    exception CannotRefute
    val RefuteDiscrimSet :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          path:Path ->
            discrims:TypedTree.DecisionTreeTest list -> TypedTree.Expr * bool
    val CombineRefutations :
      g:TcGlobals.TcGlobals ->
        r1:TypedTree.Expr -> r2:TypedTree.Expr -> TypedTree.Expr
    val ShowCounterExample :
      g:TcGlobals.TcGlobals ->
        denv:TypedTreeOps.DisplayEnv ->
          m:Range.range ->
            refuted:RefutedSet list -> (string * bool * bool) option
    type RuleNumber = int
    type Active = | Active of Path * SubExprOfInput * Pattern
    type Actives = Active list
    type Frontier =
      | Frontier of RuleNumber * Actives * TypedTreeOps.ValMap<TypedTree.Expr>
    type InvestigationPoint =
      | Investigation of RuleNumber * TypedTree.DecisionTreeTest * Path
    val isMemOfActives : p1:Path -> actives:Active list -> bool
    val lookupActive : x:Path -> l:Active list -> SubExprOfInput * Pattern
    val removeActive : x:Path -> l:Active list -> Active list
    val getDiscrimOfPattern :
      g:TcGlobals.TcGlobals ->
        tpinst:TypedTreeOps.TyparInst ->
          t:Pattern -> TypedTree.DecisionTreeTest option
    val constOfDiscrim : discrim:TypedTree.DecisionTreeTest -> TypedTree.Const
    val constOfCase : c:TypedTree.DecisionTreeCase -> TypedTree.Const
    val discrimsEq :
      g:TcGlobals.TcGlobals ->
        d1:TypedTree.DecisionTreeTest -> d2:TypedTree.DecisionTreeTest -> bool
    val isDiscrimSubsumedBy :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            d1:TypedTree.DecisionTreeTest ->
              d2:TypedTree.DecisionTreeTest -> bool
    val chooseSimultaneousEdgeSet :
      prevOpt:'a option ->
        f:('a option -> 'b -> 'a option) -> l:'b list -> 'a list * 'b list
    val canCompactConstantClass : c:TypedTree.Const -> bool
    val discrimsHaveSameSimultaneousClass :
      g:TcGlobals.TcGlobals ->
        d1:TypedTree.DecisionTreeTest -> d2:TypedTree.DecisionTreeTest -> bool
    val canInvestigate : pat:Pattern -> bool
    val ChooseInvestigationPointLeftToRight : frontiers:Frontier list -> Active
    val ( |ConstNeedsDefaultCase|_| ) : c:TypedTree.Const -> unit option
    val BuildSwitch :
      inpExprOpt:'a option ->
        g:TcGlobals.TcGlobals ->
          expr:TypedTree.Expr ->
            edges:TypedTree.DecisionTreeCase list ->
              dflt:TypedTree.DecisionTree option ->
                m:Range.range -> TypedTree.DecisionTree
    val layoutPat : pat:Pattern -> Internal.Utilities.StructuredFormat.Layout
    val layoutPath : _p:'a -> Internal.Utilities.StructuredFormat.Layout
    val layoutActive : Active -> Internal.Utilities.StructuredFormat.Layout
    val layoutFrontier : Frontier -> Internal.Utilities.StructuredFormat.Layout
    val mkFrontiers :
      investigations:(Actives * TypedTreeOps.ValMap<TypedTree.Expr>) list ->
        i:RuleNumber -> Frontier list
    val getRuleIndex : Frontier -> RuleNumber
    val isPatternPartial : p:Pattern -> bool
    val erasePartialPatterns : inpp:Pattern -> Pattern
    val erasePartials : inps:Pattern list -> Pattern list
    type EdgeDiscrim =
      | EdgeDiscrim of int * TypedTree.DecisionTreeTest * Range.range
    val getDiscrim : EdgeDiscrim -> TypedTree.DecisionTreeTest
    val CompilePatternBasic :
      g:TcGlobals.TcGlobals ->
        denv:TypedTreeOps.DisplayEnv ->
          amap:Import.ImportMap ->
            tcVal:(TypedTree.ValRef -> TypedTree.ValUseFlag ->
                     TypedTree.TType list -> Range.range ->
                     TypedTree.Expr * TypedTree.TType) ->
              infoReader:InfoReader.InfoReader ->
                exprm:Range.range ->
                  matchm:Range.range ->
                    warnOnUnused:bool ->
                      warnOnIncomplete:bool ->
                        actionOnFailure:ActionOnFailure ->
                          origInputVal:TypedTree.Val *
                          origInputValTypars:TypedTree.Typar list *
                          _origInputExprOpt:TypedTree.Expr option ->
                            typedClauses:TypedMatchClause list ->
                              inputTy:TypedTree.TType ->
                                resultTy:TypedTree.TType ->
                                  TypedTree.DecisionTree *
                                  TypedTree.DecisionTreeTarget list
    val isPartialOrWhenClause : c:TypedMatchClause -> bool
    val CompilePattern :
      TcGlobals.TcGlobals ->
        TypedTreeOps.DisplayEnv ->
          Import.ImportMap ->
            (TypedTree.ValRef -> TypedTree.ValUseFlag -> TypedTree.TType list ->
               Range.range -> TypedTree.Expr * TypedTree.TType) ->
              InfoReader.InfoReader ->
                Range.range ->
                  Range.range ->
                    bool ->
                      ActionOnFailure ->
                        TypedTree.Val * TypedTree.Typar list *
                        TypedTree.Expr option ->
                          TypedMatchClause list ->
                            TypedTree.TType ->
                              TypedTree.TType ->
                                TypedTree.DecisionTree *
                                TypedTree.DecisionTreeTarget list
  end

namespace FSharp.Compiler
  module internal ConstraintSolver = begin
    val compgenId : SyntaxTree.Ident
    val NewCompGenTypar :
      kind:TypedTree.TyparKind * rigid:TypedTree.TyparRigidity *
      staticReq:SyntaxTree.TyparStaticReq * dynamicReq:TypedTree.TyparDynamicReq *
      error:bool -> TypedTree.Typar
    val AnonTyparId : m:Range.range -> SyntaxTree.Ident
    val NewAnonTypar :
      TypedTree.TyparKind * Range.range * TypedTree.TyparRigidity *
      SyntaxTree.TyparStaticReq * TypedTree.TyparDynamicReq -> TypedTree.Typar
    val NewNamedInferenceMeasureVar :
      _m:'a * rigid:TypedTree.TyparRigidity * var:SyntaxTree.TyparStaticReq *
      id:SyntaxTree.Ident -> TypedTree.Typar
    val NewInferenceMeasurePar : unit -> TypedTree.Typar
    val NewErrorTypar : unit -> TypedTree.Typar
    val NewErrorMeasureVar : unit -> TypedTree.Typar
    val NewInferenceType : unit -> TypedTree.TType
    val NewErrorType : unit -> TypedTree.TType
    val NewErrorMeasure : unit -> TypedTree.Measure
    val NewByRefKindInferenceType :
      TcGlobals.TcGlobals -> Range.range -> TypedTree.TType
    val NewInferenceTypes : 'a list -> TypedTree.TType list
    val FreshenAndFixupTypars :
      Range.range ->
        TypedTree.TyparRigidity ->
          TypedTree.Typars ->
            TypedTree.TType list ->
              TypedTree.Typar list ->
                TypedTree.Typar list * TypedTreeOps.TyparInst * TypedTree.TTypes
    val FreshenTypeInst :
      Range.range ->
        TypedTree.Typar list ->
          TypedTree.Typar list * TypedTreeOps.TyparInst * TypedTree.TTypes
    val FreshMethInst :
      m:Range.range ->
        fctps:TypedTree.Typars ->
          tinst:TypedTree.TType list ->
            tpsorig:TypedTree.Typar list ->
              TypedTree.Typar list * TypedTreeOps.TyparInst * TypedTree.TTypes
    val FreshenTypars :
      Range.range -> TypedTree.Typar list -> TypedTree.TType list
    val FreshenMethInfo : Range.range -> Infos.MethInfo -> TypedTree.TTypes
    [<RequireQualifiedAccessAttribute ()>]
    type ContextInfo =
      | NoContext
      | IfExpression of Range.range
      | OmittedElseBranch of Range.range
      | ElseBranchResult of Range.range
      | RecordFields
      | TupleInRecordFields
      | CollectionElement of bool * Range.range
      | ReturnInComputationExpression
      | YieldInComputationExpression
      | RuntimeTypeTest of bool
      | DowncastUsedInsteadOfUpcast of bool
      | FollowingPatternMatchClause of Range.range
      | PatternMatchGuard of Range.range
      | SequenceExpression of TypedTree.TType
    type OverloadInformation =
      { methodSlot: MethodCalls.CalledMeth<TypedTree.Expr>
        amap: Import.ImportMap
        error: exn }
    type OverloadResolutionFailure =
      | NoOverloadsFound of
        methodName: string * candidates: OverloadInformation list *
        cx: TypedTree.TraitConstraintInfo option
      | PossibleCandidates of
        methodName: string * candidates: OverloadInformation list *
        cx: TypedTree.TraitConstraintInfo option
    exception ConstraintSolverTupleDiffLengths of
                                                 displayEnv:
                                                   TypedTreeOps.DisplayEnv *
                                                 TypedTree.TType list *
                                                 TypedTree.TType list *
                                                 Range.range * Range.range
    exception ConstraintSolverInfiniteTypes of
                                              displayEnv:
                                                TypedTreeOps.DisplayEnv *
                                              contextInfo: ContextInfo *
                                              TypedTree.TType * TypedTree.TType *
                                              Range.range * Range.range
    exception ConstraintSolverTypesNotInEqualityRelation of
                                                           displayEnv:
                                                             TypedTreeOps.DisplayEnv *
                                                           TypedTree.TType *
                                                           TypedTree.TType *
                                                           Range.range *
                                                           Range.range *
                                                           ContextInfo
    exception ConstraintSolverTypesNotInSubsumptionRelation of
                                                              displayEnv:
                                                                TypedTreeOps.DisplayEnv *
                                                              argTy:
                                                                TypedTree.TType *
                                                              paramTy:
                                                                TypedTree.TType *
                                                              callRange:
                                                                Range.range *
                                                              parameterRange:
                                                                Range.range
    exception ConstraintSolverMissingConstraint of
                                                  displayEnv:
                                                    TypedTreeOps.DisplayEnv *
                                                  TypedTree.Typar *
                                                  TypedTree.TyparConstraint *
                                                  Range.range * Range.range
    exception ConstraintSolverError of string * Range.range * Range.range
    exception ConstraintSolverRelatedInformation of
                                                   string option * Range.range *
                                                   exn
    exception ErrorFromApplyingDefault of
                                         tcGlobals: TcGlobals.TcGlobals *
                                         displayEnv: TypedTreeOps.DisplayEnv *
                                         TypedTree.Typar * TypedTree.TType * exn *
                                         Range.range
    exception ErrorFromAddingTypeEquation of
                                            tcGlobals: TcGlobals.TcGlobals *
                                            displayEnv: TypedTreeOps.DisplayEnv *
                                            actualTy: TypedTree.TType *
                                            expectedTy: TypedTree.TType * exn *
                                            Range.range
    exception ErrorsFromAddingSubsumptionConstraint of
                                                      tcGlobals:
                                                        TcGlobals.TcGlobals *
                                                      displayEnv:
                                                        TypedTreeOps.DisplayEnv *
                                                      actualTy: TypedTree.TType *
                                                      expectedTy:
                                                        TypedTree.TType * exn *
                                                      ContextInfo *
                                                      parameterRange:
                                                        Range.range
    exception ErrorFromAddingConstraint of
                                          displayEnv: TypedTreeOps.DisplayEnv *
                                          exn * Range.range
    exception UnresolvedOverloading of
                                      displayEnv: TypedTreeOps.DisplayEnv *
                                      callerArgs:
                                        MethodCalls.CallerArgs<TypedTree.Expr> *
                                      failure: OverloadResolutionFailure *
                                      Range.range
    exception UnresolvedConversionOperator of
                                             displayEnv: TypedTreeOps.DisplayEnv *
                                             TypedTree.TType * TypedTree.TType *
                                             Range.range
    type TcValF =
      TypedTree.ValRef -> TypedTree.ValUseFlag -> TypedTree.TType list ->
        Range.range -> TypedTree.Expr * TypedTree.TType
    [<SealedAttribute ()>]
    type ConstraintSolverState =
      { g: TcGlobals.TcGlobals
        amap: Import.ImportMap
        InfoReader: InfoReader.InfoReader
        TcVal: TcValF
        mutable ExtraCxs:
          Internal.Utilities.Collections.HashMultiMap<TypedTree.Stamp,
                                                      (TypedTree.TraitConstraintInfo *
                                                       Range.range)> }
      with
        static member
          New : TcGlobals.TcGlobals * Import.ImportMap * InfoReader.InfoReader *
                TcValF -> ConstraintSolverState
      end
    type ConstraintSolverEnv =
      { SolverState: ConstraintSolverState
        eContextInfo: ContextInfo
        MatchingOnly: bool
        m: Range.range
        EquivEnv: TypedTreeOps.TypeEquivEnv
        DisplayEnv: TypedTreeOps.DisplayEnv }
      with
        override ToString : unit -> string
        member InfoReader : InfoReader.InfoReader
        member amap : Import.ImportMap
        member g : TcGlobals.TcGlobals
      end
    val MakeConstraintSolverEnv :
      contextInfo:ContextInfo ->
        css:ConstraintSolverState ->
          m:Range.range -> denv:TypedTreeOps.DisplayEnv -> ConstraintSolverEnv
    val occursCheck :
      g:TcGlobals.TcGlobals -> un:TypedTree.Typar -> ty:TypedTree.TType -> bool
    type PermitWeakResolution =
      | Yes
      | No
      with
        member Permit : bool
      end
    val isNativeIntegerTy : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val isSignedIntegerTy : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val isUnsignedIntegerTy :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val IsIntegerOrIntegerEnumTy :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val isIntegerTy : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val isStringTy : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val isCharTy : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val isBoolTy : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val isFpTy : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val isDecimalTy : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val IsNonDecimalNumericOrIntegralEnumType :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val IsNumericOrIntegralEnumType :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val IsNonDecimalNumericType :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val IsNumericType : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val IsRelationalType : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val IsCharOrStringType : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val IsAddSubModType :
      nm:string -> g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val IsBitwiseOpType : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val IsBinaryOpOtherArgType :
      g:TcGlobals.TcGlobals ->
        permitWeakResolution:PermitWeakResolution -> ty:TypedTree.TType -> bool
    val IsSignType : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    type TraitConstraintSolution =
      | TTraitUnsolved
      | TTraitBuiltIn
      | TTraitSolved of Infos.MethInfo * TypedTree.TypeInst
      | TTraitSolvedRecdProp of Infos.RecdFieldInfo * bool
      | TTraitSolvedAnonRecdProp of
        TypedTree.AnonRecdTypeInfo * TypedTree.TypeInst * int
    val BakedInTraitConstraintNames : Set<string>
    [<SealedAttribute (); NoEqualityAttribute (); NoComparisonAttribute ()>]
    type Trace =
      { mutable actions: ((unit -> unit) * (unit -> unit)) list }
      with
        static member New : unit -> Trace
        member Push : f:(unit -> unit) -> undo:(unit -> unit) -> unit
        member Undo : unit -> unit
      end
    type OptionalTrace =
      | NoTrace
      | WithTrace of Trace
      with
        member AddFromReplay : source:Trace -> unit
        member
          CollectThenUndoOrCommit : predicate:('a -> bool) ->
                                      f:(Trace -> 'a) -> 'a
        member Exec : f:(unit -> unit) -> undo:(unit -> unit) -> unit
        member HasTrace : bool
      end
    val CollectThenUndo : f:(Trace -> 'a) -> 'a
    val FilterEachThenUndo :
      f:(Trace -> 'a -> ErrorLogger.OperationResult<'b>) ->
        meths:'a list -> ('a * exn list * Trace) list
    val ShowAccessDomain : ad:AccessibilityLogic.AccessorDomain -> string
    exception NonRigidTypar of
                              displayEnv: TypedTreeOps.DisplayEnv *
                              string option * Range.range * TypedTree.TType *
                              TypedTree.TType * Range.range
    exception AbortForFailedOverloadResolution
    val inline TryD_IgnoreAbortForFailedOverloadResolution :
      f1:(unit -> ErrorLogger.OperationResult<unit>) ->
        f2:(exn -> ErrorLogger.OperationResult<unit>) ->
          ErrorLogger.OperationResult<unit>
    exception ArgDoesNotMatchError of
                                     error:
                                       ErrorsFromAddingSubsumptionConstraint *
                                     calledMeth:
                                       MethodCalls.CalledMeth<TypedTree.Expr> *
                                     calledArg: MethodCalls.CalledArg *
                                     callerArg:
                                       MethodCalls.CallerArg<TypedTree.Expr>
    exception LocallyAbortOperationThatLosesAbbrevs
    val localAbortD : ErrorLogger.OperationResult<unit>
    val PreferUnifyTypar : v1:TypedTree.Typar -> v2:TypedTree.Typar -> bool
    val FindPreferredTypar :
      vs:(TypedTree.Typar * 'a) list -> (TypedTree.Typar * 'a) list
    val SubstMeasure : r:TypedTree.Typar -> ms:TypedTree.Measure -> unit
    val TransactStaticReq :
      csenv:ConstraintSolverEnv ->
        trace:OptionalTrace ->
          tpr:TypedTree.Typar ->
            req:SyntaxTree.TyparStaticReq -> ErrorLogger.OperationResult<unit>
    val SolveTypStaticReqTypar :
      csenv:ConstraintSolverEnv ->
        trace:OptionalTrace ->
          req:SyntaxTree.TyparStaticReq ->
            tpr:TypedTree.Typar -> ErrorLogger.OperationResult<unit>
    val SolveTypStaticReq :
      csenv:ConstraintSolverEnv ->
        trace:OptionalTrace ->
          req:SyntaxTree.TyparStaticReq ->
            ty:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val TransactDynamicReq :
      trace:OptionalTrace ->
        tpr:TypedTree.Typar ->
          req:TypedTree.TyparDynamicReq -> ErrorLogger.OperationResult<unit>
    val SolveTypDynamicReq :
      csenv:ConstraintSolverEnv ->
        trace:OptionalTrace ->
          req:TypedTree.TyparDynamicReq ->
            ty:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val TransactIsCompatFlex :
      trace:OptionalTrace ->
        tpr:TypedTree.Typar -> req:bool -> ErrorLogger.OperationResult<unit>
    val SolveTypIsCompatFlex :
      csenv:ConstraintSolverEnv ->
        trace:OptionalTrace ->
          req:bool -> ty:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SubstMeasureWarnIfRigid :
      csenv:ConstraintSolverEnv ->
        trace:OptionalTrace ->
          v:TypedTree.Typar ->
            ms:TypedTree.Measure -> ErrorLogger.OperationResult<unit>
    val UnifyMeasureWithOne :
      csenv:ConstraintSolverEnv ->
        trace:OptionalTrace ->
          ms:TypedTree.Measure -> ErrorLogger.OperationResult<unit>
    val UnifyMeasures :
      csenv:ConstraintSolverEnv ->
        trace:OptionalTrace ->
          ms1:TypedTree.Measure ->
            ms2:TypedTree.Measure -> ErrorLogger.OperationResult<unit>
    val SimplifyMeasure :
      g:TcGlobals.TcGlobals ->
        vars:TypedTree.Typar list ->
          ms:TypedTree.Measure -> TypedTree.Typar list * TypedTree.Typar option
    val SimplifyMeasuresInType :
      g:TcGlobals.TcGlobals ->
        resultFirst:bool ->
          TypedTree.Typar list * TypedTree.Typar list ->
            ty:TypedTree.TType -> TypedTree.Typar list * TypedTree.Typar list
    val SimplifyMeasuresInTypes :
      g:TcGlobals.TcGlobals ->
        TypedTree.Typar list * TypedTree.Typar list ->
          tys:TypedTree.TypeInst -> TypedTree.Typar list * TypedTree.Typar list
    val SimplifyMeasuresInConstraint :
      g:TcGlobals.TcGlobals ->
        TypedTree.Typar list * TypedTree.Typar list ->
          c:TypedTree.TyparConstraint ->
            TypedTree.Typar list * TypedTree.Typar list
    val SimplifyMeasuresInConstraints :
      g:TcGlobals.TcGlobals ->
        TypedTree.Typar list * TypedTree.Typar list ->
          cs:TypedTree.TyparConstraint list ->
            TypedTree.Typar list * TypedTree.Typar list
    val GetMeasureVarGcdInType :
      v:TypedTree.Typar -> ty:TypedTree.TType -> Rational.Rational
    val GetMeasureVarGcdInTypes :
      v:TypedTree.Typar -> tys:TypedTree.TypeInst -> Rational.Rational
    val NormalizeExponentsInTypeScheme :
      uvars:TypedTree.Typar list -> ty:TypedTree.TType -> TypedTree.Typar list
    val SimplifyMeasuresInTypeScheme :
      TcGlobals.TcGlobals ->
        bool ->
          TypedTree.Typar list ->
            TypedTree.TType ->
              TypedTree.TyparConstraint list -> TypedTree.Typar list
    val freshMeasure : unit -> TypedTree.Measure
    val CheckWarnIfRigid :
      csenv:ConstraintSolverEnv ->
        ty1:TypedTree.TType ->
          r:TypedTree.Typar ->
            ty:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveTyparEqualsTypePart1 :
      csenv:ConstraintSolverEnv ->
        m2:Range.range ->
          trace:OptionalTrace ->
            ty1:TypedTree.TType ->
              r:TypedTree.Typar ->
                ty:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveTyparEqualsTypePart2 :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              r:TypedTree.Typar ->
                ty:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val solveTypMeetsTyparConstraints :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              ty:TypedTree.TType ->
                r:TypedTree.Typar -> ErrorLogger.OperationResult<unit>
    val SolveTyparEqualsType :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              ty1:TypedTree.TType ->
                ty:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveTyparsEqualTypes :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              tptys:TypedTree.TType list ->
                tys:TypedTree.TType list -> ErrorLogger.OperationResult<unit>
    val SolveAnonInfoEqualsAnonInfo :
      csenv:ConstraintSolverEnv ->
        m2:Range.range ->
          anonInfo1:TypedTree.AnonRecdTypeInfo ->
            anonInfo2:TypedTree.AnonRecdTypeInfo ->
              ErrorLogger.OperationResult<unit>
    val SolveTypeEqualsType :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              cxsln:(TypedTree.TraitConstraintInfo *
                     TypedTree.TraitConstraintSln) option ->
                ty1:TypedTree.TType ->
                  ty2:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveTypeEqualsTypeKeepAbbrevs :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              ty1:TypedTree.TType ->
                ty2:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val private SolveTypeEqualsTypeKeepAbbrevsWithCxsln :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              cxsln:(TypedTree.TraitConstraintInfo *
                     TypedTree.TraitConstraintSln) option ->
                ty1:TypedTree.TType ->
                  ty2:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveTypeEqualsTypeEqns :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              cxsln:(TypedTree.TraitConstraintInfo *
                     TypedTree.TraitConstraintSln) option ->
                origl1:TypedTree.TypeInst ->
                  origl2:TypedTree.TypeInst -> ErrorLogger.OperationResult<unit>
    val SolveFunTypeEqn :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              cxsln:(TypedTree.TraitConstraintInfo *
                     TypedTree.TraitConstraintSln) option ->
                d1:TypedTree.TType ->
                  d2:TypedTree.TType ->
                    r1:TypedTree.TType ->
                      r2:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveTypeSubsumesType :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              cxsln:(TypedTree.TraitConstraintInfo *
                     TypedTree.TraitConstraintSln) option ->
                ty1:TypedTree.TType ->
                  ty2:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveTypeSubsumesTypeKeepAbbrevs :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              cxsln:(TypedTree.TraitConstraintInfo *
                     TypedTree.TraitConstraintSln) option ->
                ty1:TypedTree.TType ->
                  ty2:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveTyparSubtypeOfType :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              tp:TypedTree.Typar ->
                ty1:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val DepthCheck :
      ndeep:int -> m:Range.range -> ErrorLogger.OperationResult<unit>
    val SolveDimensionlessNumericType :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              ty:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveMemberConstraint :
      csenv:ConstraintSolverEnv ->
        ignoreUnresolvedOverload:bool ->
          permitWeakResolution:PermitWeakResolution ->
            ndeep:int ->
              m2:Range.range ->
                trace:OptionalTrace ->
                  traitInfo:TypedTree.TraitConstraintInfo ->
                    ErrorLogger.OperationResult<bool>
    val RecordMemberConstraintSolution :
      css:ConstraintSolverState ->
        m:Range.range ->
          trace:OptionalTrace ->
            traitInfo:TypedTree.TraitConstraintInfo ->
              res:TraitConstraintSolution -> ErrorLogger.OperationResult<bool>
    val MemberConstraintSolutionOfMethInfo :
      css:ConstraintSolverState ->
        m:Range.range ->
          minfo:Infos.MethInfo ->
            minst:TypedTree.TypeInst -> TypedTree.TraitConstraintSln
    val TransactMemberConstraintSolution :
      traitInfo:TypedTree.TraitConstraintInfo ->
        trace:OptionalTrace -> sln:TypedTree.TraitConstraintSln -> unit
    val GetRelevantMethodsForTrait :
      csenv:ConstraintSolverEnv ->
        permitWeakResolution:PermitWeakResolution ->
          nm:string -> TypedTree.TraitConstraintInfo -> Infos.MethInfo list
    val GetSupportOfMemberConstraint :
      csenv:ConstraintSolverEnv ->
        TypedTree.TraitConstraintInfo -> TypedTree.Typar list
    val SupportOfMemberConstraintIsFullySolved :
      csenv:ConstraintSolverEnv -> TypedTree.TraitConstraintInfo -> bool
    val GetFreeTyparsOfMemberConstraint :
      csenv:ConstraintSolverEnv ->
        TypedTree.TraitConstraintInfo -> TypedTree.Typar list
    val MemberConstraintIsReadyForWeakResolution :
      csenv:ConstraintSolverEnv ->
        traitInfo:TypedTree.TraitConstraintInfo -> bool
    val MemberConstraintIsReadyForStrongResolution :
      csenv:ConstraintSolverEnv ->
        traitInfo:TypedTree.TraitConstraintInfo -> bool
    val MemberConstraintSupportIsReadyForDeterminingOverloads :
      csenv:ConstraintSolverEnv ->
        traitInfo:TypedTree.TraitConstraintInfo -> bool
    val SolveRelevantMemberConstraints :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          permitWeakResolution:PermitWeakResolution ->
            trace:OptionalTrace ->
              tps:TypedTree.Typar list -> ErrorLogger.OperationResult<unit>
    val SolveRelevantMemberConstraintsForTypar :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          permitWeakResolution:PermitWeakResolution ->
            trace:OptionalTrace ->
              tp:TypedTree.Typar -> ErrorLogger.OperationResult<bool>
    val CanonicalizeRelevantMemberConstraints :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          trace:OptionalTrace ->
            tps:TypedTree.Typar list -> ErrorLogger.OperationResult<unit>
    val AddMemberConstraint :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              traitInfo:TypedTree.TraitConstraintInfo ->
                support:TypedTree.Typar list ->
                  frees:TypedTree.Typar list ->
                    ErrorLogger.OperationResult<unit>
    val AddConstraint :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              tp:TypedTree.Typar ->
                newConstraint:TypedTree.TyparConstraint ->
                  ErrorLogger.OperationResult<unit>
    val SolveTypeSupportsNull :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              ty:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveTypeSupportsComparison :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              ty:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveTypeSupportsEquality :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              ty:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveTypeIsEnum :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              ty:TypedTree.TType ->
                underlying:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveTypeIsDelegate :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              ty:TypedTree.TType ->
                aty:TypedTree.TType ->
                  bty:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveTypeIsNonNullableValueType :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              ty:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveTypeIsUnmanaged :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              ty:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveTypeChoice :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              ty:TypedTree.TType ->
                tys:TypedTree.TTypes -> ErrorLogger.OperationResult<unit>
    val SolveTypeIsReferenceType :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              ty:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveTypeRequiresDefaultConstructor :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              origTy:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val SolveTypeRequiresDefaultValue :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m2:Range.range ->
            trace:OptionalTrace ->
              origTy:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val CanMemberSigsMatchUpToCheck :
      csenv:ConstraintSolverEnv ->
        permitOptArgs:bool ->
          alwaysCheckReturn:bool ->
            unifyTypes:(TypedTree.TType -> TypedTree.TType ->
                          ErrorLogger.OperationResult<unit>) ->
              subsumeTypes:(TypedTree.TType -> TypedTree.TType ->
                              ErrorLogger.OperationResult<unit>) ->
                subsumeArg:(MethodCalls.CalledArg ->
                              MethodCalls.CallerArg<'a> ->
                              ErrorLogger.OperationResult<unit>) ->
                  reqdRetTyOpt:TypedTree.TType option ->
                    calledMeth:MethodCalls.CalledMeth<'a> ->
                      ErrorLogger.ImperativeOperationResult
    val private SolveTypeSubsumesTypeWithWrappedContextualReport :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m:Range.range ->
            trace:OptionalTrace ->
              cxsln:(TypedTree.TraitConstraintInfo *
                     TypedTree.TraitConstraintSln) option ->
                ty1:TypedTree.TType ->
                  ty2:TypedTree.TType ->
                    wrapper:(exn -> #exn) -> ErrorLogger.OperationResult<unit>
    val private SolveTypeSubsumesTypeWithReport :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m:Range.range ->
            trace:OptionalTrace ->
              cxsln:(TypedTree.TraitConstraintInfo *
                     TypedTree.TraitConstraintSln) option ->
                ty1:TypedTree.TType ->
                  ty2:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val private SolveTypeEqualsTypeWithReport :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          m:Range.range ->
            trace:OptionalTrace ->
              cxsln:(TypedTree.TraitConstraintInfo *
                     TypedTree.TraitConstraintSln) option ->
                actual:TypedTree.TType ->
                  expected:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val ArgsMustSubsumeOrConvert :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          trace:OptionalTrace ->
            cxsln:(TypedTree.TraitConstraintInfo * TypedTree.TraitConstraintSln) option ->
              isConstraint:bool ->
                enforceNullableOptionalsKnownTypes:bool ->
                  calledArg:MethodCalls.CalledArg ->
                    callerArg:MethodCalls.CallerArg<'T> ->
                      ErrorLogger.OperationResult<unit>
    val MustUnify :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          trace:OptionalTrace ->
            cxsln:(TypedTree.TraitConstraintInfo * TypedTree.TraitConstraintSln) option ->
              ty1:TypedTree.TType ->
                ty2:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val MustUnifyInsideUndo :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          trace:Trace ->
            cxsln:(TypedTree.TraitConstraintInfo * TypedTree.TraitConstraintSln) option ->
              ty1:TypedTree.TType ->
                ty2:TypedTree.TType -> ErrorLogger.OperationResult<unit>
    val ArgsMustSubsumeOrConvertInsideUndo :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          trace:Trace ->
            cxsln:(TypedTree.TraitConstraintInfo * TypedTree.TraitConstraintSln) option ->
              isConstraint:bool ->
                calledMeth:MethodCalls.CalledMeth<TypedTree.Expr> ->
                  calledArg:MethodCalls.CalledArg ->
                    MethodCalls.CallerArg<TypedTree.Expr> ->
                      ErrorLogger.OperationResult<unit>
    val TypesMustSubsumeOrConvertInsideUndo :
      csenv:ConstraintSolverEnv ->
        ndeep:int ->
          trace:OptionalTrace ->
            cxsln:(TypedTree.TraitConstraintInfo * TypedTree.TraitConstraintSln) option ->
              m:Range.range ->
                calledArgTy:TypedTree.TType ->
                  callerArgTy:TypedTree.TType ->
                    ErrorLogger.OperationResult<unit>
    val ArgsEquivInsideUndo :
      csenv:ConstraintSolverEnv ->
        isConstraint:bool ->
          calledArg:MethodCalls.CalledArg ->
            MethodCalls.CallerArg<'c> -> ErrorLogger.OperationResult<unit>
    val ReportNoCandidatesError :
      csenv:ConstraintSolverEnv ->
        nUnnamedCallerArgs:System.Int32 * nNamedCallerArgs:int ->
          methodName:System.String ->
            ad:AccessibilityLogic.AccessorDomain ->
              calledMethGroup:MethodCalls.CalledMeth<'d> list ->
                isSequential:('d -> bool) -> ErrorLogger.OperationResult<'e>
    val ReportNoCandidatesErrorExpr :
      csenv:ConstraintSolverEnv ->
        System.Int32 * int ->
          methodName:System.String ->
            ad:AccessibilityLogic.AccessorDomain ->
              calledMethGroup:MethodCalls.CalledMeth<TypedTree.Expr> list ->
                ErrorLogger.OperationResult<'f>
    val ReportNoCandidatesErrorSynExpr :
      csenv:ConstraintSolverEnv ->
        System.Int32 * int ->
          methodName:System.String ->
            ad:AccessibilityLogic.AccessorDomain ->
              calledMethGroup:MethodCalls.CalledMeth<SyntaxTree.SynExpr> list ->
                ErrorLogger.OperationResult<'g>
    val ResolveOverloading :
      csenv:ConstraintSolverEnv ->
        trace:OptionalTrace ->
          methodName:string ->
            ndeep:int ->
              cx:TypedTree.TraitConstraintInfo option ->
                callerArgs:MethodCalls.CallerArgs<TypedTree.Expr> ->
                  ad:AccessibilityLogic.AccessorDomain ->
                    calledMethGroup:MethodCalls.CalledMeth<TypedTree.Expr> list ->
                      permitOptArgs:bool ->
                        reqdRetTyOpt:TypedTree.TType option ->
                          MethodCalls.CalledMeth<TypedTree.Expr> option *
                          ErrorLogger.OperationResult<unit>
    val ResolveOverloadingForCall :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range ->
            methodName:string ->
              ndeep:int ->
                cx:TypedTree.TraitConstraintInfo option ->
                  callerArgs:MethodCalls.CallerArgs<TypedTree.Expr> ->
                    AccessibilityLogic.AccessorDomain ->
                      calledMethGroup:MethodCalls.CalledMeth<TypedTree.Expr> list ->
                        permitOptArgs:bool ->
                          reqdRetTyOpt:TypedTree.TType option ->
                            MethodCalls.CalledMeth<TypedTree.Expr> option *
                            ErrorLogger.OperationResult<unit>
    val UnifyUniqueOverloading :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range ->
            System.Int32 * int ->
              System.String ->
                AccessibilityLogic.AccessorDomain ->
                  MethodCalls.CalledMeth<SyntaxTree.SynExpr> list ->
                    TypedTree.TType -> ErrorLogger.OperationResult<bool>
    val EliminateConstraintsForGeneralizedTypars :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range -> OptionalTrace -> TypedTree.Typars -> unit
    val AddCxTypeEqualsType :
      ContextInfo ->
        TypedTreeOps.DisplayEnv ->
          ConstraintSolverState ->
            Range.range -> TypedTree.TType -> TypedTree.TType -> unit
    val UndoIfFailed : f:(Trace -> ErrorLogger.OperationResult<'a>) -> bool
    val UndoIfFailedOrWarnings :
      f:(Trace -> ErrorLogger.OperationResult<'a>) -> bool
    val AddCxTypeEqualsTypeUndoIfFailed :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range -> TypedTree.TType -> TypedTree.TType -> bool
    val AddCxTypeEqualsTypeUndoIfFailedOrWarnings :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range -> TypedTree.TType -> TypedTree.TType -> bool
    val AddCxTypeEqualsTypeMatchingOnlyUndoIfFailed :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range -> TypedTree.TType -> TypedTree.TType -> bool
    val AddCxTypeMustSubsumeTypeUndoIfFailed :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range -> TypedTree.TType -> TypedTree.TType -> bool
    val AddCxTypeMustSubsumeTypeMatchingOnlyUndoIfFailed :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range -> TypedTree.TType -> TypedTree.TType -> bool
    val AddCxTypeMustSubsumeType :
      ContextInfo ->
        TypedTreeOps.DisplayEnv ->
          ConstraintSolverState ->
            Range.range ->
              OptionalTrace -> TypedTree.TType -> TypedTree.TType -> unit
    val AddCxMethodConstraint :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range -> OptionalTrace -> TypedTree.TraitConstraintInfo -> unit
    val AddCxTypeMustSupportNull :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range -> OptionalTrace -> TypedTree.TType -> unit
    val AddCxTypeMustSupportComparison :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range -> OptionalTrace -> TypedTree.TType -> unit
    val AddCxTypeMustSupportEquality :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range -> OptionalTrace -> TypedTree.TType -> unit
    val AddCxTypeMustSupportDefaultCtor :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range -> OptionalTrace -> TypedTree.TType -> unit
    val AddCxTypeIsReferenceType :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range -> OptionalTrace -> TypedTree.TType -> unit
    val AddCxTypeIsValueType :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range -> OptionalTrace -> TypedTree.TType -> unit
    val AddCxTypeIsUnmanaged :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range -> OptionalTrace -> TypedTree.TType -> unit
    val AddCxTypeIsEnum :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range ->
            OptionalTrace -> TypedTree.TType -> TypedTree.TType -> unit
    val AddCxTypeIsDelegate :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range ->
            OptionalTrace ->
              TypedTree.TType -> TypedTree.TType -> TypedTree.TType -> unit
    val AddCxTyparDefaultsTo :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range ->
            ContextInfo -> TypedTree.Typar -> int -> TypedTree.TType -> unit
    val SolveTypeAsError :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState -> Range.range -> TypedTree.TType -> unit
    val ApplyTyparDefaultAtPriority :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState -> priority:int -> TypedTree.Typar -> unit
    val CreateCodegenState :
      tcVal:TcValF ->
        g:TcGlobals.TcGlobals -> amap:Import.ImportMap -> ConstraintSolverState
    val CodegenWitnessExprForTraitConstraint :
      TcValF ->
        TcGlobals.TcGlobals ->
          Import.ImportMap ->
            Range.range ->
              TypedTree.TraitConstraintInfo ->
                TypedTree.Expr list ->
                  ErrorLogger.OperationResult<TypedTree.Expr option>
    val CodegenWitnessesForTyparInst :
      TcValF ->
        TcGlobals.TcGlobals ->
          Import.ImportMap ->
            Range.range ->
              TypedTree.Typar list ->
                TypedTree.TType list ->
                  ErrorLogger.OperationResult<Choice<TypedTree.TraitConstraintInfo,
                                                     TypedTree.Expr> list>
    val CodegenWitnessArgForTraitConstraint :
      TcValF ->
        TcGlobals.TcGlobals ->
          Import.ImportMap ->
            Range.range ->
              TypedTree.TraitConstraintInfo ->
                ErrorLogger.OperationResult<Choice<TypedTree.TraitConstraintInfo,
                                                   TypedTree.Expr>>
    val ChooseTyparSolutionAndSolve :
      ConstraintSolverState ->
        TypedTreeOps.DisplayEnv -> TypedTree.Typar -> unit
    val CheckDeclaredTypars :
      TypedTreeOps.DisplayEnv ->
        ConstraintSolverState ->
          Range.range -> TypedTree.Typar list -> TypedTree.Typar list -> unit
    val CanonicalizePartialInferenceProblem :
      ConstraintSolverState ->
        TypedTreeOps.DisplayEnv -> Range.range -> TypedTree.Typar list -> unit
    val IsApplicableMethApprox :
      TcGlobals.TcGlobals ->
        Import.ImportMap ->
          Range.range -> Infos.MethInfo -> TypedTree.TType -> bool
  end

namespace FSharp.Compiler
  module internal CheckFormatStrings = begin
    type FormatItem =
      | Simple of TypedTree.TType
      | FuncAndVal
    val copyAndFixupFormatTypar :
      m:Range.range -> tp:TypedTree.Typar -> TypedTree.TType
    val lowestDefaultPriority : int
    val mkFlexibleFormatTypar :
      m:Range.range ->
        tys:TypedTree.TTypes -> dflt:TypedTree.TType -> TypedTree.TType
    val mkFlexibleIntFormatTypar :
      g:TcGlobals.TcGlobals -> m:Range.range -> TypedTree.TType
    val mkFlexibleDecimalFormatTypar :
      g:TcGlobals.TcGlobals -> m:Range.range -> TypedTree.TType
    val mkFlexibleFloatFormatTypar :
      g:TcGlobals.TcGlobals -> m:Range.range -> TypedTree.TType
    type FormatInfoRegister =
      { mutable leftJustify: bool
        mutable numPrefixIfPos: char option
        mutable addZeros: bool
        mutable precision: bool }
    val newInfo : unit -> FormatInfoRegister
    val parseFormatStringInternal :
      m:Range.range ->
        fragRanges:Range.range list ->
          g:TcGlobals.TcGlobals ->
            isInterpolated:bool ->
              isFormattableString:bool ->
                context:NameResolution.FormatStringCheckContext option ->
                  fmt:string ->
                    printerArgTy:TypedTree.TType ->
                      printerResidueTy:TypedTree.TType ->
                        TypedTree.TType list * (Range.range * int) list * string *
                        TypedTree.TType []
    val ParseFormatString :
      m:Range.range ->
        fragmentRanges:Range.range list ->
          g:TcGlobals.TcGlobals ->
            isInterpolated:bool ->
              isFormattableString:bool ->
                formatStringCheckContext:NameResolution.FormatStringCheckContext option ->
                  fmt:string ->
                    printerArgTy:TypedTree.TType ->
                      printerResidueTy:TypedTree.TType ->
                        printerResultTy:TypedTree.TType ->
                          TypedTree.TType list * TypedTree.TType *
                          TypedTree.TType * TypedTree.TType [] *
                          (Range.range * int) list * string
    val TryCountFormatStringArguments :
      m:Range.range ->
        g:TcGlobals.TcGlobals ->
          isInterpolated:bool ->
            fmt:string ->
              printerArgTy:TypedTree.TType ->
                printerResidueTy:TypedTree.TType -> int option
  end

namespace FSharp.Compiler
  module internal FindUnsolved = begin
    type env = | Nix
    type cenv =
      { g: TcGlobals.TcGlobals
        amap: Import.ImportMap
        denv: TypedTreeOps.DisplayEnv
        mutable unsolved: TypedTree.Typars }
      with
        override ToString : unit -> string
      end
    val accTy : cenv:cenv -> _env:'a -> ty:TypedTree.TType -> unit
    val accTypeInst : cenv:cenv -> env:'a -> tyargs:TypedTree.TType list -> unit
    val accExpr : cenv:cenv -> env:env -> expr:TypedTree.Expr -> unit
    val accMethods :
      cenv:cenv ->
        env:env ->
          baseValOpt:TypedTree.Val option ->
            l:TypedTree.ObjExprMethod list -> unit
    val accMethod :
      cenv:cenv ->
        env:env ->
          _baseValOpt:TypedTree.Val option -> TypedTree.ObjExprMethod -> unit
    val accIntfImpls :
      cenv:cenv ->
        env:env ->
          baseValOpt:TypedTree.Val option ->
            l:(TypedTree.TType * TypedTree.ObjExprMethod list) list -> unit
    val accIntfImpl :
      cenv:cenv ->
        env:env ->
          baseValOpt:TypedTree.Val option ->
            ty:TypedTree.TType * overrides:TypedTree.ObjExprMethod list -> unit
    val accOp :
      cenv:cenv ->
        env:env ->
          op:TypedTree.TOp * tyargs:TypedTree.TypeInst * args:TypedTree.Exprs *
          _m:Range.range -> unit
    val accTraitInfo :
      cenv:cenv -> env:env -> TypedTree.TraitConstraintInfo -> unit
    val accLambdas :
      cenv:cenv ->
        env:env ->
          topValInfo:TypedTree.ValReprInfo ->
            e:TypedTree.Expr -> ety:TypedTree.TType -> unit
    val accExprs : cenv:cenv -> env:env -> exprs:TypedTree.Expr list -> unit
    val accTargets :
      cenv:cenv ->
        env:env ->
          m:Range.range ->
            ty:TypedTree.TType ->
              targets:TypedTree.DecisionTreeTarget array -> unit
    val accTarget :
      cenv:cenv ->
        env:env ->
          _m:Range.range ->
            _ty:TypedTree.TType -> TypedTree.DecisionTreeTarget -> unit
    val accDTree : cenv:cenv -> env:env -> x:TypedTree.DecisionTree -> unit
    val accSwitch :
      cenv:cenv ->
        env:env ->
          e:TypedTree.Expr * cases:TypedTree.DecisionTreeCase list *
          dflt:TypedTree.DecisionTree option * _m:Range.range -> unit
    val accDiscrim :
      cenv:cenv -> env:env -> d:TypedTree.DecisionTreeTest -> unit
    val accAttrib : cenv:cenv -> env:env -> TypedTree.Attrib -> unit
    val accAttribs :
      cenv:cenv -> env:env -> attribs:TypedTree.Attrib list -> unit
    val accValReprInfo : cenv:cenv -> env:env -> TypedTree.ValReprInfo -> unit
    val accArgReprInfo :
      cenv:cenv -> env:env -> argInfo:TypedTree.ArgReprInfo -> unit
    val accVal : cenv:cenv -> env:env -> v:TypedTree.Val -> unit
    val accBind : cenv:cenv -> env:env -> bind:TypedTree.Binding -> unit
    val accBinds : cenv:cenv -> env:env -> xs:TypedTree.Bindings -> unit
    val accTyconRecdField :
      cenv:cenv -> env:env -> _tycon:'a -> rfield:TypedTree.RecdField -> unit
    val accTycon : cenv:cenv -> env:env -> tycon:TypedTree.Tycon -> unit
    val accTycons : cenv:cenv -> env:env -> tycons:TypedTree.Tycon list -> unit
    val accModuleOrNamespaceExpr :
      cenv:cenv -> env:env -> x:TypedTree.ModuleOrNamespaceExprWithSig -> unit
    val accModuleOrNamespaceDefs :
      cenv:cenv -> env:env -> x:TypedTree.ModuleOrNamespaceExpr list -> unit
    val accModuleOrNamespaceDef :
      cenv:cenv -> env:env -> x:TypedTree.ModuleOrNamespaceExpr -> unit
    val accModuleOrNamespaceBinds :
      cenv:cenv -> env:env -> xs:TypedTree.ModuleOrNamespaceBinding list -> unit
    val accModuleOrNamespaceBind :
      cenv:cenv -> env:env -> x:TypedTree.ModuleOrNamespaceBinding -> unit
    val UnsolvedTyparsOfModuleDef :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          denv:TypedTreeOps.DisplayEnv ->
            mdef:TypedTree.ModuleOrNamespaceExpr *
            extraAttribs:TypedTree.Attrib list -> TypedTree.Typar list
  end

namespace FSharp.Compiler
  module internal QuotationTranslator = begin
    val verboseCReflect : bool
    [<RequireQualifiedAccessAttribute ()>]
    type IsReflectedDefinition =
      | Yes
      | No
    [<RequireQualifiedAccessAttribute ()>]
    type QuotationSerializationFormat =
      { SupportsWitnesses: bool
        SupportsDeserializeEx: bool }
    [<SealedAttribute ()>]
    type QuotationGenerationScope =
      { g: TcGlobals.TcGlobals
        amap: Import.ImportMap
        scope: TypedTree.CcuThunk
        tcVal: ConstraintSolver.TcValF
        referencedTypeDefs: ResizeArray<AbstractIL.IL.ILTypeRef>
        referencedTypeDefsTable:
          System.Collections.Generic.Dictionary<AbstractIL.IL.ILTypeRef,int>
        typeSplices: ResizeArray<TypedTree.Typar * Range.range>
        exprSplices: ResizeArray<TypedTree.Expr * Range.range>
        isReflectedDefinition: IsReflectedDefinition
        quotationFormat: QuotationSerializationFormat
        mutable emitDebugInfoInQuotations: bool }
      with
        static member
          ComputeQuotationFormat : TcGlobals.TcGlobals ->
                                     QuotationSerializationFormat
        static member
          Create : TcGlobals.TcGlobals * Import.ImportMap * TypedTree.CcuThunk *
                   ConstraintSolver.TcValF * IsReflectedDefinition ->
                     QuotationGenerationScope
        member
          Close : unit ->
                    AbstractIL.IL.ILTypeRef list *
                    (TypedTree.TType * Range.range) list *
                    (TypedTree.Expr * Range.range) list
      end
    type QuotationTranslationEnv =
      { vs: TypedTreeOps.ValMap<int>
        numValsInScope: int
        tyvs: TypedTree.StampMap<int>
        suppressWitnesses: bool
        witnessesInScope: TypedTreeOps.TraitWitnessInfoHashMap<int>
        isinstVals: TypedTreeOps.ValMap<TypedTree.TType * TypedTree.Expr>
        substVals: TypedTreeOps.ValMap<TypedTree.Expr> }
      with
        static member
          CreateEmpty : g:TcGlobals.TcGlobals -> QuotationTranslationEnv
        member BindTypar : v:TypedTree.Typar -> QuotationTranslationEnv
        member BindTypars : vs:TypedTree.Typar list -> QuotationTranslationEnv
        member
          BindWitnessInfo : witnessInfo:TypedTree.TraitWitnessInfo ->
                              QuotationTranslationEnv
        member
          BindWitnessInfos : witnessInfos:TypedTree.TraitWitnessInfo list ->
                               QuotationTranslationEnv
      end
    val BindFormalTypars :
      env:QuotationTranslationEnv ->
        vs:TypedTree.Typar list -> QuotationTranslationEnv
    val BindVal :
      env:QuotationTranslationEnv -> v:TypedTree.Val -> QuotationTranslationEnv
    val BindIsInstVal :
      env:QuotationTranslationEnv ->
        v:TypedTree.Val ->
          ty:TypedTree.TType * e:TypedTree.Expr -> QuotationTranslationEnv
    val BindSubstVal :
      env:QuotationTranslationEnv ->
        v:TypedTree.Val -> e:TypedTree.Expr -> QuotationTranslationEnv
    val BindVals :
      env:QuotationTranslationEnv ->
        vs:TypedTree.Val list -> QuotationTranslationEnv
    val BindFlatVals :
      env:QuotationTranslationEnv ->
        vs:TypedTree.Val list -> QuotationTranslationEnv
    exception InvalidQuotedTerm of exn
    exception IgnoringPartOfQuotedTermWarning of string * Range.range
    val wfail : e:exn -> 'a
    val ( |ModuleValueOrMemberUse|_| ) :
      TcGlobals.TcGlobals ->
        TypedTree.Expr ->
          (TypedTree.ValRef * TypedTree.ValUseFlag * TypedTree.Expr *
           TypedTree.TType * TypedTree.TypeInst * TypedTree.Expr list) option
    val ( |SimpleArrayLoopUpperBound|_| ) : TypedTree.Expr -> unit option
    val ( |SimpleArrayLoopBody|_| ) :
      TcGlobals.TcGlobals ->
        TypedTree.Expr ->
          (TypedTree.Expr * TypedTree.TType * TypedTree.Expr) option
    val ( |ObjectInitializationCheck|_| ) :
      TcGlobals.TcGlobals -> TypedTree.Expr -> unit option
    val isSplice : TcGlobals.TcGlobals -> TypedTree.ValRef -> bool
    val EmitDebugInfoIfNecessary :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          m:Range.range ->
            astExpr:QuotationPickler.ExprData -> QuotationPickler.ExprData
    val ConvExpr :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          expr:TypedTree.Expr -> QuotationPickler.ExprData
    val GetWitnessArgs :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          m:Range.range ->
            tps:TypedTree.Typars ->
              tyargs:TypedTree.TType list -> QuotationPickler.ExprData list
    val ConvWitnessInfo :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          m:Range.range ->
            traitInfo:TypedTree.TraitConstraintInfo -> QuotationPickler.ExprData
    val private ConvExprCore :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          expr:TypedTree.Expr -> QuotationPickler.ExprData
    val ConvLdfld :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          m:Range.range ->
            fspec:AbstractIL.IL.ILFieldSpec ->
              enclTypeArgs:TypedTree.TypeInst ->
                args:TypedTree.Exprs -> QuotationPickler.ExprData
    val ConvUnionFieldGet :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          m:Range.range ->
            ucref:TypedTree.UnionCaseRef ->
              n:int ->
                tyargs:TypedTree.TypeInst ->
                  e:TypedTree.Expr -> QuotationPickler.ExprData
    val ConvClassOrRecdFieldGet :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          m:Range.range ->
            rfref:TypedTree.RecdFieldRef ->
              tyargs:TypedTree.TypeInst ->
                args:TypedTree.Exprs -> QuotationPickler.ExprData
    val private ConvClassOrRecdFieldGetCore :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          m:Range.range ->
            rfref:TypedTree.RecdFieldRef ->
              tyargs:TypedTree.TypeInst ->
                args:TypedTree.Exprs -> QuotationPickler.ExprData
    val ConvLetBind :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          bind:TypedTree.Binding ->
            (QuotationPickler.VarData * QuotationPickler.ExprData) option *
            QuotationTranslationEnv
    val ConvLValueArgs :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          args:TypedTree.Exprs -> QuotationPickler.ExprData list
    val ConvLValueExpr :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          expr:TypedTree.Expr -> QuotationPickler.ExprData
    val ConvLValueExprCore :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          expr:TypedTree.Expr -> QuotationPickler.ExprData
    val ConvObjectModelCall :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          m:Range.range ->
            bool * bool * bool * QuotationPickler.NamedTypeData *
            QuotationPickler.TypeData list * QuotationPickler.TypeData list *
            QuotationPickler.TypeData * string * TypedTree.TypeInst * int *
            TypedTree.Expr list * QuotationPickler.ExprData list *
            TypedTree.Expr list list -> QuotationPickler.ExprData
    val ConvObjectModelCallCore :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          m:Range.range ->
            isPropGet:bool * isPropSet:bool * isNewObj:bool *
            parentTyconR:QuotationPickler.NamedTypeData *
            witnessArgTypesR:QuotationPickler.TypeData list *
            methArgTypesR:QuotationPickler.TypeData list *
            methRetTypeR:QuotationPickler.TypeData * methName:string *
            tyargs:TypedTree.TypeInst * numGenericArgs:int *
            objArgs:TypedTree.Expr list *
            witnessArgsR:QuotationPickler.ExprData list *
            untupledCurriedArgs:TypedTree.Expr list list ->
              QuotationPickler.ExprData
    val ConvModuleValueApp :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          m:Range.range ->
            vref:TypedTree.ValRef ->
              tyargs:TypedTree.TypeInst ->
                witnessArgs:QuotationPickler.ExprData list ->
                  args:TypedTree.Expr list list -> QuotationPickler.ExprData
    val ConvModuleValueAppCore :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          m:Range.range ->
            vref:TypedTree.ValRef ->
              tyargs:TypedTree.TypeInst ->
                witnessArgsR:QuotationPickler.ExprData list ->
                  curriedArgs:TypedTree.Expr list list ->
                    QuotationPickler.ExprData
    val ConvExprs :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          args:TypedTree.Exprs -> QuotationPickler.ExprData list
    val ConvValRef :
      holeOk:bool ->
        cenv:QuotationGenerationScope ->
          env:QuotationTranslationEnv ->
            m:Range.range ->
              vref:TypedTree.ValRef ->
                tyargs:TypedTree.TypeInst -> QuotationPickler.ExprData
    val private ConvValRefCore :
      holeOk:bool ->
        cenv:QuotationGenerationScope ->
          env:QuotationTranslationEnv ->
            m:Range.range ->
              vref:TypedTree.ValRef ->
                tyargs:TypedTree.TypeInst -> QuotationPickler.ExprData
    val ConvUnionCaseRef :
      cenv:QuotationGenerationScope ->
        ucref:TypedTree.UnionCaseRef ->
          m:Range.range -> QuotationPickler.NamedTypeData * string
    val ConvRecdFieldRef :
      cenv:QuotationGenerationScope ->
        rfref:TypedTree.RecdFieldRef ->
          m:Range.range -> QuotationPickler.NamedTypeData * string
    val ConvVal :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          v:TypedTree.Val -> QuotationPickler.VarData
    val ConvTyparRef :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          m:Range.range -> tp:TypedTree.Typar -> int
    val FilterMeasureTyargs : tys:TypedTree.TType list -> TypedTree.TType list
    val ConvType :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          m:Range.range -> ty:TypedTree.TType -> QuotationPickler.TypeData
    val ConvTypes :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          m:Range.range ->
            tys:TypedTree.TType list -> QuotationPickler.TypeData list
    val ConvConst :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          m:Range.range ->
            c:TypedTree.Const -> ty:TypedTree.TType -> QuotationPickler.ExprData
    val ConvDecisionTree :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          tgs:TypedTree.DecisionTreeTarget array ->
            typR:QuotationPickler.TypeData ->
              x:TypedTree.DecisionTree -> QuotationPickler.ExprData
    val IsILTypeRefStaticLinkLocal :
      cenv:QuotationGenerationScope ->
        m:Range.range -> tr:AbstractIL.IL.ILTypeRef -> bool
    val ConvILTypeRefUnadjusted :
      cenv:QuotationGenerationScope ->
        m:Range.range ->
          tr:AbstractIL.IL.ILTypeRef -> QuotationPickler.NamedTypeData
    val ConvILTypeRef :
      cenv:QuotationGenerationScope ->
        tr:AbstractIL.IL.ILTypeRef -> QuotationPickler.NamedTypeData
    val ConvVoidType :
      cenv:QuotationGenerationScope ->
        m:Range.range -> QuotationPickler.TypeData
    val ConvILType :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          m:Range.range -> ty:AbstractIL.IL.ILType -> QuotationPickler.TypeData
    val TryElimErasableTyconRef :
      cenv:QuotationGenerationScope ->
        m:Range.range -> tcref:TypedTree.TyconRef -> TypedTree.TType option
    val ConvTyconRef :
      cenv:QuotationGenerationScope ->
        tcref:TypedTree.TyconRef ->
          m:Range.range -> QuotationPickler.NamedTypeData
    val ConvReturnType :
      cenv:QuotationGenerationScope ->
        envinner:QuotationTranslationEnv ->
          m:Range.range ->
            retTy:TypedTree.TType option -> QuotationPickler.TypeData
    val ConvExprPublic :
      QuotationGenerationScope ->
        suppressWitnesses:bool -> TypedTree.Expr -> QuotationPickler.ExprData
    val ConvMethodBase :
      cenv:QuotationGenerationScope ->
        env:QuotationTranslationEnv ->
          methName:string * v:TypedTree.Val -> QuotationPickler.MethodBaseData
    val ConvReflectedDefinition :
      QuotationGenerationScope ->
        string ->
          TypedTree.Val ->
            TypedTree.Expr ->
              QuotationPickler.MethodBaseData * QuotationPickler.ExprData
  end

namespace FSharp.Compiler
  module internal PostTypeCheckSemanticChecks = begin
    type env =
      { boundTyparNames: string list
        boundTypars: TypedTreeOps.TyparMap<unit>
        argVals: TypedTreeOps.ValMap<unit>
        sigToImplRemapInfo:
          (TypedTreeOps.Remap * TypedTreeOps.SignatureHidingInfo) list
        ctorLimitedZone: bool
        quote: bool
        reflect: bool
        external: bool
        returnScope: int
        isInAppExpr: bool }
      with
        override ToString : unit -> string
      end
    val BindTypar : env:env -> tp:TypedTree.Typar -> env
    val BindTypars :
      g:TcGlobals.TcGlobals -> env:env -> tps:TypedTree.Typar list -> env
    val BindArgVals : env:env -> vs:TypedTree.Val list -> env
    [<System.Flags ()>]
    type LimitFlags =
      | None = 0
      | ByRef = 1
      | ByRefOfSpanLike = 3
      | ByRefOfStackReferringSpanLike = 5
      | SpanLike = 8
      | StackReferringSpanLike = 16
    [<StructAttribute ()>]
    type Limit =
      { scope: int
        flags: LimitFlags }
      with
        member IsLocal : bool
      end
    val inline HasLimitFlag : targetLimit:LimitFlags -> limit:Limit -> bool
    val NoLimit : Limit
    val CombineTwoLimits : limit1:Limit -> limit2:Limit -> Limit
    val CombineLimits : limits:Limit list -> Limit
    type cenv =
      { boundVals: System.Collections.Generic.Dictionary<TypedTree.Stamp,int>
        limitVals: System.Collections.Generic.Dictionary<TypedTree.Stamp,Limit>
        mutable potentialUnboundUsesOfVals: TypedTree.StampMap<Range.range>
        mutable anonRecdTypes: TypedTree.StampMap<TypedTree.AnonRecdTypeInfo>
        g: TcGlobals.TcGlobals
        amap: Import.ImportMap
        infoReader: InfoReader.InfoReader
        internalsVisibleToPaths: TypedTree.CompilationPath list
        denv: TypedTreeOps.DisplayEnv
        viewCcu: TypedTree.CcuThunk
        reportErrors: bool
        isLastCompiland: bool * bool
        isInternalTestSpanStackReferring: bool
        mutable usesQuotations: bool
        mutable entryPointGiven: bool
        tcVal: ConstraintSolver.TcValF }
      with
        override ToString : unit -> string
      end
    val IsValArgument : env:env -> v:TypedTree.Val -> bool
    val IsValLocal : env:env -> v:TypedTree.Val -> bool
    val GetLimitVal :
      cenv:cenv -> env:env -> m:Range.range -> v:TypedTree.Val -> Limit
    val GetLimitValByRef :
      cenv:cenv -> env:env -> m:Range.range -> v:TypedTree.Val -> Limit
    val LimitVal : cenv:cenv -> v:TypedTree.Val -> limit:Limit -> unit
    val BindVal : cenv:cenv -> env:env -> v:TypedTree.Val -> unit
    val BindVals : cenv:cenv -> env:env -> vs:TypedTree.Val list -> unit
    val RecordAnonRecdInfo :
      cenv:cenv -> anonInfo:TypedTree.AnonRecdTypeInfo -> unit
    val CheckTypeDeep :
      cenv:cenv ->
        (TypedTree.TType -> unit) * (bool -> TypedTree.TyconRef -> unit) option *
        (TypedTree.TyconRef * TypedTree.TypeInst -> unit) option *
        (TypedTree.TraitConstraintSln -> unit) option *
        (env * TypedTree.Typar -> unit) option ->
          g:TcGlobals.TcGlobals ->
            env:env -> isInner:bool -> ty:TypedTree.TType -> unit
    val CheckTypesDeep :
      cenv:cenv ->
        (TypedTree.TType -> unit) * (bool -> TypedTree.TyconRef -> unit) option *
        (TypedTree.TyconRef * TypedTree.TypeInst -> unit) option *
        (TypedTree.TraitConstraintSln -> unit) option *
        (env * TypedTree.Typar -> unit) option ->
          g:TcGlobals.TcGlobals -> env:env -> tys:TypedTree.TypeInst -> unit
    val CheckTypesDeepNoInner :
      cenv:cenv ->
        (TypedTree.TType -> unit) * (bool -> TypedTree.TyconRef -> unit) option *
        (TypedTree.TyconRef * TypedTree.TypeInst -> unit) option *
        (TypedTree.TraitConstraintSln -> unit) option *
        (env * TypedTree.Typar -> unit) option ->
          g:TcGlobals.TcGlobals -> env:env -> tys:TypedTree.TypeInst -> unit
    val CheckTypeConstraintDeep :
      cenv:cenv ->
        (TypedTree.TType -> unit) * (bool -> TypedTree.TyconRef -> unit) option *
        (TypedTree.TyconRef * TypedTree.TypeInst -> unit) option *
        (TypedTree.TraitConstraintSln -> unit) option *
        (env * TypedTree.Typar -> unit) option ->
          g:TcGlobals.TcGlobals ->
            env:env -> x:TypedTree.TyparConstraint -> unit
    val CheckTraitInfoDeep :
      cenv:cenv ->
        (TypedTree.TType -> unit) * (bool -> TypedTree.TyconRef -> unit) option *
        (TypedTree.TyconRef * TypedTree.TypeInst -> unit) option *
        (TypedTree.TraitConstraintSln -> unit) option *
        (env * TypedTree.Typar -> unit) option ->
          g:TcGlobals.TcGlobals ->
            env:env -> TypedTree.TraitConstraintInfo -> unit
    val CheckForByrefLikeType :
      cenv:cenv ->
        env:env ->
          m:Range.range -> ty:TypedTree.TType -> check:(unit -> unit) -> unit
    val CheckForByrefType :
      cenv:cenv -> env:env -> ty:TypedTree.TType -> check:(unit -> unit) -> unit
    val CheckEscapes :
      cenv:cenv ->
        allowProtected:bool ->
          m:Range.range ->
            syntacticArgs:TypedTree.Val list ->
              body:TypedTree.Expr -> TypedTree.FreeVars option
    val AccessInternalsVisibleToAsInternal :
      thisCompPath:TypedTree.CompilationPath ->
        internalsVisibleToPaths:TypedTree.CompilationPath list ->
          access:TypedTree.Accessibility -> TypedTree.Accessibility
    val CheckTypeForAccess :
      cenv:cenv ->
        env:env ->
          objName:(unit -> System.String) ->
            valAcc:TypedTree.Accessibility ->
              m:Range.range -> ty:TypedTree.TType -> unit
    val WarnOnWrongTypeForAccess :
      cenv:cenv ->
        env:env ->
          objName:(unit -> System.String) ->
            valAcc:TypedTree.Accessibility ->
              m:Range.range -> ty:TypedTree.TType -> unit
    [<RequireQualifiedAccessAttribute ()>]
    type PermitByRefType =
      | None
      | NoInnerByRefLike
      | SpanLike
      | All
    [<RequireQualifiedAccessAttribute ()>]
    type PermitByRefExpr =
      | YesTupleOfArgs of int
      | Yes
      | YesReturnable
      | YesReturnableNonLocal
      | No
      with
        member Disallow : bool
        member PermitOnlyReturnable : bool
        member PermitOnlyReturnableNonLocal : bool
      end
    val inline IsLimitEscapingScope :
      env:env -> context:PermitByRefExpr -> limit:Limit -> bool
    val mkArgsPermit : n:int -> PermitByRefExpr
    val mkArgsForAppliedVal :
      isBaseCall:bool ->
        vref:TypedTree.ValRef -> argsl:'a list -> PermitByRefExpr list
    val mkArgsForAppliedExpr :
      isBaseCall:bool ->
        argsl:'a list -> x:TypedTree.Expr -> PermitByRefExpr list
    val CheckTypeAux :
      permitByRefLike:PermitByRefType ->
        cenv:cenv ->
          env:env ->
            m:Range.range ->
              ty:TypedTree.TType -> onInnerByrefError:(unit -> unit) -> unit
    val CheckType :
      permitByRefLike:PermitByRefType ->
        cenv:cenv -> env:env -> m:Range.range -> ty:TypedTree.TType -> unit
    val CheckTypeNoByrefs :
      cenv:cenv -> env:env -> m:Range.range -> ty:TypedTree.TType -> unit
    val CheckTypePermitSpanLike :
      cenv:cenv -> env:env -> m:Range.range -> ty:TypedTree.TType -> unit
    val CheckTypePermitAllByrefs :
      cenv:cenv -> env:env -> m:Range.range -> ty:TypedTree.TType -> unit
    val CheckTypeNoInnerByrefs :
      cenv:cenv -> env:env -> m:Range.range -> ty:TypedTree.TType -> unit
    val CheckTypeInstNoByrefs :
      cenv:cenv ->
        env:env -> m:Range.range -> tyargs:TypedTree.TType list -> unit
    val CheckTypeInstPermitAllByrefs :
      cenv:cenv ->
        env:env -> m:Range.range -> tyargs:TypedTree.TType list -> unit
    val CheckTypeInstNoInnerByrefs :
      cenv:cenv ->
        env:env -> m:Range.range -> tyargs:TypedTree.TType list -> unit
    val ( |OptionalCoerce| ) : _arg1:TypedTree.Expr -> TypedTree.Expr
    val CheckNoReraise :
      cenv:cenv ->
        freesOpt:TypedTree.FreeVars option -> body:TypedTree.Expr -> unit
    val isSpliceOperator : g:TcGlobals.TcGlobals -> v:TypedTree.ValRef -> bool
    type TTypeEquality =
      | ExactlyEqual
      | FeasiblyEqual
      | NotEqual
    val compareTypesWithRegardToTypeVariablesAndMeasures :
      g:TcGlobals.TcGlobals ->
        amap:'a ->
          m:Range.range ->
            typ1:TypedTree.TType -> typ2:TypedTree.TType -> TTypeEquality
    val CheckMultipleInterfaceInstantiations :
      cenv:cenv ->
        typ:TypedTree.TType ->
          interfaces:TypedTree.TType list ->
            isObjectExpression:bool -> m:Range.range -> unit
    val CheckExprNoByrefs : cenv:cenv -> env:env -> expr:TypedTree.Expr -> unit
    val CheckValRef :
      cenv:cenv ->
        env:env ->
          v:TypedTree.ValRef -> m:Range.range -> context:PermitByRefExpr -> unit
    val CheckValUse :
      cenv:cenv ->
        env:env ->
          vref:TypedTree.ValRef * vFlags:TypedTree.ValUseFlag * m:Range.range ->
            context:PermitByRefExpr -> Limit
    val CheckForOverAppliedExceptionRaisingPrimitive :
      cenv:cenv -> expr:TypedTree.Expr -> unit
    val CheckCallLimitArgs :
      cenv:cenv ->
        env:env ->
          m:Range.range ->
            returnTy:TypedTree.TType ->
              limitArgs:Limit -> context:PermitByRefExpr -> Limit
    val CheckCall :
      cenv:cenv ->
        env:env ->
          m:Range.range ->
            returnTy:TypedTree.TType ->
              args:TypedTree.Expr list ->
                contexts:PermitByRefExpr list ->
                  context:PermitByRefExpr -> Limit
    val CheckCallWithReceiver :
      cenv:cenv ->
        env:env ->
          m:Range.range ->
            returnTy:TypedTree.TType ->
              args:TypedTree.Expr list ->
                contexts:PermitByRefExpr list ->
                  context:PermitByRefExpr -> Limit
    val CheckExprLinear :
      cenv:cenv ->
        env:env ->
          expr:TypedTree.Expr ->
            context:PermitByRefExpr -> contf:(Limit -> Limit) -> Limit
    val CheckExpr :
      cenv:cenv ->
        env:env -> origExpr:TypedTree.Expr -> context:PermitByRefExpr -> Limit
    val CheckMethods :
      cenv:cenv ->
        env:env ->
          baseValOpt:TypedTree.Val option ->
            methods:TypedTree.ObjExprMethod list -> unit
    val CheckMethod :
      cenv:cenv ->
        env:env ->
          baseValOpt:TypedTree.Val option -> TypedTree.ObjExprMethod -> unit
    val CheckInterfaceImpls :
      cenv:cenv ->
        env:env ->
          baseValOpt:TypedTree.Val option ->
            l:(TypedTree.TType * TypedTree.ObjExprMethod list) list -> unit
    val CheckInterfaceImpl :
      cenv:cenv ->
        env:env ->
          baseValOpt:TypedTree.Val option ->
            _ty:TypedTree.TType * overrides:TypedTree.ObjExprMethod list -> unit
    val CheckExprOp :
      cenv:cenv ->
        env:env ->
          op:TypedTree.TOp * tyargs:TypedTree.TypeInst * args:TypedTree.Exprs *
          m:Range.range ->
            context:PermitByRefExpr -> expr:TypedTree.Expr -> Limit
    val CheckLambdas :
      isTop:bool ->
        memInfo:TypedTree.ValMemberInfo option ->
          cenv:cenv ->
            env:env ->
              inlined:bool ->
                topValInfo:TypedTree.ValReprInfo ->
                  alwaysCheckNoReraise:bool ->
                    e:TypedTree.Expr ->
                      mOrig:Range.range ->
                        ety:TypedTree.TType -> context:PermitByRefExpr -> Limit
    val CheckExprs :
      cenv:cenv ->
        env:env ->
          exprs:TypedTree.Expr list -> contexts:PermitByRefExpr list -> Limit
    val CheckExprsNoByRefLike :
      cenv:cenv -> env:env -> exprs:TypedTree.Expr list -> Limit
    val CheckExprsPermitByRefLike :
      cenv:cenv -> env:env -> exprs:TypedTree.Expr list -> Limit
    val CheckExprsPermitReturnableByRef :
      cenv:cenv -> env:env -> exprs:TypedTree.Expr list -> Limit
    val CheckExprPermitByRefLike :
      cenv:cenv -> env:env -> expr:TypedTree.Expr -> Limit
    val CheckExprPermitReturnableByRef :
      cenv:cenv -> env:env -> expr:TypedTree.Expr -> Limit
    val CheckDecisionTreeTargets :
      cenv:cenv ->
        env:env ->
          targets:TypedTree.DecisionTreeTarget array ->
            context:PermitByRefExpr -> Limit
    val CheckDecisionTreeTarget :
      cenv:cenv ->
        env:env ->
          context:PermitByRefExpr -> TypedTree.DecisionTreeTarget -> Limit
    val CheckDecisionTree :
      cenv:cenv -> env:env -> x:TypedTree.DecisionTree -> unit
    val CheckDecisionTreeSwitch :
      cenv:cenv ->
        env:env ->
          e:TypedTree.Expr * cases:TypedTree.DecisionTreeCase list *
          dflt:TypedTree.DecisionTree option * m:Range.range -> unit
    val CheckDecisionTreeTest :
      cenv:cenv ->
        env:env -> m:Range.range -> discrim:TypedTree.DecisionTreeTest -> unit
    val CheckAttrib : cenv:cenv -> env:env -> TypedTree.Attrib -> unit
    val CheckAttribExpr : cenv:cenv -> env:env -> TypedTree.AttribExpr -> unit
    val CheckAttribArgExpr : cenv:cenv -> env:env -> expr:TypedTree.Expr -> unit
    val CheckAttribs : cenv:cenv -> env:env -> attribs:TypedTree.Attribs -> unit
    val CheckValInfo : cenv:cenv -> env:env -> TypedTree.ValReprInfo -> unit
    val CheckArgInfo :
      cenv:cenv -> env:env -> argInfo:TypedTree.ArgReprInfo -> unit
    val CheckValSpecAux :
      permitByRefLike:PermitByRefType ->
        cenv:cenv ->
          env:env -> v:TypedTree.Val -> onInnerByrefError:(unit -> unit) -> unit
    val CheckValSpec :
      permitByRefLike:PermitByRefType ->
        cenv:cenv -> env:env -> v:TypedTree.Val -> unit
    val AdjustAccess :
      isHidden:bool ->
        cpath:(unit -> TypedTree.CompilationPath) ->
          access:TypedTree.Accessibility -> TypedTree.Accessibility
    val CheckBinding :
      cenv:cenv ->
        env:env ->
          alwaysCheckNoReraise:bool ->
            context:PermitByRefExpr -> TypedTree.Binding -> Limit
    val CheckBindings : cenv:cenv -> env:env -> xs:TypedTree.Bindings -> unit
    val CheckModuleBinding : cenv:cenv -> env:env -> TypedTree.Binding -> unit
    val CheckModuleBindings :
      cenv:cenv -> env:env -> binds:TypedTree.Binding list -> unit
    val CheckRecdField :
      isUnion:bool ->
        cenv:cenv ->
          env:env -> tycon:TypedTree.Tycon -> rfield:TypedTree.RecdField -> unit
    val CheckEntityDefn : cenv:cenv -> env:env -> tycon:TypedTree.Entity -> unit
    val CheckEntityDefns :
      cenv:cenv -> env:env -> tycons:TypedTree.Entity list -> unit
    val CheckModuleExpr :
      cenv:cenv -> env:env -> x:TypedTree.ModuleOrNamespaceExprWithSig -> unit
    val CheckDefnsInModule :
      cenv:cenv -> env:env -> x:TypedTree.ModuleOrNamespaceExpr list -> unit
    val CheckNothingAfterEntryPoint : cenv:cenv -> m:Range.range -> unit
    val CheckDefnInModule :
      cenv:cenv -> env:env -> x:TypedTree.ModuleOrNamespaceExpr -> unit
    val CheckModuleSpec :
      cenv:cenv -> env:env -> x:TypedTree.ModuleOrNamespaceBinding -> unit
    val CheckTopImpl :
      g:TcGlobals.TcGlobals * amap:Import.ImportMap * reportErrors:bool *
      infoReader:InfoReader.InfoReader *
      internalsVisibleToPaths:TypedTree.CompilationPath list *
      viewCcu:TypedTree.CcuThunk * tcValF:ConstraintSolver.TcValF *
      denv:TypedTreeOps.DisplayEnv *
      mexpr:TypedTree.ModuleOrNamespaceExprWithSig *
      extraAttribs:TypedTree.Attribs * (bool * bool) *
      isInternalTestSpanStackReferring:bool ->
        bool * TypedTree.StampMap<TypedTree.AnonRecdTypeInfo>
  end

namespace FSharp.Compiler
  module internal CheckExpressions = begin
    val mkNilListPat :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> ty:TypedTree.TType -> PatternMatchCompilation.Pattern
    val mkConsListPat :
      g:TcGlobals.TcGlobals ->
        ty:TypedTree.TType ->
          ph:PatternMatchCompilation.Pattern ->
            pt:PatternMatchCompilation.Pattern ->
              PatternMatchCompilation.Pattern
    exception BakedInMemberConstraintName of string * Range.range
    exception FunctionExpected of
                                 TypedTreeOps.DisplayEnv * TypedTree.TType *
                                 Range.range
    exception NotAFunction of
                             TypedTreeOps.DisplayEnv * TypedTree.TType *
                             Range.range * Range.range
    exception NotAFunctionButIndexer of
                                       TypedTreeOps.DisplayEnv * TypedTree.TType *
                                       string option * Range.range * Range.range
    exception Recursion of
                          TypedTreeOps.DisplayEnv * SyntaxTree.Ident *
                          TypedTree.TType * TypedTree.TType * Range.range
    exception RecursiveUseCheckedAtRuntime of
                                             TypedTreeOps.DisplayEnv *
                                             TypedTree.ValRef * Range.range
    exception LetRecEvaluatedOutOfOrder of
                                          TypedTreeOps.DisplayEnv *
                                          TypedTree.ValRef * TypedTree.ValRef *
                                          Range.range
    exception LetRecCheckedAtRuntime of Range.range
    exception LetRecUnsound of
                              TypedTreeOps.DisplayEnv * TypedTree.ValRef list *
                              Range.range
    exception TyconBadArgs of
                             TypedTreeOps.DisplayEnv * TypedTree.TyconRef * int *
                             Range.range
    exception UnionCaseWrongArguments of
                                        TypedTreeOps.DisplayEnv * int * int *
                                        Range.range
    exception UnionCaseWrongNumberOfArgs of
                                           TypedTreeOps.DisplayEnv * int * int *
                                           Range.range
    exception FieldsFromDifferentTypes of
                                         TypedTreeOps.DisplayEnv *
                                         TypedTree.RecdFieldRef *
                                         TypedTree.RecdFieldRef * Range.range
    exception FieldGivenTwice of
                                TypedTreeOps.DisplayEnv * TypedTree.RecdFieldRef *
                                Range.range
    exception MissingFields of string list * Range.range
    exception FunctionValueUnexpected of
                                        TypedTreeOps.DisplayEnv *
                                        TypedTree.TType * Range.range
    exception UnitTypeExpected of
                                 TypedTreeOps.DisplayEnv * TypedTree.TType *
                                 Range.range
    exception UnitTypeExpectedWithEquality of
                                             TypedTreeOps.DisplayEnv *
                                             TypedTree.TType * Range.range
    exception UnitTypeExpectedWithPossibleAssignment of
                                                       TypedTreeOps.DisplayEnv *
                                                       TypedTree.TType * bool *
                                                       string * Range.range
    exception UnitTypeExpectedWithPossiblePropertySetter of
                                                           TypedTreeOps.DisplayEnv *
                                                           TypedTree.TType *
                                                           string * string *
                                                           Range.range
    exception UnionPatternsBindDifferentNames of Range.range
    exception VarBoundTwice of SyntaxTree.Ident
    exception ValueRestriction of
                                 TypedTreeOps.DisplayEnv * bool * TypedTree.Val *
                                 TypedTree.Typar * Range.range
    exception ValNotMutable of
                              TypedTreeOps.DisplayEnv * TypedTree.ValRef *
                              Range.range
    exception ValNotLocal of
                            TypedTreeOps.DisplayEnv * TypedTree.ValRef *
                            Range.range
    exception InvalidRuntimeCoercion of
                                       TypedTreeOps.DisplayEnv * TypedTree.TType *
                                       TypedTree.TType * Range.range
    exception IndeterminateRuntimeCoercion of
                                             TypedTreeOps.DisplayEnv *
                                             TypedTree.TType * TypedTree.TType *
                                             Range.range
    exception IndeterminateStaticCoercion of
                                            TypedTreeOps.DisplayEnv *
                                            TypedTree.TType * TypedTree.TType *
                                            Range.range
    exception RuntimeCoercionSourceSealed of
                                            TypedTreeOps.DisplayEnv *
                                            TypedTree.TType * Range.range
    exception CoercionTargetSealed of
                                     TypedTreeOps.DisplayEnv * TypedTree.TType *
                                     Range.range
    exception UpcastUnnecessary of Range.range
    exception TypeTestUnnecessary of Range.range
    exception StaticCoercionShouldUseBox of
                                           TypedTreeOps.DisplayEnv *
                                           TypedTree.TType * TypedTree.TType *
                                           Range.range
    exception SelfRefObjCtor of bool * Range.range
    exception VirtualAugmentationOnNullValuedType of Range.range
    exception NonVirtualAugmentationOnNullValuedType of Range.range
    exception UseOfAddressOfOperator of Range.range
    exception DeprecatedThreadStaticBindingWarning of Range.range
    exception IntfImplInIntrinsicAugmentation of Range.range
    exception IntfImplInExtrinsicAugmentation of Range.range
    exception OverrideInIntrinsicAugmentation of Range.range
    exception OverrideInExtrinsicAugmentation of Range.range
    exception NonUniqueInferredAbstractSlot of
                                              TcGlobals.TcGlobals *
                                              TypedTreeOps.DisplayEnv * string *
                                              Infos.MethInfo * Infos.MethInfo *
                                              Range.range
    exception StandardOperatorRedefinitionWarning of string * Range.range
    exception InvalidInternalsVisibleToAssemblyName of string * string option
    type SafeInitData =
      | SafeInitField of TypedTree.RecdFieldRef * TypedTree.RecdField
      | NoSafeInitInfo
    [<SealedAttribute ()>]
    type CtorInfo =
      { ctorShapeCounter: int
        safeThisValOpt: TypedTree.Val option
        safeInitInfo: SafeInitData
        ctorIsImplicit: bool }
    [<NoEqualityAttribute (); NoComparisonAttribute (); SealedAttribute ()>]
    type UngeneralizableItem =
      class
        new : computeFreeTyvars:(unit -> TypedTree.FreeTyvars) ->
                UngeneralizableItem
        member GetFreeTyvars : unit -> TypedTree.FreeTyvars
        member CachedFreeLocalTycons : TypedTree.FreeTycons
        member CachedFreeTraitSolutions : TypedTree.FreeLocals
        member WillNeverHaveFreeTypars : bool
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type TcEnv =
      { eNameResEnv: NameResolution.NameResolutionEnv
        eUngeneralizableItems: UngeneralizableItem list
        ePath: SyntaxTree.Ident list
        eCompPath: TypedTree.CompilationPath
        eAccessPath: TypedTree.CompilationPath
        eAccessRights: AccessibilityLogic.AccessorDomain
        eInternalsVisibleCompPaths: TypedTree.CompilationPath list
        eModuleOrNamespaceTypeAccumulator: TypedTree.ModuleOrNamespaceType ref
        eContextInfo: ConstraintSolver.ContextInfo
        eFamilyType: TypedTree.TyconRef option
        eCtorInfo: CtorInfo option
        eCallerMemberName: string option }
      with
        override ToString : unit -> string
        member AccessRights : AccessibilityLogic.AccessorDomain
        member DisplayEnv : TypedTreeOps.DisplayEnv
        member NameEnv : NameResolution.NameResolutionEnv
      end
    val ComputeAccessRights :
      eAccessPath:TypedTree.CompilationPath ->
        eInternalsVisibleCompPaths:TypedTree.CompilationPath list ->
          eFamilyType:TypedTree.TyconRef option ->
            AccessibilityLogic.AccessorDomain
    val InitialExplicitCtorInfo :
      safeThisValOpt:TypedTree.Val option * safeInitInfo:SafeInitData ->
        CtorInfo
    val InitialImplicitCtorInfo : unit -> CtorInfo
    val EnterFamilyRegion : tcref:TypedTree.TyconRef -> env:TcEnv -> TcEnv
    val ExitFamilyRegion : env:TcEnv -> TcEnv
    val AreWithinCtorShape : env:TcEnv -> bool
    val AreWithinImplicitCtor : env:TcEnv -> bool
    val GetCtorShapeCounter : env:TcEnv -> int
    val GetRecdInfo : env:TcEnv -> TypedTree.RecordConstructionInfo
    val AdjustCtorShapeCounter : f:(int -> int) -> env:TcEnv -> TcEnv
    val ExitCtorShapeRegion : env:TcEnv -> TcEnv
    val addFreeItemOfTy :
      ty:TypedTree.TType ->
        eUngeneralizableItems:UngeneralizableItem list ->
          UngeneralizableItem list
    val addFreeItemOfModuleTy :
      TypedTree.ModuleOrNamespaceType ->
        UngeneralizableItem list -> UngeneralizableItem list
    val AddValMapToNameEnv :
      vs:AbstractIL.Internal.Library.NameMap<TypedTree.Val> ->
        nenv:NameResolution.NameResolutionEnv ->
          NameResolution.NameResolutionEnv
    val AddValListToNameEnv :
      vs:TypedTree.Val list ->
        nenv:NameResolution.NameResolutionEnv ->
          NameResolution.NameResolutionEnv
    val AddLocalValPrimitive : v:TypedTree.Val -> TcEnv -> TcEnv
    val AddLocalValMap :
      tcSink:NameResolution.TcResultsSink ->
        scopem:Range.range ->
          vals:AbstractIL.Internal.Library.NameMap<TypedTree.Val> ->
            env:TcEnv -> TcEnv
    val AddLocalVals :
      tcSink:NameResolution.TcResultsSink ->
        scopem:Range.range -> vals:TypedTree.Val list -> env:TcEnv -> TcEnv
    val AddLocalVal :
      NameResolution.TcResultsSink ->
        scopem:Range.range -> v:TypedTree.Val -> TcEnv -> TcEnv
    val AddDeclaredTypars :
      check:NameResolution.CheckForDuplicateTyparFlag ->
        typars:TypedTree.Typar list -> env:TcEnv -> TcEnv
    type UnscopedTyparEnv =
      | UnscopedTyparEnv of AbstractIL.Internal.Library.NameMap<TypedTree.Typar>
    val emptyUnscopedTyparEnv : UnscopedTyparEnv
    val AddUnscopedTypar :
      n:string -> p:TypedTree.Typar -> UnscopedTyparEnv -> UnscopedTyparEnv
    val TryFindUnscopedTypar :
      n:string -> UnscopedTyparEnv -> TypedTree.Typar option
    val HideUnscopedTypars :
      typars:TypedTree.Typar list -> UnscopedTyparEnv -> UnscopedTyparEnv
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type TcFileState =
      { g: TcGlobals.TcGlobals
        mutable recUses:
          TypedTreeOps.ValMultiMap<TypedTree.Expr ref * Range.range * bool>
        mutable postInferenceChecks: ResizeArray<(unit -> unit)>
        mutable createsGeneratedProvidedTypes: bool
        isScript: bool
        amap: Import.ImportMap
        synArgNameGenerator: SyntaxTreeOps.SynArgNameGenerator
        tcSink: NameResolution.TcResultsSink
        topCcu: TypedTree.CcuThunk
        css: ConstraintSolver.ConstraintSolverState
        compilingCanonicalFslibModuleType: bool
        isSig: bool
        haveSig: bool
        niceNameGen: CompilerGlobalState.NiceNameGenerator
        infoReader: InfoReader.InfoReader
        nameResolver: NameResolution.NameResolver
        conditionalDefines: string list option
        isInternalTestSpanStackReferring: bool
        TcSequenceExpressionEntry:
          TcFileState -> TcEnv -> TypedTree.TType -> UnscopedTyparEnv ->
            bool * bool ref * SyntaxTree.SynExpr -> Range.range ->
            TypedTree.Expr * UnscopedTyparEnv
        TcArrayOrListSequenceExpression:
          TcFileState -> TcEnv -> TypedTree.TType -> UnscopedTyparEnv ->
            bool * SyntaxTree.SynExpr -> Range.range ->
            TypedTree.Expr * UnscopedTyparEnv
        TcComputationExpression:
          TcFileState -> TcEnv -> TypedTree.TType -> UnscopedTyparEnv ->
            Range.range * TypedTree.Expr * TypedTree.TType * SyntaxTree.SynExpr ->
            TypedTree.Expr * UnscopedTyparEnv }
      with
        static member
          Create : g:TcGlobals.TcGlobals * isScript:bool *
                   niceNameGen:CompilerGlobalState.NiceNameGenerator *
                   amap:Import.ImportMap * topCcu:TypedTree.CcuThunk *
                   isSig:bool * haveSig:bool *
                   conditionalDefines:string list option *
                   tcSink:NameResolution.TcResultsSink *
                   tcVal:ConstraintSolver.TcValF *
                   isInternalTestSpanStackReferring:bool *
                   tcSequenceExpressionEntry:(TcFileState -> TcEnv ->
                                                TypedTree.TType ->
                                                UnscopedTyparEnv ->
                                                bool * bool ref *
                                                SyntaxTree.SynExpr ->
                                                Range.range ->
                                                TypedTree.Expr *
                                                UnscopedTyparEnv) *
                   tcArrayOrListSequenceExpression:(TcFileState -> TcEnv ->
                                                      TypedTree.TType ->
                                                      UnscopedTyparEnv ->
                                                      bool * SyntaxTree.SynExpr ->
                                                      Range.range ->
                                                      TypedTree.Expr *
                                                      UnscopedTyparEnv) *
                   tcComputationExpression:(TcFileState -> TcEnv ->
                                              TypedTree.TType ->
                                              UnscopedTyparEnv ->
                                              Range.range * TypedTree.Expr *
                                              TypedTree.TType *
                                              SyntaxTree.SynExpr ->
                                              TypedTree.Expr * UnscopedTyparEnv) ->
                     TcFileState
        override ToString : unit -> string
      end
    type cenv = TcFileState
    val CopyAndFixupTypars :
      m:Range.range ->
        rigid:TypedTree.TyparRigidity ->
          tpsorig:TypedTree.Typars ->
            TypedTree.Typars * TypedTreeOps.TyparInst * TypedTree.TType list
    val UnifyTypes :
      cenv:TcFileState ->
        env:TcEnv ->
          m:Range.range ->
            actualTy:TypedTree.TType -> expectedTy:TypedTree.TType -> unit
    val MakeInnerEnvWithAcc :
      addOpenToNameEnv:bool ->
        env:TcEnv ->
          nm:SyntaxTree.Ident ->
            mtypeAcc:TypedTree.ModuleOrNamespaceType ref ->
              modKind:TypedTree.ModuleOrNamespaceKind -> TcEnv
    val MakeInnerEnv :
      addOpenToNameEnv:bool ->
        env:TcEnv ->
          nm:SyntaxTree.Ident ->
            modKind:TypedTree.ModuleOrNamespaceKind ->
              TcEnv * TypedTree.ModuleOrNamespaceType ref
    val MakeInnerEnvForTyconRef :
      env:TcEnv ->
        tcref:TypedTree.TyconRef -> isExtrinsicExtension:bool -> TcEnv
    val MakeInnerEnvForMember : env:TcEnv -> v:TypedTree.Val -> TcEnv
    val GetCurrAccumulatedModuleOrNamespaceType :
      env:TcEnv -> TypedTree.ModuleOrNamespaceType
    val SetCurrAccumulatedModuleOrNamespaceType :
      env:TcEnv -> x:TypedTree.ModuleOrNamespaceType -> unit
    val LocateEnv :
      ccu:TypedTree.CcuThunk ->
        env:TcEnv -> enclosingNamespacePath:SyntaxTree.Ident list -> TcEnv
    val ShrinkContext :
      env:TcEnv -> oldRange:Range.range -> newRange:Range.range -> TcEnv
    val UnifyRefTupleType :
      contextInfo:ConstraintSolver.ContextInfo ->
        cenv:TcFileState ->
          denv:TypedTreeOps.DisplayEnv ->
            m:Range.range ->
              ty:TypedTree.TType -> ps:'a list -> TypedTree.TTypes
    val UnifyTupleTypeAndInferCharacteristics :
      contextInfo:ConstraintSolver.ContextInfo ->
        cenv:TcFileState ->
          denv:TypedTreeOps.DisplayEnv ->
            m:Range.range ->
              knownTy:TypedTree.TType ->
                isExplicitStruct:bool ->
                  ps:'a list -> TypedTree.TupInfo * TypedTree.TTypes
    val UnifyAnonRecdTypeAndInferCharacteristics :
      contextInfo:ConstraintSolver.ContextInfo ->
        cenv:TcFileState ->
          denv:TypedTreeOps.DisplayEnv ->
            m:Range.range ->
              ty:TypedTree.TType ->
                isExplicitStruct:bool ->
                  unsortedNames:SyntaxTree.Ident [] ->
                    TypedTree.AnonRecdTypeInfo * TypedTree.TType list
    val UnifyFunctionTypeUndoIfFailed :
      cenv:TcFileState ->
        denv:TypedTreeOps.DisplayEnv ->
          m:Range.range ->
            ty:TypedTree.TType -> (TypedTree.TType * TypedTree.TType) voption
    val UnifyFunctionType :
      extraInfo:Range.range option ->
        cenv:TcFileState ->
          denv:TypedTreeOps.DisplayEnv ->
            mFunExpr:Range.range ->
              ty:TypedTree.TType -> TypedTree.TType * TypedTree.TType
    val ReportImplicitlyIgnoredBoolExpression :
      denv:TypedTreeOps.DisplayEnv ->
        m:Range.range -> ty:TypedTree.TType -> expr:TypedTree.Expr -> exn
    val UnifyUnitType :
      cenv:TcFileState ->
        env:TcEnv ->
          m:Range.range -> ty:TypedTree.TType -> expr:TypedTree.Expr -> bool
    val TryUnifyUnitTypeWithoutWarning :
      cenv:TcFileState ->
        env:TcEnv -> m:Range.range -> ty:TypedTree.TType -> bool
    module AttributeTargets = begin
      val FieldDecl : System.AttributeTargets
      val FieldDeclRestricted : System.AttributeTargets
      val UnionCaseDecl : System.AttributeTargets
      val TyconDecl : System.AttributeTargets
      val ExnDecl : System.AttributeTargets
      val ModuleDecl : System.AttributeTargets
      val Top : System.AttributeTargets
    end
    val ForNewConstructors :
      tcSink:NameResolution.TcResultsSink ->
        env:TcEnv ->
          mObjTy:Range.range ->
            methodName:string ->
              meths:Infos.MethInfo list -> NameResolution.AfterResolution
    val TcSynRationalConst : c:SyntaxTree.SynRationalConst -> Rational.Rational
    val TcConst :
      cenv:TcFileState ->
        ty:TypedTree.TType ->
          m:Range.range -> env:TcEnv -> c:SyntaxTree.SynConst -> TypedTree.Const
    val TcFieldInit :
      Range.range -> AbstractIL.IL.ILFieldInit -> TypedTree.Const
    val AdjustValSynInfoInSignature :
      g:TcGlobals.TcGlobals ->
        ty:TypedTree.TType -> SyntaxTree.SynValInfo -> SyntaxTree.SynValInfo
    type PartialValReprInfo =
      | PartialValReprInfo of
        curriedArgInfos: TypedTree.ArgReprInfo list list *
        returnInfo: TypedTree.ArgReprInfo
    val TranslateTopArgSynInfo :
      isArg:bool ->
        m:Range.range ->
          tcAttributes:(SyntaxTree.SynAttribute list -> TypedTree.Attribs) ->
            SyntaxTree.SynArgInfo -> TypedTree.ArgReprInfo
    val TranslateTopValSynInfo :
      Range.range ->
        tcAttributes:(System.AttributeTargets -> SyntaxTree.SynAttribute list ->
                        TypedTree.Attribs) ->
          synValInfo:SyntaxTree.SynValInfo -> PartialValReprInfo
    val TranslatePartialArity :
      tps:TypedTree.Typar list -> PartialValReprInfo -> TypedTree.ValReprInfo
    val ComputeLogicalName :
      id:SyntaxTree.Ident -> memberFlags:SyntaxTree.MemberFlags -> string
    type PreValMemberInfo =
      | PreValMemberInfo of
        memberInfo: TypedTree.ValMemberInfo * logicalName: string *
        compiledName: string
    val MakeMemberDataAndMangledNameForMemberVal :
      g:TcGlobals.TcGlobals * tcref:TypedTree.TyconRef * isExtrinsic:bool *
      attrs:TypedTree.Attribs * optImplSlotTys:TypedTree.TType list *
      memberFlags:SyntaxTree.MemberFlags * valSynData:SyntaxTree.SynValInfo *
      id:SyntaxTree.Ident * isCompGen:bool -> PreValMemberInfo
    type OverridesOK =
      | OverridesOK
      | WarnOnOverrides
      | ErrorOnOverrides
    type ExplicitTyparInfo =
      | ExplicitTyparInfo of
        rigidCopyOfDeclaredTypars: TypedTree.Typars *
        declaredTypars: TypedTree.Typars * infer: bool
    val permitInferTypars : ExplicitTyparInfo
    val dontInferTypars : ExplicitTyparInfo
    type ArgAndRetAttribs =
      | ArgAndRetAttribs of TypedTree.Attribs list list * TypedTree.Attribs
    val noArgOrRetAttribs : ArgAndRetAttribs
    type DeclKind =
      | ModuleOrMemberBinding
      | IntrinsicExtensionBinding
      | ExtrinsicExtensionBinding
      | ClassLetBinding of isStatic: bool
      | ObjectExpressionOverrideBinding
      | ExpressionBinding
      with
        static member
          AllowedAttribTargets : SyntaxTree.MemberFlags option ->
                                   DeclKind -> System.AttributeTargets
        static member CanGeneralizeConstrainedTypars : DeclKind -> bool
        static member CanOverrideOrImplement : DeclKind -> OverridesOK
        static member ConvertToLinearBindings : DeclKind -> bool
        static member ImplicitlyStatic : DeclKind -> bool
        static member IsAccessModifierPermitted : DeclKind -> bool
        static member IsModuleOrMemberOrExtensionBinding : DeclKind -> bool
        static member MustHaveArity : DeclKind -> bool
        member CanBeDllImport : bool
      end
    [<SealedAttribute ()>]
    type PrelimValScheme1 =
      | PrelimValScheme1 of
        id: SyntaxTree.Ident * explicitTyparInfo: ExplicitTyparInfo *
        TypedTree.TType * PartialValReprInfo option * PreValMemberInfo option *
        bool * TypedTree.ValInline * TypedTree.ValBaseOrThisInfo *
        ArgAndRetAttribs * SyntaxTree.SynAccess option * bool
      with
        member Ident : SyntaxTree.Ident
        member Type : TypedTree.TType
      end
    type PrelimValScheme2 =
      | PrelimValScheme2 of
        SyntaxTree.Ident * TypedTreeOps.TypeScheme * PartialValReprInfo option *
        PreValMemberInfo option * bool * TypedTree.ValInline *
        TypedTree.ValBaseOrThisInfo * ArgAndRetAttribs *
        SyntaxTree.SynAccess option * bool * bool
    type ValScheme =
      | ValScheme of
        id: SyntaxTree.Ident * typeScheme: TypedTreeOps.TypeScheme *
        topValInfo: TypedTree.ValReprInfo option *
        memberInfo: PreValMemberInfo option * isMutable: bool *
        inlineInfo: TypedTree.ValInline *
        baseOrThisInfo: TypedTree.ValBaseOrThisInfo *
        visibility: SyntaxTree.SynAccess option * compgen: bool *
        isIncrClass: bool * isTyFunc: bool * hasDeclaredTypars: bool
      with
        member GeneralizedTypars : TypedTree.Typars
        member TypeScheme : TypedTreeOps.TypeScheme
        member ValReprInfo : TypedTree.ValReprInfo option
      end
    type TcPatPhase2Input =
      | TcPatPhase2Input of
        AbstractIL.Internal.Library.NameMap<TypedTree.Val *
                                            TypedTreeOps.TypeScheme> * bool
      with
        member RightPath : TcPatPhase2Input
      end
    [<SealedAttribute ()>]
    type CheckedBindingInfo =
      | CheckedBindingInfo of
        inlineFlag: TypedTree.ValInline * valAttribs: TypedTree.Attribs *
        xmlDoc: XmlDoc.XmlDoc *
        tcPatPhase2: TcPatPhase2Input -> PatternMatchCompilation.Pattern *
        exlicitTyparInfo: ExplicitTyparInfo *
        nameToPrelimValSchemeMap:
          AbstractIL.Internal.Library.NameMap<PrelimValScheme1> *
        rhsExprChecked: TypedTree.Expr * argAndRetAttribs: ArgAndRetAttribs *
        overallPatTy: TypedTree.TType * mBinding: Range.range *
        spBind: SyntaxTree.DebugPointForBinding * isCompilerGenerated: bool *
        literalValue: TypedTree.Const option * isFixed: bool
      with
        member Expr : TypedTree.Expr
        member SeqPoint : SyntaxTree.DebugPointForBinding
      end
    val GeneralizedTypeForTypeScheme :
      typeScheme:TypedTreeOps.TypeScheme -> TypedTree.TType
    val NonGenericTypeScheme : ty:TypedTree.TType -> TypedTreeOps.TypeScheme
    val UpdateAccModuleOrNamespaceType :
      cenv:TcFileState ->
        env:TcEnv ->
          f:(bool -> TypedTree.ModuleOrNamespaceType ->
               TypedTree.ModuleOrNamespaceType) -> unit
    val PublishModuleDefn :
      cenv:TcFileState -> env:TcEnv -> mspec:TypedTree.Tycon -> unit
    val PublishTypeDefn :
      cenv:TcFileState -> env:TcEnv -> mspec:TypedTree.Tycon -> unit
    val PublishValueDefnPrim :
      cenv:TcFileState -> env:TcEnv -> vspec:TypedTree.Val -> unit
    val PublishValueDefn :
      cenv:TcFileState ->
        env:TcEnv -> declKind:DeclKind -> vspec:TypedTree.Val -> unit
    val CombineVisibilityAttribs :
      vis1:'a option -> vis2:'a option -> m:Range.range -> 'a option
    val ComputeAccessAndCompPath :
      env:TcEnv ->
        declKindOpt:DeclKind option ->
          m:Range.range ->
            vis:SyntaxTree.SynAccess option ->
              overrideVis:TypedTree.Accessibility option ->
                actualParent:TypedTree.ParentRef ->
                  TypedTree.Accessibility * TypedTree.CompilationPath option
    val CheckForAbnormalOperatorNames :
      cenv:TcFileState ->
        idRange:Range.range ->
          coreDisplayName:string ->
            memberInfoOpt:TypedTree.ValMemberInfo option -> unit
    val MakeAndPublishVal :
      cenv:TcFileState ->
        env:TcEnv ->
          altActualParent:TypedTree.ParentRef * inSig:bool * declKind:DeclKind *
          vrec:TypedTree.ValRecursiveScopeInfo * vscheme:ValScheme *
          attrs:TypedTree.Attribs * doc:XmlDoc.XmlDoc *
          konst:TypedTree.Const option * isGeneratedEventVal:bool ->
            TypedTree.Val
    val MakeAndPublishVals :
      cenv:TcFileState ->
        env:TcEnv ->
          altActualParent:TypedTree.ParentRef * inSig:bool * declKind:DeclKind *
          vrec:TypedTree.ValRecursiveScopeInfo * valSchemes:Map<'a,ValScheme> *
          attrs:TypedTree.Attribs * doc:XmlDoc.XmlDoc *
          literalValue:TypedTree.Const option ->
            Map<'a,(TypedTree.Val * TypedTreeOps.TypeScheme)>
        when 'a : comparison
    val MakeAndPublishBaseVal :
      cenv:TcFileState ->
        env:TcEnv ->
          SyntaxTree.Ident option -> TypedTree.TType -> TypedTree.Val option
    val MakeAndPublishSafeThisVal :
      cenv:TcFileState ->
        env:TcEnv ->
          thisIdOpt:SyntaxTree.Ident option ->
            thisTy:TypedTree.TType -> TypedTree.Val option
    val AdjustAndForgetUsesOfRecValue :
      cenv:TcFileState ->
        vrefTgt:TypedTree.ValRef -> valScheme:ValScheme -> unit
    val AdjustRecType : vspec:TypedTree.Val -> vscheme:ValScheme -> unit
    val RecordUseOfRecValue :
      cenv:TcFileState ->
        vrec:TypedTree.ValRecursiveScopeInfo ->
          vrefTgt:TypedTree.ValRef ->
            vexp:TypedTree.Expr -> m:Range.range -> TypedTree.Expr
    [<SealedAttribute ()>]
    type RecursiveUseFixupPoints =
      | RecursiveUseFixupPoints of (TypedTree.Expr ref * Range.range) list
    val GetAllUsesOfRecValue :
      cenv:TcFileState -> vrefTgt:TypedTree.Val -> RecursiveUseFixupPoints
    val ChooseCanonicalDeclaredTyparsAfterInference :
      g:TcGlobals.TcGlobals ->
        denv:TypedTreeOps.DisplayEnv ->
          declaredTypars:TypedTree.Typar list ->
            m:Range.range -> TypedTree.Typars
    val ChooseCanonicalValSchemeAfterInference :
      g:TcGlobals.TcGlobals ->
        denv:TypedTreeOps.DisplayEnv ->
          vscheme:ValScheme -> m:Range.range -> ValScheme
    val PlaceTyparsInDeclarationOrder :
      declaredTypars:TypedTree.Typar list ->
        generalizedTypars:TypedTree.Typar list -> TypedTree.Typar list
    val SetTyparRigid :
      TypedTreeOps.DisplayEnv -> Range.range -> TypedTree.Typar -> unit
    val GeneralizeVal :
      cenv:TcFileState ->
        denv:TypedTreeOps.DisplayEnv ->
          enclosingDeclaredTypars:TypedTree.Typar list ->
            generalizedTyparsForThisBinding:TypedTree.Typar list ->
              PrelimValScheme1 -> PrelimValScheme2
    val GeneralizeVals :
      cenv:TcFileState ->
        denv:TypedTreeOps.DisplayEnv ->
          enclosingDeclaredTypars:TypedTree.Typar list ->
            generalizedTypars:TypedTree.Typar list ->
              types:AbstractIL.Internal.Library.NameMap<PrelimValScheme1> ->
                Map<string,PrelimValScheme2>
    val DontGeneralizeVals :
      types:AbstractIL.Internal.Library.NameMap<PrelimValScheme1> ->
        Map<string,PrelimValScheme2>
    val InferGenericArityFromTyScheme :
      TypedTreeOps.TypeScheme ->
        partialValReprInfo:PartialValReprInfo -> TypedTree.ValReprInfo
    val ComputeIsTyFunc :
      id:SyntaxTree.Ident * hasDeclaredTypars:bool *
      arityInfo:TypedTree.ValReprInfo option -> bool
    val UseSyntacticArity :
      declKind:DeclKind ->
        typeScheme:TypedTreeOps.TypeScheme ->
          partialValReprInfo:PartialValReprInfo -> TypedTree.ValReprInfo option
    val CombineSyntacticAndInferredArities :
      g:TcGlobals.TcGlobals ->
        declKind:DeclKind ->
          rhsExpr:TypedTree.Expr ->
            prelimScheme:PrelimValScheme2 -> PartialValReprInfo option
    val BuildValScheme :
      declKind:DeclKind ->
        partialArityInfoOpt:PartialValReprInfo option ->
          prelimScheme:PrelimValScheme2 -> ValScheme
    val UseCombinedArity :
      g:TcGlobals.TcGlobals ->
        declKind:DeclKind ->
          rhsExpr:TypedTree.Expr -> prelimScheme:PrelimValScheme2 -> ValScheme
    val UseNoArity : prelimScheme:PrelimValScheme2 -> ValScheme
    val MakeAndPublishSimpleVals :
      cenv:TcFileState ->
        env:TcEnv ->
          names:AbstractIL.Internal.Library.NameMap<PrelimValScheme1> ->
            Map<string,(TypedTree.Val * TypedTreeOps.TypeScheme)> *
            Map<string,TypedTree.Val>
    val MakeAndPublishSimpleValsForMergedScope :
      cenv:TcFileState ->
        env:TcEnv ->
          m:Range.range ->
            names:AbstractIL.Internal.Library.NameMap<PrelimValScheme1> ->
              TcEnv * Map<string,(TypedTree.Val * TypedTreeOps.TypeScheme)> *
              Map<string,TypedTree.Val>
    val FreshenTyconRef :
      m:Range.range ->
        rigid:TypedTree.TyparRigidity ->
          tcref:TypedTree.TyconRef ->
            declaredTyconTypars:TypedTree.Typar list ->
              TypedTree.TType * TypedTree.Typar list * TypedTreeOps.TyparInst *
              TypedTree.TType
    val FreshenPossibleForallTy :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          rigid:TypedTree.TyparRigidity ->
            ty:TypedTree.TType ->
              TypedTree.Typar list * TypedTree.Typar list * TypedTree.TType list *
              TypedTree.TType
    val FreshenTyconRef2 :
      m:Range.range ->
        tcref:TypedTree.TyconRef ->
          TypedTree.Typars * TypedTreeOps.TyparInst * TypedTree.TType list *
          TypedTree.TType
    val FreshenAbstractSlot :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            synTyparDecls:SyntaxTree.SynValTyparDecls ->
              absMethInfo:Infos.MethInfo ->
                bool * TypedTree.Typars * TypedTree.TType list list *
                TypedTree.TType
    val BuildFieldMap :
      cenv:TcFileState ->
        env:TcEnv ->
          isPartial:bool ->
            ty:TypedTree.TType ->
              flds:((SyntaxTree.Ident list * SyntaxTree.Ident) * 'a) list ->
                m:Range.range ->
                  TypedTree.TypeInst * TypedTree.TyconRef * Map<string,'a> *
                  (string * 'a) list
    val ApplyUnionCaseOrExn :
      makerForUnionCase:(TypedTree.UnionCaseRef * TypedTree.TypeInst -> 'a) *
      makerForExnTag:(TypedTree.TyconRef -> 'a) ->
        m:Range.range ->
          cenv:TcFileState ->
            env:TcEnv ->
              overallTy:TypedTree.TType ->
                item:NameResolution.Item ->
                  'a * TypedTree.TType list * SyntaxTree.Ident list
    val ApplyUnionCaseOrExnTypes :
      m:Range.range ->
        cenv:TcFileState ->
          env:TcEnv ->
            overallTy:TypedTree.TType ->
              c:NameResolution.Item ->
                (Range.range -> TypedTree.Exprs -> TypedTree.Expr) *
                TypedTree.TType list * SyntaxTree.Ident list
    val ApplyUnionCaseOrExnTypesForPat :
      m:Range.range ->
        cenv:TcFileState ->
          env:TcEnv ->
            overallTy:TypedTree.TType ->
              c:NameResolution.Item ->
                (Range.range -> PatternMatchCompilation.Pattern list ->
                   PatternMatchCompilation.Pattern) * TypedTree.TType list *
                SyntaxTree.Ident list
    val UnionCaseOrExnCheck :
      env:TcEnv -> numArgTys:int -> numArgs:int -> m:Range.range -> unit
    val TcUnionCaseOrExnField :
      cenv:TcFileState ->
        env:TcEnv ->
          ty1:TypedTree.TType ->
            m:Range.range ->
              c:SyntaxTree.Ident list ->
                n:int ->
                  (TypedTree.UnionCaseRef * TypedTree.TypeInst -> 'a) *
                  (TypedTree.TyconRef -> 'a) -> 'a * TypedTree.TType
    type GeneralizeConstrainedTyparOptions =
      | CanGeneralizeConstrainedTypars
      | DoNotGeneralizeConstrainedTypars
    module GeneralizationHelpers = begin
      val ComputeUngeneralizableTypars :
        env:TcEnv ->
          Internal.Utilities.Collections.Tagged.Set<TypedTree.Typar,
                                                    System.Collections.Generic.IComparer<TypedTree.Typar>>
      val ComputeUnabstractableTycons : env:TcEnv -> TypedTree.FreeTycons
      val ComputeUnabstractableTraitSolutions :
        env:TcEnv -> TypedTree.FreeLocals
      val IsGeneralizableValue :
        g:TcGlobals.TcGlobals -> t:TypedTree.Expr -> bool
      val CanGeneralizeConstrainedTyparsForDecl :
        declKind:DeclKind -> GeneralizeConstrainedTyparOptions
      val TrimUngeneralizableTypars :
        genConstrainedTyparFlag:GeneralizeConstrainedTyparOptions ->
          inlineFlag:TypedTree.ValInline ->
            generalizedTypars:TypedTree.Typar list ->
              freeInEnv:AbstractIL.Internal.Zset<TypedTree.Typar> ->
                TypedTree.Typar list * AbstractIL.Internal.Zset<TypedTree.Typar>
      val CondenseTypars :
        cenv:TcFileState * denv:TypedTreeOps.DisplayEnv *
        generalizedTypars:TypedTree.Typars * tauTy:TypedTree.TType *
        m:Range.range -> TypedTree.Typar list
      val ComputeAndGeneralizeGenericTypars :
        cenv:TcFileState * denv:TypedTreeOps.DisplayEnv * m:Range.range *
        freeInEnv:TypedTree.FreeTypars * canInferTypars:bool *
        genConstrainedTyparFlag:GeneralizeConstrainedTyparOptions *
        inlineFlag:TypedTree.ValInline * exprOpt:TypedTree.Expr option *
        allDeclaredTypars:TypedTree.Typars * maxInferredTypars:TypedTree.Typars *
        tauTy:TypedTree.TType * resultFirst:bool -> TypedTree.Typars
      val CheckDeclaredTyparsPermitted :
        memFlagsOpt:SyntaxTree.MemberFlags option * declaredTypars:'a list *
        m:Range.range -> unit
      val ComputeCanInferExtraGeneralizableTypars :
        parentRef:TypedTree.ParentRef * canInferTypars:bool *
        memFlagsOpt:SyntaxTree.MemberFlags option -> bool
    end
    val ComputeInlineFlag :
      memFlagsOption:SyntaxTree.MemberFlags option ->
        isInline:bool -> isMutable:bool -> m:Range.range -> TypedTree.ValInline
    type NormalizedBindingRhs =
      | NormalizedBindingRhs of
        simplePats: SyntaxTree.SynSimplePats list *
        returnTyOpt: SyntaxTree.SynBindingReturnInfo option *
        rhsExpr: SyntaxTree.SynExpr
    val PushOnePatternToRhs :
      cenv:cenv ->
        isMember:bool ->
          p:SyntaxTree.SynPat -> NormalizedBindingRhs -> NormalizedBindingRhs
    type NormalizedBindingPatternInfo =
      | NormalizedBindingPat of
        SyntaxTree.SynPat * NormalizedBindingRhs * SyntaxTree.SynValData *
        SyntaxTree.SynValTyparDecls
    type NormalizedBinding =
      | NormalizedBinding of
        visibility: SyntaxTree.SynAccess option *
        kind: SyntaxTree.SynBindingKind * mustInline: bool * isMutable: bool *
        attribs: SyntaxTree.SynAttribute list * xmlDoc: XmlDoc.XmlDoc *
        typars: SyntaxTree.SynValTyparDecls * valSynData: SyntaxTree.SynValData *
        pat: SyntaxTree.SynPat * rhsExpr: NormalizedBindingRhs *
        mBinding: Range.range * spBinding: SyntaxTree.DebugPointForBinding
    type IsObjExprBinding =
      | ObjExprBinding
      | ValOrMemberBinding
    module BindingNormalization = begin
      val private PushMultiplePatternsToRhs :
        cenv:cenv ->
          isMember:bool ->
            ps:SyntaxTree.SynPat list ->
              NormalizedBindingRhs -> NormalizedBindingRhs
      val private MakeNormalizedStaticOrValBinding :
        cenv:cenv ->
          isObjExprBinding:IsObjExprBinding ->
            id:SyntaxTree.Ident ->
              vis:SyntaxTree.SynAccess option ->
                typars:SyntaxTree.SynValTyparDecls ->
                  args:SyntaxTree.SynPat list ->
                    rhsExpr:NormalizedBindingRhs ->
                      valSynData:SyntaxTree.SynValData ->
                        NormalizedBindingPatternInfo
      val private MakeNormalizedInstanceMemberBinding :
        cenv:cenv ->
          thisId:SyntaxTree.Ident ->
            memberId:SyntaxTree.Ident ->
              toolId:SyntaxTree.Ident option ->
                vis:SyntaxTree.SynAccess option ->
                  m:Range.range ->
                    typars:SyntaxTree.SynValTyparDecls ->
                      args:SyntaxTree.SynPat list ->
                        rhsExpr:NormalizedBindingRhs ->
                          valSynData:SyntaxTree.SynValData ->
                            NormalizedBindingPatternInfo
      val private NormalizeStaticMemberBinding :
        cenv:cenv ->
          memberFlags:SyntaxTree.MemberFlags ->
            valSynData:SyntaxTree.SynValData ->
              id:SyntaxTree.Ident ->
                vis:SyntaxTree.SynAccess option ->
                  typars:SyntaxTree.SynValTyparDecls ->
                    args:SyntaxTree.SynPat list ->
                      m:Range.range ->
                        rhsExpr:NormalizedBindingRhs ->
                          NormalizedBindingPatternInfo
      val private NormalizeInstanceMemberBinding :
        cenv:cenv ->
          memberFlags:SyntaxTree.MemberFlags ->
            valSynData:SyntaxTree.SynValData ->
              thisId:SyntaxTree.Ident ->
                memberId:SyntaxTree.Ident ->
                  toolId:SyntaxTree.Ident option ->
                    vis:SyntaxTree.SynAccess option ->
                      typars:SyntaxTree.SynValTyparDecls ->
                        args:SyntaxTree.SynPat list ->
                          m:Range.range ->
                            rhsExpr:NormalizedBindingRhs ->
                              NormalizedBindingPatternInfo
      val private NormalizeBindingPattern :
        cenv:TcFileState ->
          nameResolver:NameResolution.NameResolver ->
            isObjExprBinding:IsObjExprBinding ->
              env:TcEnv ->
                valSynData:SyntaxTree.SynValData ->
                  pat:SyntaxTree.SynPat ->
                    rhsExpr:NormalizedBindingRhs -> NormalizedBindingPatternInfo
      val NormalizeBinding :
        isObjExprBinding:IsObjExprBinding ->
          cenv:TcFileState ->
            env:TcEnv -> binding:SyntaxTree.SynBinding -> NormalizedBinding
    end
    module EventDeclarationNormalization = begin
      val ConvertSynInfo :
        m:Range.range -> SyntaxTree.SynValInfo -> SyntaxTree.SynValInfo
      val ConvertMemberFlags :
        memberFlags:SyntaxTree.MemberFlags -> SyntaxTree.MemberFlags
      val private ConvertMemberFlagsOpt :
        m:Range.range ->
          memberFlagsOpt:SyntaxTree.MemberFlags option ->
            SyntaxTree.MemberFlags option
      val private ConvertSynData :
        m:Range.range ->
          valSynData:SyntaxTree.SynValData -> SyntaxTree.SynValData
      val private RenameBindingPattern :
        f:(string -> string) ->
          declPattern:SyntaxTree.SynPat -> SyntaxTree.SynPat
      val GenerateExtraBindings :
        cenv:TcFileState ->
          bindingAttribs:TypedTree.Attribs * binding:NormalizedBinding ->
            NormalizedBinding list
    end
    val FreshenObjectArgType :
      cenv:TcFileState ->
        m:Range.range ->
          rigid:TypedTree.TyparRigidity ->
            tcref:TypedTree.TyconRef ->
              isExtrinsic:bool ->
                declaredTyconTypars:TypedTree.Typar list ->
                  TypedTree.TType * TypedTree.Typar list *
                  TypedTreeOps.TyparInst * TypedTree.TType * TypedTree.TType
    val TcValEarlyGeneralizationConsistencyCheck :
      cenv:TcFileState ->
        env:TcEnv ->
          v:TypedTree.Val * vrec:TypedTree.ValRecursiveScopeInfo *
          tinst:TypedTree.TType list * vty:TypedTree.TType * tau:TypedTree.TType *
          m:Range.range -> unit
    val TcVal :
      checkAttributes:bool ->
        cenv:TcFileState ->
          env:TcEnv ->
            tpenv:'a ->
              vref:TypedTree.ValRef ->
                optInst:(TypedTree.ValUseFlag *
                         ('a -> TypedTree.TyparKind list ->
                            TypedTree.TypeInst * 'a)) option ->
                  optAfterResolution:NameResolution.AfterResolution option ->
                    m:Range.range ->
                      TypedTree.Typar list * TypedTree.Expr * bool *
                      TypedTree.TType * TypedTree.TType list * 'a
    val LightweightTcValForUsingInBuildMethodCall :
      g:TcGlobals.TcGlobals ->
        vref:TypedTree.ValRef ->
          vrefFlags:TypedTree.ValUseFlag ->
            vrefTypeInst:TypedTree.TTypes ->
              m:Range.range -> TypedTree.Expr * TypedTree.TType
    type ApplicableExpr =
      | ApplicableExpr of cenv * TypedTree.Expr * bool
      with
        member
          SupplyArgument : e2:TypedTree.Expr * m:Range.range -> ApplicableExpr
        member Expr : TypedTree.Expr
        member Range : Range.range
        member Type : TypedTree.TType
      end
    val MakeApplicableExprNoFlex :
      cenv:cenv -> expr:TypedTree.Expr -> ApplicableExpr
    val MakeApplicableExprWithFlex :
      cenv:TcFileState -> env:TcEnv -> expr:TypedTree.Expr -> ApplicableExpr
    val TcRuntimeTypeTest :
      isCast:bool ->
        isOperator:bool ->
          cenv:TcFileState ->
            denv:TypedTreeOps.DisplayEnv ->
              m:Range.range ->
                tgtTy:TypedTree.TType -> srcTy:TypedTree.TType -> unit
    val TcStaticUpcast :
      cenv:TcFileState ->
        denv:TypedTreeOps.DisplayEnv ->
          m:Range.range ->
            tgtTy:TypedTree.TType -> srcTy:TypedTree.TType -> unit
    val BuildPossiblyConditionalMethodCall :
      cenv:TcFileState ->
        env:TcEnv ->
          isMutable:TypedTreeOps.Mutates ->
            m:Range.range ->
              isProp:bool ->
                minfo:Infos.MethInfo ->
                  valUseFlags:TypedTree.ValUseFlag ->
                    minst:TypedTree.TType list ->
                      objArgs:TypedTree.Expr list ->
                        args:TypedTree.Exprs -> TypedTree.Expr * TypedTree.TType
    val TryFindIntrinsicOrExtensionMethInfo :
      collectionSettings:NameResolution.ResultCollectionSettings ->
        cenv:cenv ->
          env:TcEnv ->
            m:Range.range ->
              ad:AccessibilityLogic.AccessorDomain ->
                nm:string -> ty:TypedTree.TType -> Infos.MethInfo list
    val TryFindFSharpSignatureInstanceGetterProperty :
      cenv:cenv ->
        env:TcEnv ->
          m:Range.range ->
            nm:string ->
              ty:TypedTree.TType ->
                sigTys:TypedTree.TType list -> Infos.PropInfo option
    val BuildDisposableCleanup :
      cenv:cenv ->
        env:TcEnv -> m:Range.range -> v:TypedTree.Val -> TypedTree.Expr
    val BuildOffsetToStringData :
      cenv:cenv -> env:TcEnv -> m:Range.range -> TypedTree.Expr
    val BuildILFieldGet :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            objExpr:TypedTree.Expr -> finfo:Infos.ILFieldInfo -> TypedTree.Expr
    val private CheckFieldLiteralArg :
      finfo:Infos.ILFieldInfo -> argExpr:TypedTree.Expr -> m:Range.range -> unit
    val BuildILFieldSet :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          objExpr:TypedTree.Expr ->
            finfo:Infos.ILFieldInfo -> argExpr:TypedTree.Expr -> TypedTree.Expr
    val BuildILStaticFieldSet :
      m:Range.range ->
        finfo:Infos.ILFieldInfo -> argExpr:TypedTree.Expr -> TypedTree.Expr
    val BuildRecdFieldSet :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          objExpr:TypedTree.Expr ->
            rfinfo:Infos.RecdFieldInfo ->
              argExpr:TypedTree.Expr -> TypedTree.Expr
    val ( |BinOpExpr|_| ) :
      SyntaxTree.SynExpr ->
        (SyntaxTree.Ident * SyntaxTree.SynExpr * SyntaxTree.SynExpr) option
    val ( |SimpleEqualsExpr|_| ) :
      e:SyntaxTree.SynExpr -> (SyntaxTree.SynExpr * SyntaxTree.SynExpr) option
    val TryGetNamedArg :
      e:SyntaxTree.SynExpr ->
        (bool * SyntaxTree.Ident * SyntaxTree.SynExpr) option
    val inline IsNamedArg : e:SyntaxTree.SynExpr -> bool
    val GetMethodArgs :
      arg:SyntaxTree.SynExpr ->
        SyntaxTree.SynExpr list *
        (bool * SyntaxTree.Ident * SyntaxTree.SynExpr) list
    val CompilePatternForMatch :
      cenv:TcFileState ->
        env:TcEnv ->
          mExpr:Range.range ->
            matchm:Range.range ->
              warnOnUnused:bool ->
                actionOnFailure:PatternMatchCompilation.ActionOnFailure ->
                  inputVal:TypedTree.Val * generalizedTypars:TypedTree.Typars *
                  inputExprOpt:TypedTree.Expr option ->
                    clauses:PatternMatchCompilation.TypedMatchClause list ->
                      inputTy:TypedTree.TType ->
                        resultTy:TypedTree.TType -> TypedTree.Expr
    val CompilePatternForMatchClauses :
      cenv:TcFileState ->
        env:TcEnv ->
          mExpr:Range.range ->
            matchm:Range.range ->
              warnOnUnused:bool ->
                actionOnFailure:PatternMatchCompilation.ActionOnFailure ->
                  inputExprOpt:TypedTree.Expr option ->
                    inputTy:TypedTree.TType ->
                      resultTy:TypedTree.TType ->
                        tclauses:PatternMatchCompilation.TypedMatchClause list ->
                          TypedTree.Val * TypedTree.Expr
    val AnalyzeArbitraryExprAsEnumerable :
      cenv:cenv ->
        env:TcEnv ->
          localAlloc:bool ->
            m:Range.range ->
              exprty:TypedTree.TType ->
                expr:TypedTree.Expr ->
                  TypedTree.Val * TypedTree.Expr * TypedTree.TType *
                  TypedTree.TType * TypedTree.Expr * TypedTree.TType *
                  TypedTree.Expr * TypedTree.TType * TypedTree.Expr
    val ConvertArbitraryExprToEnumerable :
      cenv:cenv ->
        ty:TypedTree.TType ->
          env:TcEnv -> expr:TypedTree.Expr -> TypedTree.Expr * TypedTree.TType
    type InitializationGraphAnalysisState =
      | Top
      | InnerTop
      | DefinitelyStrict
      | MaybeLazy
      | DefinitelyLazy
    type PreInitializationGraphEliminationBinding =
      { FixupPoints: RecursiveUseFixupPoints
        Binding: TypedTree.Binding }
    val EliminateInitializationGraphs :
      g:TcGlobals.TcGlobals ->
        mustHaveArity:bool ->
          denv:TypedTreeOps.DisplayEnv ->
            bindings:'Binding list ->
              iterBindings:((PreInitializationGraphEliminationBinding list ->
                               unit) -> 'Binding list -> unit) ->
                buildLets:(TypedTree.Binding list -> 'Result) ->
                  mapBindings:((PreInitializationGraphEliminationBinding list ->
                                  TypedTree.Binding list) -> 'Binding list ->
                                 'Result list) ->
                    bindsm:Range.range -> 'Result list
    val CheckAndRewriteObjectCtor :
      g:TcGlobals.TcGlobals ->
        env:TcEnv -> ctorLambdaExpr:TypedTree.Expr -> TypedTree.Expr
    val buildApp :
      cenv:TcFileState ->
        expr:ApplicableExpr ->
          resultTy:TypedTree.TType ->
            arg:TypedTree.Expr ->
              m:Range.range -> ApplicableExpr * TypedTree.TType
    type DelayedItem =
      | DelayedTypeApp of SyntaxTree.SynType list * Range.range * Range.range
      | DelayedApp of
        SyntaxTree.ExprAtomicFlag * SyntaxTree.SynExpr * Range.range
      | DelayedDotLookup of SyntaxTree.Ident list * Range.range
      | DelayedDot
      | DelayedSet of SyntaxTree.SynExpr * Range.range
    val MakeDelayedSet : e:SyntaxTree.SynExpr * m:Range.range -> DelayedItem
    type NewSlotsOK =
      | NewSlotsOK
      | NoNewSlots
    type ImplicitlyBoundTyparsAllowed =
      | NewTyparsOKButWarnIfNotRigid
      | NewTyparsOK
      | NoNewTypars
    type CheckConstraints =
      | CheckCxs
      | NoCheckCxs
    type MemberOrValContainerInfo =
      | MemberOrValContainerInfo of
        tcref: TypedTree.TyconRef *
        optIntfSlotTy: (TypedTree.TType * MethodOverrides.SlotImplSet) option *
        baseValOpt: TypedTree.Val option * safeInitInfo: SafeInitData *
        declaredTyconTypars: TypedTree.Typars
    type ContainerInfo =
      | ContainerInfo of TypedTree.ParentRef * MemberOrValContainerInfo option
      with
        member ParentRef : TypedTree.ParentRef
      end
    val ExprContainerInfo : ContainerInfo
    type NormalizedRecBindingDefn =
      | NormalizedRecBindingDefn of
        containerInfo: ContainerInfo * newslotsOk: NewSlotsOK *
        declKind: DeclKind * binding: NormalizedBinding
    type ValSpecResult =
      | ValSpecResult of
        altActualParent: TypedTree.ParentRef *
        memberInfoOpt: PreValMemberInfo option * id: SyntaxTree.Ident *
        enclosingDeclaredTypars: TypedTree.Typars *
        declaredTypars: TypedTree.Typars * ty: TypedTree.TType *
        partialValReprInfo: PartialValReprInfo * declKind: DeclKind
    type RecDefnBindingInfo =
      | RecDefnBindingInfo of
        containerInfo: ContainerInfo * newslotsOk: NewSlotsOK *
        declKind: DeclKind * synBinding: SyntaxTree.SynBinding
    type RecursiveBindingInfo =
      | RecursiveBindingInfo of
        recBindIndex: int * containerInfo: ContainerInfo *
        enclosingDeclaredTypars: TypedTree.Typars *
        inlineFlag: TypedTree.ValInline * vspec: TypedTree.Val *
        explicitTyparInfo: ExplicitTyparInfo *
        partialValReprInfo: PartialValReprInfo *
        memberInfoOpt: PreValMemberInfo option *
        baseValOpt: TypedTree.Val option * safeThisValOpt: TypedTree.Val option *
        safeInitInfo: SafeInitData * visibility: SyntaxTree.SynAccess option *
        ty: TypedTree.TType * declKind: DeclKind
      with
        member ContainerInfo : ContainerInfo
        member DeclKind : DeclKind
        member DeclaredTypars : TypedTree.Typars
        member EnclosingDeclaredTypars : TypedTree.Typars
        member ExplicitTyparInfo : ExplicitTyparInfo
        member Index : int
        member Val : TypedTree.Val
      end
    type PreCheckingRecursiveBinding =
      { SyntacticBinding: NormalizedBinding
        RecBindingInfo: RecursiveBindingInfo }
    type PreGeneralizationRecursiveBinding =
      { ExtraGeneralizableTypars: TypedTree.Typars
        CheckedBinding: CheckedBindingInfo
        RecBindingInfo: RecursiveBindingInfo }
    type PostGeneralizationRecursiveBinding =
      { ValScheme: ValScheme
        CheckedBinding: CheckedBindingInfo
        RecBindingInfo: RecursiveBindingInfo }
      with
        member GeneralizedTypars : TypedTree.Typars
      end
    type PostSpecialValsRecursiveBinding =
      { ValScheme: ValScheme
        Binding: TypedTree.Binding }
    val CanInferExtraGeneralizedTyparsForRecBinding :
      pgrbind:PreGeneralizationRecursiveBinding -> bool
    val GetInstanceMemberThisVariable :
      vspec:TypedTree.Val * expr:TypedTree.Expr -> TypedTree.Val option
    val TcTyparConstraint :
      ridx:int ->
        cenv:TcFileState ->
          newOk:ImplicitlyBoundTyparsAllowed ->
            checkCxs:CheckConstraints ->
              occ:NameResolution.ItemOccurence ->
                env:TcEnv ->
                  tpenv:UnscopedTyparEnv ->
                    c:SyntaxTree.SynTypeConstraint -> UnscopedTyparEnv
    val TcPseudoMemberSpec :
      cenv:TcFileState ->
        newOk:ImplicitlyBoundTyparsAllowed ->
          env:TcEnv ->
            synTypes:SyntaxTree.SynType list ->
              tpenv:UnscopedTyparEnv ->
                memSpfn:SyntaxTree.SynMemberSig ->
                  m:Range.range ->
                    TypedTree.TraitConstraintInfo * UnscopedTyparEnv
    val TcValSpec :
      cenv:TcFileState ->
        TcEnv ->
          DeclKind ->
            ImplicitlyBoundTyparsAllowed ->
              ContainerInfo ->
                SyntaxTree.MemberFlags option ->
                  thisTyOpt:TypedTree.TType option ->
                    UnscopedTyparEnv ->
                      SyntaxTree.SynValSig ->
                        TypedTree.Attrib list ->
                          ValSpecResult list * UnscopedTyparEnv
    val TcTyparOrMeasurePar :
      optKind:TypedTree.TyparKind option ->
        cenv:TcFileState ->
          env:TcEnv ->
            newOk:ImplicitlyBoundTyparsAllowed ->
              tpenv:UnscopedTyparEnv ->
                SyntaxTree.SynTypar -> TypedTree.Typar * UnscopedTyparEnv
    val TcTypar :
      cenv:TcFileState ->
        env:TcEnv ->
          newOk:ImplicitlyBoundTyparsAllowed ->
            tpenv:UnscopedTyparEnv ->
              tp:SyntaxTree.SynTypar -> TypedTree.Typar * UnscopedTyparEnv
    val TcTyparDecl :
      cenv:TcFileState ->
        env:TcEnv -> SyntaxTree.SynTyparDecl -> TypedTree.Typar
    val TcTyparDecls :
      cenv:TcFileState ->
        env:TcEnv ->
          synTypars:SyntaxTree.SynTyparDecl list -> TypedTree.Typar list
    val TcTypeOrMeasure :
      optKind:TypedTree.TyparKind option ->
        cenv:TcFileState ->
          newOk:ImplicitlyBoundTyparsAllowed ->
            checkCxs:CheckConstraints ->
              occ:NameResolution.ItemOccurence ->
                env:TcEnv ->
                  tpenv:UnscopedTyparEnv ->
                    ty:SyntaxTree.SynType -> TypedTree.TType * UnscopedTyparEnv
    val TcType :
      cenv:TcFileState ->
        newOk:ImplicitlyBoundTyparsAllowed ->
          checkCxs:CheckConstraints ->
            occ:NameResolution.ItemOccurence ->
              env:TcEnv ->
                tpenv:UnscopedTyparEnv ->
                  ty:SyntaxTree.SynType -> TypedTree.TType * UnscopedTyparEnv
    val TcMeasure :
      cenv:TcFileState ->
        newOk:ImplicitlyBoundTyparsAllowed ->
          checkCxs:CheckConstraints ->
            occ:NameResolution.ItemOccurence ->
              env:TcEnv ->
                tpenv:UnscopedTyparEnv ->
                  SyntaxTree.SynType ->
                    m:Range.range -> TypedTree.Measure * UnscopedTyparEnv
    val TcAnonTypeOrMeasure :
      optKind:TypedTree.TyparKind option ->
        _cenv:TcFileState ->
          rigid:TypedTree.TyparRigidity ->
            dyn:TypedTree.TyparDynamicReq ->
              newOk:ImplicitlyBoundTyparsAllowed ->
                m:Range.range -> TypedTree.Typar
    val TcTypes :
      cenv:TcFileState ->
        newOk:ImplicitlyBoundTyparsAllowed ->
          checkCxs:CheckConstraints ->
            occ:NameResolution.ItemOccurence ->
              env:TcEnv ->
                tpenv:UnscopedTyparEnv ->
                  args:SyntaxTree.SynType list ->
                    TypedTree.TType list * UnscopedTyparEnv
    val TcTypesAsTuple :
      cenv:TcFileState ->
        newOk:ImplicitlyBoundTyparsAllowed ->
          checkCxs:CheckConstraints ->
            occ:NameResolution.ItemOccurence ->
              env:TcEnv ->
                tpenv:UnscopedTyparEnv ->
                  args:(bool * SyntaxTree.SynType) list ->
                    m:Range.range -> TypedTree.TTypes * UnscopedTyparEnv
    val TcMeasuresAsTuple :
      cenv:TcFileState ->
        newOk:ImplicitlyBoundTyparsAllowed ->
          checkCxs:CheckConstraints ->
            occ:NameResolution.ItemOccurence ->
              env:TcEnv ->
                tpenv:UnscopedTyparEnv ->
                  args:(bool * SyntaxTree.SynType) list ->
                    m:Range.range -> TypedTree.Measure * UnscopedTyparEnv
    val TcTypesOrMeasures :
      optKinds:TypedTree.TyparKind list option ->
        cenv:TcFileState ->
          newOk:ImplicitlyBoundTyparsAllowed ->
            checkCxs:CheckConstraints ->
              occ:NameResolution.ItemOccurence ->
                env:TcEnv ->
                  tpenv:UnscopedTyparEnv ->
                    args:SyntaxTree.SynType list ->
                      m:Range.range -> TypedTree.TType list * UnscopedTyparEnv
    val TcTyparConstraints :
      cenv:TcFileState ->
        newOk:ImplicitlyBoundTyparsAllowed ->
          checkCxs:CheckConstraints ->
            occ:NameResolution.ItemOccurence ->
              env:TcEnv ->
                tpenv:UnscopedTyparEnv ->
                  synConstraints:SyntaxTree.SynTypeConstraint list ->
                    UnscopedTyparEnv
    val TcStaticConstantParameter :
      cenv:TcFileState ->
        env:TcEnv ->
          tpenv:UnscopedTyparEnv ->
            kind:TypedTree.TType ->
              SyntaxTree.SynType ->
                idOpt:SyntaxTree.Ident option ->
                  container:NameResolution.ArgumentContainer ->
                    obj * UnscopedTyparEnv
    val CrackStaticConstantArgs :
      cenv:TcFileState ->
        env:TcEnv ->
          tpenv:UnscopedTyparEnv ->
            staticParameters:Tainted<ExtensionTyping.ProvidedParameterInfo> [] *
            args:SyntaxTree.SynType list *
            container:NameResolution.ArgumentContainer *
            containerName:System.String * m:Range.range -> obj []
    val TcProvidedTypeAppToStaticConstantArgs :
      cenv:TcFileState ->
        env:TcEnv ->
          optGeneratedTypePath:string list option ->
            tpenv:UnscopedTyparEnv ->
              tcref:TypedTree.TyconRef ->
                args:SyntaxTree.SynType list ->
                  m:Range.range ->
                    bool * Tainted<ExtensionTyping.ProvidedType> *
                    (unit -> unit)
    val TryTcMethodAppToStaticConstantArgs :
      cenv:TcFileState ->
        env:TcEnv ->
          tpenv:UnscopedTyparEnv ->
            minfos:Infos.MethInfo list *
            argsOpt:(SyntaxTree.SynType list * 'a) option *
            mExprAndArg:Range.range * mItem:Range.range -> Infos.MethInfo option
    val TcProvidedMethodAppToStaticConstantArgs :
      cenv:TcFileState ->
        env:TcEnv ->
          tpenv:UnscopedTyparEnv ->
            minfo:Infos.MethInfo *
            methBeforeArguments:Tainted<ExtensionTyping.ProvidedMethodBase> *
            staticParams:Tainted<ExtensionTyping.ProvidedParameterInfo> [] *
            args:SyntaxTree.SynType list * m:Range.range ->
              Tainted<ExtensionTyping.ProvidedMethodBase>
    val TcProvidedTypeApp :
      cenv:TcFileState ->
        env:TcEnv ->
          tpenv:UnscopedTyparEnv ->
            tcref:TypedTree.TyconRef ->
              args:SyntaxTree.SynType list ->
                m:Range.range -> TypedTree.TType * UnscopedTyparEnv
    val TcTypeApp :
      cenv:TcFileState ->
        newOk:ImplicitlyBoundTyparsAllowed ->
          checkCxs:CheckConstraints ->
            occ:NameResolution.ItemOccurence ->
              env:TcEnv ->
                tpenv:UnscopedTyparEnv ->
                  m:Range.range ->
                    tcref:TypedTree.TyconRef ->
                      pathTypeArgs:NameResolution.EnclosingTypeInst ->
                        synArgTys:SyntaxTree.SynType list ->
                          TypedTree.TType * UnscopedTyparEnv
    val TcTypeOrMeasureAndRecover :
      optKind:TypedTree.TyparKind option ->
        cenv:TcFileState ->
          newOk:ImplicitlyBoundTyparsAllowed ->
            checkCxs:CheckConstraints ->
              occ:NameResolution.ItemOccurence ->
                env:TcEnv ->
                  tpenv:UnscopedTyparEnv ->
                    ty:SyntaxTree.SynType -> TypedTree.TType * UnscopedTyparEnv
    val TcTypeAndRecover :
      cenv:TcFileState ->
        newOk:ImplicitlyBoundTyparsAllowed ->
          checkCxs:CheckConstraints ->
            occ:NameResolution.ItemOccurence ->
              env:TcEnv ->
                tpenv:UnscopedTyparEnv ->
                  ty:SyntaxTree.SynType -> TypedTree.TType * UnscopedTyparEnv
    val TcNestedTypeApplication :
      cenv:TcFileState ->
        newOk:ImplicitlyBoundTyparsAllowed ->
          checkCxs:CheckConstraints ->
            occ:NameResolution.ItemOccurence ->
              env:TcEnv ->
                tpenv:UnscopedTyparEnv ->
                  mWholeTypeApp:Range.range ->
                    ty:TypedTree.TType ->
                      pathTypeArgs:NameResolution.EnclosingTypeInst ->
                        tyargs:SyntaxTree.SynType list ->
                          TypedTree.TType * UnscopedTyparEnv
    val TryAdjustHiddenVarNameToCompGenName :
      cenv:TcFileState ->
        env:TcEnv ->
          id:SyntaxTree.Ident ->
            altNameRefCellOpt:Ref<SyntaxTree.SynSimplePatAlternativeIdInfo> option ->
              SyntaxTree.Ident option
    val TcSimplePat :
      optArgsOK:bool ->
        checkCxs:CheckConstraints ->
          cenv:TcFileState ->
            ty:TypedTree.TType ->
              env:TcEnv ->
                tpenv:UnscopedTyparEnv * names:Map<string,PrelimValScheme1> *
                takenNames:Set<string> ->
                  p:SyntaxTree.SynSimplePat ->
                    string *
                    (UnscopedTyparEnv * Map<string,PrelimValScheme1> *
                     Set<string>)
    val ValidateOptArgOrder : spats:SyntaxTree.SynSimplePats -> unit
    val TcSimplePats :
      cenv:TcFileState ->
        optArgsOK:bool ->
          checkCxs:CheckConstraints ->
            ty:TypedTree.TType ->
              env:TcEnv ->
                tpenv:UnscopedTyparEnv * names:Map<string,PrelimValScheme1> *
                takenNames:Set<string> ->
                  p:SyntaxTree.SynSimplePats ->
                    string list *
                    (UnscopedTyparEnv * Map<string,PrelimValScheme1> *
                     Set<string>)
    val TcSimplePatsOfUnknownType :
      cenv:TcFileState ->
        optArgsOK:bool ->
          checkCxs:CheckConstraints ->
            env:TcEnv ->
              tpenv:UnscopedTyparEnv ->
                spats:SyntaxTree.SynSimplePats ->
                  string list *
                  (UnscopedTyparEnv * Map<string,PrelimValScheme1> * Set<string>)
    val TcPatBindingName :
      cenv:TcFileState ->
        env:TcEnv ->
          id:SyntaxTree.Ident ->
            ty:TypedTree.TType ->
              isMemberThis:bool ->
                vis1:SyntaxTree.SynAccess option ->
                  topValData:PartialValReprInfo option ->
                    inlineFlag:TypedTree.ValInline *
                    declaredTypars:ExplicitTyparInfo *
                    argAttribs:ArgAndRetAttribs * isMutable:bool *
                    vis2:SyntaxTree.SynAccess option * compgen:bool ->
                      names:Map<string,PrelimValScheme1> *
                      takenNames:Set<string> ->
                        (TcPatPhase2Input ->
                           PatternMatchCompilation.PatternValBinding) *
                        Map<string,PrelimValScheme1> * Set<string>
    val TcPatAndRecover :
      warnOnUpper:NameResolution.WarnOnUpperFlag ->
        cenv:TcFileState ->
          env:TcEnv ->
            topValInfo:PartialValReprInfo option ->
              TypedTree.ValInline * ExplicitTyparInfo * ArgAndRetAttribs * bool *
              SyntaxTree.SynAccess option * bool ->
                tpenv:UnscopedTyparEnv * names:Map<string,PrelimValScheme1> *
                takenNames:Set<string> ->
                  ty:TypedTree.TType ->
                    pat:SyntaxTree.SynPat ->
                      (TcPatPhase2Input -> PatternMatchCompilation.Pattern) *
                      (UnscopedTyparEnv * Map<string,PrelimValScheme1> *
                       Set<string>)
    val TcPat :
      warnOnUpper:NameResolution.WarnOnUpperFlag ->
        cenv:TcFileState ->
          env:TcEnv ->
            topValInfo:PartialValReprInfo option ->
              TypedTree.ValInline * ExplicitTyparInfo * ArgAndRetAttribs * bool *
              SyntaxTree.SynAccess option * bool ->
                tpenv:UnscopedTyparEnv * names:Map<string,PrelimValScheme1> *
                takenNames:Set<string> ->
                  ty:TypedTree.TType ->
                    pat:SyntaxTree.SynPat ->
                      (TcPatPhase2Input -> PatternMatchCompilation.Pattern) *
                      (UnscopedTyparEnv * Map<string,PrelimValScheme1> *
                       Set<string>)
    val TcPatterns :
      warnOnUpper:NameResolution.WarnOnUpperFlag ->
        cenv:TcFileState ->
          env:TcEnv ->
            TypedTree.ValInline * ExplicitTyparInfo * ArgAndRetAttribs * bool *
            SyntaxTree.SynAccess option * bool ->
              UnscopedTyparEnv * Map<string,PrelimValScheme1> * Set<string> ->
                argTys:TypedTree.TType list ->
                  args:SyntaxTree.SynPat list ->
                    (TcPatPhase2Input -> PatternMatchCompilation.Pattern) list *
                    (UnscopedTyparEnv * Map<string,PrelimValScheme1> *
                     Set<string>)
    val solveTypAsError :
      cenv:TcFileState ->
        denv:TypedTreeOps.DisplayEnv ->
          m:Range.range -> ty:TypedTree.TType -> unit
    val RecordNameAndTypeResolutions_IdeallyWithoutHavingOtherEffects :
      cenv:TcFileState ->
        env:TcEnv -> tpenv:UnscopedTyparEnv -> expr:SyntaxTree.SynExpr -> unit
    val RecordNameAndTypeResolutions_IdeallyWithoutHavingOtherEffects_Delayed :
      cenv:TcFileState ->
        env:TcEnv -> tpenv:UnscopedTyparEnv -> delayed:DelayedItem list -> unit
    val UnifyTypesAndRecover :
      cenv:TcFileState ->
        env:TcEnv ->
          m:Range.range ->
            expectedTy:TypedTree.TType -> actualTy:TypedTree.TType -> unit
    val TcExprOfUnknownType :
      cenv:TcFileState ->
        env:TcEnv ->
          tpenv:UnscopedTyparEnv ->
            expr:SyntaxTree.SynExpr ->
              TypedTree.Expr * TypedTree.TType * UnscopedTyparEnv
    val TcExprFlex :
      cenv:TcFileState ->
        flex:bool ->
          compat:bool ->
            ty:TypedTree.TType ->
              env:TcEnv ->
                tpenv:UnscopedTyparEnv ->
                  e:SyntaxTree.SynExpr -> TypedTree.Expr * UnscopedTyparEnv
    val TcExpr :
      cenv:TcFileState ->
        ty:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              expr:SyntaxTree.SynExpr -> TypedTree.Expr * UnscopedTyparEnv
    val TcExprNoRecover :
      cenv:TcFileState ->
        ty:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              expr:SyntaxTree.SynExpr -> TypedTree.Expr * UnscopedTyparEnv
    val TcExprOfUnknownTypeThen :
      cenv:TcFileState ->
        env:TcEnv ->
          tpenv:UnscopedTyparEnv ->
            expr:SyntaxTree.SynExpr ->
              delayed:DelayedItem list ->
                TypedTree.Expr * TypedTree.TType * UnscopedTyparEnv
    val TcExprThatIsCtorBody :
      TypedTree.Val option * SafeInitData ->
        cenv:TcFileState ->
          overallTy:TypedTree.TType ->
            env:TcEnv ->
              tpenv:UnscopedTyparEnv ->
                expr:SyntaxTree.SynExpr -> TypedTree.Expr * UnscopedTyparEnv
    val TcExprThatCanBeCtorBody :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              expr:SyntaxTree.SynExpr -> TypedTree.Expr * UnscopedTyparEnv
    val TcExprThatCantBeCtorBody :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              expr:SyntaxTree.SynExpr -> TypedTree.Expr * UnscopedTyparEnv
    val TcStmtThatCantBeCtorBody :
      cenv:TcFileState ->
        env:TcEnv ->
          tpenv:UnscopedTyparEnv ->
            expr:SyntaxTree.SynExpr -> TypedTree.Expr * UnscopedTyparEnv
    val TcStmt :
      cenv:TcFileState ->
        env:TcEnv ->
          tpenv:UnscopedTyparEnv ->
            synExpr:SyntaxTree.SynExpr -> TypedTree.Expr * UnscopedTyparEnv
    val TryTcStmt :
      cenv:TcFileState ->
        env:TcEnv ->
          tpenv:UnscopedTyparEnv ->
            synExpr:SyntaxTree.SynExpr ->
              bool * TypedTree.Expr * UnscopedTyparEnv
    val TcExprThen :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              synExpr:SyntaxTree.SynExpr ->
                delayed:DelayedItem list -> TypedTree.Expr * UnscopedTyparEnv
    val TcExprs :
      cenv:TcFileState ->
        env:TcEnv ->
          m:Range.range ->
            tpenv:UnscopedTyparEnv ->
              flexes:bool list ->
                argTys:TypedTree.TType list ->
                  args:SyntaxTree.SynExpr list ->
                    TypedTree.Expr list * UnscopedTyparEnv
    val CheckSuperInit :
      cenv:TcFileState -> objTy:TypedTree.TType -> m:Range.range -> unit
    val TcExprUndelayedNoType :
      cenv:TcFileState ->
        env:TcEnv ->
          tpenv:UnscopedTyparEnv ->
            synExpr:SyntaxTree.SynExpr ->
              TypedTree.Expr * TypedTree.TType * UnscopedTyparEnv
    val TcExprUndelayed :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              synExpr:SyntaxTree.SynExpr -> TypedTree.Expr * UnscopedTyparEnv
    val TcIteratedLambdas :
      cenv:TcFileState ->
        isFirst:bool ->
          env:TcEnv ->
            overallTy:TypedTree.TType ->
              takenNames:Set<string> ->
                tpenv:UnscopedTyparEnv ->
                  e:SyntaxTree.SynExpr -> TypedTree.Expr * UnscopedTyparEnv
    val TcIndexerThen :
      cenv:TcFileState ->
        env:TcEnv ->
          overallTy:TypedTree.TType ->
            mWholeExpr:Range.range ->
              mDot:Range.range ->
                tpenv:UnscopedTyparEnv ->
                  wholeExpr:SyntaxTree.SynExpr ->
                    e1:SyntaxTree.SynExpr ->
                      indexArgs:SyntaxTree.SynIndexerArg list ->
                        delayed:DelayedItem list ->
                          TypedTree.Expr * UnscopedTyparEnv
    val TcNewExpr :
      cenv:TcFileState ->
        env:TcEnv ->
          tpenv:UnscopedTyparEnv ->
            objTy:TypedTree.TType ->
              mObjTyOpt:Range.range option ->
                superInit:bool ->
                  arg:SyntaxTree.SynExpr ->
                    mWholeExprOrObjTy:Range.range ->
                      TypedTree.Expr * UnscopedTyparEnv
    val TcCtorCall :
      isNaked:bool ->
        cenv:TcFileState ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              overallTy:TypedTree.TType ->
                objTy:TypedTree.TType ->
                  mObjTyOpt:Range.range option ->
                    item:NameResolution.Item ->
                      superInit:bool ->
                        args:SyntaxTree.SynExpr list ->
                          mWholeCall:Range.range ->
                            delayed:DelayedItem list ->
                              afterTcOverloadResolutionOpt:NameResolution.AfterResolution option ->
                                TypedTree.Expr * UnscopedTyparEnv
    val TcRecordConstruction :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              optOrigExprInfo:(TypedTree.Expr * TypedTree.Val * TypedTree.Expr) option ->
                objTy:TypedTree.TType ->
                  fldsList:seq<string * SyntaxTree.SynExpr> ->
                    m:Range.range -> TypedTree.Expr * UnscopedTyparEnv
    val GetNameAndArityOfObjExprBinding :
      _cenv:'b ->
        _env:'c -> b:NormalizedBinding -> string * SyntaxTree.SynValInfo
    val FreshenObjExprAbstractSlot :
      cenv:TcFileState ->
        env:TcEnv ->
          implty:TypedTree.TType ->
            virtNameAndArityPairs:((string * 'd) * Infos.MethInfo) list ->
              bind:NormalizedBinding * bindAttribs:TypedTree.Attribs *
              bindName:string * absSlots:('e * Infos.MethInfo) list ->
                (bool * TypedTree.Typars * TypedTree.TType) option
    val TcObjectExprBinding :
      cenv:cenv ->
        env:TcEnv ->
          implty:TypedTree.TType ->
            tpenv:UnscopedTyparEnv ->
              absSlotInfo:(bool * TypedTree.Typars * TypedTree.TType) option *
              bind:NormalizedBinding ->
                (SyntaxTree.Ident * SyntaxTree.MemberFlags * TypedTree.TType *
                 TypedTree.Attribs * TypedTree.Expr) * UnscopedTyparEnv
    val ComputeObjectExprOverrides :
      cenv:TcFileState ->
        env:TcEnv ->
          tpenv:UnscopedTyparEnv ->
            impls:(Range.range * TypedTree.TType * SyntaxTree.SynBinding list) list ->
              (Range.range * TypedTree.TType * MethodOverrides.RequiredSlot list *
               AbstractIL.Internal.Library.NameMultiMap<MethodOverrides.RequiredSlot> *
               MethodOverrides.OverrideInfo list *
               (MethodOverrides.OverrideInfo *
                (TypedTree.Val option * TypedTree.Val * TypedTree.Val list list *
                 TypedTree.Attribs * TypedTree.Expr)) list) list *
              UnscopedTyparEnv
    val CheckSuperType :
      cenv:TcFileState -> ty:TypedTree.TType -> m:Range.range -> unit
    val TcObjectExpr :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              synObjTy:SyntaxTree.SynType *
              argopt:(SyntaxTree.SynExpr * SyntaxTree.Ident option) option *
              binds:SyntaxTree.SynBinding list *
              extraImpls:SyntaxTree.SynInterfaceImpl list * mNewExpr:Range.range *
              mWholeExpr:Range.range -> TypedTree.Expr * UnscopedTyparEnv
    val TcConstStringExpr :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            m:Range.range ->
              tpenv:UnscopedTyparEnv ->
                s:string -> TypedTree.Expr * UnscopedTyparEnv
    val TcFormatStringExpr :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            m:Range.range ->
              tpenv:UnscopedTyparEnv ->
                fmtString:string -> TypedTree.Expr * UnscopedTyparEnv
    val TcInterpolatedStringExpr :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            m:Range.range ->
              tpenv:UnscopedTyparEnv ->
                parts:SyntaxTree.SynInterpolatedStringPart list ->
                  TypedTree.Expr * UnscopedTyparEnv
    val TcConstExpr :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            m:Range.range ->
              tpenv:UnscopedTyparEnv ->
                c:SyntaxTree.SynConst -> TypedTree.Expr * UnscopedTyparEnv
    val TcAssertExpr :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            m:Range.range ->
              tpenv:UnscopedTyparEnv ->
                x:SyntaxTree.SynExpr -> TypedTree.Expr * UnscopedTyparEnv
    val TcRecdExpr :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              inherits:(SyntaxTree.SynType * SyntaxTree.SynExpr * Range.range *
                        SyntaxTree.BlockSeparator option * Range.range) option *
              optOrigExpr:(SyntaxTree.SynExpr * SyntaxTree.BlockSeparator) option *
              flds:(SyntaxTree.RecordFieldName * SyntaxTree.SynExpr option *
                    SyntaxTree.BlockSeparator option) list *
              mWholeExpr:Range.range -> TypedTree.Expr * UnscopedTyparEnv
    val TcAnonRecdExpr :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              isStruct:bool *
              optOrigSynExpr:(SyntaxTree.SynExpr * SyntaxTree.BlockSeparator) option *
              unsortedFieldIdsAndSynExprsGiven:(SyntaxTree.Ident *
                                                SyntaxTree.SynExpr) list *
              mWholeExpr:Range.range -> TypedTree.Expr * UnscopedTyparEnv
    val TcForEachExpr :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              pat:SyntaxTree.SynPat * enumSynExpr:SyntaxTree.SynExpr *
              bodySynExpr:SyntaxTree.SynExpr * mWholeExpr:Range.range *
              spForLoop:SyntaxTree.DebugPointAtFor ->
                TypedTree.Expr * UnscopedTyparEnv
    val TcQuotationExpr :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              _oper:SyntaxTree.SynExpr * raw:bool * ast:SyntaxTree.SynExpr *
              isFromQueryExpression:bool * m:Range.range ->
                TypedTree.Expr * UnscopedTyparEnv
    val Propagate :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              expr:ApplicableExpr ->
                exprty:TypedTree.TType -> delayed:DelayedItem list -> unit
    val PropagateThenTcDelayed :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              mExpr:Range.range ->
                expr:ApplicableExpr ->
                  exprty:TypedTree.TType ->
                    atomicFlag:SyntaxTree.ExprAtomicFlag ->
                      delayed:DelayedItem list ->
                        TypedTree.Expr * UnscopedTyparEnv
    val TcDelayed :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              mExpr:Range.range ->
                expr:ApplicableExpr ->
                  exprty:TypedTree.TType ->
                    atomicFlag:SyntaxTree.ExprAtomicFlag ->
                      delayed:DelayedItem list ->
                        TypedTree.Expr * UnscopedTyparEnv
    val delayRest :
      rest:SyntaxTree.Ident list ->
        mPrior:Range.range -> delayed:DelayedItem list -> DelayedItem list
    val TcNameOfExpr :
      cenv:TcFileState ->
        env:TcEnv ->
          tpenv:UnscopedTyparEnv -> synArg:SyntaxTree.SynExpr -> TypedTree.Expr
    val TcNameOfExprResult :
      cenv:TcFileState ->
        lastIdent:SyntaxTree.Ident -> m:Range.range -> TypedTree.Expr
    val TcFunctionApplicationThen :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              mExprAndArg:Range.range ->
                expr:ApplicableExpr ->
                  exprty:TypedTree.TType ->
                    synArg:SyntaxTree.SynExpr ->
                      atomicFlag:SyntaxTree.ExprAtomicFlag ->
                        delayed:DelayedItem list ->
                          TypedTree.Expr * UnscopedTyparEnv
    val GetLongIdentTypeNameInfo :
      delayed:DelayedItem list -> NameResolution.TypeNameResolutionInfo
    val TcLongIdentThen :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              SyntaxTree.LongIdentWithDots ->
                delayed:DelayedItem list -> TypedTree.Expr * UnscopedTyparEnv
    val TcItemThen :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              tinstEnclosing:NameResolution.EnclosingTypeInst *
              item:NameResolution.Item * mItem:Range.range *
              rest:SyntaxTree.Ident list *
              afterResolution:NameResolution.AfterResolution ->
                delayed:DelayedItem list -> TypedTree.Expr * UnscopedTyparEnv
    val GetSynMemberApplicationArgs :
      delayed:DelayedItem list ->
        tpenv:'f ->
          SyntaxTree.ExprAtomicFlag *
          (SyntaxTree.SynType list * Range.range) option *
          SyntaxTree.SynExpr list * DelayedItem list * 'f
    val TcMemberTyArgsOpt :
      cenv:TcFileState ->
        env:TcEnv ->
          tpenv:UnscopedTyparEnv ->
            tyargsOpt:(SyntaxTree.SynType list * Range.range) option ->
              TypedTree.TType list option * UnscopedTyparEnv
    val GetMemberApplicationArgs :
      delayed:DelayedItem list ->
        cenv:TcFileState ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              SyntaxTree.ExprAtomicFlag * TypedTree.TType list option *
              SyntaxTree.SynExpr list * DelayedItem list * UnscopedTyparEnv
    val TcLookupThen :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              mObjExpr:Range.range ->
                objExpr:TypedTree.Expr ->
                  objExprTy:TypedTree.TType ->
                    longId:SyntaxTree.Ident list ->
                      delayed:DelayedItem list ->
                        mExprAndLongId:Range.range ->
                          TypedTree.Expr * UnscopedTyparEnv
    val TcEventValueThen :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              mItem:Range.range ->
                mExprAndItem:Range.range ->
                  objDetails:(TypedTree.Expr * TypedTree.TType) option ->
                    einfo:Infos.EventInfo ->
                      delayed:DelayedItem list ->
                        TypedTree.Expr * UnscopedTyparEnv
    val TcMethodApplicationThen :
      cenv:TcFileState ->
        env:TcEnv ->
          overallTy:TypedTree.TType ->
            objTyOpt:TypedTree.TType option ->
              tpenv:UnscopedTyparEnv ->
                callerTyArgs:TypedTree.TType list option ->
                  objArgs:TypedTree.Expr list ->
                    m:Range.range ->
                      mItem:Range.range ->
                        methodName:string ->
                          ad:AccessibilityLogic.AccessorDomain ->
                            mut:TypedTreeOps.Mutates ->
                              isProp:bool ->
                                meths:(Infos.MethInfo * Infos.PropInfo option) list ->
                                  afterResolution:NameResolution.AfterResolution ->
                                    isSuperInit:TypedTree.ValUseFlag ->
                                      args:SyntaxTree.SynExpr list ->
                                        atomicFlag:SyntaxTree.ExprAtomicFlag ->
                                          delayed:DelayedItem list ->
                                            TypedTree.Expr * UnscopedTyparEnv
    val GetNewInferenceTypeForMethodArg :
      cenv:TcFileState ->
        env:'g -> tpenv:'h -> x:SyntaxTree.SynExpr -> TypedTree.TType
    val TcMethodApplication :
      isCheckingAttributeCall:bool ->
        cenv:TcFileState ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              tyargsOpt:TypedTree.TType list option ->
                objArgs:TypedTree.Expr list ->
                  mMethExpr:Range.range ->
                    mItem:Range.range ->
                      methodName:string ->
                        objTyOpt:TypedTree.TType option ->
                          ad:AccessibilityLogic.AccessorDomain ->
                            mut:TypedTreeOps.Mutates ->
                              isProp:bool ->
                                calledMethsAndProps:(Infos.MethInfo *
                                                     Infos.PropInfo option) list ->
                                  afterResolution:NameResolution.AfterResolution ->
                                    isSuperInit:TypedTree.ValUseFlag ->
                                      curriedCallerArgs:SyntaxTree.SynExpr list ->
                                        exprTy:TypedTree.TType ->
                                          delayed:DelayedItem list ->
                                            (TypedTree.Expr *
                                             MethodCalls.CallerNamedArg<TypedTree.Expr> list *
                                             DelayedItem list) *
                                            UnscopedTyparEnv
    val TcSetterArgExpr :
      cenv:TcFileState ->
        env:TcEnv ->
          denv:TypedTreeOps.DisplayEnv ->
            objExpr:TypedTree.Expr ->
              ad:AccessibilityLogic.AccessorDomain ->
                MethodCalls.AssignedItemSetter<TypedTree.Expr> ->
                  (TypedTree.Expr -> TypedTree.Expr) option * TypedTree.Expr *
                  Range.range
    val TcUnnamedMethodArgs :
      cenv:TcFileState ->
        env:TcEnv ->
          lambdaPropagationInfo:(MethodCalls.ArgumentAnalysis [] [] *
                                 (SyntaxTree.Ident *
                                  MethodCalls.ArgumentAnalysis) [] []) [] ->
            tpenv:UnscopedTyparEnv ->
              args:MethodCalls.CallerArg<SyntaxTree.SynExpr> list list ->
                MethodCalls.CallerArg<TypedTree.Expr> list list *
                ((MethodCalls.ArgumentAnalysis [] [] *
                  (SyntaxTree.Ident * MethodCalls.ArgumentAnalysis) [] []) [] *
                 UnscopedTyparEnv)
    val TcUnnamedMethodArg :
      cenv:TcFileState ->
        env:TcEnv ->
          lambdaPropagationInfo:(MethodCalls.ArgumentAnalysis [] [] *
                                 (SyntaxTree.Ident *
                                  MethodCalls.ArgumentAnalysis) [] []) [] *
          tpenv:UnscopedTyparEnv ->
            i:int * j:int * MethodCalls.CallerArg<SyntaxTree.SynExpr> ->
              MethodCalls.CallerArg<TypedTree.Expr> *
              ((MethodCalls.ArgumentAnalysis [] [] *
                (SyntaxTree.Ident * MethodCalls.ArgumentAnalysis) [] []) [] *
               UnscopedTyparEnv)
    val TcMethodNamedArgs :
      cenv:TcFileState ->
        env:TcEnv ->
          lambdaPropagationInfo:(MethodCalls.ArgumentAnalysis [] [] *
                                 (SyntaxTree.Ident *
                                  MethodCalls.ArgumentAnalysis) [] []) [] ->
            tpenv:UnscopedTyparEnv ->
              args:MethodCalls.CallerNamedArg<SyntaxTree.SynExpr> list list ->
                MethodCalls.CallerNamedArg<TypedTree.Expr> list list *
                ((MethodCalls.ArgumentAnalysis [] [] *
                  (SyntaxTree.Ident * MethodCalls.ArgumentAnalysis) [] []) [] *
                 UnscopedTyparEnv)
    val TcMethodNamedArg :
      cenv:TcFileState ->
        env:TcEnv ->
          lambdaPropagationInfo:(MethodCalls.ArgumentAnalysis [] [] *
                                 (SyntaxTree.Ident *
                                  MethodCalls.ArgumentAnalysis) [] []) [] *
          tpenv:UnscopedTyparEnv ->
            MethodCalls.CallerNamedArg<SyntaxTree.SynExpr> ->
              MethodCalls.CallerNamedArg<TypedTree.Expr> *
              ((MethodCalls.ArgumentAnalysis [] [] *
                (SyntaxTree.Ident * MethodCalls.ArgumentAnalysis) [] []) [] *
               UnscopedTyparEnv)
    val TcMethodArg :
      cenv:TcFileState ->
        env:TcEnv ->
          lambdaPropagationInfo:(MethodCalls.ArgumentAnalysis [] [] *
                                 (SyntaxTree.Ident *
                                  MethodCalls.ArgumentAnalysis) [] []) [] *
          tpenv:UnscopedTyparEnv ->
            lambdaPropagationInfoForArg:MethodCalls.ArgumentAnalysis [] *
            MethodCalls.CallerArg<SyntaxTree.SynExpr> ->
              MethodCalls.CallerArg<TypedTree.Expr> *
              ((MethodCalls.ArgumentAnalysis [] [] *
                (SyntaxTree.Ident * MethodCalls.ArgumentAnalysis) [] []) [] *
               UnscopedTyparEnv)
    val TcNewDelegateThen :
      cenv:TcFileState ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              mDelTy:Range.range ->
                mExprAndArg:Range.range ->
                  delegateTy:TypedTree.TType ->
                    arg:SyntaxTree.SynExpr ->
                      atomicFlag:SyntaxTree.ExprAtomicFlag ->
                        delayed:DelayedItem list ->
                          TypedTree.Expr * UnscopedTyparEnv
    val bindLetRec :
      binds:TypedTree.Bindings ->
        m:Range.range -> e:TypedTree.Expr -> TypedTree.Expr
    val CheckRecursiveBindingIds : binds:seq<SyntaxTree.SynBinding> -> unit
    val TcLinearExprs :
      bodyChecker:(TypedTree.TType -> TcEnv -> UnscopedTyparEnv ->
                     SyntaxTree.SynExpr -> TypedTree.Expr * UnscopedTyparEnv) ->
        cenv:TcFileState ->
          env:TcEnv ->
            overallTy:TypedTree.TType ->
              tpenv:UnscopedTyparEnv ->
                isCompExpr:bool ->
                  expr:SyntaxTree.SynExpr ->
                    cont:(TypedTree.Expr * UnscopedTyparEnv ->
                            TypedTree.Expr * UnscopedTyparEnv) ->
                      TypedTree.Expr * UnscopedTyparEnv
    val TcAndPatternCompileMatchClauses :
      mExpr:Range.range ->
        matchm:Range.range ->
          actionOnFailure:PatternMatchCompilation.ActionOnFailure ->
            cenv:TcFileState ->
              inputExprOpt:TypedTree.Expr option ->
                inputTy:TypedTree.TType ->
                  resultTy:TypedTree.TType ->
                    env:TcEnv ->
                      tpenv:UnscopedTyparEnv ->
                        synClauses:SyntaxTree.SynMatchClause list ->
                          TypedTree.Val * TypedTree.Expr * UnscopedTyparEnv
    val TcMatchPattern :
      cenv:TcFileState ->
        inputTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              pat:SyntaxTree.SynPat * optWhenExpr:SyntaxTree.SynExpr option ->
                PatternMatchCompilation.Pattern * TypedTree.Expr option *
                TypedTree.Val list * TcEnv * UnscopedTyparEnv
    val TcMatchClauses :
      cenv:TcFileState ->
        inputTy:TypedTree.TType ->
          resultTy:TypedTree.TType ->
            env:TcEnv ->
              tpenv:UnscopedTyparEnv ->
                clauses:SyntaxTree.SynMatchClause list ->
                  PatternMatchCompilation.TypedMatchClause list *
                  UnscopedTyparEnv
    val TcMatchClause :
      cenv:TcFileState ->
        inputTy:TypedTree.TType ->
          resultTy:TypedTree.TType ->
            env:TcEnv ->
              isFirst:bool ->
                tpenv:UnscopedTyparEnv ->
                  SyntaxTree.SynMatchClause ->
                    PatternMatchCompilation.TypedMatchClause * UnscopedTyparEnv
    val TcStaticOptimizationConstraint :
      cenv:TcFileState ->
        env:TcEnv ->
          tpenv:UnscopedTyparEnv ->
            c:SyntaxTree.SynStaticOptimizationConstraint ->
              TypedTree.StaticOptimization * UnscopedTyparEnv
    val mkConvToNativeInt :
      g:TcGlobals.TcGlobals ->
        e:TypedTree.Expr -> m:Range.range -> TypedTree.Expr
    val TcAndBuildFixedExpr :
      cenv:TcFileState ->
        env:TcEnv ->
          overallPatTy:TypedTree.TType * fixedExpr:TypedTree.Expr *
          overallExprTy:TypedTree.TType * mBinding:Range.range -> TypedTree.Expr
    val TcNormalizedBinding :
      declKind:DeclKind ->
        cenv:cenv ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              overallTy:TypedTree.TType ->
                safeThisValOpt:TypedTree.Val option ->
                  safeInitInfo:SafeInitData ->
                    enclosingDeclaredTypars:TypedTree.Typar list *
                    ExplicitTyparInfo ->
                      bind:NormalizedBinding ->
                        CheckedBindingInfo * UnscopedTyparEnv
    val TcLiteral :
      cenv:cenv ->
        overallTy:TypedTree.TType ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              attrs:TypedTree.Attribs * synLiteralValExpr:SyntaxTree.SynExpr ->
                bool * TypedTree.Const option
    val TcBindingTyparDecls :
      alwaysRigid:bool ->
        cenv:TcFileState ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              SyntaxTree.SynValTyparDecls ->
                ExplicitTyparInfo * UnscopedTyparEnv
    val TcNonrecBindingTyparDecls :
      cenv:cenv ->
        env:TcEnv ->
          tpenv:UnscopedTyparEnv ->
            bind:NormalizedBinding -> ExplicitTyparInfo * UnscopedTyparEnv
    val TcNonRecursiveBinding :
      declKind:DeclKind ->
        cenv:TcFileState ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              ty:TypedTree.TType ->
                b:SyntaxTree.SynBinding -> CheckedBindingInfo * UnscopedTyparEnv
    val TcAttribute :
      canFail:bool ->
        cenv:TcFileState ->
          env:TcEnv ->
            attrTgt:System.AttributeTargets ->
              synAttr:SyntaxTree.SynAttribute ->
                (System.AttributeTargets * TypedTree.Attrib) list * bool
    val TcAttributesWithPossibleTargets :
      canFail:bool ->
        cenv:TcFileState ->
          env:TcEnv ->
            attrTgt:System.AttributeTargets ->
              synAttribs:SyntaxTree.SynAttribute list ->
                (System.AttributeTargets * TypedTree.Attrib) list * bool
    val TcAttributesMaybeFail :
      canFail:bool ->
        cenv:TcFileState ->
          env:TcEnv ->
            attrTgt:System.AttributeTargets ->
              synAttribs:SyntaxTree.SynAttribute list ->
                TypedTree.Attrib list * bool
    val TcAttributesCanFail :
      cenv:TcFileState ->
        env:TcEnv ->
          attrTgt:System.AttributeTargets ->
            synAttribs:SyntaxTree.SynAttribute list ->
              TypedTree.Attrib list * (unit -> TypedTree.Attribs)
    val TcAttributes :
      cenv:TcFileState ->
        env:TcEnv ->
          attrTgt:System.AttributeTargets ->
            synAttribs:SyntaxTree.SynAttribute list -> TypedTree.Attribs
    val TcLetBinding :
      cenv:TcFileState ->
        isUse:bool ->
          env:TcEnv ->
            containerInfo:ContainerInfo ->
              declKind:DeclKind ->
                tpenv:UnscopedTyparEnv ->
                  synBinds:SyntaxTree.SynBinding list *
                  synBindsRange:Range.range * scopem:Range.range ->
                    (TypedTree.Expr * TypedTree.TType ->
                       TypedTree.Expr * TypedTree.TType) * TcEnv *
                    UnscopedTyparEnv
    val TcLetBindings :
      cenv:TcFileState ->
        env:TcEnv ->
          containerInfo:ContainerInfo ->
            declKind:DeclKind ->
              tpenv:UnscopedTyparEnv ->
                binds:SyntaxTree.SynBinding list * bindsm:Range.range *
                scopem:Range.range ->
                  TypedTree.ModuleOrNamespaceExpr list * TcEnv *
                  UnscopedTyparEnv
    val CheckMemberFlags :
      optIntfSlotTy:'a option ->
        newslotsOK:NewSlotsOK ->
          overridesOK:OverridesOK ->
            memberFlags:SyntaxTree.MemberFlags -> m:Range.range -> unit
    val ApplyTypesFromArgumentPatterns :
      cenv:TcFileState * env:TcEnv * optArgsOK:bool * ty:TypedTree.TType *
      m:Range.range * tpenv:UnscopedTyparEnv * NormalizedBindingRhs *
      memberFlagsOpt:SyntaxTree.MemberFlags option -> unit
    val ComputeIsComplete :
      enclosingDeclaredTypars:TypedTree.Typar list ->
        declaredTypars:TypedTree.Typar list -> ty:TypedTree.TType -> bool
    val ApplyAbstractSlotInference :
      cenv:cenv ->
        envinner:TcEnv ->
          bindingTy:TypedTree.TType * m:Range.range *
          synTyparDecls:SyntaxTree.SynValTyparDecls *
          declaredTypars:TypedTree.Typars * memberId:SyntaxTree.Ident *
          tcrefObjTy:TypedTree.TType * renaming:TypedTreeOps.TyparInst *
          _objTy:'i *
          optIntfSlotTy:(TypedTree.TType * MethodOverrides.SlotImplSet) option *
          valSynData:SyntaxTree.SynValInfo * memberFlags:SyntaxTree.MemberFlags *
          attribs:TypedTree.Attribs -> TypedTree.TType list * TypedTree.Typars
    val CheckForNonAbstractInterface :
      declKind:DeclKind ->
        tcref:TypedTree.TyconRef ->
          memberFlags:SyntaxTree.MemberFlags -> m:Range.range -> unit
    val AnalyzeRecursiveStaticMemberOrValDecl :
      cenv:TcFileState * envinner:TcEnv * tpenv:'j * declKind:DeclKind *
      newslotsOK:NewSlotsOK * overridesOK:OverridesOK *
      tcrefContainerInfo:MemberOrValContainerInfo option * vis1:'k option *
      id:SyntaxTree.Ident * vis2:'k option * declaredTypars:'l *
      memberFlagsOpt:SyntaxTree.MemberFlags option *
      thisIdOpt:SyntaxTree.Ident option * bindingAttribs:TypedTree.Attribs *
      valSynInfo:SyntaxTree.SynValInfo * ty:TypedTree.TType * bindingRhs:'m *
      mBinding:Range.range * explicitTyparInfo:'n ->
        TcEnv * 'j * SyntaxTree.Ident * 'o option * PreValMemberInfo option *
        'k option * 'k option * TypedTree.Val option * TypedTree.Typar list *
        TypedTree.Val option * 'n * 'm * 'l
    val AnalyzeRecursiveInstanceMemberDecl :
      cenv:cenv * envinner:TcEnv * tpenv:'p * declKind:DeclKind *
      synTyparDecls:SyntaxTree.SynValTyparDecls *
      valSynInfo:SyntaxTree.SynValInfo * explicitTyparInfo:ExplicitTyparInfo *
      newslotsOK:NewSlotsOK * overridesOK:OverridesOK * vis1:'q option *
      thisId:SyntaxTree.Ident * memberId:SyntaxTree.Ident *
      toolId:SyntaxTree.Ident option * bindingAttribs:TypedTree.Attribs *
      vis2:'q option * tcrefContainerInfo:MemberOrValContainerInfo option *
      memberFlagsOpt:SyntaxTree.MemberFlags option * ty:TypedTree.TType *
      bindingRhs:NormalizedBindingRhs * mBinding:Range.range ->
        TcEnv * 'p * SyntaxTree.Ident * SyntaxTree.Ident option *
        PreValMemberInfo option * 'q option * 'q option * 'r option *
        TypedTree.Typar list * TypedTree.Val option * ExplicitTyparInfo *
        NormalizedBindingRhs * TypedTree.Typars
    val AnalyzeRecursiveDecl :
      cenv:TcFileState * envinner:TcEnv * tpenv:UnscopedTyparEnv *
      declKind:DeclKind * synTyparDecls:SyntaxTree.SynValTyparDecls *
      declaredTypars:TypedTree.Typars * thisIdOpt:SyntaxTree.Ident option *
      valSynInfo:SyntaxTree.SynValInfo * explicitTyparInfo:ExplicitTyparInfo *
      newslotsOK:NewSlotsOK * overridesOK:OverridesOK *
      vis1:SyntaxTree.SynAccess option * declPattern:SyntaxTree.SynPat *
      bindingAttribs:TypedTree.Attribs *
      tcrefContainerInfo:MemberOrValContainerInfo option *
      memberFlagsOpt:SyntaxTree.MemberFlags option * ty:TypedTree.TType *
      bindingRhs:NormalizedBindingRhs * mBinding:Range.range ->
        TcEnv * UnscopedTyparEnv * SyntaxTree.Ident * SyntaxTree.Ident option *
        PreValMemberInfo option * SyntaxTree.SynAccess option *
        SyntaxTree.SynAccess option * TypedTree.Val option *
        TypedTree.Typar list * TypedTree.Val option * ExplicitTyparInfo *
        NormalizedBindingRhs * TypedTree.Typars
    val AnalyzeAndMakeAndPublishRecursiveValue :
      overridesOK:OverridesOK ->
        isGeneratedEventVal:bool ->
          cenv:TcFileState ->
            env:TcEnv ->
              tpenv:UnscopedTyparEnv * recBindIdx:int ->
                NormalizedRecBindingDefn ->
                  (PreCheckingRecursiveBinding list * TypedTree.Val list) *
                  (UnscopedTyparEnv * int)
    val AnalyzeAndMakeAndPublishRecursiveValues :
      overridesOK:OverridesOK ->
        cenv:TcFileState ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              binds:NormalizedRecBindingDefn list ->
                PreCheckingRecursiveBinding list * TypedTree.Val list *
                (UnscopedTyparEnv * int)
    val TcLetrecBinding :
      cenv:TcFileState * envRec:TcEnv * scopem:Range.range *
      extraGeneralizableTypars:TypedTree.Typars *
      reqdThisValTyOpt:TypedTree.TType option ->
        envNonRec:TcEnv *
        generalizedRecBinds:PostGeneralizationRecursiveBinding list *
        preGeneralizationRecBinds:PreGeneralizationRecursiveBinding list *
        tpenv:UnscopedTyparEnv *
        uncheckedRecBindsTable:Map<TypedTree.Stamp,PreCheckingRecursiveBinding> ->
          rbind:PreCheckingRecursiveBinding ->
            TcEnv * PostGeneralizationRecursiveBinding list *
            PreGeneralizationRecursiveBinding list * UnscopedTyparEnv *
            Map<TypedTree.Stamp,PreCheckingRecursiveBinding>
    val TcIncrementalLetRecGeneralization :
      cenv:TcFileState ->
        scopem:Range.range ->
          envNonRec:TcEnv *
          generalizedRecBinds:PostGeneralizationRecursiveBinding list *
          preGeneralizationRecBinds:PreGeneralizationRecursiveBinding list *
          tpenv:UnscopedTyparEnv *
          uncheckedRecBindsTable:Map<TypedTree.Stamp,PreCheckingRecursiveBinding> ->
            TcEnv * PostGeneralizationRecursiveBinding list *
            PreGeneralizationRecursiveBinding list * UnscopedTyparEnv *
            Map<TypedTree.Stamp,PreCheckingRecursiveBinding>
    val TcLetrecComputeAndGeneralizeGenericTyparsForBinding :
      cenv:TcFileState ->
        denv:TypedTreeOps.DisplayEnv ->
          freeInEnv:Internal.Utilities.Collections.Tagged.Set<TypedTree.Typar,
                                                              System.Collections.Generic.IComparer<TypedTree.Typar>> ->
            pgrbind:PreGeneralizationRecursiveBinding -> TypedTree.Typar list
    val TcLetrecComputeSupportForBinding :
      cenv:TcFileState ->
        pgrbind:PreGeneralizationRecursiveBinding -> TypedTree.Typar list
    val TcLetrecGeneralizeBinding :
      cenv:TcFileState ->
        denv:TypedTreeOps.DisplayEnv ->
          generalizedTypars:TypedTree.Typar list ->
            pgrbind:PreGeneralizationRecursiveBinding ->
              PostGeneralizationRecursiveBinding
    val TcLetrecComputeCtorSafeThisValBind :
      cenv:TcFileState ->
        safeThisValOpt:TypedTree.Val option -> TypedTree.Binding option
    val MakeCheckSafeInitField :
      g:TcGlobals.TcGlobals ->
        tinst:TypedTree.TypeInst ->
          thisValOpt:TypedTree.Val option ->
            rfref:TypedTree.RecdFieldRef ->
              reqExpr:TypedTree.Expr -> expr:TypedTree.Expr -> TypedTree.Expr
    val MakeCheckSafeInit :
      g:TcGlobals.TcGlobals ->
        tinst:TypedTree.TypeInst ->
          safeInitInfo:SafeInitData ->
            reqExpr:TypedTree.Expr -> expr:TypedTree.Expr -> TypedTree.Expr
    val TcLetrecAdjustMemberForSpecialVals :
      cenv:TcFileState ->
        pgrbind:PostGeneralizationRecursiveBinding ->
          PostSpecialValsRecursiveBinding
    val FixupLetrecBind :
      cenv:TcFileState ->
        denv:TypedTreeOps.DisplayEnv ->
          generalizedTyparsForRecursiveBlock:TypedTree.Typars ->
            bind:PostSpecialValsRecursiveBinding ->
              PreInitializationGraphEliminationBinding
    val unionGeneralizedTypars :
      typarSets:TypedTree.Typar list list -> TypedTree.Typar list
    val TcLetrec :
      overridesOK:OverridesOK ->
        cenv:TcFileState ->
          env:TcEnv ->
            tpenv:UnscopedTyparEnv ->
              binds:RecDefnBindingInfo list * bindsm:Range.range *
              scopem:Range.range ->
                TypedTree.Bindings * TcEnv * UnscopedTyparEnv
    val TcAndPublishValSpec :
      cenv:TcFileState * env:TcEnv * containerInfo:ContainerInfo *
      declKind:DeclKind * memFlagsOpt:SyntaxTree.MemberFlags option *
      tpenv:UnscopedTyparEnv * valSpfn:SyntaxTree.SynValSig ->
        TypedTree.Val list * UnscopedTyparEnv
  end

namespace FSharp.Compiler
  module internal CheckComputationExpressions = begin
    type cenv = CheckExpressions.TcFileState
    type CompExprTranslationPass =
      | Initial
      | Subsequent
    type CustomOperationsMode =
      | Allowed
      | Denied
    val TryFindIntrinsicOrExtensionMethInfo :
      collectionSettings:NameResolution.ResultCollectionSettings ->
        cenv:cenv ->
          env:CheckExpressions.TcEnv ->
            m:Range.range ->
              ad:AccessibilityLogic.AccessorDomain ->
                nm:string -> ty:TypedTree.TType -> Infos.MethInfo list
    val IgnoreAttribute : 'a -> 'b option
    val ( |ExprAsPat|_| ) : f:SyntaxTree.SynExpr -> SyntaxTree.SynPat option
    val ( |JoinRelation|_| ) :
      cenv:CheckExpressions.TcFileState ->
        env:CheckExpressions.TcEnv ->
          e:SyntaxTree.SynExpr ->
            (SyntaxTree.SynExpr * SyntaxTree.SynExpr) option
    val elimFastIntegerForLoop :
      spBind:SyntaxTree.DebugPointAtFor * id:SyntaxTree.Ident *
      start:SyntaxTree.SynExpr * dir:bool * finish:SyntaxTree.SynExpr *
      innerExpr:SyntaxTree.SynExpr * m:Range.range -> SyntaxTree.SynExpr
    val YieldFree : cenv:cenv -> expr:SyntaxTree.SynExpr -> bool
    val ( |SimpleSemicolonSequence|_| ) :
      cenv:cenv ->
        acceptDeprecated:bool ->
          cexpr:SyntaxTree.SynExpr -> SyntaxTree.SynExpr list option
    val RecordNameAndTypeResolutions_IdeallyWithoutHavingOtherEffects :
      cenv:CheckExpressions.TcFileState ->
        env:CheckExpressions.TcEnv ->
          tpenv:CheckExpressions.UnscopedTyparEnv ->
            expr:SyntaxTree.SynExpr -> unit
    val TcComputationExpression :
      cenv:CheckExpressions.TcFileState ->
        env:CheckExpressions.TcEnv ->
          overallTy:TypedTree.TType ->
            tpenv:CheckExpressions.UnscopedTyparEnv ->
              mWhole:Range.range * interpExpr:TypedTree.Expr *
              builderTy:TypedTree.TType * comp:SyntaxTree.SynExpr ->
                TypedTree.Expr * CheckExpressions.UnscopedTyparEnv
    val mkSeqEmpty :
      cenv:cenv ->
        env:CheckExpressions.TcEnv ->
          m:Range.range -> genTy:TypedTree.TType -> TypedTree.Expr
    val mkSeqCollect :
      cenv:cenv ->
        env:CheckExpressions.TcEnv ->
          m:Range.range ->
            enumElemTy:TypedTree.TType ->
              genTy:TypedTree.TType ->
                lam:TypedTree.Expr -> enumExpr:TypedTree.Expr -> TypedTree.Expr
    val mkSeqUsing :
      cenv:cenv ->
        env:CheckExpressions.TcEnv ->
          m:Range.range ->
            resourceTy:TypedTree.TType ->
              genTy:TypedTree.TType ->
                resourceExpr:TypedTree.Expr ->
                  lam:TypedTree.Expr -> TypedTree.Expr
    val mkSeqDelay :
      cenv:cenv ->
        env:CheckExpressions.TcEnv ->
          m:Range.range ->
            genTy:TypedTree.TType -> lam:TypedTree.Expr -> TypedTree.Expr
    val mkSeqAppend :
      cenv:cenv ->
        env:CheckExpressions.TcEnv ->
          m:Range.range ->
            genTy:TypedTree.TType ->
              e1:TypedTree.Expr -> e2:TypedTree.Expr -> TypedTree.Expr
    val mkSeqFromFunctions :
      cenv:cenv ->
        env:CheckExpressions.TcEnv ->
          m:Range.range ->
            genTy:TypedTree.TType ->
              e1:TypedTree.Expr -> e2:TypedTree.Expr -> TypedTree.Expr
    val mkSeqFinally :
      cenv:cenv ->
        env:CheckExpressions.TcEnv ->
          m:Range.range ->
            genTy:TypedTree.TType ->
              e1:TypedTree.Expr -> e2:TypedTree.Expr -> TypedTree.Expr
    val mkSeqExprMatchClauses :
      pat':PatternMatchCompilation.Pattern * vspecs:TypedTree.Val list ->
        innerExpr:TypedTree.Expr ->
          PatternMatchCompilation.TypedMatchClause list
    val compileSeqExprMatchClauses :
      cenv:cenv ->
        env:CheckExpressions.TcEnv ->
          inputExprMark:Range.range ->
            pat:PatternMatchCompilation.Pattern * vspecs:TypedTree.Val list ->
              innerExpr:TypedTree.Expr ->
                inputExprOpt:TypedTree.Expr option ->
                  bindPatTy:TypedTree.TType ->
                    genInnerTy:TypedTree.TType -> TypedTree.Val * TypedTree.Expr
    val TcSequenceExpression :
      cenv:cenv ->
        env:CheckExpressions.TcEnv ->
          tpenv:CheckExpressions.UnscopedTyparEnv ->
            comp:SyntaxTree.SynExpr ->
              overallTy:TypedTree.TType ->
                m:Range.range ->
                  TypedTree.Expr * CheckExpressions.UnscopedTyparEnv
    val TcSequenceExpressionEntry :
      cenv:cenv ->
        env:CheckExpressions.TcEnv ->
          overallTy:TypedTree.TType ->
            tpenv:CheckExpressions.UnscopedTyparEnv ->
              isArrayOrList:bool * isNotNakedRefCell:bool ref *
              comp:SyntaxTree.SynExpr ->
                m:Range.range ->
                  TypedTree.Expr * CheckExpressions.UnscopedTyparEnv
    val TcArrayOrListSequenceExpression :
      cenv:cenv ->
        env:CheckExpressions.TcEnv ->
          overallTy:TypedTree.TType ->
            tpenv:CheckExpressions.UnscopedTyparEnv ->
              isArray:bool * comp:SyntaxTree.SynExpr ->
                m:Range.range ->
                  TypedTree.Expr * CheckExpressions.UnscopedTyparEnv
  end

namespace FSharp.Compiler
  module internal CheckDeclarations = begin
    type cenv = CheckExpressions.TcFileState
    type MutRecDataForOpen =
      | MutRecDataForOpen of
        SyntaxTree.SynOpenDeclTarget * Range.range * appliedScope: Range.range
    type MutRecDataForModuleAbbrev =
      | MutRecDataForModuleAbbrev of
        SyntaxTree.Ident * SyntaxTree.LongIdent * Range.range
    [<RequireQualifiedAccessAttribute ()>]
    type MutRecShape<'TypeData,'LetsData,'ModuleData> =
      | Tycon of 'TypeData
      | Lets of 'LetsData
      | Module of 'ModuleData * MutRecShapes<'TypeData,'LetsData,'ModuleData>
      | ModuleAbbrev of MutRecDataForModuleAbbrev
      | Open of MutRecDataForOpen
    and MutRecShapes<'TypeData,'LetsData,'ModuleData> =
      MutRecShape<'TypeData,'LetsData,'ModuleData> list
    module MutRecShapes = begin
      val map :
        f1:('a -> 'b) ->
          f2:('c -> 'd) ->
            f3:('e -> 'f) ->
              x:MutRecShape<'a,'c,'e> list -> MutRecShape<'b,'d,'f> list
      val mapTycons :
        f1:('a -> 'b) ->
          xs:MutRecShape<'a,'c,'d> list -> MutRecShape<'b,'c,'d> list
      val mapTyconsAndLets :
        f1:('a -> 'b) ->
          f2:('c -> 'd) ->
            xs:MutRecShape<'a,'c,'e> list -> MutRecShape<'b,'d,'e> list
      val mapLets :
        f2:('a -> 'b) ->
          xs:MutRecShape<'c,'a,'d> list -> MutRecShape<'c,'b,'d> list
      val mapModules :
        f1:('a -> 'b) ->
          xs:MutRecShape<'c,'d,'a> list -> MutRecShape<'c,'d,'b> list
      val mapWithEnv :
        fTycon:('Env -> 'a -> 'b) ->
          fLets:('Env -> 'c -> 'd) ->
            env:'Env ->
              x:MutRecShape<'a,'c,('e * 'Env)> list ->
                MutRecShape<'b,'d,('e * 'Env)> list
      val mapTyconsWithEnv :
        f1:('a -> 'b -> 'c) ->
          env:'a ->
            xs:MutRecShape<'b,'d,('e * 'a)> list ->
              MutRecShape<'c,'d,('e * 'a)> list
      val mapWithParent :
        parent:'a ->
          f1:('a -> 'b -> MutRecShapes<'c,'d,'b> -> 'e * 'a) ->
            f2:('a -> 'c -> 'f) ->
              f3:('a -> 'd -> 'g) ->
                xs:MutRecShape<'c,'d,'b> list -> MutRecShape<'f,'g,'e> list
      val computeEnvs :
        f1:('a -> 'b -> 'Env) ->
          f2:('Env -> MutRecShape<'c,'d,'b> list -> 'a) ->
            env:'Env ->
              xs:MutRecShape<'c,'d,'b> list ->
                'a * MutRecShape<'c,'d,('b * 'a)> list
      val extendEnvs :
        f1:('Env -> MutRecShape<'a,'b,('c * 'Env)> list -> 'Env) ->
          env:'Env ->
            xs:MutRecShape<'a,'b,('c * 'Env)> list ->
              'Env * MutRecShape<'a,'b,('c * 'Env)> list
      val dropEnvs :
        xs:MutRecShape<'a,'b,('c * 'd)> list -> MutRecShape<'a,'b,'c> list
      val expandTyconsWithEnv :
        f1:('a -> 'b -> 'c list * 'c list) ->
          env:'a ->
            xs:MutRecShape<'b,'c list,('d * 'a)> list ->
              MutRecShape<'b,'c list,('d * 'a)> list
      val mapFoldWithEnv :
        f1:('a -> 'b -> MutRecShape<'c,'d,('e * 'b)> ->
              MutRecShape<'f,'g,('e * 'b)> * 'a) ->
          z:'a ->
            env:'b ->
              xs:MutRecShape<'c,'d,('e * 'b)> list ->
                MutRecShape<'f,'g,('e * 'b)> list * 'a
      val collectTycons : x:MutRecShape<'a,'b,'c> list -> 'a list
      val topTycons : x:MutRecShape<'a,'b,'c> list -> 'a list
      val iter :
        f1:('a -> unit) ->
          f2:('b -> unit) ->
            f3:('c -> unit) ->
              f4:(MutRecDataForOpen -> unit) ->
                f5:(MutRecDataForModuleAbbrev -> unit) ->
                  x:MutRecShape<'a,'b,'c> list -> unit
      val iterTycons : f1:('a -> unit) -> x:MutRecShape<'a,'b,'c> list -> unit
      val iterTyconsAndLets :
        f1:('a -> unit) ->
          f2:('b -> unit) -> x:MutRecShape<'a,'b,'c> list -> unit
      val iterModules : f1:('a -> unit) -> x:MutRecShape<'b,'c,'a> list -> unit
      val iterWithEnv :
        f1:('a -> 'b -> unit) ->
          f2:('a -> 'c -> unit) ->
            f3:('a -> MutRecDataForOpen -> unit) ->
              f4:('a -> MutRecDataForModuleAbbrev -> unit) ->
                env:'a -> x:MutRecShape<'b,'c,('d * 'a)> list -> unit
      val iterTyconsWithEnv :
        f1:('a -> 'b -> unit) ->
          env:'a -> xs:MutRecShape<'b,'c,('d * 'a)> list -> unit
    end
    val ModuleOrNamespaceContainerInfo :
      modref:TypedTree.EntityRef -> CheckExpressions.ContainerInfo
    val TyconContainerInfo :
      parent:TypedTree.ParentRef * tcref:TypedTree.TyconRef *
      declaredTyconTypars:TypedTree.Typars *
      safeInitInfo:CheckExpressions.SafeInitData ->
        CheckExpressions.ContainerInfo
    type TyconBindingDefn =
      | TyconBindingDefn of
        CheckExpressions.ContainerInfo * CheckExpressions.NewSlotsOK *
        CheckExpressions.DeclKind * SyntaxTree.SynMemberDefn * Range.range
    type MutRecSigsInitialData =
      MutRecShape<SyntaxTree.SynTypeDefnSig,SyntaxTree.SynValSig,
                  SyntaxTree.SynComponentInfo> list
    type MutRecDefnsInitialData =
      MutRecShape<SyntaxTree.SynTypeDefn,SyntaxTree.SynBinding list,
                  SyntaxTree.SynComponentInfo> list
    type MutRecDefnsPhase1DataForTycon =
      | MutRecDefnsPhase1DataForTycon of
        SyntaxTree.SynComponentInfo * SyntaxTree.SynTypeDefnSimpleRepr *
        (SyntaxTree.SynType * Range.range) list *
        preEstablishedHasDefaultCtor: bool * hasSelfReferentialCtor: bool *
        isAtOriginalTyconDefn: bool
    type MutRecDefnsPhase1Data =
      MutRecShape<(MutRecDefnsPhase1DataForTycon * SyntaxTree.SynMemberDefn list),
                  CheckExpressions.RecDefnBindingInfo list,
                  SyntaxTree.SynComponentInfo> list
    type MutRecDefnsPhase2DataForTycon =
      | MutRecDefnsPhase2DataForTycon of
        TypedTree.Tycon option * TypedTree.ParentRef * CheckExpressions.DeclKind *
        TypedTree.TyconRef * TypedTree.Val option *
        CheckExpressions.SafeInitData * TypedTree.Typars *
        SyntaxTree.SynMemberDefn list * Range.range *
        CheckExpressions.NewSlotsOK * fixupFinalAttribs: unit -> unit
    type MutRecDefnsPhase2DataForModule =
      | MutRecDefnsPhase2DataForModule of
        TypedTree.ModuleOrNamespaceType ref * TypedTree.ModuleOrNamespace
    type MutRecDefnsPhase2Data =
      MutRecShape<MutRecDefnsPhase2DataForTycon,
                  CheckExpressions.RecDefnBindingInfo list,
                  (MutRecDefnsPhase2DataForModule * CheckExpressions.TcEnv)> list
    type MutRecDefnsPhase2InfoForTycon =
      | MutRecDefnsPhase2InfoForTycon of
        TypedTree.Tycon option * TypedTree.TyconRef * TypedTree.Typars *
        CheckExpressions.DeclKind * TyconBindingDefn list *
        fixupFinalAttrs: unit -> unit
    type MutRecDefnsPhase2Info =
      MutRecShape<MutRecDefnsPhase2InfoForTycon,
                  CheckExpressions.RecDefnBindingInfo list,
                  (MutRecDefnsPhase2DataForModule * CheckExpressions.TcEnv)> list
    val AddLocalExnDefnAndReport :
      tcSink:NameResolution.TcResultsSink ->
        scopem:Range.range ->
          env:CheckExpressions.TcEnv ->
            exnc:TypedTree.Tycon -> CheckExpressions.TcEnv
    val AddLocalTyconRefs :
      ownDefinition:bool ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            m:Range.range ->
              tcrefs:TypedTree.TyconRef list ->
                env:CheckExpressions.TcEnv -> CheckExpressions.TcEnv
    val AddLocalTycons :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            tycons:TypedTree.Tycon list ->
              env:CheckExpressions.TcEnv -> CheckExpressions.TcEnv
    val AddLocalTyconsAndReport :
      tcSink:NameResolution.TcResultsSink ->
        scopem:Range.range ->
          g:TcGlobals.TcGlobals ->
            amap:Import.ImportMap ->
              m:Range.range ->
                tycons:TypedTree.Tycon list ->
                  env:CheckExpressions.TcEnv -> CheckExpressions.TcEnv
    val AddLocalSubModule :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            env:CheckExpressions.TcEnv ->
              modul:TypedTree.ModuleOrNamespace -> CheckExpressions.TcEnv
    val AddLocalSubModuleAndReport :
      tcSink:NameResolution.TcResultsSink ->
        scopem:Range.range ->
          g:TcGlobals.TcGlobals ->
            amap:Import.ImportMap ->
              m:Range.range ->
                env:CheckExpressions.TcEnv ->
                  modul:TypedTree.ModuleOrNamespace -> CheckExpressions.TcEnv
    val BuildRootModuleType :
      enclosingNamespacePath:SyntaxTree.Ident list ->
        cpath:TypedTree.CompilationPath ->
          mtyp:TypedTree.ModuleOrNamespaceType ->
            TypedTree.ModuleOrNamespaceType * TypedTree.ModuleOrNamespace list
    val BuildRootModuleExpr :
      enclosingNamespacePath:SyntaxTree.Ident list ->
        cpath:TypedTree.CompilationPath ->
          mexpr:TypedTree.ModuleOrNamespaceExpr ->
            TypedTree.ModuleOrNamespaceExpr
    val TryStripPrefixPath :
      g:TcGlobals.TcGlobals ->
        enclosingNamespacePath:SyntaxTree.Ident list ->
          (SyntaxTree.Ident * SyntaxTree.Ident list) option
    val AddModuleAbbreviationAndReport :
      tcSink:NameResolution.TcResultsSink ->
        scopem:Range.range ->
          id:SyntaxTree.Ident ->
            modrefs:TypedTree.ModuleOrNamespaceRef list ->
              env:CheckExpressions.TcEnv -> CheckExpressions.TcEnv
    val OpenModuleOrNamespaceRefs :
      tcSink:NameResolution.TcResultsSink ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            scopem:Range.range ->
              root:bool ->
                env:CheckExpressions.TcEnv ->
                  mvvs:TypedTree.ModuleOrNamespaceRef list ->
                    openDeclaration:NameResolution.OpenDeclaration ->
                      CheckExpressions.TcEnv
    val OpenTypeContent :
      tcSink:NameResolution.TcResultsSink ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            scopem:Range.range ->
              env:CheckExpressions.TcEnv ->
                typ:TypedTree.TType ->
                  openDeclaration:NameResolution.OpenDeclaration ->
                    CheckExpressions.TcEnv
    val AddRootModuleOrNamespaceRefs :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            env:CheckExpressions.TcEnv ->
              modrefs:TypedTree.ModuleOrNamespaceRef list ->
                CheckExpressions.TcEnv
    val addInternalsAccessibility :
      env:CheckExpressions.TcEnv ->
        ccu:TypedTree.CcuThunk -> CheckExpressions.TcEnv
    val AddNonLocalCcu :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          scopem:Range.range ->
            env:CheckExpressions.TcEnv ->
              assemblyName:string ->
                ccu:TypedTree.CcuThunk *
                internalsVisibleToAttributes:string list ->
                  CheckExpressions.TcEnv
    val AddLocalRootModuleOrNamespace :
      NameResolution.TcResultsSink ->
        TcGlobals.TcGlobals ->
          Import.ImportMap ->
            Range.range ->
              CheckExpressions.TcEnv ->
                TypedTree.ModuleOrNamespaceType -> CheckExpressions.TcEnv
    val ImplicitlyOpenOwnNamespace :
      tcSink:NameResolution.TcResultsSink ->
        g:TcGlobals.TcGlobals ->
          amap:Import.ImportMap ->
            scopem:Range.range ->
              enclosingNamespacePath:SyntaxTree.Ident list ->
                env:CheckExpressions.TcEnv -> CheckExpressions.TcEnv
    exception NotUpperCaseConstructor of Range.range
    val CheckNamespaceModuleOrTypeName :
      g:TcGlobals.TcGlobals -> id:SyntaxTree.Ident -> unit
    val CheckDuplicates :
      idf:('a -> SyntaxTree.Ident) -> k:string -> elems:'a list -> 'a list
    module TcRecdUnionAndEnumDeclarations = begin
      val CombineReprAccess :
        parent:TypedTree.ParentRef ->
          vis:TypedTree.Accessibility -> TypedTree.Accessibility
      val MakeRecdFieldSpec :
        _cenv:'a ->
          env:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              isStatic:bool * konst:TypedTree.Const option * ty':TypedTree.TType *
              attrsForProperty:TypedTree.Attribs *
              attrsForField:TypedTree.Attribs * id:SyntaxTree.Ident *
              nameGenerated:bool * isMutable:bool * vol:bool *
              xmldoc:XmlDoc.XmlDoc * vis:SyntaxTree.SynAccess option *
              m:Range.range -> TypedTree.RecdField
      val TcFieldDecl :
        cenv:CheckExpressions.TcFileState ->
          env:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              isIncrClass:bool ->
                tpenv:CheckExpressions.UnscopedTyparEnv ->
                  isStatic:bool * synAttrs:SyntaxTree.SynAttribute list *
                  id:SyntaxTree.Ident * nameGenerated:bool *
                  ty:SyntaxTree.SynType * isMutable:bool * xmldoc:XmlDoc.XmlDoc *
                  vis:SyntaxTree.SynAccess option * m:Range.range ->
                    TypedTree.RecdField
      val TcAnonFieldDecl :
        cenv:CheckExpressions.TcFileState ->
          env:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              tpenv:CheckExpressions.UnscopedTyparEnv ->
                nm:string -> SyntaxTree.SynField -> TypedTree.RecdField
      val TcNamedFieldDecl :
        cenv:CheckExpressions.TcFileState ->
          env:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              isIncrClass:bool ->
                tpenv:CheckExpressions.UnscopedTyparEnv ->
                  SyntaxTree.SynField -> TypedTree.RecdField
      val TcNamedFieldDecls :
        cenv:CheckExpressions.TcFileState ->
          env:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              isIncrClass:bool ->
                tpenv:CheckExpressions.UnscopedTyparEnv ->
                  fields:SyntaxTree.SynField list -> TypedTree.RecdField list
      val CheckUnionCaseName : cenv:cenv -> id:SyntaxTree.Ident -> unit
      val ValidateFieldNames :
        synFields:SyntaxTree.SynField list * tastFields:TypedTree.RecdField list ->
          unit
      val TcUnionCaseDecl :
        cenv:CheckExpressions.TcFileState ->
          env:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              thisTy:TypedTree.TType ->
                thisTyInst:TypedTree.TypeInst ->
                  tpenv:CheckExpressions.UnscopedTyparEnv ->
                    SyntaxTree.SynUnionCase -> TypedTree.UnionCase
      val TcUnionCaseDecls :
        cenv:CheckExpressions.TcFileState ->
          env:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              thisTy:TypedTree.TType ->
                thisTyInst:TypedTree.TypeInst ->
                  tpenv:CheckExpressions.UnscopedTyparEnv ->
                    unionCases:SyntaxTree.SynUnionCase list ->
                      TypedTree.UnionCase list
      val TcEnumDecl :
        cenv:CheckExpressions.TcFileState ->
          env:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              thisTy:TypedTree.TType ->
                fieldTy:TypedTree.TType ->
                  SyntaxTree.SynEnumCase -> TypedTree.RecdField
      val TcEnumDecls :
        cenv:CheckExpressions.TcFileState ->
          env:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              thisTy:TypedTree.TType ->
                enumCases:SyntaxTree.SynEnumCase list ->
                  TypedTree.TType * TypedTree.RecdField list
    end
    val PublishInterface :
      cenv:cenv ->
        denv:TypedTreeOps.DisplayEnv ->
          tcref:TypedTree.TyconRef ->
            m:Range.range -> compgen:bool -> ty':TypedTree.TType -> unit
    val TcAndPublishMemberSpec :
      cenv:CheckExpressions.TcFileState ->
        env:CheckExpressions.TcEnv ->
          containerInfo:CheckExpressions.ContainerInfo ->
            declKind:CheckExpressions.DeclKind ->
              tpenv:CheckExpressions.UnscopedTyparEnv ->
                memb:SyntaxTree.SynMemberSig ->
                  TypedTree.Val list * CheckExpressions.UnscopedTyparEnv
    val TcTyconMemberSpecs :
      cenv:CheckExpressions.TcFileState ->
        env:CheckExpressions.TcEnv ->
          containerInfo:CheckExpressions.ContainerInfo ->
            declKind:CheckExpressions.DeclKind ->
              tpenv:CheckExpressions.UnscopedTyparEnv ->
                augSpfn:SyntaxTree.SynMemberSig list ->
                  TypedTree.Val list * CheckExpressions.UnscopedTyparEnv
    val TcOpenLidAndPermitAutoResolve :
      tcSink:NameResolution.TcResultsSink ->
        env:CheckExpressions.TcEnv ->
          amap:Import.ImportMap ->
            longId:SyntaxTree.Ident list ->
              (int * TypedTree.ModuleOrNamespaceRef *
               TypedTree.ModuleOrNamespaceType) list
    val TcOpenModuleOrNamespaceDecl :
      NameResolution.TcResultsSink ->
        TcGlobals.TcGlobals ->
          Import.ImportMap ->
            Range.range ->
              CheckExpressions.TcEnv ->
                (SyntaxTree.Ident list * Range.range) -> CheckExpressions.TcEnv
    val TcOpenTypeDecl :
      cenv:cenv ->
        mOpenDecl:Range.range ->
          scopem:Range.range ->
            env:CheckExpressions.TcEnv ->
              synType:SyntaxTree.SynType * m:Range.range ->
                CheckExpressions.TcEnv
    val TcOpenDecl :
      cenv:CheckExpressions.TcFileState ->
        mOpenDecl:Range.range ->
          scopem:Range.range ->
            env:CheckExpressions.TcEnv ->
              target:SyntaxTree.SynOpenDeclTarget -> CheckExpressions.TcEnv
    exception ParameterlessStructCtor of Range.range
    val MakeSafeInitField :
      g:TcGlobals.TcGlobals ->
        env:CheckExpressions.TcEnv ->
          m:Range.range -> isStatic:bool -> TypedTree.RecdField
    module IncrClassChecking = begin
      type IncrClassBindingGroup =
        | IncrClassBindingGroup of TypedTree.Binding list * bool * bool
        | IncrClassDo of TypedTree.Expr * bool
      type IncrClassCtorLhs =
        { TyconRef: TypedTree.TyconRef
          InstanceCtorDeclaredTypars: TypedTree.Typars
          StaticCtorValInfo:
            System.Lazy<TypedTree.Val list * TypedTree.Val *
                        CheckExpressions.ValScheme>
          InstanceCtorVal: TypedTree.Val
          InstanceCtorValScheme: CheckExpressions.ValScheme
          InstanceCtorArgs: TypedTree.Val list
          InstanceCtorSafeThisValOpt: TypedTree.Val option
          InstanceCtorSafeInitInfo: CheckExpressions.SafeInitData
          InstanceCtorBaseValOpt: TypedTree.Val option
          InstanceCtorThisVal: TypedTree.Val
          NameGenerator: CompilerGlobalState.NiceNameGenerator }
        with
          member
            GetNormalizedInstanceCtorDeclaredTypars : cenv:cenv ->
                                                        denv:TypedTreeOps.DisplayEnv ->
                                                          m:Range.range ->
                                                            TypedTree.Typar list
        end
      val TcImplicitCtorLhs_Phase2A :
        cenv:cenv * env:CheckExpressions.TcEnv *
        tpenv:CheckExpressions.UnscopedTyparEnv * tcref:TypedTree.TyconRef *
        vis:SyntaxTree.SynAccess option * attrs:SyntaxTree.SynAttribute list *
        spats:SyntaxTree.SynSimplePat list * thisIdOpt:SyntaxTree.Ident option *
        baseValOpt:TypedTree.Val option *
        safeInitInfo:CheckExpressions.SafeInitData * m:Range.range *
        copyOfTyconTypars:TypedTree.Typar list * objTy:TypedTree.TType *
        thisTy:TypedTree.TType * doc:XmlDoc.PreXmlDoc -> IncrClassCtorLhs
      val private MakeIncrClassField :
        g:TcGlobals.TcGlobals * cpath:TypedTree.CompilationPath *
        formalTyparInst:TypedTreeOps.TyparInst * v:TypedTree.Val * isStatic:bool *
        rfref:TypedTree.RecdFieldRef -> TypedTree.RecdField
      type IncrClassValRepr =
        | InVar of bool
        | InField of bool * int * TypedTree.RecdFieldRef
        | InMethod of bool * TypedTree.Val * TypedTree.ValReprInfo
      type IncrClassReprInfo =
        { TakenFieldNames: Set<string>
          RepInfoTcGlobals: TcGlobals.TcGlobals
          ValReprs: AbstractIL.Internal.Zmap<TypedTree.Val,IncrClassValRepr>
          ValsWithRepresentation: AbstractIL.Internal.Zset<TypedTree.Val> }
        with
          static member
            Empty : g:TcGlobals.TcGlobals * names:string list ->
                      IncrClassReprInfo
          static member
            IsMethodRepr : cenv:cenv -> bind:TypedTree.Binding -> bool
          member
            ChooseAndAddRepresentation : cenv:cenv * env:CheckExpressions.TcEnv *
                                         isStatic:bool * isCtorArg:bool *
                                         ctorInfo:IncrClassCtorLhs *
                                         staticForcedFieldVars:TypedTree.FreeLocals *
                                         instanceForcedFieldVars:TypedTree.FreeLocals *
                                         bind:TypedTree.Binding ->
                                           IncrClassReprInfo
          member
            ChooseRepresentation : cenv:cenv * env:CheckExpressions.TcEnv *
                                   isStatic:bool * isCtorArg:bool *
                                   ctorInfo:IncrClassCtorLhs *
                                   staticForcedFieldVars:TypedTree.FreeLocals *
                                   instanceForcedFieldVars:TypedTree.FreeLocals *
                                   takenFieldNames:Set<string> *
                                   bind:TypedTree.Binding ->
                                     IncrClassValRepr * Set<string>
          member
            FixupIncrClassExprPhase2C : cenv:CheckExpressions.TcFileState ->
                                          thisValOpt:TypedTree.Val option ->
                                            safeStaticInitInfo:CheckExpressions.SafeInitData ->
                                              thisTyInst:TypedTree.TypeInst ->
                                                expr:TypedTree.Expr ->
                                                  TypedTree.Expr
          member IsValRepresentedAsLocalVar : v:TypedTree.Val -> bool
          member IsValRepresentedAsMethod : v:TypedTree.Val -> bool
          member IsValWithRepresentation : v:TypedTree.Val -> bool
          member LookupRepr : v:TypedTree.Val -> IncrClassValRepr
          member
            MakeValueAssign : thisValOpt:TypedTree.Val option ->
                                tinst:TypedTree.TypeInst ->
                                  safeStaticInitInfo:CheckExpressions.SafeInitData ->
                                    v:TypedTree.Val ->
                                      expr:TypedTree.Expr ->
                                        m:Range.range -> TypedTree.Expr
          member
            MakeValueGetAddress : readonly:bool ->
                                    thisValOpt:TypedTree.Val option ->
                                      tinst:TypedTree.TypeInst ->
                                        safeStaticInitInfo:CheckExpressions.SafeInitData ->
                                          v:TypedTree.Val ->
                                            m:Range.range -> TypedTree.Expr
          member
            MakeValueLookup : thisValOpt:TypedTree.Val option ->
                                tinst:TypedTree.TypeInst ->
                                  safeStaticInitInfo:CheckExpressions.SafeInitData ->
                                    v:TypedTree.Val ->
                                      tyargs:TypedTree.TType list ->
                                        m:Range.range -> TypedTree.Expr
          member
            PublishIncrClassFields : cenv:cenv * denv:TypedTreeOps.DisplayEnv *
                                     cpath:TypedTree.CompilationPath *
                                     ctorInfo:IncrClassCtorLhs *
                                     safeStaticInitInfo:CheckExpressions.SafeInitData ->
                                       unit
          member ValNowWithRepresentation : v:TypedTree.Val -> IncrClassReprInfo
        end
      type IncrClassConstructionBindingsPhase2C =
        | Phase2CBindings of IncrClassBindingGroup list
        | Phase2CCtorJustAfterSuperInit
        | Phase2CCtorJustAfterLastLet
      val MakeCtorForIncrClassConstructionPhase2C :
        cenv:cenv * env:CheckExpressions.TcEnv * ctorInfo:IncrClassCtorLhs *
        inheritsExpr:TypedTree.Expr * inheritsIsVisible:bool *
        decs:IncrClassConstructionBindingsPhase2C list *
        memberBinds:TypedTree.Binding list *
        generalizedTyparsForRecursiveBlock:TypedTree.Typar list *
        safeStaticInitInfo:CheckExpressions.SafeInitData ->
          TypedTree.Expr * TypedTree.Expr option * TypedTree.Binding list *
          IncrClassReprInfo
    end
    module MutRecBindingChecking = begin
      type TyconBindingPhase2A =
        | Phase2AIncrClassCtor of IncrClassChecking.IncrClassCtorLhs
        | Phase2AInherit of
          SyntaxTree.SynType * SyntaxTree.SynExpr * TypedTree.Val option *
          Range.range
        | Phase2AIncrClassBindings of
          TypedTree.TyconRef * SyntaxTree.SynBinding list * bool * bool *
          Range.range
        | Phase2AMember of CheckExpressions.PreCheckingRecursiveBinding
        | Phase2AIncrClassCtorJustAfterSuperInit
        | Phase2AIncrClassCtorJustAfterLastLet
      type TyconBindingsPhase2A =
        | TyconBindingsPhase2A of
          TypedTree.Tycon option * CheckExpressions.DeclKind *
          TypedTree.Val list * TypedTree.TyconRef * TypedTree.Typar list *
          TypedTree.TType * TyconBindingPhase2A list
      type MutRecDefnsPhase2AData =
        MutRecShape<TyconBindingsPhase2A,
                    CheckExpressions.PreCheckingRecursiveBinding list,
                    (MutRecDefnsPhase2DataForModule * CheckExpressions.TcEnv)> list
      type TyconBindingPhase2B =
        | Phase2BIncrClassCtor of
          IncrClassChecking.IncrClassCtorLhs * TypedTree.Binding option
        | Phase2BInherit of TypedTree.Expr * TypedTree.Val option
        | Phase2BIncrClassBindings of
          IncrClassChecking.IncrClassBindingGroup list
        | Phase2BMember of int
        | Phase2BIncrClassCtorJustAfterSuperInit
        | Phase2BIncrClassCtorJustAfterLastLet
      type TyconBindingsPhase2B =
        | TyconBindingsPhase2B of
          TypedTree.Tycon option * TypedTree.TyconRef * TyconBindingPhase2B list
      type MutRecDefnsPhase2BData =
        MutRecShape<TyconBindingsPhase2B,int list,
                    (MutRecDefnsPhase2DataForModule * CheckExpressions.TcEnv)> list
      type TyconBindingPhase2C =
        | Phase2CIncrClassCtor of
          IncrClassChecking.IncrClassCtorLhs * TypedTree.Binding option
        | Phase2CInherit of TypedTree.Expr * TypedTree.Val option
        | Phase2CIncrClassBindings of
          IncrClassChecking.IncrClassBindingGroup list
        | Phase2CMember of
          CheckExpressions.PreInitializationGraphEliminationBinding
        | Phase2CIncrClassCtorJustAfterSuperInit
        | Phase2CIncrClassCtorJustAfterLastLet
      type TyconBindingsPhase2C =
        | TyconBindingsPhase2C of
          TypedTree.Tycon option * TypedTree.TyconRef * TyconBindingPhase2C list
      type MutRecDefnsPhase2CData =
        MutRecShape<TyconBindingsPhase2C,
                    CheckExpressions.PreInitializationGraphEliminationBinding list,
                    (MutRecDefnsPhase2DataForModule * CheckExpressions.TcEnv)> list
      val TcMutRecBindings_Phase2A_CreateRecursiveValuesAndCheckArgumentPatterns
            :
        cenv:cenv ->
          tpenv:CheckExpressions.UnscopedTyparEnv ->
            envMutRec:CheckExpressions.TcEnv * mutRecDefns:MutRecDefnsPhase2Info ->
              MutRecDefnsPhase2AData *
              CheckExpressions.PreCheckingRecursiveBinding list *
              CheckExpressions.UnscopedTyparEnv
      val TcMutRecBindings_Phase2B_TypeCheckAndIncrementalGeneralization :
        cenv:cenv ->
          tpenv:CheckExpressions.UnscopedTyparEnv ->
            envInitial:CheckExpressions.TcEnv ->
              envMutRec:CheckExpressions.TcEnv * defnsAs:MutRecDefnsPhase2AData *
              uncheckedRecBinds:CheckExpressions.PreCheckingRecursiveBinding list *
              scopem:Range.range ->
                MutRecDefnsPhase2BData *
                CheckExpressions.PostGeneralizationRecursiveBinding list *
                CheckExpressions.UnscopedTyparEnv
      val TcMutRecBindings_Phase2C_FixupRecursiveReferences :
        cenv:cenv ->
          denv:TypedTreeOps.DisplayEnv * defnsBs:MutRecDefnsPhase2BData *
          generalizedTyparsForRecursiveBlock:TypedTree.Typar list *
          generalizedRecBinds:CheckExpressions.PostGeneralizationRecursiveBinding list *
          scopem:Range.range ->
            MutRecShape<TyconBindingsPhase2C,
                        CheckExpressions.PreInitializationGraphEliminationBinding list,
                        (MutRecDefnsPhase2DataForModule * CheckExpressions.TcEnv)> list
      val TcMutRecBindings_Phase2D_ExtractImplicitFieldAndMethodBindings :
        cenv:cenv ->
          envMutRec:CheckExpressions.TcEnv ->
            tpenv:CheckExpressions.UnscopedTyparEnv ->
              denv:TypedTreeOps.DisplayEnv *
              generalizedTyparsForRecursiveBlock:TypedTree.Typar list *
              defnsCs:MutRecDefnsPhase2CData ->
                MutRecShape<(TypedTree.Tycon option *
                             CheckExpressions.PreInitializationGraphEliminationBinding list *
                             TypedTree.Binding list),
                            CheckExpressions.PreInitializationGraphEliminationBinding list,
                            (MutRecDefnsPhase2DataForModule *
                             CheckExpressions.TcEnv)> list
      val TcModuleAbbrevDecl :
        cenv:cenv ->
          scopem:Range.range ->
            env:CheckExpressions.TcEnv ->
              id:SyntaxTree.Ident * p:SyntaxTree.Ident list * m:Range.range ->
                CheckExpressions.TcEnv
      val TcMutRecDefns_UpdateNSContents :
        mutRecNSInfo:(TypedTree.ModuleOrNamespace option *
                      TypedTree.ModuleOrNamespaceType ref) option -> unit
      val TcMutRecDefns_UpdateModuleContents :
        mutRecNSInfo:(TypedTree.ModuleOrNamespace option *
                      TypedTree.ModuleOrNamespaceType ref) option ->
          defns:MutRecShape<'a,'b,(MutRecDefnsPhase2DataForModule * 'c)> list ->
            unit
      val TcMutRecDefns_ComputeEnvs :
        getTyconOpt:('a -> TypedTree.Tycon option) ->
          getVals:('b -> TypedTree.Val list) ->
            cenv:cenv ->
              report:bool ->
                scopem:Range.range ->
                  m:Range.range ->
                    envInitial:CheckExpressions.TcEnv ->
                      mutRecShape:MutRecShape<'a,'b,
                                              MutRecDefnsPhase2DataForModule> list ->
                        CheckExpressions.TcEnv *
                        MutRecShape<'a,'b,
                                    (MutRecDefnsPhase2DataForModule *
                                     CheckExpressions.TcEnv)> list
      val TcMutRecDefns_Phase2_Bindings :
        cenv:cenv ->
          envInitial:CheckExpressions.TcEnv ->
            tpenv:CheckExpressions.UnscopedTyparEnv ->
              bindsm:Range.range ->
                scopem:Range.range ->
                  mutRecNSInfo:(TypedTree.ModuleOrNamespace option *
                                TypedTree.ModuleOrNamespaceType ref) option ->
                    envMutRecPrelimWithReprs:CheckExpressions.TcEnv ->
                      mutRecDefns:MutRecDefnsPhase2Info ->
                        MutRecShape<(TypedTree.Tycon option *
                                     TypedTree.Binding list),
                                    TypedTree.Binding list,
                                    (MutRecDefnsPhase2DataForModule *
                                     CheckExpressions.TcEnv)> list *
                        CheckExpressions.TcEnv
    end
    val TcMutRecDefns_Phase2 :
      cenv:cenv ->
        envInitial:CheckExpressions.TcEnv ->
          bindsm:Range.range ->
            scopem:Range.range ->
              mutRecNSInfo:(TypedTree.ModuleOrNamespace option *
                            TypedTree.ModuleOrNamespaceType ref) option ->
                envMutRec:CheckExpressions.TcEnv ->
                  mutRecDefns:MutRecDefnsPhase2Data ->
                    MutRecShape<(TypedTree.Tycon option * TypedTree.Binding list),
                                TypedTree.Binding list,
                                (MutRecDefnsPhase2DataForModule *
                                 CheckExpressions.TcEnv)> list *
                    CheckExpressions.TcEnv
    module AddAugmentationDeclarations = begin
      val tcaugHasNominalInterface :
        g:TcGlobals.TcGlobals ->
          tcaug:TypedTree.TyconAugmentation -> tcref:TypedTree.TyconRef -> bool
      val AddGenericCompareDeclarations :
        cenv:cenv ->
          env:CheckExpressions.TcEnv ->
            scSet:Set<TypedTree.Stamp> -> tycon:TypedTree.Tycon -> unit
      val AddGenericEqualityWithComparerDeclarations :
        cenv:cenv ->
          env:CheckExpressions.TcEnv ->
            seSet:Set<TypedTree.Stamp> -> tycon:TypedTree.Tycon -> unit
      val AddGenericCompareBindings :
        cenv:cenv -> tycon:TypedTree.Tycon -> TypedTree.Binding list
      val AddGenericCompareWithComparerBindings :
        cenv:cenv -> tycon:TypedTree.Tycon -> TypedTree.Binding list
      val AddGenericEqualityWithComparerBindings :
        cenv:cenv -> tycon:TypedTree.Tycon -> TypedTree.Binding list
      val AddGenericHashAndComparisonDeclarations :
        cenv:cenv ->
          env:CheckExpressions.TcEnv ->
            scSet:Set<TypedTree.Stamp> ->
              seSet:Set<TypedTree.Stamp> -> tycon:TypedTree.Tycon -> unit
      val AddGenericHashAndComparisonBindings :
        cenv:cenv -> tycon:TypedTree.Tycon -> TypedTree.Binding list
      val AddGenericEqualityBindings :
        cenv:cenv ->
          env:CheckExpressions.TcEnv ->
            tycon:TypedTree.Tycon -> TypedTree.Binding list
    end
    module TyconConstraintInference = begin
      val InferSetOfTyconsSupportingComparable :
        cenv:cenv ->
          denv:TypedTreeOps.DisplayEnv ->
            tyconsWithStructuralTypes:(TypedTree.Tycon *
                                       (TypedTree.TType * 'a) list) list ->
              Set<TypedTree.Stamp>
      val InferSetOfTyconsSupportingEquatable :
        cenv:cenv ->
          denv:TypedTreeOps.DisplayEnv ->
            tyconsWithStructuralTypes:(TypedTree.Tycon *
                                       (TypedTree.TType * 'a) list) list ->
              Set<TypedTree.Stamp>
    end
    val ComputeModuleName : longPath:SyntaxTree.Ident list -> SyntaxTree.Ident
    val CheckForDuplicateConcreteType :
      env:CheckExpressions.TcEnv -> nm:string -> m:Range.range -> unit
    val CheckForDuplicateModule :
      env:CheckExpressions.TcEnv -> nm:string -> m:Range.range -> unit
    module TcExceptionDeclarations = begin
      val TcExnDefnCore_Phase1A :
        cenv:CheckExpressions.TcFileState ->
          env:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              SyntaxTree.SynExceptionDefnRepr -> TypedTree.Entity
      val TcExnDefnCore_Phase1G_EstablishRepresentation :
        cenv:cenv ->
          env:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              exnc:TypedTree.Entity ->
                SyntaxTree.SynExceptionDefnRepr -> TypedTree.RecdField list
      val private TcExnDefnCore :
        cenv:CheckExpressions.TcFileState ->
          env:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              synExnDefnRepr:SyntaxTree.SynExceptionDefnRepr ->
                TypedTree.Binding list * TypedTree.Entity
      val TcExnDefn :
        cenv:CheckExpressions.TcFileState ->
          envInitial:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              SyntaxTree.SynExceptionDefn * scopem:Range.range ->
                TypedTree.Binding list * TypedTree.Entity *
                CheckExpressions.TcEnv
      val TcExnSignature :
        cenv:CheckExpressions.TcFileState ->
          envInitial:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              tpenv:CheckExpressions.UnscopedTyparEnv ->
                SyntaxTree.SynExceptionSig * scopem:Range.range ->
                  TypedTree.Binding list * TypedTree.Val list *
                  TypedTree.EntityRef * CheckExpressions.TcEnv
    end
    module EstablishTypeDefinitionCores = begin
      type TypeRealizationPass =
        | FirstPass
        | SecondPass
      val private ComputeTyconName :
        longPath:SyntaxTree.Ident list * doErase:bool * typars:TypedTree.Typars ->
          SyntaxTree.Ident
      val private GetTyconAttribs :
        g:TcGlobals.TcGlobals ->
          attrs:TypedTree.Attribs -> bool * bool * bool * bool * bool
      val private InferTyconKind :
        g:TcGlobals.TcGlobals ->
          kind:SyntaxTree.SynTypeDefnKind * attrs:TypedTree.Attribs *
          slotsigs:'a list * fields:'b list * inSig:bool * isConcrete:bool *
          m:Range.range -> SyntaxTree.SynTypeDefnKind
      val private ( |TyconCoreAbbrevThatIsReallyAUnion|_| ) :
        hasMeasureAttr:bool * envinner:CheckExpressions.TcEnv *
        id:SyntaxTree.Ident ->
          synTyconRepr:SyntaxTree.SynTypeDefnSimpleRepr ->
            (SyntaxTree.Ident * Range.range) option
      val private GetStructuralElementsOfTyconDefn :
        cenv:CheckExpressions.TcFileState ->
          env:CheckExpressions.TcEnv ->
            tpenv:CheckExpressions.UnscopedTyparEnv ->
              MutRecDefnsPhase1DataForTycon ->
                tycon:Lib.NonNullSlot<TypedTree.Entity> ->
                  (TypedTree.TType * Range.range) list
      val ComputeModuleOrNamespaceKind :
        g:TcGlobals.TcGlobals ->
          isModule:bool ->
            typeNames:Set<'a> ->
              attribs:TypedTree.Attribs ->
                nm:'a -> TypedTree.ModuleOrNamespaceKind when 'a : comparison
      val AdjustModuleName :
        modKind:TypedTree.ModuleOrNamespaceKind -> nm:string -> string
      val InstanceMembersNeedSafeInitCheck :
        cenv:cenv -> m:Range.range -> thisTy:TypedTree.TType -> bool
      val ComputeInstanceSafeInitInfo :
        cenv:cenv ->
          env:CheckExpressions.TcEnv ->
            m:Range.range ->
              thisTy:TypedTree.TType -> CheckExpressions.SafeInitData
      val TypeNamesInMutRecDecls :
        cenv:CheckExpressions.TcFileState ->
          env:CheckExpressions.TcEnv ->
            compDecls:MutRecShapes<(MutRecDefnsPhase1DataForTycon * 'MemberInfo),
                                   'LetInfo,SyntaxTree.SynComponentInfo> ->
              Set<string>
      val TypeNamesInNonMutRecDecls :
        defs:seq<SyntaxTree.SynModuleDecl> -> Set<string>
      val TypeNamesInNonMutRecSigDecls :
        defs:seq<SyntaxTree.SynModuleSigDecl> -> Set<string>
      val TcTyconDefnCore_Phase1A_BuildInitialModule :
        cenv:CheckExpressions.TcFileState ->
          envInitial:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              typeNames:Set<string> ->
                compInfo:SyntaxTree.SynComponentInfo ->
                  decls:MutRecShapes<(MutRecDefnsPhase1DataForTycon * 'a),'b,
                                     SyntaxTree.SynComponentInfo> ->
                    MutRecDefnsPhase2DataForModule *
                    (TypedTree.ParentRef * Set<string> * CheckExpressions.TcEnv)
      val private TcTyconDefnCore_Phase1A_BuildInitialTycon :
        cenv:cenv ->
          env:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              MutRecDefnsPhase1DataForTycon -> TypedTree.Entity
      val private TcTyconDefnCore_Phase1B_EstablishBasicKind :
        cenv:cenv ->
          inSig:bool ->
            envinner:CheckExpressions.TcEnv ->
              MutRecDefnsPhase1DataForTycon ->
                tycon:TypedTree.Tycon ->
                  TypedTree.Attrib list * (unit -> TypedTree.Attribs)
      val private TcTyconDefnCore_GetGenerateDeclaration_Rhs :
        SyntaxTree.SynType ->
          (SyntaxTree.LongIdent * SyntaxTree.SynType list * Range.range) option
      val private TcTyconDefnCore_TryAsGenerateDeclaration :
        cenv:cenv ->
          envinner:CheckExpressions.TcEnv ->
            tpenv:CheckExpressions.UnscopedTyparEnv ->
              tycon:TypedTree.Tycon * rhsType:SyntaxTree.SynType ->
                (TypedTree.TyconRef * Tainted<ExtensionTyping.ProvidedType> *
                 (unit -> unit) * SyntaxTree.SynType list * Range.range) option
      val private
          TcTyconDefnCore_Phase1C_EstablishDeclarationForGeneratedSetOfTypes :
        cenv:cenv ->
          inSig:bool ->
            tycon:TypedTree.Tycon * rhsType:SyntaxTree.SynType *
            tcrefForContainer:TypedTree.TyconRef *
            theRootType:Tainted<ExtensionTyping.ProvidedType> *
            checkTypeName:(unit -> unit) * args:'a list * m:Range.range -> unit
      val private TcTyconDefnCore_Phase1C_Phase1E_EstablishAbbreviations :
        cenv:cenv ->
          envinner:CheckExpressions.TcEnv ->
            inSig:bool ->
              tpenv:CheckExpressions.UnscopedTyparEnv ->
                pass:TypeRealizationPass ->
                  MutRecDefnsPhase1DataForTycon ->
                    tycon:TypedTree.Tycon -> attrs:TypedTree.Attribs -> unit
      val private
          TcTyconDefnCore_Phase1D_Phase1F_EstablishSuperTypesAndInterfaceTypes :
        cenv:CheckExpressions.TcFileState ->
          tpenv:CheckExpressions.UnscopedTyparEnv ->
            inSig:bool ->
              pass:TypeRealizationPass ->
                envMutRec:CheckExpressions.TcEnv *
                mutRecDefns:MutRecShape<((MutRecDefnsPhase1DataForTycon * 'a *
                                          'b) *
                                         (TypedTree.Tycon *
                                          (TypedTree.Attribs * 'c)) option),'d,
                                        ('e * CheckExpressions.TcEnv)> list ->
                  unit
      val private TcTyconDefnCore_Phase1G_EstablishRepresentation :
        cenv:cenv ->
          envinner:CheckExpressions.TcEnv ->
            tpenv:CheckExpressions.UnscopedTyparEnv ->
              inSig:bool ->
                MutRecDefnsPhase1DataForTycon ->
                  tycon:TypedTree.Tycon ->
                    attrs:TypedTree.Attribs ->
                      TypedTree.Val option * CheckExpressions.SafeInitData
      val private TcTyconDefnCore_CheckForCyclicAbbreviations :
        tycons:TypedTree.Entity list -> unit
      val TcTyconDefnCore_CheckForCyclicStructsAndInheritance :
        cenv:cenv -> tycons:TypedTree.Entity list -> unit
      val TcMutRecDefns_CheckExplicitConstraints :
        cenv:CheckExpressions.TcFileState ->
          tpenv:CheckExpressions.UnscopedTyparEnv ->
            m:Range.range ->
              checkCxs:CheckExpressions.CheckConstraints ->
                envMutRecPrelim:CheckExpressions.TcEnv ->
                  withEnvs:MutRecShape<((MutRecDefnsPhase1DataForTycon * 'a * 'b) *
                                        TypedTree.Tycon option),'c,
                                       ('d * CheckExpressions.TcEnv)> list ->
                    unit
      val TcMutRecDefns_Phase1 :
        mkLetInfo:(CheckExpressions.ContainerInfo -> 'LetInfo -> 'a) ->
          cenv:cenv ->
            envInitial:CheckExpressions.TcEnv ->
              parent:TypedTree.ParentRef ->
                typeNames:Set<string> ->
                  inSig:bool ->
                    tpenv:CheckExpressions.UnscopedTyparEnv ->
                      m:Range.range ->
                        scopem:Range.range ->
                          mutRecNSInfo:(TypedTree.ModuleOrNamespace option *
                                        TypedTree.ModuleOrNamespaceType ref) option ->
                            mutRecDefns:MutRecShapes<(MutRecDefnsPhase1DataForTycon *
                                                      'MemberInfo),'LetInfo,
                                                     SyntaxTree.SynComponentInfo> ->
                              TypedTree.Entity list * CheckExpressions.TcEnv *
                              MutRecShape<((MutRecDefnsPhase1DataForTycon *
                                            'MemberInfo * TypedTree.ParentRef) *
                                           TypedTree.Entity option *
                                           (unit -> unit) *
                                           (TypedTree.Val option *
                                            CheckExpressions.SafeInitData)),'a,
                                          (MutRecDefnsPhase2DataForModule *
                                           CheckExpressions.TcEnv)> list
    end
    module TcDeclarations = begin
      val private ComputeTyconDeclKind :
        cenv:cenv ->
          envForDecls:CheckExpressions.TcEnv ->
            tyconOpt:Lib.NonNullSlot<TypedTree.Entity> option ->
              isAtOriginalTyconDefn:bool ->
                inSig:bool ->
                  m:Range.range ->
                    synTypars:SyntaxTree.SynTyparDecl list ->
                      synTyparCxs:SyntaxTree.SynTypeConstraint list ->
                        longPath:SyntaxTree.Ident list ->
                          CheckExpressions.DeclKind * TypedTree.EntityRef *
                          TypedTree.Typars
      val private isAugmentationTyconDefnRepr :
        _arg1:SyntaxTree.SynTypeDefnSimpleRepr -> bool
      val private isAutoProperty : _arg1:SyntaxTree.SynMemberDefn -> bool
      val private isMember : _arg1:SyntaxTree.SynMemberDefn -> bool
      val private isImplicitCtor : _arg1:SyntaxTree.SynMemberDefn -> bool
      val private isImplicitInherit : _arg1:SyntaxTree.SynMemberDefn -> bool
      val private isAbstractSlot : _arg1:SyntaxTree.SynMemberDefn -> bool
      val private isInterface : _arg1:SyntaxTree.SynMemberDefn -> bool
      val private isInherit : _arg1:SyntaxTree.SynMemberDefn -> bool
      val private isField : _arg1:SyntaxTree.SynMemberDefn -> bool
      val private isTycon : _arg1:SyntaxTree.SynMemberDefn -> bool
      val private allFalse : ps:('a -> bool) list -> x:'a -> bool
      val private CheckMembersForm : ds:SyntaxTree.SynMemberDefn list -> unit
      val private SplitTyconDefn :
        SyntaxTree.SynTypeDefn ->
          MutRecDefnsPhase1DataForTycon * SyntaxTree.SynMemberDefn list
      val TcMutRecDefinitions :
        cenv:cenv ->
          envInitial:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              typeNames:Set<string> ->
                tpenv:CheckExpressions.UnscopedTyparEnv ->
                  m:Range.range ->
                    scopem:Range.range ->
                      mutRecNSInfo:(TypedTree.ModuleOrNamespace option *
                                    TypedTree.ModuleOrNamespaceType ref) option ->
                        mutRecDefns:MutRecDefnsInitialData ->
                          MutRecShape<(TypedTree.Tycon option *
                                       TypedTree.Binding list),
                                      TypedTree.Binding list,
                                      (MutRecDefnsPhase2DataForModule *
                                       CheckExpressions.TcEnv)> list *
                          CheckExpressions.TcEnv
      val private SplitTyconSignature :
        SyntaxTree.SynTypeDefnSig ->
          MutRecDefnsPhase1DataForTycon *
          (SyntaxTree.SynComponentInfo * SyntaxTree.SynMemberSig list)
      val private TcMutRecSignatureDecls_Phase2 :
        cenv:cenv ->
          scopem:Range.range ->
            envMutRec:CheckExpressions.TcEnv ->
              mutRecDefns:MutRecShape<((MutRecDefnsPhase1DataForTycon *
                                        (SyntaxTree.SynComponentInfo *
                                         SyntaxTree.SynMemberSig list) *
                                        TypedTree.ParentRef) *
                                       Lib.NonNullSlot<TypedTree.Entity> option *
                                       'a * 'b),
                                      (CheckExpressions.ContainerInfo *
                                       SyntaxTree.SynValSig),
                                      ('c * CheckExpressions.TcEnv)> list ->
                MutRecShape<(TypedTree.Val list *
                             CheckExpressions.UnscopedTyparEnv),
                            CheckExpressions.TcEnv,('c * CheckExpressions.TcEnv)> list
      val TcMutRecSignatureDecls :
        cenv:cenv ->
          envInitial:CheckExpressions.TcEnv ->
            parent:TypedTree.ParentRef ->
              typeNames:Set<string> ->
                tpenv:CheckExpressions.UnscopedTyparEnv ->
                  m:Range.range ->
                    scopem:Range.range ->
                      mutRecNSInfo:(TypedTree.ModuleOrNamespace option *
                                    TypedTree.ModuleOrNamespaceType ref) option ->
                        mutRecSigs:MutRecSigsInitialData ->
                          CheckExpressions.TcEnv
    end
    val TcSignatureElementNonMutRec :
      cenv:CheckExpressions.TcFileState ->
        parent:TypedTree.ParentRef ->
          typeNames:Set<string> ->
            endm:Range.range ->
              env:CheckExpressions.TcEnv ->
                synSigDecl:SyntaxTree.SynModuleSigDecl ->
                  AbstractIL.Internal.Library.Eventually<CheckExpressions.TcEnv>
    val TcSignatureElements :
      cenv:CheckExpressions.TcFileState ->
        parent:TypedTree.ParentRef ->
          endm:Range.range ->
            env:CheckExpressions.TcEnv ->
              xml:XmlDoc.PreXmlDoc ->
                mutRecNSInfo:(TypedTree.ModuleOrNamespace option *
                              TypedTree.ModuleOrNamespaceType ref) option ->
                  defs:SyntaxTree.SynModuleSigDecl list ->
                    AbstractIL.Internal.Library.Eventually<CheckExpressions.TcEnv>
    val TcSignatureElementsNonMutRec :
      cenv:CheckExpressions.TcFileState ->
        parent:TypedTree.ParentRef ->
          typeNames:Set<string> ->
            endm:Range.range ->
              env:CheckExpressions.TcEnv ->
                defs:SyntaxTree.SynModuleSigDecl list ->
                  AbstractIL.Internal.Library.Eventually<CheckExpressions.TcEnv>
    val TcSignatureElementsMutRec :
      cenv:CheckExpressions.TcFileState ->
        parent:TypedTree.ParentRef ->
          typeNames:Set<string> ->
            m:Range.range ->
              mutRecNSInfo:(TypedTree.ModuleOrNamespace option *
                            TypedTree.ModuleOrNamespaceType ref) option ->
                envInitial:CheckExpressions.TcEnv ->
                  defs:SyntaxTree.SynModuleSigDecl list ->
                    AbstractIL.Internal.Library.Eventually<CheckExpressions.TcEnv>
    val TcModuleOrNamespaceSignatureElementsNonMutRec :
      cenv:CheckExpressions.TcFileState ->
        parent:TypedTree.ParentRef ->
          env:CheckExpressions.TcEnv ->
            id:SyntaxTree.Ident * modKind:TypedTree.ModuleOrNamespaceKind *
            defs:SyntaxTree.SynModuleSigDecl list * m:Range.range *
            xml:XmlDoc.PreXmlDoc ->
              AbstractIL.Internal.Library.Eventually<TypedTree.ModuleOrNamespaceType *
                                                     CheckExpressions.TcEnv>
    val ElimModuleDoBinding :
      bind:SyntaxTree.SynModuleDecl -> SyntaxTree.SynModuleDecl
    val TcMutRecDefnsEscapeCheck :
      binds:MutRecShapes<(TypedTree.Tycon option * TypedTree.Binding list),
                         TypedTree.Binding list,'a> ->
        env:CheckExpressions.TcEnv -> unit
    val CheckLetOrDoInNamespace :
      binds:SyntaxTree.SynBinding list -> m:Range.range -> unit
    val TcModuleOrNamespaceElementNonMutRec :
      cenv:cenv ->
        parent:TypedTree.ParentRef ->
          typeNames:Set<string> ->
            scopem:Range.range ->
              env:CheckExpressions.TcEnv ->
                synDecl:SyntaxTree.SynModuleDecl ->
                  AbstractIL.Internal.Library.Eventually<((TypedTree.ModuleOrNamespaceExpr list ->
                                                             TypedTree.ModuleOrNamespaceExpr list) *
                                                          (System.AttributeTargets *
                                                           TypedTree.Attrib) list) *
                                                         CheckExpressions.TcEnv *
                                                         CheckExpressions.TcEnv>
    val TcModuleOrNamespaceElementsNonMutRec :
      cenv:cenv ->
        parent:TypedTree.ParentRef ->
          typeNames:Set<string> ->
            endm:Range.range ->
              defsSoFar:((TypedTree.ModuleOrNamespaceExpr list ->
                            TypedTree.ModuleOrNamespaceExpr list) *
                         (System.AttributeTargets * TypedTree.Attrib) list) list *
              env:CheckExpressions.TcEnv * envAtEnd:CheckExpressions.TcEnv ->
                moreDefs:SyntaxTree.SynModuleDecl list ->
                  AbstractIL.Internal.Library.Eventually<((TypedTree.ModuleOrNamespaceExpr list ->
                                                             TypedTree.ModuleOrNamespaceExpr list) *
                                                          (System.AttributeTargets *
                                                           TypedTree.Attrib) list) list *
                                                         CheckExpressions.TcEnv>
    val TcModuleOrNamespaceElementsMutRec :
      cenv:cenv ->
        parent:TypedTree.ParentRef ->
          typeNames:Set<string> ->
            m:Range.range ->
              envInitial:CheckExpressions.TcEnv ->
                mutRecNSInfo:(TypedTree.ModuleOrNamespace option *
                              TypedTree.ModuleOrNamespaceType ref) option ->
                  defs:SyntaxTree.SynModuleDecl list ->
                    AbstractIL.Internal.Library.Eventually<((TypedTree.ModuleOrNamespaceExpr list ->
                                                               TypedTree.ModuleOrNamespaceExpr list) *
                                                            (System.AttributeTargets *
                                                             TypedTree.Attrib) list) *
                                                           CheckExpressions.TcEnv *
                                                           CheckExpressions.TcEnv>
    val TcMutRecDefsFinish :
      cenv:cenv ->
        defs:MutRecShape<(TypedTree.Tycon option * TypedTree.Binding list),
                         TypedTree.Binding list,
                         (MutRecDefnsPhase2DataForModule *
                          CheckExpressions.TcEnv)> list ->
          m:Range.range -> TypedTree.ModuleOrNamespaceExpr
    val TcModuleOrNamespaceElements :
      cenv:cenv ->
        parent:TypedTree.ParentRef ->
          endm:Range.range ->
            env:CheckExpressions.TcEnv ->
              xml:XmlDoc.PreXmlDoc ->
                mutRecNSInfo:(TypedTree.ModuleOrNamespace option *
                              TypedTree.ModuleOrNamespaceType ref) option ->
                  defs:SyntaxTree.SynModuleDecl list ->
                    AbstractIL.Internal.Library.Eventually<TypedTree.ModuleOrNamespaceExpr *
                                                           (System.AttributeTargets *
                                                            TypedTree.Attrib) list *
                                                           CheckExpressions.TcEnv>
    val ApplyAssemblyLevelAutoOpenAttributeToTcEnv :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          ccu:TypedTree.CcuThunk ->
            scopem:Range.range ->
              env:CheckExpressions.TcEnv ->
                p:System.String * root:bool -> CheckExpressions.TcEnv
    val AddCcuToTcEnv :
      TcGlobals.TcGlobals * Import.ImportMap * Range.range *
      CheckExpressions.TcEnv * assemblyName:string * ccu:TypedTree.CcuThunk *
      autoOpens:string list * internalsVisibleToAttributes:string list ->
        CheckExpressions.TcEnv
    val emptyTcEnv : g:TcGlobals.TcGlobals -> CheckExpressions.TcEnv
    val CreateInitialTcEnv :
      TcGlobals.TcGlobals * Import.ImportMap * Range.range * assemblyName:string *
      (TypedTree.CcuThunk * string list * string list) list ->
        CheckExpressions.TcEnv
    type ConditionalDefines = string list
    type TopAttribs =
      { mainMethodAttrs: TypedTree.Attribs
        netModuleAttrs: TypedTree.Attribs
        assemblyAttrs: TypedTree.Attribs }
    val EmptyTopAttrs : TopAttribs
    val CombineTopAttrs : TopAttribs -> TopAttribs -> TopAttribs
    val IterTyconsOfModuleOrNamespaceType :
      f:(TypedTree.Entity -> unit) ->
        mty:TypedTree.ModuleOrNamespaceType -> unit
    val ApplyDefaults :
      cenv:cenv ->
        g:TcGlobals.TcGlobals ->
          denvAtEnd:TypedTreeOps.DisplayEnv ->
            m:Range.range ->
              mexpr:TypedTree.ModuleOrNamespaceExpr ->
                extraAttribs:TypedTree.Attrib list -> unit
    val CheckValueRestriction :
      denvAtEnd:TypedTreeOps.DisplayEnv ->
        rootSigOpt:'a option ->
          implFileTypePriorToSig:TypedTree.ModuleOrNamespaceType ->
            m:Range.range -> unit
    val SolveInternalUnknowns :
      g:TcGlobals.TcGlobals ->
        cenv:cenv ->
          denvAtEnd:TypedTreeOps.DisplayEnv ->
            mexpr:TypedTree.ModuleOrNamespaceExpr ->
              extraAttribs:TypedTree.Attrib list -> unit
    val CheckModuleSignature :
      g:TcGlobals.TcGlobals ->
        cenv:cenv ->
          m:Range.range ->
            denvAtEnd:TypedTreeOps.DisplayEnv ->
              rootSigOpt:TypedTree.ModuleOrNamespaceType option ->
                implFileTypePriorToSig:TypedTree.ModuleOrNamespaceType ->
                  implFileSpecPriorToSig:Lib.NonNullSlot<TypedTree.Entity> ->
                    mexpr:TypedTree.ModuleOrNamespaceExpr ->
                      TypedTree.ModuleOrNamespaceExprWithSig
    val MakeInitialEnv :
      env:CheckExpressions.TcEnv ->
        CheckExpressions.TcEnv * TypedTree.ModuleOrNamespaceType ref
    val TypeCheckOneImplFile :
      TcGlobals.TcGlobals * CompilerGlobalState.NiceNameGenerator *
      Import.ImportMap * TypedTree.CcuThunk * (unit -> bool) *
      string list option * NameResolution.TcResultsSink * bool ->
        CheckExpressions.TcEnv ->
          TypedTree.ModuleOrNamespaceType option ->
            SyntaxTree.ParsedImplFileInput ->
              AbstractIL.Internal.Library.Eventually<TopAttribs *
                                                     TypedTree.TypedImplFile *
                                                     TypedTree.ModuleOrNamespaceType *
                                                     CheckExpressions.TcEnv *
                                                     bool>
    val TypeCheckOneSigFile :
      TcGlobals.TcGlobals * CompilerGlobalState.NiceNameGenerator *
      Import.ImportMap * TypedTree.CcuThunk * (unit -> bool) *
      string list option * NameResolution.TcResultsSink * bool ->
        CheckExpressions.TcEnv ->
          SyntaxTree.ParsedSigFileInput ->
            AbstractIL.Internal.Library.Eventually<CheckExpressions.TcEnv *
                                                   TypedTree.ModuleOrNamespaceType *
                                                   bool>
  end

namespace FSharp.Compiler
  module internal Optimizer = begin
    val verboseOptimizationInfo : bool
    val verboseOptimizations : bool
    val i_ldlen : AbstractIL.IL.ILInstr list
    [<LiteralAttribute ()>]
    val callSize : int = 1
    [<LiteralAttribute ()>]
    val forAndWhileLoopSize : int = 5
    [<LiteralAttribute ()>]
    val tryWithSize : int = 5
    [<LiteralAttribute ()>]
    val tryFinallySize : int = 5
    [<LiteralAttribute ()>]
    val closureTotalSize : int = 10
    [<LiteralAttribute ()>]
    val methodDefnTotalSize : int = 1
    type TypeValueInfo = | UnknownTypeValue
    type ExprValueInfo =
      | UnknownValue
      | SizeValue of size: int * ExprValueInfo
      | ValValue of TypedTree.ValRef * ExprValueInfo
      | TupleValue of ExprValueInfo []
      | RecdValue of TypedTree.TyconRef * ExprValueInfo []
      | UnionCaseValue of TypedTree.UnionCaseRef * ExprValueInfo []
      | ConstValue of TypedTree.Const * TypedTree.TType
      | CurriedLambdaValue of
        id: CompilerGlobalState.Unique * arity: int * size: int *
        value: TypedTree.Expr * TypedTree.TType
      | ConstExprValue of size: int * value: TypedTree.Expr
    type ValInfo =
      { ValMakesNoCriticalTailcalls: bool
        ValExprInfo: ExprValueInfo }
    type ValInfos =
      class
        new : entries:seq<TypedTree.ValRef * ValInfo> -> ValInfos
        member Filter : f:(TypedTree.ValRef * ValInfo -> bool) -> ValInfos
        member
          Map : f:(TypedTree.ValRef * ValInfo -> TypedTree.ValRef * ValInfo) ->
                  ValInfos
        member
          TryFind : v:TypedTree.ValRef -> (TypedTree.ValRef * ValInfo) option
        member
          TryFindForFslib : g:TcGlobals.TcGlobals * vref:TypedTree.ValRef ->
                              bool * (TypedTree.ValRef * ValInfo)
        member Entries : seq<TypedTree.ValRef * ValInfo>
      end
    type ModuleInfo =
      { ValInfos: ValInfos
        ModuleOrNamespaceInfos:
          AbstractIL.Internal.Library.NameMap<LazyModuleInfo> }
    and LazyModuleInfo = Lazy<ModuleInfo>
    type ImplFileOptimizationInfo = LazyModuleInfo
    type CcuOptimizationInfo = LazyModuleInfo
    val braceL :
      x:Internal.Utilities.StructuredFormat.Layout ->
        Internal.Utilities.StructuredFormat.Layout
    val seqL :
      xL:('a -> Internal.Utilities.StructuredFormat.Layout) ->
        xs:seq<'a> -> Internal.Utilities.StructuredFormat.Layout
    val namemapL :
      xL:(string -> 'a -> Internal.Utilities.StructuredFormat.Layout) ->
        xmap:AbstractIL.Internal.Library.NameMap<'a> ->
          Internal.Utilities.StructuredFormat.Layout
    val exprValueInfoL :
      g:TcGlobals.TcGlobals ->
        exprVal:ExprValueInfo -> Internal.Utilities.StructuredFormat.Layout
    val exprValueInfosL :
      g:TcGlobals.TcGlobals ->
        vinfos:ExprValueInfo [] -> Internal.Utilities.StructuredFormat.Layout
    val moduleInfoL :
      TcGlobals.TcGlobals ->
        LazyModuleInfo -> Internal.Utilities.StructuredFormat.Layout
    val valInfoL :
      g:TcGlobals.TcGlobals ->
        x:ValInfo -> Internal.Utilities.StructuredFormat.Layout
    type Summary<'Info> =
      { Info: 'Info
        FunctionSize: int
        TotalSize: int
        HasEffect: bool
        MightMakeCriticalTailcall: bool }
    val SizeOfValueInfos : arr:ExprValueInfo [] -> int
    val SizeOfValueInfo : x:ExprValueInfo -> int
    [<LiteralAttribute ()>]
    val minDepthForASizeNode : int = 5
    val MakeValueInfoWithCachedSize :
      vdepth:int -> v:ExprValueInfo -> ExprValueInfo
    val MakeSizedValueInfo : v:ExprValueInfo -> ExprValueInfo
    val BoundValueInfoBySize : vinfo:ExprValueInfo -> ExprValueInfo
    [<LiteralAttribute ()>]
    val jitOptDefault : bool = true
    [<LiteralAttribute ()>]
    val localOptDefault : bool = true
    [<LiteralAttribute ()>]
    val crossModuleOptDefault : bool = true
    type OptimizationSettings =
      { abstractBigTargets: bool
        jitOptUser: bool option
        localOptUser: bool option
        crossModuleOptUser: bool option
        bigTargetSize: int
        veryBigExprSize: int
        lambdaInlineThreshold: int
        reportingPhase: bool
        reportNoNeedToTailcall: bool
        reportFunctionSizes: bool
        reportHasEffect: bool
        reportTotalSizes: bool }
      with
        member EliminateImmediatelyConsumedLocals : unit -> bool
        member EliminateRecdFieldGet : unit -> bool
        member EliminateSequential : unit -> bool
        member EliminateSwitch : unit -> bool
        member EliminateTryWithAndTryFinally : unit -> bool
        member EliminateTupleFieldGet : unit -> bool
        member EliminateUnionCaseFieldGet : unit -> bool
        member EliminateUnusedBindings : unit -> bool
        member ExpandStructuralValues : unit -> bool
        member InlineLambdas : unit -> bool
        member KeepOptimizationValues : unit -> bool
        member crossModuleOpt : unit -> bool
        member jitOpt : unit -> bool
        member localOpt : unit -> bool
        static member Defaults : OptimizationSettings
      end
    type cenv =
      { g: TcGlobals.TcGlobals
        TcVal: ConstraintSolver.TcValF
        amap: Import.ImportMap
        optimizing: bool
        scope: TypedTree.CcuThunk
        localInternalVals:
          System.Collections.Generic.Dictionary<TypedTree.Stamp,ValInfo>
        settings: OptimizationSettings
        emitTailcalls: bool
        casApplied: System.Collections.Generic.Dictionary<TypedTree.Stamp,bool> }
      with
        override ToString : unit -> string
      end
    [<SealedAttribute ()>]
    type IncrementalOptimizationEnv =
      { latestBoundId: SyntaxTree.Ident option
        dontInline: AbstractIL.Internal.Zset<CompilerGlobalState.Unique>
        dontSplitVars: TypedTreeOps.ValMap<unit>
        disableMethodSplitting: bool
        functionVal: (TypedTree.Val * TypedTree.ValReprInfo) option
        typarInfos: (TypedTree.Typar * TypeValueInfo) list
        localExternalVals:
          AbstractIL.Internal.Library.LayeredMap<TypedTree.Stamp,ValInfo>
        globalModuleInfos:
          AbstractIL.Internal.Library.LayeredMap<string,LazyModuleInfo> }
      with
        override ToString : unit -> string
        static member Empty : IncrementalOptimizationEnv
      end
    val IsPartialExprVal : x:ExprValueInfo -> bool
    val CheckInlineValueIsComplete :
      v:TypedTree.Val -> res:ExprValueInfo -> unit
    val check :
      vref:TypedTree.ValRef -> res:ValInfo -> TypedTree.ValRef * ValInfo
    val EmptyModuleInfo : System.Lazy<ModuleInfo>
    val UnionOptimizationInfos : seq<LazyModuleInfo> -> System.Lazy<ModuleInfo>
    val FindOrCreateModuleInfo :
      n:'a -> ss:Map<'a,System.Lazy<ModuleInfo>> -> System.Lazy<ModuleInfo>
        when 'a : comparison
    val FindOrCreateGlobalModuleInfo :
      n:'a ->
        ss:AbstractIL.Internal.Library.LayeredMap<'a,System.Lazy<ModuleInfo>> ->
          System.Lazy<ModuleInfo> when 'a : comparison
    val BindValueInSubModuleFSharpCore :
      mp:string [] ->
        i:int -> v:TypedTree.Val -> vval:ValInfo -> ss:ModuleInfo -> ModuleInfo
    val BindValueInModuleForFslib :
      n:string ->
        mp:string [] ->
          i:int ->
            v:TypedTree.Val ->
              vval:ValInfo ->
                ss:AbstractIL.Internal.Library.NameMap<LazyModuleInfo> ->
                  AbstractIL.Internal.Library.NameMap<LazyModuleInfo>
    val BindValueInGlobalModuleForFslib :
      n:'a ->
        mp:string [] ->
          i:int ->
            v:TypedTree.Val ->
              vval:ValInfo ->
                ss:AbstractIL.Internal.Library.LayeredMap<'a,
                                                          System.Lazy<ModuleInfo>> ->
                  Map<'a,System.Lazy<ModuleInfo>> when 'a : comparison
    val BindValueForFslib :
      nlvref:TypedTree.NonLocalValOrMemberRef ->
        v:TypedTree.Val ->
          vval:ValInfo ->
            env:IncrementalOptimizationEnv -> IncrementalOptimizationEnv
    val UnknownValInfo : ValInfo
    val mkValInfo : info:Summary<ExprValueInfo> -> v:TypedTree.Val -> ValInfo
    val BindInternalLocalVal :
      cenv:cenv -> v:TypedTree.Val -> vval:ValInfo -> env:'a -> 'a
    val BindExternalLocalVal :
      cenv:cenv ->
        v:TypedTree.Val ->
          vval:ValInfo ->
            env:IncrementalOptimizationEnv -> IncrementalOptimizationEnv
    val BindValsInModuleOrNamespace :
      cenv:cenv ->
        mval:LazyModuleInfo ->
          env:IncrementalOptimizationEnv -> IncrementalOptimizationEnv
    val inline BindInternalValToUnknown : cenv:'a -> v:'b -> env:'c -> 'c
    val inline BindInternalValsToUnknown : cenv:'a -> vs:'b -> env:'c -> 'c
    val BindTypeVar :
      tyv:TypedTree.Typar ->
        typeinfo:TypeValueInfo ->
          env:IncrementalOptimizationEnv -> IncrementalOptimizationEnv
    val BindTypeVarsToUnknown :
      tps:TypedTree.Typar list ->
        env:IncrementalOptimizationEnv -> IncrementalOptimizationEnv
    val BindCcu :
      TypedTree.CcuThunk ->
        LazyModuleInfo ->
          IncrementalOptimizationEnv ->
            TcGlobals.TcGlobals -> IncrementalOptimizationEnv
    val GetInfoForLocalValue :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          v:TypedTree.Val -> m:Range.range -> ValInfo
    val TryGetInfoForCcu :
      env:IncrementalOptimizationEnv ->
        ccu:TypedTree.CcuThunk -> LazyModuleInfo option
    val TryGetInfoForEntity : sv:ModuleInfo -> n:string -> ModuleInfo option
    val TryGetInfoForPath :
      sv:ModuleInfo -> p:string [] -> i:int -> ModuleInfo option
    val TryGetInfoForNonLocalEntityRef :
      env:IncrementalOptimizationEnv ->
        nleref:TypedTree.NonLocalEntityRef -> ModuleInfo option
    val GetInfoForNonLocalVal :
      cenv:cenv ->
        env:IncrementalOptimizationEnv -> vref:TypedTree.ValRef -> ValInfo
    val GetInfoForVal :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          m:Range.range -> vref:TypedTree.ValRef -> ValInfo
    val stripValue : _arg1:ExprValueInfo -> ExprValueInfo
    val ( |StripConstValue|_| ) : ev:ExprValueInfo -> TypedTree.Const option
    val ( |StripLambdaValue|_| ) :
      ev:ExprValueInfo ->
        (CompilerGlobalState.Unique * int * int * TypedTree.Expr *
         TypedTree.TType) option
    val destTupleValue : ev:ExprValueInfo -> ExprValueInfo [] option
    val destRecdValue : ev:ExprValueInfo -> ExprValueInfo [] option
    val ( |StripUnionCaseValue|_| ) :
      ev:ExprValueInfo -> (TypedTree.UnionCaseRef * ExprValueInfo []) option
    val mkBoolVal : g:TcGlobals.TcGlobals -> n:bool -> ExprValueInfo
    val mkInt8Val : g:TcGlobals.TcGlobals -> n:sbyte -> ExprValueInfo
    val mkInt16Val : g:TcGlobals.TcGlobals -> n:int16 -> ExprValueInfo
    val mkInt32Val : g:TcGlobals.TcGlobals -> n:int32 -> ExprValueInfo
    val mkInt64Val : g:TcGlobals.TcGlobals -> n:int64 -> ExprValueInfo
    val mkUInt8Val : g:TcGlobals.TcGlobals -> n:byte -> ExprValueInfo
    val mkUInt16Val : g:TcGlobals.TcGlobals -> n:uint16 -> ExprValueInfo
    val mkUInt32Val : g:TcGlobals.TcGlobals -> n:uint32 -> ExprValueInfo
    val mkUInt64Val : g:TcGlobals.TcGlobals -> n:uint64 -> ExprValueInfo
    val ( |StripInt32Value|_| ) : _arg1:ExprValueInfo -> int32 option
    val MakeValueInfoForValue :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          vref:TypedTree.ValRef -> vinfo:ExprValueInfo -> ExprValueInfo
    val MakeValueInfoForRecord :
      tcref:TypedTree.TyconRef -> argvals:ExprValueInfo [] -> ExprValueInfo
    val MakeValueInfoForTuple : argvals:ExprValueInfo [] -> ExprValueInfo
    val MakeValueInfoForUnionCase :
      cspec:TypedTree.UnionCaseRef -> argvals:ExprValueInfo [] -> ExprValueInfo
    val MakeValueInfoForConst :
      c:TypedTree.Const -> ty:TypedTree.TType -> ExprValueInfo
    val inline IntegerUnaryOp :
      g:TcGlobals.TcGlobals ->
        f8:(sbyte -> sbyte) ->
          f16:(int16 -> int16) ->
            f32:(int -> int) ->
              f64:(int64 -> int64) ->
                fu8:(byte -> byte) ->
                  fu16:(uint16 -> uint16) ->
                    fu32:(uint32 -> uint32) ->
                      fu64:(uint64 -> uint64) ->
                        a:ExprValueInfo -> ExprValueInfo option
    val inline SignedIntegerUnaryOp :
      g:TcGlobals.TcGlobals ->
        f8:(sbyte -> sbyte) ->
          f16:(int16 -> int16) ->
            f32:(int32 -> int32) ->
              f64:(int64 -> int64) -> a:ExprValueInfo -> ExprValueInfo option
    val inline IntegerBinaryOp :
      g:TcGlobals.TcGlobals ->
        f8:(sbyte -> sbyte -> sbyte) ->
          f16:(int16 -> int16 -> int16) ->
            f32:(int -> int -> int) ->
              f64:(int64 -> int64 -> int64) ->
                fu8:(byte -> byte -> byte) ->
                  fu16:(uint16 -> uint16 -> uint16) ->
                    fu32:(uint32 -> uint32 -> uint32) ->
                      fu64:(uint64 -> uint64 -> uint64) ->
                        a:ExprValueInfo ->
                          b:ExprValueInfo -> ExprValueInfo option
    val mkAssemblyCodeValueInfo :
      g:TcGlobals.TcGlobals ->
        instrs:AbstractIL.IL.ILInstr list ->
          argvals:ExprValueInfo list ->
            tys:TypedTree.TType list -> ExprValueInfo
    [<LiteralAttribute ()>]
    val localVarSize : int = 1
    val AddTotalSizes : l:Summary<'a> list -> int
    val AddFunctionSizes : l:Summary<'a> list -> int
    val OrEffects : l:Summary<'a> list -> bool
    val OrTailcalls : l:Summary<'a> list -> bool
    val OptimizeList : f:('a -> 'b * 'c) -> l:'a list -> 'b list * 'c list
    val NoExprs : TypedTree.Expr list * Summary<ExprValueInfo> list
    val CombineValueInfos : einfos:Summary<'a> list -> res:'b -> Summary<'b>
    val CombineValueInfosUnknown :
      einfos:Summary<'a> list -> Summary<ExprValueInfo>
    val AbstractLazyModulInfoByHiding :
      isAssemblyBoundary:bool ->
        mhi:TypedTreeOps.SignatureHidingInfo ->
          (LazyModuleInfo -> LazyModuleInfo)
    val AbstractOptimizationInfoToEssentials :
      (System.Lazy<ModuleInfo> -> System.Lazy<ModuleInfo>)
    val AbstractExprInfoByVars :
      boundVars:TypedTree.Val list * boundTyVars:TypedTree.Typar list ->
        ivalue:ExprValueInfo -> ExprValueInfo
    val RemapOptimizationInfo :
      TcGlobals.TcGlobals ->
        TypedTreeOps.Remap -> (LazyModuleInfo -> LazyModuleInfo)
    val AbstractAndRemapModulInfo :
      msg:string ->
        g:TcGlobals.TcGlobals ->
          m:Range.range ->
            repackage:TypedTreeOps.SignatureRepackageInfo *
            hidden:TypedTreeOps.SignatureHidingInfo ->
              info:LazyModuleInfo -> LazyModuleInfo
    [<LiteralAttribute ()>]
    val suffixForVariablesThatMayNotBeEliminated : string = "$cont"
    val IsTyFuncValRefExpr : _arg1:TypedTree.Expr -> bool
    val IsSmallConstExpr : x:TypedTree.Expr -> bool
    val ValueOfExpr : expr:TypedTree.Expr -> ExprValueInfo
    val IsDiscardableEffectExpr : expr:TypedTree.Expr -> bool
    val ValueIsUsedOrHasEffect :
      cenv:cenv ->
        fvs:(unit -> AbstractIL.Internal.Zset<TypedTree.Val>) ->
          b:TypedTree.Binding * binfo:Summary<'a> -> bool
    val SplitValuesByIsUsedOrHasEffect :
      cenv:cenv ->
        fvs:(unit -> AbstractIL.Internal.Zset<TypedTree.Val>) ->
          x:(TypedTree.Binding * Summary<'a>) list ->
            TypedTree.Binding list * Summary<'a> list
    val IlAssemblyCodeInstrHasEffect : i:AbstractIL.IL.ILInstr -> bool
    val IlAssemblyCodeHasEffect : instrs:AbstractIL.IL.ILInstr list -> bool
    val ExprHasEffect : TcGlobals.TcGlobals -> TypedTree.Expr -> bool
    val ExprsHaveEffect : g:TcGlobals.TcGlobals -> exprs:TypedTree.Exprs -> bool
    val BindingsHaveEffect :
      g:TcGlobals.TcGlobals -> binds:TypedTree.Bindings -> bool
    val BindingHasEffect :
      g:TcGlobals.TcGlobals -> bind:TypedTree.Binding -> bool
    val OpHasEffect :
      g:TcGlobals.TcGlobals -> m:Range.range -> op:TypedTree.TOp -> bool
    val TryEliminateBinding :
      cenv:cenv ->
        _env:'a ->
          TypedTree.Binding ->
            e2:TypedTree.Expr -> _m:'b -> TypedTree.Expr option
    val TryEliminateLet :
      cenv:cenv ->
        env:'a ->
          bind:TypedTree.Binding ->
            e2:TypedTree.Expr -> m:Range.range -> TypedTree.Expr * int
    val ( |KnownValApp|_| ) :
      expr:TypedTree.Expr ->
        (TypedTree.ValRef * TypedTree.TType list * TypedTree.Expr list) option
    val ( |TDBoolSwitch|_| ) :
      dtree:TypedTree.DecisionTree ->
        (TypedTree.Expr * bool * TypedTree.DecisionTree * TypedTree.DecisionTree *
         Range.range) option
    val ( |ConstantBoolTarget|_| ) :
      target:TypedTree.DecisionTreeTarget -> bool option
    val CountBoolLogicTree :
      TypedTree.DecisionTreeTarget [] * int * int * bool ->
        tree:TypedTree.DecisionTree -> int * int
    val RewriteBoolLogicTree :
      TypedTree.DecisionTreeTarget [] * TypedTree.DecisionTree *
      TypedTree.DecisionTree * bool ->
        tree:TypedTree.DecisionTree -> TypedTree.DecisionTree
    val RewriteBoolLogicCase :
      TypedTree.DecisionTreeTarget [] * TypedTree.DecisionTree *
      TypedTree.DecisionTree * bool ->
        TypedTree.DecisionTreeCase -> TypedTree.DecisionTreeCase
    val CombineBoolLogic : expr:TypedTree.Expr -> TypedTree.Expr
    val CanExpandStructuralBinding : v:TypedTree.Val -> bool
    val ExprIsValue : _arg1:TypedTree.Expr -> bool
    val MakeStructuralBindingTemp :
      v:TypedTree.Val ->
        i:'a ->
          arg:TypedTree.Expr ->
            argTy:TypedTree.TType -> TypedTree.Expr * TypedTree.Binding
    val ExpandStructuralBindingRaw :
      cenv:cenv -> expr:TypedTree.Expr -> TypedTree.Expr
    val RearrangeTupleBindings :
      expr:TypedTree.Expr ->
        fin:(TypedTree.Expr -> TypedTree.Expr) -> TypedTree.Expr option
    val ExpandStructuralBinding :
      cenv:cenv -> expr:TypedTree.Expr -> TypedTree.Expr
    val ( |QueryRun|_| ) :
      g:TcGlobals.TcGlobals ->
        expr:TypedTree.Expr -> (TypedTree.Expr * TypedTree.TType option) option
    val ( |MaybeRefTupled| ) : e:TypedTree.Expr -> TypedTree.Exprs
    val ( |AnyInstanceMethodApp|_| ) :
      e:TypedTree.Expr ->
        (TypedTree.ValRef * TypedTree.TypeInst * TypedTree.Expr *
         TypedTree.Exprs) option
    val ( |InstanceMethodApp|_| ) :
      g:TcGlobals.TcGlobals ->
        expectedValRef:TypedTree.ValRef ->
          e:TypedTree.Expr ->
            (TypedTree.TypeInst * TypedTree.Expr * TypedTree.Exprs) option
    val ( |QuerySourceEnumerable|_| ) :
      g:TcGlobals.TcGlobals ->
        _arg1:TypedTree.Expr -> (TypedTree.TType * TypedTree.Expr) option
    val ( |QueryFor|_| ) :
      g:TcGlobals.TcGlobals ->
        _arg1:TypedTree.Expr ->
          (TypedTree.TType * TypedTree.TType * TypedTree.TType * TypedTree.Expr *
           TypedTree.Expr) option
    val ( |QueryYield|_| ) :
      g:TcGlobals.TcGlobals ->
        _arg1:TypedTree.Expr ->
          (TypedTree.TType * TypedTree.TType * TypedTree.Expr) option
    val ( |QueryYieldFrom|_| ) :
      g:TcGlobals.TcGlobals ->
        _arg1:TypedTree.Expr ->
          (TypedTree.TType * TypedTree.TType * TypedTree.Expr) option
    val ( |QuerySelect|_| ) :
      g:TcGlobals.TcGlobals ->
        _arg1:TypedTree.Expr ->
          (TypedTree.TType * TypedTree.TType * TypedTree.TType * TypedTree.Expr *
           TypedTree.Expr) option
    val ( |QueryZero|_| ) :
      g:TcGlobals.TcGlobals ->
        _arg1:TypedTree.Expr -> (TypedTree.TType * TypedTree.TType) option
    val ( |AnyRefTupleTrans| ) :
      e:TypedTree.Expr -> TypedTree.Exprs * (TypedTree.Exprs -> TypedTree.Expr)
    val ( |AnyQueryBuilderOpTrans|_| ) :
      g:TcGlobals.TcGlobals ->
        _arg1:TypedTree.Expr ->
          (TypedTree.Expr * (TypedTree.Expr -> TypedTree.Expr)) option
    val tryRewriteToSeqCombinators :
      g:TcGlobals.TcGlobals -> e:TypedTree.Expr -> TypedTree.Expr option
    val TryDetectQueryQuoteAndRun :
      cenv:cenv -> expr:TypedTree.Expr -> TypedTree.Expr option
    val IsILMethodRefSystemStringConcat : mref:AbstractIL.IL.ILMethodRef -> bool
    val IsILMethodRefSystemStringConcatArray :
      mref:AbstractIL.IL.ILMethodRef -> bool
    val OptimizeExpr :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          expr:TypedTree.Expr -> TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeObjectExpr :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          ty:TypedTree.TType * baseValOpt:TypedTree.Val option *
          basecall:TypedTree.Expr * overrides:TypedTree.ObjExprMethod list *
          iimpls:(TypedTree.TType * TypedTree.ObjExprMethod list) list *
          m:Range.range -> TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeMethods :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          baseValOpt:TypedTree.Val option ->
            methods:TypedTree.ObjExprMethod list ->
              TypedTree.ObjExprMethod list * Summary<ExprValueInfo> list
    val OptimizeMethod :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          baseValOpt:TypedTree.Val option ->
            TypedTree.ObjExprMethod ->
              TypedTree.ObjExprMethod * Summary<ExprValueInfo>
    val OptimizeInterfaceImpls :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          baseValOpt:TypedTree.Val option ->
            iimpls:(TypedTree.TType * TypedTree.ObjExprMethod list) list ->
              (TypedTree.TType * TypedTree.ObjExprMethod list) list *
              Summary<ExprValueInfo> list
    val OptimizeInterfaceImpl :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          baseValOpt:TypedTree.Val option ->
            ty:TypedTree.TType * overrides:TypedTree.ObjExprMethod list ->
              (TypedTree.TType * TypedTree.ObjExprMethod list) *
              Summary<ExprValueInfo>
    val MakeOptimizedSystemStringConcatCall :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          m:Range.range ->
            args:TypedTree.Exprs -> TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeExprOp :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          op:TypedTree.TOp * tyargs:TypedTree.TypeInst * args:TypedTree.Exprs *
          m:Range.range -> TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeExprOpReductions :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          op:TypedTree.TOp * tyargs:TypedTree.TypeInst * args:TypedTree.Exprs *
          m:Range.range -> TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeExprOpReductionsAfter :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          op:TypedTree.TOp * tyargs:TypedTree.TypeInst * argsR:TypedTree.Exprs *
          arginfos:Summary<ExprValueInfo> list * m:Range.range ->
            TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeExprOpFallback :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          op:TypedTree.TOp * tyargs:TypedTree.TypeInst * argsR:TypedTree.Exprs *
          m:Range.range ->
            arginfos:Summary<ExprValueInfo> list ->
              valu:ExprValueInfo -> TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeConst :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          expr:TypedTree.Expr ->
            c:TypedTree.Const * m:Range.range * ty:TypedTree.TType ->
              TypedTree.Expr * Summary<ExprValueInfo>
    val TryOptimizeRecordFieldGet :
      cenv:cenv ->
        _env:IncrementalOptimizationEnv ->
          e1info:Summary<ExprValueInfo> * TypedTree.RecdFieldRef *
          _tinst:TypedTree.TypeInst * m:Range.range -> ExprValueInfo option
    val TryOptimizeTupleFieldGet :
      cenv:cenv ->
        _env:IncrementalOptimizationEnv ->
          _tupInfo:TypedTree.TupInfo * e1info:Summary<ExprValueInfo> *
          tys:TypedTree.TypeInst * n:int * m:Range.range -> ExprValueInfo option
    val TryOptimizeUnionCaseGet :
      cenv:cenv ->
        _env:IncrementalOptimizationEnv ->
          e1info:Summary<ExprValueInfo> * cspec:TypedTree.UnionCaseRef *
          _tys:TypedTree.TypeInst * n:int * m:Range.range ->
            ExprValueInfo option
    val OptimizeFastIntegerForLoop :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          spStart:SyntaxTree.DebugPointAtFor * v:TypedTree.Val *
          e1:TypedTree.Expr * dir:TypedTree.ForLoopStyle * e2:TypedTree.Expr *
          e3:TypedTree.Expr * m:Range.range ->
            TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeLetRec :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          binds:TypedTree.Bindings * bodyExpr:TypedTree.Expr * m:Range.range ->
            TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeLinearExpr :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          expr:TypedTree.Expr ->
            contf:(TypedTree.Expr * Summary<ExprValueInfo> ->
                     TypedTree.Expr * Summary<ExprValueInfo>) ->
              TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeTryFinally :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          spTry:SyntaxTree.DebugPointAtTry *
          spFinally:SyntaxTree.DebugPointAtFinally * e1:TypedTree.Expr *
          e2:TypedTree.Expr * m:Range.range * ty:TypedTree.TType ->
            TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeTryWith :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          e1:TypedTree.Expr * vf:TypedTree.Val * ef:TypedTree.Expr *
          vh:TypedTree.Val * eh:TypedTree.Expr * m:Range.range *
          ty:TypedTree.TType * spTry:SyntaxTree.DebugPointAtTry *
          spWith:SyntaxTree.DebugPointAtWith ->
            TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeWhileLoop :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          spWhile:SyntaxTree.DebugPointAtWhile *
          marker:TypedTree.SpecialWhileLoopMarker * e1:TypedTree.Expr *
          e2:TypedTree.Expr * m:Range.range ->
            TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeTraitCall :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          traitInfo:TypedTree.TraitConstraintInfo * args:TypedTree.Exprs *
          m:Range.range -> TypedTree.Expr * Summary<ExprValueInfo>
    val TryOptimizeVal :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          mustInline:bool * valInfoForVal:ExprValueInfo * m:Range.range ->
            TypedTree.Expr option
    val TryOptimizeValInfo :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          m:Range.range -> vinfo:Summary<ExprValueInfo> -> TypedTree.Expr option
    val AddValEqualityInfo :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          v:TypedTree.ValRef ->
            info:Summary<ExprValueInfo> -> Summary<ExprValueInfo>
    val OptimizeVal :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          expr:TypedTree.Expr ->
            v:TypedTree.ValRef * m:Range.range ->
              TypedTree.Expr * Summary<ExprValueInfo>
    val StripToNominalTyconRef :
      cenv:cenv -> ty:TypedTree.TType -> TypedTree.TyconRef * TypedTree.TypeInst
    val CanDevirtualizeApplication :
      cenv:cenv ->
        v:TypedTree.ValRef ->
          vref:TypedTree.ValRef -> ty:TypedTree.TType -> args:'a list -> bool
    val TakeAddressOfStructArgumentIfNeeded :
      cenv:cenv ->
        vref:TypedTree.ValRef ->
          ty:TypedTree.TType ->
            args:TypedTree.Expr list ->
              m:Range.range ->
                (TypedTree.Expr -> TypedTree.Expr) * TypedTree.Expr list
    val DevirtualizeApplication :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          vref:TypedTree.ValRef ->
            ty:TypedTree.TType ->
              tyargs:TypedTree.TType list ->
                args:TypedTree.Expr list ->
                  m:Range.range -> TypedTree.Expr * Summary<ExprValueInfo>
    val TryDevirtualizeApplication :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          f:TypedTree.Expr * tyargs:TypedTree.TType list *
          args:TypedTree.Expr list * m:Range.range ->
            (TypedTree.Expr * Summary<ExprValueInfo>) option
    val TryInlineApplication :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          finfo:Summary<ExprValueInfo> ->
            tyargs:TypedTree.TType list * args:TypedTree.Expr list *
            m:Range.range -> (TypedTree.Expr * Summary<ExprValueInfo>) option
    val OptimizeApplication :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          f0:TypedTree.Expr * f0ty:TypedTree.TType * tyargs:TypedTree.TypeInst *
          args:TypedTree.Exprs * m:Range.range ->
            TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeLambdas :
      vspec:TypedTree.Val option ->
        cenv:cenv ->
          env:IncrementalOptimizationEnv ->
            topValInfo:TypedTree.ValReprInfo ->
              e:TypedTree.Expr ->
                ety:TypedTree.TType -> TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeExprsThenReshapeAndConsiderSplits :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          exprs:(ExprValueInfo * TypedTree.Expr) list ->
            TypedTree.Exprs * Summary<ExprValueInfo> list
    val OptimizeExprsThenConsiderSplits :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          exprs:TypedTree.Exprs -> TypedTree.Exprs * Summary<ExprValueInfo> list
    val OptimizeExprThenReshapeAndConsiderSplit :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          shape:ExprValueInfo * e:TypedTree.Expr ->
            TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeDecisionTreeTargets :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          m:Range.range ->
            targets:TypedTree.DecisionTreeTarget [] ->
              TypedTree.DecisionTreeTarget list * Summary<ExprValueInfo> list
    val ReshapeExpr :
      cenv:cenv -> shape:ExprValueInfo * e:TypedTree.Expr -> TypedTree.Expr
    val OptimizeExprThenConsiderSplit :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          e:TypedTree.Expr -> TypedTree.Expr * Summary<ExprValueInfo>
    val ComputeSplitToMethodCondition :
      flag:bool ->
        threshold:int ->
          cenv:cenv ->
            env:IncrementalOptimizationEnv ->
              e:TypedTree.Expr * einfo:Summary<'b> -> bool
    val ConsiderSplitToMethod :
      flag:bool ->
        threshold:int ->
          cenv:cenv ->
            env:IncrementalOptimizationEnv ->
              e:TypedTree.Expr * einfo:Summary<ExprValueInfo> ->
                TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeMatch :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          spMatch:SyntaxTree.DebugPointForBinding * exprm:Range.range *
          dtree:TypedTree.DecisionTree *
          targets:TypedTree.DecisionTreeTarget array * m:Range.range *
          ty:TypedTree.TType -> TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeMatchPart2 :
      cenv:cenv ->
        spMatch:SyntaxTree.DebugPointForBinding * exprm:Range.range *
        dtreeR:TypedTree.DecisionTree *
        targetsR:TypedTree.DecisionTreeTarget list *
        dinfo:Summary<ExprValueInfo> * tinfos:Summary<ExprValueInfo> list *
        m:Range.range * ty:TypedTree.TType ->
          TypedTree.Expr * Summary<ExprValueInfo>
    val CombineMatchInfos :
      dinfo:Summary<'c> -> tinfo:Summary<'d> -> Summary<ExprValueInfo>
    val RebuildOptimizedMatch :
      spMatch:SyntaxTree.DebugPointForBinding * exprm:Range.range *
      m:Range.range * ty:TypedTree.TType * dtree:TypedTree.DecisionTree *
      tgs:TypedTree.DecisionTreeTarget list * dinfo:Summary<ExprValueInfo> *
      tinfos:Summary<ExprValueInfo> list ->
        TypedTree.Expr * Summary<ExprValueInfo>
    val OptimizeDecisionTreeTarget :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          _m:Range.range ->
            TypedTree.DecisionTreeTarget ->
              TypedTree.DecisionTreeTarget * Summary<ExprValueInfo>
    val OptimizeDecisionTree :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          m:Range.range ->
            x:TypedTree.DecisionTree ->
              TypedTree.DecisionTree * Summary<ExprValueInfo>
    val TryOptimizeDecisionTreeTest :
      cenv:cenv ->
        test:TypedTree.DecisionTreeTest -> vinfo:ExprValueInfo -> bool option
    val OptimizeSwitch :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          e:TypedTree.Expr * cases:TypedTree.DecisionTreeCase list *
          dflt:TypedTree.DecisionTree option * m:Range.range ->
            TypedTree.DecisionTree * Summary<ExprValueInfo>
    val OptimizeSwitchFallback :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          eR:TypedTree.Expr * einfo:Summary<ExprValueInfo> *
          cases:TypedTree.DecisionTreeCase list *
          dflt:TypedTree.DecisionTree option * m:Range.range ->
            TypedTree.DecisionTree * Summary<ExprValueInfo>
    val OptimizeBinding :
      cenv:cenv ->
        isRec:bool ->
          env:IncrementalOptimizationEnv ->
            TypedTree.Binding ->
              (TypedTree.Binding * Summary<ExprValueInfo>) *
              IncrementalOptimizationEnv
    val OptimizeBindings :
      cenv:cenv ->
        isRec:bool ->
          env:IncrementalOptimizationEnv ->
            xs:TypedTree.Bindings ->
              (TypedTree.Binding * Summary<ExprValueInfo>) list *
              IncrementalOptimizationEnv
    val OptimizeModuleExpr :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          x:TypedTree.ModuleOrNamespaceExprWithSig ->
            TypedTree.ModuleOrNamespaceExprWithSig * LazyModuleInfo
    val mkValBind : bind:TypedTree.Binding -> info:'e -> TypedTree.ValRef * 'e
    val OptimizeModuleDef :
      cenv:cenv ->
        env:IncrementalOptimizationEnv *
        bindInfosColl:(TypedTree.Binding * Summary<ExprValueInfo>) list list ->
          x:TypedTree.ModuleOrNamespaceExpr ->
            (TypedTree.ModuleOrNamespaceExpr * System.Lazy<ModuleInfo>) *
            (IncrementalOptimizationEnv *
             (TypedTree.Binding * Summary<ExprValueInfo>) list list)
    val OptimizeModuleBindings :
      cenv:cenv ->
        env:IncrementalOptimizationEnv *
        bindInfosColl:(TypedTree.Binding * Summary<ExprValueInfo>) list list ->
          xs:TypedTree.ModuleOrNamespaceBinding list ->
            (TypedTree.ModuleOrNamespaceBinding *
             Choice<(TypedTree.Binding * Summary<ExprValueInfo>),
                    (string * LazyModuleInfo)>) list *
            (IncrementalOptimizationEnv *
             (TypedTree.Binding * Summary<ExprValueInfo>) list list)
    val OptimizeModuleBinding :
      cenv:cenv ->
        env:IncrementalOptimizationEnv *
        bindInfosColl:(TypedTree.Binding * Summary<ExprValueInfo>) list list ->
          x:TypedTree.ModuleOrNamespaceBinding ->
            (TypedTree.ModuleOrNamespaceBinding *
             Choice<(TypedTree.Binding * Summary<ExprValueInfo>),
                    (string * LazyModuleInfo)>) *
            (IncrementalOptimizationEnv *
             (TypedTree.Binding * Summary<ExprValueInfo>) list list)
    val OptimizeModuleDefs :
      cenv:cenv ->
        env:IncrementalOptimizationEnv *
        bindInfosColl:(TypedTree.Binding * Summary<ExprValueInfo>) list list ->
          defs:TypedTree.ModuleOrNamespaceExpr list ->
            (TypedTree.ModuleOrNamespaceExpr list * System.Lazy<ModuleInfo>) *
            (IncrementalOptimizationEnv *
             (TypedTree.Binding * Summary<ExprValueInfo>) list list)
    val OptimizeImplFileInternal :
      cenv:cenv ->
        env:IncrementalOptimizationEnv ->
          isIncrementalFragment:bool ->
            hidden:TypedTreeOps.SignatureHidingInfo ->
              TypedTree.TypedImplFile ->
                IncrementalOptimizationEnv * TypedTree.TypedImplFile *
                LazyModuleInfo * TypedTreeOps.SignatureHidingInfo
    val OptimizeImplFile :
      OptimizationSettings * TypedTree.CcuThunk * TcGlobals.TcGlobals *
      ConstraintSolver.TcValF * Import.ImportMap * IncrementalOptimizationEnv *
      isIncrementalFragment:bool * emitTailcalls:bool *
      TypedTreeOps.SignatureHidingInfo * TypedTree.TypedImplFile ->
        (IncrementalOptimizationEnv * TypedTree.TypedImplFile * LazyModuleInfo *
         TypedTreeOps.SignatureHidingInfo) *
        (bool -> TypedTree.Expr -> TypedTree.Expr)
    val p_ExprValueInfo :
      x:ExprValueInfo -> st:TypedTreePickle.WriterState -> unit
    val p_ValInfo : v:ValInfo -> st:TypedTreePickle.WriterState -> unit
    val p_ModuleInfo : x:ModuleInfo -> st:TypedTreePickle.WriterState -> unit
    val p_LazyModuleInfo :
      x:LazyModuleInfo -> st:TypedTreePickle.WriterState -> unit
    val p_CcuOptimizationInfo :
      LazyModuleInfo -> TypedTreePickle.WriterState -> unit
    val u_ExprInfo : st:TypedTreePickle.ReaderState -> ExprValueInfo
    val u_ValInfo : st:TypedTreePickle.ReaderState -> ValInfo
    val u_ModuleInfo : st:TypedTreePickle.ReaderState -> ModuleInfo
    val u_LazyModuleInfo : st:TypedTreePickle.ReaderState -> LazyModuleInfo
    val u_CcuOptimizationInfo : TypedTreePickle.ReaderState -> LazyModuleInfo
  end

namespace FSharp.Compiler
  module internal Detuple = begin
    val ( |TyappAndApp|_| ) :
      e:TypedTree.Expr ->
        (TypedTree.Expr * TypedTree.TType * TypedTree.TType list *
         TypedTree.Exprs * Range.range) option
    module GlobalUsageAnalysis = begin
      val bindAccBounds :
        vals:AbstractIL.Internal.Zset<'a> ->
          _isInDTree:'b * v:'a -> AbstractIL.Internal.Zset<'a>
      val GetValsBoundInExpr :
        TypedTree.Expr -> AbstractIL.Internal.Zset<TypedTree.Val>
      type accessor = | TupleGet of int * TypedTree.TType list
      type Results =
        { Uses:
            AbstractIL.Internal.Zmap<TypedTree.Val,
                                     (accessor list * TypedTree.TType list *
                                      TypedTree.Expr list) list>
          Defns: AbstractIL.Internal.Zmap<TypedTree.Val,TypedTree.Expr>
          DecisionTreeBindings: AbstractIL.Internal.Zset<TypedTree.Val>
          RecursiveBindings:
            AbstractIL.Internal.Zmap<TypedTree.Val,(bool * TypedTree.Vals)>
          TopLevelBindings: AbstractIL.Internal.Zset<TypedTree.Val>
          IterationIsAtTopLevel: bool }
      val z0 : Results
      val logUse :
        f:TypedTree.Val ->
          accessor list * TypedTree.TType list * TypedTree.Expr list ->
            z:Results -> Results
      val logBinding : z:Results -> isInDTree:bool * v:TypedTree.Val -> Results
      val logNonRecBinding : z:Results -> bind:TypedTree.Binding -> Results
      val logRecBindings : z:Results -> binds:TypedTree.Bindings -> Results
      val foldUnderLambda :
        f:(Results -> 'a -> Results) -> z:Results -> x:'a -> Results
      val UsageFolders :
        g:TcGlobals.TcGlobals -> TypedTreeOps.ExprFolder<Results>
      val GetUsageInfoOfImplFile :
        TcGlobals.TcGlobals -> TypedTree.TypedImplFile -> Results
    end
    val internalError : str:string -> 'a
    val mkLocalVal :
      m:Range.range ->
        name:string ->
          ty:TypedTree.TType ->
            topValInfo:TypedTree.ValReprInfo option -> TypedTree.Val
    type TupleStructure =
      | UnknownTS
      | TupleTS of TupleStructure list
    val ValReprInfoForTS : ts:TupleStructure -> TypedTree.ArgReprInfo list list
    val andTS : ts:TupleStructure -> tsB:TupleStructure -> TupleStructure
    val checkTS : _arg1:TupleStructure -> TupleStructure
    val uncheckedExprTS : expr:TypedTree.Expr -> TupleStructure
    val uncheckedTypeTS :
      g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> TupleStructure
    val exprTS : exprs:TypedTree.Expr -> TupleStructure
    val typeTS : g:TcGlobals.TcGlobals -> tys:TypedTree.TType -> TupleStructure
    val rebuildTS :
      g:TcGlobals.TcGlobals ->
        m:Range.range ->
          ts:TupleStructure -> vs:TypedTree.Val list -> TypedTree.Expr
    type CallPattern = TupleStructure list
    val callPatternOrder : (CallPattern -> CallPattern -> int)
    val argsCP : exprs:TypedTree.Expr list -> TupleStructure list
    val noArgsCP : 'a list
    val inline isTrivialCP : xs:'a list -> bool
    val minimalCallPattern :
      callPattern:TupleStructure list -> TupleStructure list
    val commonCallPattern :
      callPatterns:TupleStructure list list -> TupleStructure list
    val siteCP :
      _accessors:'a * _inst:'b * args:TypedTree.Expr list -> TupleStructure list
    val sitesCPs :
      sites:('a * 'b * TypedTree.Expr list) list -> TupleStructure list list
    type TransformedFormal =
      | SameArg
      | NewArgs of TypedTree.Val list * TypedTree.Expr
    type Transform =
      { transformCallPattern: CallPattern
        transformedFormals: TransformedFormal list
        transformedVal: TypedTree.Val }
    val mkTransform :
      g:TcGlobals.TcGlobals ->
        f:TypedTree.Val ->
          m:Range.range ->
            tps:TypedTree.Typar list ->
              x1Ntys:TypedTree.TType list ->
                rty:TypedTree.TType ->
                  callPattern:TupleStructure list *
                  tyfringes:(TypedTree.TType list * TypedTree.Val list) list ->
                    Transform
    val zipTupleStructureAndType :
      g:TcGlobals.TcGlobals ->
        ts:TupleStructure ->
          ty:TypedTree.TType -> TupleStructure * TypedTree.TType list
    val zipTupleStructuresAndTypes :
      g:TcGlobals.TcGlobals ->
        tss:TupleStructure list ->
          tys:TypedTree.TTypes -> TupleStructure list * TypedTree.TType list
    val zipCallPatternArgTys :
      m:Range.range ->
        g:TcGlobals.TcGlobals ->
          callPattern:TupleStructure list ->
            vss:TypedTree.Val list list ->
              TupleStructure list *
              (TypedTree.TType list * TypedTree.Val list) list
    val decideFormalSuggestedCP :
      g:TcGlobals.TcGlobals ->
        z:GlobalUsageAnalysis.Results ->
          tys:TypedTree.TType list ->
            vss:TypedTree.Val list list -> TupleStructure list
    val decideTransform :
      g:TcGlobals.TcGlobals ->
        z:GlobalUsageAnalysis.Results ->
          v:TypedTree.Val ->
            callPatterns:TupleStructure list list ->
              m:Range.range * tps:TypedTree.Typar list *
              vss:TypedTree.Val list list * rty:TypedTree.TType ->
                (TypedTree.Val * Transform) option
    val eligibleVal :
      g:TcGlobals.TcGlobals -> m:Range.range -> v:TypedTree.Val -> bool
    val determineTransforms :
      g:TcGlobals.TcGlobals ->
        z:GlobalUsageAnalysis.Results ->
          AbstractIL.Internal.Zmap<TypedTree.Val,Transform>
    type penv =
      { transforms: AbstractIL.Internal.Zmap<TypedTree.Val,Transform>
        ccu: TypedTree.CcuThunk
        g: TcGlobals.TcGlobals }
    val hasTransfrom : penv:penv -> f:TypedTree.Val -> Transform option
    type env =
      { eg: TcGlobals.TcGlobals
        prefix: string
        m: Range.range }
      with
        override ToString : unit -> string
      end
    val suffixE : env:env -> s:string -> env
    val rangeE : env:env -> m:Range.range -> env
    val push : b:'a -> bs:'a list -> 'a list
    val pushL : xs:'a list -> bs:'a list -> 'a list
    val newLocal :
      env:env -> ty:TypedTree.TType -> TypedTree.Val * TypedTree.Expr
    val newLocalN :
      env:env -> i:'a -> ty:TypedTree.TType -> TypedTree.Val * TypedTree.Expr
    val noEffectExpr :
      env:env ->
        bindings:TypedTree.Binding list ->
          x:TypedTree.Expr -> TypedTree.Binding list * TypedTree.Expr
    val buildProjections :
      env:env ->
        bindings:TypedTree.Binding list ->
          x:TypedTree.Expr ->
            xtys:TypedTree.TType list ->
              TypedTree.Binding list * TypedTree.Expr list
    val collapseArg :
      env:env ->
        bindings:TypedTree.Binding list ->
          ts:TupleStructure ->
            x:TypedTree.Expr -> TypedTree.Binding list * TypedTree.Expr list
    val collapseArgs :
      env:env ->
        bindings:TypedTree.Binding list ->
          n:int ->
            callPattern:TupleStructure list ->
              args:TypedTree.Exprs ->
                TypedTree.Binding list * TypedTree.Expr list
    val mkLets :
      binds:TypedTree.Binding list -> body:TypedTree.Expr -> TypedTree.Expr
    val fixupApp :
      penv:penv ->
        fx:TypedTree.Expr * fty:TypedTree.TType * tys:TypedTree.TypeInst *
        args:TypedTree.Exprs * m:Range.range -> TypedTree.Expr
    val transFormal :
      ybi:TransformedFormal -> xi:TypedTree.Val list -> TypedTree.Val list list
    val transRebind :
      ybi:TransformedFormal -> xi:TypedTree.Val list -> TypedTree.Binding list
    val passBind : penv:penv -> TypedTree.Binding -> TypedTree.Binding
    val passBinds :
      penv:penv -> binds:TypedTree.Binding list -> TypedTree.Binding list
    val passBindRhs :
      conv:(TypedTree.Expr -> TypedTree.Expr) ->
        TypedTree.Binding -> TypedTree.Binding
    val preInterceptExpr :
      penv:penv ->
        conv:(TypedTree.Expr -> TypedTree.Expr) ->
          expr:TypedTree.Expr -> TypedTree.Expr option
    val postTransformExpr :
      penv:penv -> expr:TypedTree.Expr -> TypedTree.Expr option
    val passImplFile :
      penv:penv -> assembly:TypedTree.TypedImplFile -> TypedTree.TypedImplFile
    val DetupleImplFile :
      TypedTree.CcuThunk ->
        TcGlobals.TcGlobals ->
          TypedTree.TypedImplFile -> TypedTree.TypedImplFile
  end

namespace FSharp.Compiler
  module internal InnerLambdasToTopLevelFuncs = begin
    val verboseTLR : bool
    val internalError : str:string -> 'a
    module Zmap = begin
      val force :
        k:'a ->
          mp:AbstractIL.Internal.Zmap<'a,'b> ->
            str:string * soK:('a -> string) -> 'b
    end
    type Tree<'T> =
      | TreeNode of Tree<'T> list
      | LeafNode of 'T
    val fringeTR : tr:Tree<'a> -> 'a list
    val emptyTR : Tree<'a>
    val destApp :
      f:TypedTree.Expr * fty:TypedTree.TType * tys:TypedTree.TType list *
      args:'a * m:'b ->
        TypedTree.Expr * TypedTree.TType * TypedTree.TType list * 'a * 'b
    val showTyparSet : tps:AbstractIL.Internal.Zset<TypedTree.Typar> -> string
    val isDelayedRepr : f:TypedTree.Val -> e:TypedTree.Expr -> bool
    val mkLocalNameTypeArity :
      compgen:bool ->
        m:Range.range ->
          name:string ->
            ty:TypedTree.TType ->
              topValInfo:TypedTree.ValReprInfo option -> TypedTree.Val
    val GetValsBoundUnderMustInline :
      xinfo:Detuple.GlobalUsageAnalysis.Results ->
        AbstractIL.Internal.Zset<TypedTree.Val>
    val IsRefusedTLR : g:TcGlobals.TcGlobals -> f:TypedTree.Val -> bool
    val IsMandatoryTopLevel : f:TypedTree.Val -> bool
    val IsMandatoryNonTopLevel :
      g:TcGlobals.TcGlobals -> f:TypedTree.Val -> bool
    module Pass1_DetermineTLRAndArities = begin
      val GetMaxNumArgsAtUses :
        xinfo:Detuple.GlobalUsageAnalysis.Results -> f:TypedTree.Val -> int
      val SelectTLRVals :
        g:TcGlobals.TcGlobals ->
          xinfo:Detuple.GlobalUsageAnalysis.Results ->
            f:TypedTree.Val -> e:TypedTree.Expr -> (TypedTree.Val * int) option
      val IsValueRecursionFree :
        xinfo:Detuple.GlobalUsageAnalysis.Results -> f:TypedTree.Val -> bool
      val DumpArity : arityM:AbstractIL.Internal.Zmap<TypedTree.Val,int> -> unit
      val DetermineTLRAndArities :
        g:TcGlobals.TcGlobals ->
          expr:TypedTree.TypedImplFile ->
            AbstractIL.Internal.Zset<TypedTree.Val> *
            AbstractIL.Internal.Zset<TypedTree.Val> *
            AbstractIL.Internal.Zmap<TypedTree.Val,int>
    end
    type BindingGroupSharingSameReqdItems =
      class
        new : bindings:TypedTree.Bindings -> BindingGroupSharingSameReqdItems
        member Contains : v:TypedTree.Val -> bool
        override ToString : unit -> string
        member IsEmpty : bool
        member Pairs : (TypedTree.Val * BindingGroupSharingSameReqdItems) list
        member Vals : TypedTree.Vals
      end
    val fclassOrder :
      System.Collections.Generic.IComparer<BindingGroupSharingSameReqdItems>
    type ReqdItem =
      | ReqdSubEnv of TypedTree.Val
      | ReqdVal of TypedTree.Val
      with
        override ToString : unit -> string
      end
    val reqdItemOrder : System.Collections.Generic.IComparer<ReqdItem>
    type ReqdItemsForDefn =
      { reqdTypars: AbstractIL.Internal.Zset<TypedTree.Typar>
        reqdItems: AbstractIL.Internal.Zset<ReqdItem>
        m: Range.range }
      with
        static member
          Initial : typars:TypedTree.Typar list ->
                      m:Range.range -> ReqdItemsForDefn
        member
          Extend : typars:TypedTree.Typar list * items:ReqdItem list ->
                     ReqdItemsForDefn
        override ToString : unit -> string
        member ReqdSubEnvs : TypedTree.Val list
        member ReqdVals : TypedTree.Val list
      end
    type Generators = AbstractIL.Internal.Zset<TypedTree.Val>
    val IsArityMet :
      vref:TypedTree.ValRef ->
        wf:int -> tys:TypedTree.TypeInst -> args:'a list -> bool
    module Pass2_DetermineReqdItems = begin
      type state =
        { stack:
            (BindingGroupSharingSameReqdItems * Generators * ReqdItemsForDefn) list
          reqdItemsMap:
            AbstractIL.Internal.Zmap<BindingGroupSharingSameReqdItems,
                                     ReqdItemsForDefn>
          fclassM:
            AbstractIL.Internal.Zmap<TypedTree.Val,
                                     BindingGroupSharingSameReqdItems>
          revDeclist: BindingGroupSharingSameReqdItems list
          recShortCallS: AbstractIL.Internal.Zset<TypedTree.Val> }
      val state0 : state
      val PushFrame :
        fclass:BindingGroupSharingSameReqdItems ->
          reqdTypars0:TypedTree.Typar list * reqdVals0:Generators *
          m:Range.range -> state:state -> state
      val SaveFrame :
        fclass:BindingGroupSharingSameReqdItems -> state:state -> state
      val LogRequiredFrom :
        gv:TypedTree.Val -> items:ReqdItem list -> state:state -> state
      val LogShortCall : gv:TypedTree.Val -> state:state -> state
      val FreeInBindings : bs:TypedTree.Binding list -> TypedTree.FreeVars
      val ExprEnvIntercept :
        tlrS:AbstractIL.Internal.Zset<TypedTree.Val> *
        arityM:AbstractIL.Internal.Zmap<TypedTree.Val,int> ->
          recurseF:(state -> TypedTree.Expr -> state) ->
            noInterceptF:(state -> TypedTree.Expr -> state) ->
              z:state -> expr:TypedTree.Expr -> state
      val CloseReqdTypars :
        fclassM:AbstractIL.Internal.Zmap<TypedTree.Val,'a> ->
          reqdItemsMap:AbstractIL.Internal.Zmap<'a,ReqdItemsForDefn> ->
            AbstractIL.Internal.Zmap<'a,ReqdItemsForDefn>
      val DumpReqdValMap :
        reqdItemsMap:seq<System.Collections.Generic.KeyValuePair<'a,'b>> -> unit
      val DetermineReqdItems :
        tlrS:AbstractIL.Internal.Zset<TypedTree.Val> *
        arityM:AbstractIL.Internal.Zmap<TypedTree.Val,int> ->
          expr:TypedTree.TypedImplFile ->
            AbstractIL.Internal.Zmap<BindingGroupSharingSameReqdItems,
                                     ReqdItemsForDefn> *
            AbstractIL.Internal.Zmap<TypedTree.Val,
                                     BindingGroupSharingSameReqdItems> *
            BindingGroupSharingSameReqdItems list *
            AbstractIL.Internal.Zset<TypedTree.Val>
    end
    type PackedReqdItems =
      { ep_etps: TypedTree.Typars
        ep_aenvs: TypedTree.Val list
        ep_pack: TypedTree.Bindings
        ep_unpack: TypedTree.Bindings }
    exception AbortTLR of Range.range
    val FlatEnvPacks :
      g:TcGlobals.TcGlobals ->
        fclassM:AbstractIL.Internal.Zmap<TypedTree.Val,
                                         BindingGroupSharingSameReqdItems> ->
          topValS:AbstractIL.Internal.Zset<TypedTree.Val> ->
            declist:#BindingGroupSharingSameReqdItems list ->
              reqdItemsMap:AbstractIL.Internal.Zmap<BindingGroupSharingSameReqdItems,
                                                    ReqdItemsForDefn> ->
                AbstractIL.Internal.Zmap<BindingGroupSharingSameReqdItems,
                                         PackedReqdItems>
    val DumpEnvPackM :
      g:TcGlobals.TcGlobals ->
        envPackM:seq<System.Collections.Generic.KeyValuePair<'a,PackedReqdItems>> ->
          unit
    val ChooseReqdItemPackings :
      g:TcGlobals.TcGlobals ->
        fclassM:AbstractIL.Internal.Zmap<TypedTree.Val,
                                         BindingGroupSharingSameReqdItems> ->
          topValS:AbstractIL.Internal.Zset<TypedTree.Val> ->
            declist:#BindingGroupSharingSameReqdItems list ->
              reqdItemsMap:AbstractIL.Internal.Zmap<BindingGroupSharingSameReqdItems,
                                                    ReqdItemsForDefn> ->
                AbstractIL.Internal.Zmap<BindingGroupSharingSameReqdItems,
                                         PackedReqdItems>
    val MakeSimpleArityInfo :
      tps:TypedTree.Typar list -> n:int -> TypedTree.ValReprInfo
    val CreateNewValuesForTLR :
      g:TcGlobals.TcGlobals ->
        tlrS:AbstractIL.Internal.Zset<TypedTree.Val> ->
          arityM:AbstractIL.Internal.Zmap<TypedTree.Val,int> ->
            fclassM:AbstractIL.Internal.Zmap<TypedTree.Val,'a> ->
              envPackM:AbstractIL.Internal.Zmap<'a,PackedReqdItems> ->
                AbstractIL.Internal.Zmap<TypedTree.Val,TypedTree.Val>
    module Pass4_RewriteAssembly = begin
      [<NoEqualityAttribute (); NoComparisonAttribute ()>]
      type RewriteContext =
        { ccu: TypedTree.CcuThunk
          g: TcGlobals.TcGlobals
          tlrS: AbstractIL.Internal.Zset<TypedTree.Val>
          topValS: AbstractIL.Internal.Zset<TypedTree.Val>
          arityM: AbstractIL.Internal.Zmap<TypedTree.Val,int>
          fclassM:
            AbstractIL.Internal.Zmap<TypedTree.Val,
                                     BindingGroupSharingSameReqdItems>
          recShortCallS: AbstractIL.Internal.Zset<TypedTree.Val>
          envPackM:
            AbstractIL.Internal.Zmap<BindingGroupSharingSameReqdItems,
                                     PackedReqdItems>
          fHatM: AbstractIL.Internal.Zmap<TypedTree.Val,TypedTree.Val> }
      type IsRecursive =
        | IsRec
        | NotRec
      type LiftedDeclaration = IsRecursive * TypedTree.Bindings
      type RewriteState =
        { rws_mustinline: bool
          rws_innerLevel: int
          rws_preDecs: Tree<LiftedDeclaration> }
      val rewriteState0 : RewriteState
      val EnterInner : z:RewriteState -> RewriteState
      val ExitInner : z:RewriteState -> RewriteState
      val EnterMustInline :
        b:bool ->
          z:RewriteState ->
            f:(RewriteState -> 'a * RewriteState) -> RewriteState * 'a
      val ExtractPreDecs :
        z:RewriteState -> LiftedDeclaration list * RewriteState
      val PopPreDecs : z:RewriteState -> RewriteState * Tree<LiftedDeclaration>
      val SetPreDecs :
        z:RewriteState -> pdt:Tree<LiftedDeclaration> -> RewriteState
      val LiftTopBinds : _isRec:'a -> _penv:'b -> z:'c -> binds:'d -> 'c * 'd
      val MakePreDec :
        m:Range.range ->
          isRec:IsRecursive * binds:TypedTree.Bindings ->
            expr:TypedTree.Expr -> TypedTree.Expr
      val MakePreDecs :
        m:Range.range ->
          preDecs:(IsRecursive * TypedTree.Bindings) list ->
            expr:TypedTree.Expr -> TypedTree.Expr
      val RecursivePreDecs :
        pdsA:Tree<'a * 'b list> ->
          pdsB:Tree<'a * 'b list> -> Tree<IsRecursive * 'b list>
      val ConvertBind :
        g:TcGlobals.TcGlobals -> TypedTree.Binding -> TypedTree.Binding
      val TransTLRBindings :
        penv:RewriteContext ->
          binds:TypedTree.Bindings ->
            TypedTree.Binding list * TypedTree.Binding list
      val GetAEnvBindings :
        penv:RewriteContext ->
          fc:BindingGroupSharingSameReqdItems -> TypedTree.Binding list
      val TransBindings :
        xisRec:IsRecursive ->
          penv:RewriteContext ->
            binds:TypedTree.Bindings ->
              TypedTree.Binding list * TypedTree.Binding list
      val TransApp :
        penv:RewriteContext ->
          fx:TypedTree.Expr * fty:TypedTree.TType * tys:TypedTree.TypeInst *
          args:TypedTree.Expr list * m:Range.range -> TypedTree.Expr
      val TransExpr :
        penv:RewriteContext ->
          z:RewriteState -> expr:TypedTree.Expr -> TypedTree.Expr * RewriteState
      val TransLinearExpr :
        penv:RewriteContext ->
          z:RewriteState ->
            expr:TypedTree.Expr ->
              contf:(TypedTree.Expr * RewriteState ->
                       TypedTree.Expr * RewriteState) ->
                TypedTree.Expr * RewriteState
      val TransMethod :
        penv:RewriteContext ->
          z:RewriteState ->
            TypedTree.ObjExprMethod -> TypedTree.ObjExprMethod * RewriteState
      val TransBindingRhs :
        penv:RewriteContext ->
          z:RewriteState ->
            TypedTree.Binding -> TypedTree.Binding * RewriteState
      val TransDecisionTree :
        penv:RewriteContext ->
          z:RewriteState ->
            x:TypedTree.DecisionTree -> TypedTree.DecisionTree * RewriteState
      val TransDecisionTreeTarget :
        penv:RewriteContext ->
          z:RewriteState ->
            TypedTree.DecisionTreeTarget ->
              TypedTree.DecisionTreeTarget * RewriteState
      val TransValBinding :
        penv:RewriteContext ->
          z:RewriteState ->
            bind:TypedTree.Binding -> TypedTree.Binding * RewriteState
      val TransValBindings :
        penv:RewriteContext ->
          z:RewriteState ->
            binds:TypedTree.Binding list ->
              TypedTree.Binding list * RewriteState
      val TransModuleExpr :
        penv:RewriteContext ->
          z:RewriteState ->
            x:TypedTree.ModuleOrNamespaceExprWithSig ->
              TypedTree.ModuleOrNamespaceExprWithSig * RewriteState
      val TransModuleDefs :
        penv:RewriteContext ->
          z:RewriteState ->
            x:TypedTree.ModuleOrNamespaceExpr list ->
              TypedTree.ModuleOrNamespaceExpr list * RewriteState
      val TransModuleDef :
        penv:RewriteContext ->
          z:RewriteState ->
            x:TypedTree.ModuleOrNamespaceExpr ->
              TypedTree.ModuleOrNamespaceExpr * RewriteState
      val TransModuleBindings :
        penv:RewriteContext ->
          z:RewriteState ->
            binds:TypedTree.ModuleOrNamespaceBinding list ->
              TypedTree.ModuleOrNamespaceBinding list * RewriteState
      val TransModuleBinding :
        penv:RewriteContext ->
          z:RewriteState ->
            x:TypedTree.ModuleOrNamespaceBinding ->
              TypedTree.ModuleOrNamespaceBinding * RewriteState
      val TransImplFile :
        penv:RewriteContext ->
          z:RewriteState ->
            TypedTree.TypedImplFile -> TypedTree.TypedImplFile * RewriteState
    end
    val RecreateUniqueBounds :
      g:TcGlobals.TcGlobals ->
        expr:TypedTree.TypedImplFile -> TypedTree.TypedImplFile
    val MakeTLRDecisions :
      TypedTree.CcuThunk ->
        TcGlobals.TcGlobals ->
          TypedTree.TypedImplFile -> TypedTree.TypedImplFile
  end

namespace FSharp.Compiler
  module internal LowerCallsAndSeqs = begin
    val InterceptExpr :
      g:TcGlobals.TcGlobals ->
        cont:(TypedTree.Expr -> TypedTree.Expr) ->
          expr:TypedTree.Expr -> TypedTree.Expr option
    val LowerImplFile :
      g:TcGlobals.TcGlobals ->
        assembly:TypedTree.TypedImplFile -> TypedTree.TypedImplFile
    val mkLambdaNoType :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> uv:TypedTree.Val -> e:TypedTree.Expr -> TypedTree.Expr
    val callNonOverloadedMethod :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          m:Range.range ->
            methName:string ->
              ty:TypedTree.TType -> args:TypedTree.Exprs -> TypedTree.Expr
    type LoweredSeqFirstPhaseResult =
      { phase2:
          TypedTree.ValRef * TypedTree.ValRef * TypedTree.ValRef *
          Map<AbstractIL.IL.ILCodeLabel,int> ->
            TypedTree.Expr * TypedTree.Expr * TypedTree.Expr
        entryPoints: int list
        significantClose: bool
        stateVars: TypedTree.ValRef list
        asyncVars: TypedTree.FreeVars }
    val isVarFreeInExpr : v:TypedTree.Val -> e:TypedTree.Expr -> bool
    val ( |Seq|_| ) :
      g:TcGlobals.TcGlobals ->
        expr:TypedTree.Expr -> (TypedTree.Expr * TypedTree.TType) option
    val IsPossibleSequenceExpr :
      g:TcGlobals.TcGlobals -> overallExpr:TypedTree.Expr -> bool
    val ConvertSequenceExprToObject :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          overallExpr:TypedTree.Expr ->
            (TypedTree.ValRef * TypedTree.ValRef * TypedTree.ValRef *
             TypedTree.ValRef list * TypedTree.Expr * TypedTree.Expr *
             TypedTree.Expr * TypedTree.TType * Range.range) option
  end

namespace FSharp.Compiler
  module internal AutoBox = begin
    type cenv =
      { g: TcGlobals.TcGlobals
        amap: Import.ImportMap }
      with
        override ToString : unit -> string
      end
    val DecideEscapes :
      syntacticArgs:TypedTree.Val list ->
        body:TypedTree.Expr -> AbstractIL.Internal.Zset<TypedTree.Val>
    val DecideLambda :
      exprF:(AbstractIL.Internal.Zset<TypedTree.Val> -> TypedTree.Expr ->
               AbstractIL.Internal.Zset<TypedTree.Val>) option ->
        cenv:cenv ->
          topValInfo:TypedTree.ValReprInfo ->
            expr:TypedTree.Expr ->
              ety:TypedTree.TType ->
                z:AbstractIL.Internal.Zset<TypedTree.Val> ->
                  AbstractIL.Internal.Zset<TypedTree.Val>
    val DecideExprOp :
      exprF:(AbstractIL.Internal.Zset<TypedTree.Val> -> TypedTree.Expr ->
               AbstractIL.Internal.Zset<TypedTree.Val>) ->
        noInterceptF:(AbstractIL.Internal.Zset<TypedTree.Val> ->
                        TypedTree.Expr ->
                        AbstractIL.Internal.Zset<TypedTree.Val>) ->
          z:AbstractIL.Internal.Zset<TypedTree.Val> ->
            expr:TypedTree.Expr ->
              op:TypedTree.TOp * tyargs:'a list * args:TypedTree.Expr list ->
                AbstractIL.Internal.Zset<TypedTree.Val>
    val DecideExpr :
      cenv:cenv ->
        exprF:(AbstractIL.Internal.Zset<TypedTree.Val> -> TypedTree.Expr ->
                 AbstractIL.Internal.Zset<TypedTree.Val>) ->
          noInterceptF:(AbstractIL.Internal.Zset<TypedTree.Val> ->
                          TypedTree.Expr ->
                          AbstractIL.Internal.Zset<TypedTree.Val>) ->
            z:AbstractIL.Internal.Zset<TypedTree.Val> ->
              expr:TypedTree.Expr -> AbstractIL.Internal.Zset<TypedTree.Val>
    val DecideBinding :
      cenv:cenv ->
        z:AbstractIL.Internal.Zset<TypedTree.Val> ->
          TypedTree.Binding -> AbstractIL.Internal.Zset<TypedTree.Val>
    val DecideBindings :
      cenv:cenv ->
        z:AbstractIL.Internal.Zset<TypedTree.Val> ->
          binds:TypedTree.Binding list ->
            AbstractIL.Internal.Zset<TypedTree.Val>
    val DecideImplFile :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          implFile:TypedTree.TypedImplFile ->
            AbstractIL.Internal.Zset<TypedTree.Val>
    val TransformExpr :
      g:TcGlobals.TcGlobals ->
        nvs:TypedTreeOps.ValMap<'a * TypedTree.Expr> ->
          exprF:(TypedTree.Expr -> TypedTree.Expr) ->
            expr:TypedTree.Expr -> TypedTree.Expr option
    val TransformBinding :
      g:TcGlobals.TcGlobals ->
        nvs:TypedTreeOps.ValMap<TypedTree.Val * 'a> ->
          exprF:(TypedTree.Expr -> TypedTree.Expr) ->
            TypedTree.Binding -> TypedTree.Binding option
    val TransformImplFile :
      g:TcGlobals.TcGlobals ->
        amap:Import.ImportMap ->
          implFile:TypedTree.TypedImplFile -> TypedTree.TypedImplFile
  end

namespace FSharp.Compiler
  module internal IlxGen = begin
    val IsNonErasedTypar : tp:TypedTree.Typar -> bool
    val DropErasedTypars : tps:TypedTree.Typar list -> TypedTree.Typar list
    val DropErasedTyargs : tys:TypedTree.TType list -> TypedTree.TType list
    val AddNonUserCompilerGeneratedAttribs :
      g:TcGlobals.TcGlobals ->
        mdef:AbstractIL.IL.ILMethodDef -> AbstractIL.IL.ILMethodDef
    val debugDisplayMethodName : string
    val useHiddenInitCode : bool
    val iLdcZero : AbstractIL.IL.ILInstr
    val iLdcInt64 : i:int64 -> AbstractIL.IL.ILInstr
    val iLdcDouble : i:double -> AbstractIL.IL.ILInstr
    val iLdcSingle : i:single -> AbstractIL.IL.ILInstr
    val mkLdfldMethodDef :
      ilMethName:string * reprAccess:AbstractIL.IL.ILMemberAccess *
      isStatic:bool * ilTy:AbstractIL.IL.ILType * ilFieldName:string *
      ilPropType:AbstractIL.IL.ILType -> AbstractIL.IL.ILMethodDef
    val ChooseParamNames :
      fieldNamesAndTypes:(string * string * 'a) list ->
        (string * string * 'a) list
    val CheckCodeDoesSomething : code:AbstractIL.IL.ILCode -> bool
    val ChooseFreeVarNames :
      takenNames:string list -> ts:string list -> string list
    val IsILTypeByref : _arg1:AbstractIL.IL.ILType -> bool
    val mainMethName : string
    type AttributeDecoder =
      class
        new : namedArgs:TypedTree.AttribNamedArg list -> AttributeDecoder
        member FindBool : x:string -> dflt:bool -> bool
        member FindInt16 : x:string -> dflt:int16 -> int16
        member FindInt32 : x:string -> dflt:int32 -> int32
        member FindString : x:string -> dflt:string -> string
        member FindTypeName : x:string -> dflt:string -> string
      end
    val mutable reports : (System.IO.TextWriter -> unit)
    val AddReport : f:(System.IO.TextWriter -> unit) -> unit
    val ReportStatistics : System.IO.TextWriter -> unit
    val NewCounter : nm:string -> (unit -> unit)
    val CountClosure : (unit -> unit)
    val CountMethodDef : (unit -> unit)
    val CountStaticFieldDef : (unit -> unit)
    val CountCallFuncInstructions : (unit -> unit)
    type IlxGenIntraAssemblyInfo =
      { StaticFieldInfo:
          System.Collections.Generic.Dictionary<AbstractIL.IL.ILMethodRef,
                                                AbstractIL.IL.ILFieldSpec> }
    type FakeUnit = | Fake
    type IlxGenBackend =
      | IlWriteBackend
      | IlReflectBackend
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type IlxGenOptions =
      { fragName: string
        generateFilterBlocks: bool
        workAroundReflectionEmitBugs: bool
        emitConstantArraysUsingStaticDataBlobs: bool
        mainMethodInfo: TypedTree.Attribs option
        localOptimizationsAreOn: bool
        generateDebugSymbols: bool
        testFlagEmitFeeFeeAs100001: bool
        ilxBackend: IlxGenBackend
        isInteractive: bool
        isInteractiveItExpr: bool
        alwaysCallVirt: bool }
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type cenv =
      { g: TcGlobals.TcGlobals
        amap: Import.ImportMap
        tcVal: ConstraintSolver.TcValF
        viewCcu: TypedTree.CcuThunk
        opts: IlxGenOptions
        mutable ilUnitTy: AbstractIL.IL.ILType option
        intraAssemblyInfo: IlxGenIntraAssemblyInfo
        casApplied: System.Collections.Generic.Dictionary<TypedTree.Stamp,bool>
        mutable optimizeDuringCodeGen: bool -> TypedTree.Expr -> TypedTree.Expr
        mutable exprRecursionDepth: int
        delayedGenMethods: System.Collections.Generic.Queue<(cenv -> unit)> }
      with
        override ToString : unit -> string
      end
    val mkTypeOfExpr :
      cenv:cenv -> m:Range.range -> ilty:AbstractIL.IL.ILType -> TypedTree.Expr
    val mkGetNameExpr :
      cenv:cenv -> ilt:AbstractIL.IL.ILType -> m:Range.range -> TypedTree.Expr
    val useCallVirt :
      cenv:cenv ->
        boxity:AbstractIL.IL.ILBoxity ->
          mspec:AbstractIL.IL.ILMethodSpec -> isBaseCall:bool -> bool
    type CompileLocation =
      { Scope: AbstractIL.IL.ILScopeRef
        TopImplQualifiedName: string
        Namespace: string option
        Enclosing: string list
        QualifiedNameOfFile: string }
    val mkTopName : ns:string option -> n:string -> string
    val CompLocForFragment :
      fragName:string -> ccu:TypedTree.CcuThunk -> CompileLocation
    val CompLocForCcu : ccu:TypedTree.CcuThunk -> CompileLocation
    val CompLocForSubModuleOrNamespace :
      cloc:CompileLocation ->
        submod:TypedTree.ModuleOrNamespace -> CompileLocation
    val CompLocForFixedPath :
      fragName:string ->
        qname:string -> TypedTree.CompilationPath -> CompileLocation
    val CompLocForFixedModule :
      fragName:string ->
        qname:string -> mspec:TypedTree.ModuleOrNamespace -> CompileLocation
    val NestedTypeRefForCompLoc :
      cloc:CompileLocation -> n:string -> AbstractIL.IL.ILTypeRef
    val CleanUpGeneratedTypeName : nm:string -> string
    val TypeNameForInitClass : cloc:CompileLocation -> string
    val TypeNameForImplicitMainMethod : cloc:CompileLocation -> string
    val TypeNameForPrivateImplementationDetails : cloc:CompileLocation -> string
    val CompLocForInitClass : cloc:CompileLocation -> CompileLocation
    val CompLocForImplicitMainMethod : cloc:CompileLocation -> CompileLocation
    val CompLocForPrivateImplementationDetails :
      cloc:CompileLocation -> CompileLocation
    val TypeRefForCompLoc : cloc:CompileLocation -> AbstractIL.IL.ILTypeRef
    val mkILTyForCompLoc : cloc:CompileLocation -> AbstractIL.IL.ILType
    val ComputeMemberAccess : hidden:bool -> AbstractIL.IL.ILMemberAccess
    val ComputePublicTypeAccess : unit -> AbstractIL.IL.ILTypeDefAccess
    val ComputeTypeAccess :
      tref:AbstractIL.IL.ILTypeRef ->
        hidden:bool -> AbstractIL.IL.ILTypeDefAccess
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type TypeReprEnv =
      class
        new : reprs:Map<TypedTree.Stamp,uint16> * count:int -> TypeReprEnv
        static member ForTycon : tycon:TypedTree.Tycon -> TypeReprEnv
        static member ForTyconRef : tycon:TypedTree.TyconRef -> TypeReprEnv
        static member ForTypars : tps:TypedTree.Typar list -> TypeReprEnv
        member Add : tps:TypedTree.Typar list -> TypeReprEnv
        member AddOne : tp:TypedTree.Typar -> TypeReprEnv
        member Item : tp:TypedTree.Typar * m:Range.range -> uint16
        member Count : int
        static member Empty : TypeReprEnv
      end
    val GenTyconRef : tcref:TypedTree.TyconRef -> TypedTree.CompiledTypeRepr
    type VoidNotOK =
      | VoidNotOK
      | VoidOK
    val voidCheck :
      m:Range.range ->
        g:TcGlobals.TcGlobals -> permits:VoidNotOK -> ty:TypedTree.TType -> unit
    type PtrsOK =
      | PtrTypesOK
      | PtrTypesNotOK
    val GenReadOnlyAttributeIfNecessary :
      g:TcGlobals.TcGlobals ->
        ty:TypedTree.TType -> AbstractIL.IL.ILAttribute option
    val GenReadOnlyModReqIfNecessary :
      g:TcGlobals.TcGlobals ->
        ty:TypedTree.TType -> ilTy:AbstractIL.IL.ILType -> AbstractIL.IL.ILType
    val GenTypeArgAux :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv -> tyarg:TypedTree.TType -> AbstractIL.IL.ILType
    val GenTypeArgsAux :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv ->
            tyargs:TypedTree.TType list -> AbstractIL.IL.ILType list
    val GenTyAppAux :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv ->
            repr:TypedTree.CompiledTypeRepr ->
              tinst:TypedTree.TType list -> AbstractIL.IL.ILType
    val GenILTyAppAux :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv ->
            tref:AbstractIL.IL.ILTypeRef * boxity:AbstractIL.IL.ILBoxity *
            ilTypeOpt:AbstractIL.IL.ILType option ->
              tinst:TypedTree.TType list -> AbstractIL.IL.ILType
    val GenNamedTyAppAux :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv ->
            ptrsOK:PtrsOK ->
              tcref:TypedTree.TyconRef ->
                tinst:TypedTree.TType list -> AbstractIL.IL.ILType
    val GenTypeAux :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv ->
            voidOK:VoidNotOK ->
              ptrsOK:PtrsOK -> ty:TypedTree.TType -> AbstractIL.IL.ILType
    val GenUnionCaseRef :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv ->
            i:int ->
              fspecs:TypedTree.RecdField [] ->
                AbstractIL.Extensions.ILX.Types.IlxUnionField []
    val GenUnionRef :
      amap:Import.ImportMap ->
        m:Range.range ->
          tcref:TypedTree.TyconRef ->
            AbstractIL.Extensions.ILX.Types.IlxUnionRef
    val ComputeUnionHasHelpers :
      g:TcGlobals.TcGlobals ->
        tcref:TypedTree.TyconRef ->
          AbstractIL.Extensions.ILX.Types.IlxUnionHasHelpers
    val GenUnionSpec :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv ->
            tcref:TypedTree.TyconRef ->
              tyargs:TypedTree.TypeInst ->
                AbstractIL.Extensions.ILX.Types.IlxUnionSpec
    val GenUnionCaseSpec :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv ->
            ucref:TypedTree.UnionCaseRef ->
              tyargs:TypedTree.TypeInst ->
                AbstractIL.Extensions.ILX.Types.IlxUnionSpec * int
    val GenType :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv -> ty:TypedTree.TType -> AbstractIL.IL.ILType
    val GenTypes :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv ->
            tys:TypedTree.TType list -> AbstractIL.IL.ILType list
    val GenTypePermitVoid :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv -> ty:TypedTree.TType -> AbstractIL.IL.ILType
    val GenTypesPermitVoid :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv ->
            tys:TypedTree.TType list -> AbstractIL.IL.ILType list
    val GenTyApp :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv ->
            repr:TypedTree.CompiledTypeRepr ->
              tyargs:TypedTree.TType list -> AbstractIL.IL.ILType
    val GenNamedTyApp :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv ->
            tcref:TypedTree.TyconRef ->
              tinst:TypedTree.TType list -> AbstractIL.IL.ILType
    val GenReturnType :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv ->
            returnTyOpt:TypedTree.TType option -> AbstractIL.IL.ILType
    val GenParamType :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv ->
            isSlotSig:bool -> ty:TypedTree.TType -> AbstractIL.IL.ILType
    val GenParamTypes :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv ->
            isSlotSig:bool ->
              tys:TypedTree.TType list -> AbstractIL.IL.ILType list
    val GenTypeArgs :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv ->
            tyargs:TypedTree.TypeInst -> AbstractIL.IL.ILGenericArgs
    val GenTypePermitVoidAux :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv -> ty:TypedTree.TType -> AbstractIL.IL.ILType
    val GenFieldSpecForStaticField :
      isInteractive:bool * g:TcGlobals.TcGlobals *
      ilContainerTy:AbstractIL.IL.ILType * vspec:TypedTree.Val * nm:string *
      m:Range.range * cloc:CompileLocation * ilTy:AbstractIL.IL.ILType ->
        AbstractIL.IL.ILFieldSpec
    val GenRecdFieldRef :
      m:Range.range ->
        cenv:cenv ->
          tyenv:TypeReprEnv ->
            rfref:TypedTree.RecdFieldRef ->
              tyargs:TypedTree.TType list -> AbstractIL.IL.ILFieldSpec
    val GenExnType :
      amap:Import.ImportMap ->
        m:Range.range ->
          tyenv:TypeReprEnv -> ecref:TypedTree.TyconRef -> AbstractIL.IL.ILType
    type ArityInfo = int list
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type IlxClosureInfo =
      { cloExpr: TypedTree.Expr
        cloName: string
        cloArityInfo: ArityInfo
        ilCloFormalReturnTy: AbstractIL.IL.ILType
        ilCloAllFreeVars: AbstractIL.Extensions.ILX.Types.IlxClosureFreeVar []
        cloSpec: AbstractIL.Extensions.ILX.Types.IlxClosureSpec
        cloAttribs: TypedTree.Attribs
        cloILGenericParams: AbstractIL.IL.ILGenericParameterDefs
        cloFreeVars: TypedTree.Val list
        cloFreeTyvars: TypedTree.Typars
        cloWitnessInfos: TypedTreeOps.TraitWitnessInfos
        ilCloLambdas: AbstractIL.Extensions.ILX.Types.IlxClosureLambdas
        localTypeFuncILGenericArgs: AbstractIL.IL.ILType list
        localTypeFuncContractFreeTypars: TypedTree.Typar list
        localTypeFuncDirectILGenericParams: AbstractIL.IL.ILGenericParameterDefs
        localTypeFuncInternalFreeTypars: TypedTree.Typar list }
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type ValStorage =
      | Null
      | StaticField of
        AbstractIL.IL.ILFieldSpec * TypedTree.ValRef * bool *
        AbstractIL.IL.ILType * string * AbstractIL.IL.ILType *
        AbstractIL.IL.ILMethodRef * AbstractIL.IL.ILMethodRef *
        OptionalShadowLocal
      | StaticProperty of AbstractIL.IL.ILMethodSpec * OptionalShadowLocal
      | Method of
        TypedTree.ValReprInfo * TypedTree.ValRef * AbstractIL.IL.ILMethodSpec *
        AbstractIL.IL.ILMethodSpec * Range.range * TypedTree.Typars *
        TypedTree.Typars * TypedTreeOps.CurriedArgInfos *
        TypedTree.ArgReprInfo list * TypedTreeOps.TraitWitnessInfos *
        TypedTree.TType list * TypedTree.ArgReprInfo
      | Env of
        AbstractIL.IL.ILType * AbstractIL.IL.ILFieldSpec *
        NamedLocalIlxClosureInfo ref option
      | Arg of int
      | Local of idx: int * realloc: bool * NamedLocalIlxClosureInfo ref option
    and OptionalShadowLocal =
      | NoShadowLocal
      | ShadowLocal of ValStorage
    and NamedLocalIlxClosureInfo =
      | NamedLocalIlxClosureInfoGenerator of (IlxGenEnv -> IlxClosureInfo)
      | NamedLocalIlxClosureInfoGenerated of IlxClosureInfo
      with
        override ToString : unit -> string
      end
    and ModuleStorage =
      { Vals: Lazy<AbstractIL.Internal.Library.NameMap<ValStorage>>
        SubModules: Lazy<AbstractIL.Internal.Library.NameMap<ModuleStorage>> }
      with
        override ToString : unit -> string
      end
    and BranchCallItem =
      | BranchCallClosure of ArityInfo
      | BranchCallMethod of
        ArityInfo * (TypedTree.TType * TypedTree.ArgReprInfo) list list *
        TypedTree.Typars * int * int * int
      with
        override ToString : unit -> string
      end
    and Mark =
      | Mark of AbstractIL.IL.ILCodeLabel
      with
        member CodeLabel : AbstractIL.IL.ILCodeLabel
      end
    and sequel =
      | EndFilter
      | LeaveHandler of (bool * int * Mark)
      | Br of Mark
      | CmpThenBrOrContinue of Pops * AbstractIL.IL.ILInstr list
      | Continue
      | DiscardThen of sequel
      | Return
      | EndLocalScope of sequel * Mark
      | ReturnVoid
    and Pushes = AbstractIL.IL.ILType list
    and Pops = int
    and IlxGenEnv =
      { tyenv: TypeReprEnv
        someTypeInThisAssembly: AbstractIL.IL.ILType
        isFinalFile: bool
        cloc: CompileLocation
        sigToImplRemapInfo:
          (TypedTreeOps.Remap * TypedTreeOps.SignatureHidingInfo) list
        valsInScope: TypedTreeOps.ValMap<Lazy<ValStorage>>
        witnessesInScope: TypedTreeOps.TraitWitnessInfoHashMap<ValStorage>
        suppressWitnesses: bool
        innerVals: (TypedTree.ValRef * (BranchCallItem * Mark)) list
        letBoundVars: TypedTree.ValRef list
        liveLocals: Lib.IntMap<unit>
        withinSEH: bool
        isInLoop: bool }
      with
        override ToString : unit -> string
      end
    val discard : sequel
    val discardAndReturnVoid : sequel
    val SetIsInLoop : isInLoop:bool -> eenv:IlxGenEnv -> IlxGenEnv
    val ReplaceTyenv : tyenv:TypeReprEnv -> eenv:IlxGenEnv -> IlxGenEnv
    val EnvForTypars : tps:TypedTree.Typar list -> eenv:IlxGenEnv -> IlxGenEnv
    val AddTyparsToEnv :
      typars:TypedTree.Typar list -> eenv:IlxGenEnv -> IlxGenEnv
    val AddSignatureRemapInfo :
      _msg:'a ->
        rpi:TypedTreeOps.SignatureRepackageInfo *
        mhi:TypedTreeOps.SignatureHidingInfo -> eenv:IlxGenEnv -> IlxGenEnv
    val OutputStorage : pps:System.IO.TextWriter -> s:ValStorage -> unit
    val AddStorageForVal :
      g:TcGlobals.TcGlobals ->
        v:TypedTree.Val * s:Lazy<ValStorage> -> eenv:IlxGenEnv -> IlxGenEnv
    val AddStorageForLocalVals :
      g:TcGlobals.TcGlobals ->
        vals:(TypedTree.Val * ValStorage) list -> eenv:IlxGenEnv -> IlxGenEnv
    val AddStorageForLocalWitness :
      eenv:IlxGenEnv -> w:TypedTree.TraitWitnessInfo * s:ValStorage -> IlxGenEnv
    val AddStorageForLocalWitnesses :
      witnesses:(TypedTree.TraitWitnessInfo * ValStorage) list ->
        eenv:IlxGenEnv -> IlxGenEnv
    val StorageForVal :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> v:TypedTree.Val -> eenv:IlxGenEnv -> ValStorage
    val StorageForValRef :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> v:TypedTree.ValRef -> eenv:IlxGenEnv -> ValStorage
    val ComputeGenerateWitnesses :
      g:TcGlobals.TcGlobals -> eenv:IlxGenEnv -> bool
    val TryStorageForWitness :
      _g:TcGlobals.TcGlobals ->
        eenv:IlxGenEnv -> w:TypedTree.TraitWitnessInfo -> ValStorage option
    val IsValRefIsDllImport :
      g:TcGlobals.TcGlobals -> vref:TypedTree.ValRef -> bool
    val GetMethodSpecForMemberVal :
      amap:Import.ImportMap ->
        g:TcGlobals.TcGlobals ->
          memberInfo:TypedTree.ValMemberInfo ->
            vref:TypedTree.ValRef ->
              AbstractIL.IL.ILMethodSpec * AbstractIL.IL.ILMethodSpec *
              TypedTree.Typar list * TypedTree.Typar list *
              TypedTreeOps.CurriedArgInfos * TypedTree.ArgReprInfo list *
              TypedTree.ArgReprInfo * TypedTreeOps.TraitWitnessInfos *
              TypedTree.TType list * TypedTree.TType option
    val ComputeFieldSpecForVal :
      optIntraAssemblyInfo:IlxGenIntraAssemblyInfo option * isInteractive:bool *
      g:TcGlobals.TcGlobals * ilTyForProperty:AbstractIL.IL.ILType *
      vspec:TypedTree.Val * nm:string * m:Range.range * cloc:CompileLocation *
      ilTy:AbstractIL.IL.ILType * ilGetterMethRef:AbstractIL.IL.ILMethodRef ->
        AbstractIL.IL.ILFieldSpec
    val ComputeStorageForFSharpValue :
      amap:Import.ImportMap ->
        g:TcGlobals.TcGlobals ->
          cloc:CompileLocation ->
            optIntraAssemblyInfo:IlxGenIntraAssemblyInfo option ->
              optShadowLocal:OptionalShadowLocal ->
                isInteractive:bool ->
                  returnTy:TypedTree.TType ->
                    vref:TypedTree.ValRef -> m:Range.range -> ValStorage
    val ComputeStorageForFSharpMember :
      amap:Import.ImportMap ->
        g:TcGlobals.TcGlobals ->
          topValInfo:TypedTree.ValReprInfo ->
            memberInfo:TypedTree.ValMemberInfo ->
              vref:TypedTree.ValRef -> m:Range.range -> ValStorage
    val ComputeStorageForFSharpFunctionOrFSharpExtensionMember :
      amap:Import.ImportMap ->
        g:TcGlobals.TcGlobals ->
          cloc:CompileLocation ->
            topValInfo:TypedTree.ValReprInfo ->
              vref:TypedTree.ValRef -> m:Range.range -> ValStorage
    val IsFSharpValCompiledAsMethod :
      TcGlobals.TcGlobals -> TypedTree.Val -> bool
    val ComputeStorageForTopVal :
      amap:Import.ImportMap * g:TcGlobals.TcGlobals *
      optIntraAssemblyInfo:IlxGenIntraAssemblyInfo option * isInteractive:bool *
      optShadowLocal:OptionalShadowLocal * vref:TypedTree.ValRef *
      cloc:CompileLocation -> ValStorage
    val ComputeAndAddStorageForLocalTopVal :
      amap:Import.ImportMap * g:TcGlobals.TcGlobals *
      intraAssemblyFieldTable:IlxGenIntraAssemblyInfo * isInteractive:bool *
      optShadowLocal:OptionalShadowLocal ->
        cloc:CompileLocation -> v:TypedTree.Val -> eenv:IlxGenEnv -> IlxGenEnv
    val ComputeStorageForNonLocalTopVal :
      amap:Import.ImportMap ->
        g:TcGlobals.TcGlobals ->
          cloc:CompileLocation ->
            modref:TypedTree.EntityRef -> v:TypedTree.Val -> ValStorage
    val AddStorageForNonLocalModuleOrNamespaceRef :
      amap:Import.ImportMap ->
        g:TcGlobals.TcGlobals ->
          cloc:CompileLocation ->
            acc:IlxGenEnv ->
              modref:TypedTree.ModuleOrNamespaceRef ->
                modul:TypedTree.ModuleOrNamespace -> IlxGenEnv
    val AddStorageForExternalCcu :
      amap:Import.ImportMap ->
        g:TcGlobals.TcGlobals ->
          eenv:IlxGenEnv -> ccu:TypedTree.CcuThunk -> IlxGenEnv
    val AddBindingsForLocalModuleType :
      allocVal:(CompileLocation -> TypedTree.Val -> 'a -> 'a) ->
        cloc:CompileLocation ->
          eenv:'a -> mty:TypedTree.ModuleOrNamespaceType -> 'a
    val AddExternalCcusToIlxGenEnv :
      amap:Import.ImportMap ->
        g:TcGlobals.TcGlobals ->
          eenv:IlxGenEnv -> ccus:TypedTree.CcuThunk list -> IlxGenEnv
    val AddBindingsForTycon :
      allocVal:(CompileLocation -> TypedTree.Val -> 'a -> 'a) ->
        cloc:CompileLocation -> tycon:TypedTree.Tycon -> eenv:'a -> 'a
    val AddBindingsForModuleDefs :
      allocVal:(CompileLocation -> TypedTree.Val -> 'a -> 'a) ->
        cloc:CompileLocation ->
          eenv:'a -> mdefs:TypedTree.ModuleOrNamespaceExpr list -> 'a
    val AddBindingsForModuleDef :
      allocVal:(CompileLocation -> TypedTree.Val -> 'a -> 'a) ->
        cloc:CompileLocation ->
          eenv:'a -> x:TypedTree.ModuleOrNamespaceExpr -> 'a
    val AddBindingsForModule :
      allocVal:(CompileLocation -> TypedTree.Val -> 'a -> 'a) ->
        cloc:CompileLocation ->
          x:TypedTree.ModuleOrNamespaceBinding -> eenv:'a -> 'a
    val AddBindingsForModuleTopVals :
      _g:'a ->
        allocVal:('b -> 'c -> 'c) -> _cloc:'d -> eenv:'c -> vs:'b list -> 'c
    val AddIncrementalLocalAssemblyFragmentToIlxGenEnv :
      amap:Import.ImportMap * isIncrementalFragment:bool * g:TcGlobals.TcGlobals *
      ccu:TypedTree.CcuThunk * fragName:string *
      intraAssemblyInfo:IlxGenIntraAssemblyInfo * eenv:IlxGenEnv *
      typedImplFiles:TypedTree.TypedImplFile list -> IlxGenEnv
    val GenILSourceMarker :
      g:TcGlobals.TcGlobals -> m:Range.range -> AbstractIL.IL.ILSourceMarker
    val GenPossibleILSourceMarker :
      cenv:cenv -> m:Range.range -> AbstractIL.IL.ILSourceMarker option
    val HashRangeSorted :
      ht:System.Collections.Generic.IDictionary<'a,(int * 'b)> -> 'b list
    val MergeOptions :
      m:Range.range -> o1:'a option -> o2:'a option -> 'a option
    val MergePropertyPair :
      m:Range.range ->
        pd:AbstractIL.IL.ILPropertyDef ->
          pdef:AbstractIL.IL.ILPropertyDef -> AbstractIL.IL.ILPropertyDef
    type PropKey =
      | PropKey of
        string * AbstractIL.IL.ILTypes * AbstractIL.IL.ILThisConvention
    val AddPropertyDefToHash :
      m:Range.range ->
        ht:System.Collections.Generic.Dictionary<PropKey,
                                                 (int *
                                                  AbstractIL.IL.ILPropertyDef)> ->
          pdef:AbstractIL.IL.ILPropertyDef -> unit
    val MergePropertyDefs :
      m:Range.range ->
        ilPropertyDefs:#AbstractIL.IL.ILPropertyDef list ->
          AbstractIL.IL.ILPropertyDef list
    type TypeDefBuilder =
      class
        new : tdef:AbstractIL.IL.ILTypeDef *
              tdefDiscards:((AbstractIL.IL.ILMethodDef -> bool) *
                            (AbstractIL.IL.ILPropertyDef -> bool)) option ->
                TypeDefBuilder
        member AddEventDef : edef:AbstractIL.IL.ILEventDef -> unit
        member AddFieldDef : ilFieldDef:AbstractIL.IL.ILFieldDef -> unit
        member AddMethodDef : ilMethodDef:AbstractIL.IL.ILMethodDef -> unit
        member
          AddOrMergePropertyDef : pdef:AbstractIL.IL.ILPropertyDef *
                                  m:Range.range -> unit
        member Close : unit -> AbstractIL.IL.ILTypeDef
        member GetCurrentFields : unit -> seq<AbstractIL.IL.ILFieldDef>
        member
          PrependInstructionsToSpecificMethodDef : cond:(AbstractIL.IL.ILMethodDef ->
                                                           bool) *
                                                   instrs:AbstractIL.IL.ILInstr list *
                                                   tag:AbstractIL.IL.ILSourceMarker option ->
                                                     unit
        member NestedTypeDefs : TypeDefsBuilder
      end
    and TypeDefsBuilder =
      class
        new : unit -> TypeDefsBuilder
        member
          AddTypeDef : tdef:AbstractIL.IL.ILTypeDef * eliminateIfEmpty:bool *
                       addAtEnd:bool *
                       tdefDiscards:((AbstractIL.IL.ILMethodDef -> bool) *
                                     (AbstractIL.IL.ILPropertyDef -> bool)) option ->
                         unit
        member Close : unit -> AbstractIL.IL.ILTypeDef list
        member
          FindNestedTypeDefBuilder : tref:AbstractIL.IL.ILTypeRef ->
                                       TypeDefBuilder
        member FindNestedTypeDefsBuilder : path:string list -> TypeDefsBuilder
        member FindTypeDefBuilder : nm:string -> TypeDefBuilder
      end
    type AnonTypeGenerationTable =
      class
        new : unit -> AnonTypeGenerationTable
        member
          Table : System.Collections.Generic.Dictionary<TypedTree.Stamp,
                                                        (AbstractIL.IL.ILMethodRef *
                                                         AbstractIL.IL.ILMethodRef [] *
                                                         AbstractIL.IL.ILType)>
      end
    type AssemblyBuilder =
      class
        new : cenv:cenv * anonTypeTable:AnonTypeGenerationTable ->
                AssemblyBuilder
        member
          AddEventDef : tref:AbstractIL.IL.ILTypeRef *
                        edef:AbstractIL.IL.ILEventDef -> unit
        member
          AddExplicitInitToSpecificMethodDef : cond:(AbstractIL.IL.ILMethodDef ->
                                                       bool) *
                                               tref:AbstractIL.IL.ILTypeRef *
                                               fspec:AbstractIL.IL.ILFieldSpec *
                                               sourceOpt:AbstractIL.IL.ILSourceMarker option *
                                               feefee:AbstractIL.IL.ILInstr list *
                                               seqpt:AbstractIL.IL.ILInstr list ->
                                                 unit
        member
          AddFieldDef : tref:AbstractIL.IL.ILTypeRef *
                        ilFieldDef:AbstractIL.IL.ILFieldDef -> unit
        member AddInitializeScriptsInOrderToEntryPoint : unit -> unit
        member
          AddMethodDef : tref:AbstractIL.IL.ILTypeRef *
                         ilMethodDef:AbstractIL.IL.ILMethodDef -> unit
        member
          AddOrMergePropertyDef : tref:AbstractIL.IL.ILTypeRef *
                                  pdef:AbstractIL.IL.ILPropertyDef *
                                  m:Range.range -> unit
        member
          AddReflectedDefinition : vspec:TypedTree.Val * expr:TypedTree.Expr ->
                                     unit
        member
          AddScriptInitFieldSpec : fieldSpec:AbstractIL.IL.ILFieldSpec *
                                   range:Range.range -> unit
        member
          AddTypeDef : tref:AbstractIL.IL.ILTypeRef *
                       tdef:AbstractIL.IL.ILTypeDef * eliminateIfEmpty:bool *
                       addAtEnd:bool *
                       tdefDiscards:((AbstractIL.IL.ILMethodDef -> bool) *
                                     (AbstractIL.IL.ILPropertyDef -> bool)) option ->
                         unit
        member
          Close : unit ->
                    AbstractIL.IL.ILTypeDef list *
                    ((string * TypedTree.Val) * TypedTree.Expr) list
        member
          GenerateAnonType : genToStringMethod:(AbstractIL.IL.ILType ->
                                                  #seq<AbstractIL.IL.ILMethodDef>) *
                             anonInfo:TypedTree.AnonRecdTypeInfo -> unit
        member
          GenerateRawDataValueType : cloc:CompileLocation * size:int ->
                                       AbstractIL.IL.ILTypeSpec
        member
          GetCurrentFields : tref:AbstractIL.IL.ILTypeRef ->
                               seq<AbstractIL.IL.ILFieldDef>
        member
          GetExplicitEntryPointInfo : unit -> AbstractIL.IL.ILTypeRef option
        member GrabExtraBindingsToGenerate : unit -> TypedTree.Binding list
        member
          LookupAnonType : genToStringMethod:(AbstractIL.IL.ILType ->
                                                #seq<AbstractIL.IL.ILMethodDef>) *
                           anonInfo:TypedTree.AnonRecdTypeInfo ->
                             AbstractIL.IL.ILMethodRef *
                             AbstractIL.IL.ILMethodRef [] * AbstractIL.IL.ILType
        member
          ReplaceNameOfReflectedDefinition : vspec:TypedTree.Val *
                                             newName:string -> unit
        member cenv : cenv
      end
    val pop : i:int -> Pops
    val Push : tys:Pushes -> Pushes
    val Push0 : Pushes
    val FeeFee : cenv:cenv -> int
    val FeeFeeInstr :
      cenv:cenv -> doc:AbstractIL.IL.ILSourceDocument -> AbstractIL.IL.ILInstr
    type CodeGenBuffer =
      class
        new : m:Range.range * mgbuf:AssemblyBuilder * methodName:string *
              alreadyUsedArgs:int -> CodeGenBuffer
        member
          AllocLocal : ranges:(string * (Mark * Mark)) list *
                       ty:AbstractIL.IL.ILType * isFixed:bool -> int
        member AssertEmptyStack : unit -> unit
        member
          Close : unit ->
                    ((string * (Mark * Mark)) list * AbstractIL.IL.ILType * bool) list *
                    int *
                    System.Collections.Generic.Dictionary<AbstractIL.IL.ILCodeLabel,
                                                          int> *
                    AbstractIL.IL.ILInstr [] *
                    AbstractIL.IL.ILExceptionSpec list * bool
        member DoPops : n:Pops -> unit
        member DoPushes : pushes:Pushes -> unit
        member
          EmitExceptionClause : clause:AbstractIL.IL.ILExceptionSpec -> unit
        member
          EmitInstr : pops:Pops * pushes:Pushes * i:AbstractIL.IL.ILInstr ->
                        unit
        member
          EmitInstrs : pops:Pops * pushes:Pushes * is:AbstractIL.IL.ILInstr list ->
                         unit
        member EmitSeqPoint : src:Range.range -> unit
        member EmitStartOfHiddenCode : unit -> unit
        member private EnsureNopBetweenDebugPoints : unit -> unit
        member GenerateDelayMark : _nm:'b -> Mark
        member GetCurrentStack : unit -> AbstractIL.IL.ILType list
        member GetLastDebugPoint : unit -> Range.range option
        member Mark : s:'a -> Mark
        member
          ReallocLocal : cond:(int ->
                                 (string * (Mark * Mark)) list *
                                 AbstractIL.IL.ILType * bool -> bool) *
                         ranges:(string * (Mark * Mark)) list *
                         ty:AbstractIL.IL.ILType * isFixed:bool -> int * bool
        member
          SetCodeLabelToCodeLabel : lab1:AbstractIL.IL.ILCodeLabel *
                                    lab2:AbstractIL.IL.ILCodeLabel -> unit
        member SetCodeLabelToPC : lab:AbstractIL.IL.ILCodeLabel * pc:int -> unit
        member SetMark : mark1:Mark * mark2:Mark -> unit
        member SetMarkToHere : Mark -> unit
        member SetStack : s:AbstractIL.IL.ILType list -> unit
        member MethodName : string
        member PreallocatedArgCount : int
        member mgbuf : AssemblyBuilder
      end
    module CG = begin
      val EmitInstr :
        cgbuf:CodeGenBuffer ->
          pops:Pops -> pushes:Pushes -> i:AbstractIL.IL.ILInstr -> unit
      val EmitInstrs :
        cgbuf:CodeGenBuffer ->
          pops:Pops -> pushes:Pushes -> is:AbstractIL.IL.ILInstr list -> unit
      val EmitSeqPoint : cgbuf:CodeGenBuffer -> src:Range.range -> unit
      val GenerateDelayMark : cgbuf:CodeGenBuffer -> nm:'a -> Mark
      val SetMark : cgbuf:CodeGenBuffer -> m1:Mark -> m2:Mark -> unit
      val SetMarkToHere : cgbuf:CodeGenBuffer -> m1:Mark -> unit
      val SetStack : cgbuf:CodeGenBuffer -> s:AbstractIL.IL.ILType list -> unit
      val GenerateMark : cgbuf:CodeGenBuffer -> s:'a -> Mark
    end
    val GenString : cenv:cenv -> cgbuf:CodeGenBuffer -> s:string -> unit
    val GenConstArray :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            ilElementType:AbstractIL.IL.ILType ->
              data:'a [] ->
                write:(AbstractIL.Internal.ByteBuffer -> 'a -> unit) -> unit
    val CodeGenThen :
      cenv:cenv ->
        mgbuf:AssemblyBuilder ->
          entryPointInfo:(TypedTree.ValRef * BranchCallItem) list *
          methodName:string * eenv:IlxGenEnv * alreadyUsedArgs:int *
          codeGenFunction:(CodeGenBuffer -> IlxGenEnv -> unit) * m:Range.range ->
            AbstractIL.IL.ILLocal list * int *
            System.Collections.Generic.Dictionary<AbstractIL.IL.ILCodeLabel,int> *
            AbstractIL.IL.ILInstr [] * AbstractIL.IL.ILExceptionSpec list *
            AbstractIL.IL.ILLocalDebugInfo list * bool
    val CodeGenMethod :
      cenv:cenv ->
        mgbuf:AssemblyBuilder ->
          entryPointInfo:(TypedTree.ValRef * BranchCallItem) list *
          methodName:string * eenv:IlxGenEnv * alreadyUsedArgs:int *
          codeGenFunction:(CodeGenBuffer -> IlxGenEnv -> unit) * m:Range.range ->
            AbstractIL.IL.ILInstr [] * AbstractIL.IL.ILMethodBody
    val StartDelayedLocalScope : nm:string -> cgbuf:CodeGenBuffer -> Mark * Mark
    val StartLocalScope : nm:string -> cgbuf:CodeGenBuffer -> Mark * Mark
    val LocalScope :
      nm:string -> cgbuf:CodeGenBuffer -> f:(Mark * Mark -> 'a) -> 'a
    val compileSequenceExpressions : bool
    type EmitDebugPointState =
      | SPAlways
      | SPSuppress
    val BindingEmitsNoCode :
      g:TcGlobals.TcGlobals -> b:TypedTree.Binding -> bool
    val ComputeDebugPointForBinding :
      g:TcGlobals.TcGlobals ->
        TypedTree.Binding -> bool * Range.range option * EmitDebugPointState
    val BindingEmitsDebugPoint :
      g:TcGlobals.TcGlobals -> bind:TypedTree.Binding -> bool
    val BindingIsInvisible : TypedTree.Binding -> bool
    val BindingEmitsHiddenCode : TypedTree.Binding -> bool
    val FirstEmittedCodeWillBeDebugPoint :
      g:TcGlobals.TcGlobals ->
        sp:EmitDebugPointState -> expr:TypedTree.Expr -> bool
    val EmitDebugPointForWholeExpr :
      g:TcGlobals.TcGlobals ->
        sp:EmitDebugPointState -> expr:TypedTree.Expr -> bool
    val EmitHiddenCodeMarkerForWholeExpr :
      g:TcGlobals.TcGlobals ->
        sp:EmitDebugPointState -> expr:TypedTree.Expr -> bool
    val RangeOfDebugPointForWholeExpr :
      g:TcGlobals.TcGlobals -> expr:TypedTree.Expr -> Range.range
    val DoesGenExprStartWithDebugPoint :
      g:TcGlobals.TcGlobals ->
        sp:EmitDebugPointState -> expr:TypedTree.Expr -> bool
    val ProcessDebugPointForExpr :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          sp:EmitDebugPointState -> expr:TypedTree.Expr -> unit
    val GenExpr :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            sp:EmitDebugPointState ->
              expr:TypedTree.Expr -> sequel:sequel -> unit
    val ProcessDelayedGenMethods : cenv:cenv -> unit
    val GenExprWithStackGuard :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            sp:EmitDebugPointState ->
              expr:TypedTree.Expr -> sequel:sequel -> unit
    val GenExprPreSteps :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            sp:EmitDebugPointState ->
              expr:TypedTree.Expr -> sequel:sequel -> bool
    val GenExprAux :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            sp:EmitDebugPointState ->
              expr:TypedTree.Expr -> sequel:sequel -> unit
    val GenExprs :
      cenv:cenv ->
        cgbuf:CodeGenBuffer -> eenv:IlxGenEnv -> es:TypedTree.Expr list -> unit
    val CodeGenMethodForExpr :
      cenv:cenv ->
        mgbuf:AssemblyBuilder ->
          spReq:EmitDebugPointState *
          entryPointInfo:(TypedTree.ValRef * BranchCallItem) list *
          methodName:string * eenv:IlxGenEnv * alreadyUsedArgs:int *
          expr0:TypedTree.Expr * sequel0:sequel -> AbstractIL.IL.ILMethodBody
    val sequelAfterDiscard : sequel:sequel -> sequel option
    val sequelIgnoringEndScopesAndDiscard : sequel:sequel -> sequel
    val sequelIgnoreEndScopes : sequel:sequel -> sequel
    val GenSequelEndScopes : cgbuf:CodeGenBuffer -> sequel:sequel -> unit
    val StringOfSequel : sequel:sequel -> string
    val GenSequel :
      cenv:cenv ->
        cloc:CompileLocation -> cgbuf:CodeGenBuffer -> sequel:sequel -> unit
    val GenConstant :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            c:TypedTree.Const * m:Range.range * ty:TypedTree.TType ->
              sequel:sequel -> unit
    val GenUnitTy :
      cenv:cenv -> eenv:IlxGenEnv -> m:Range.range -> AbstractIL.IL.ILType
    val GenUnit :
      cenv:cenv ->
        eenv:IlxGenEnv -> m:Range.range -> cgbuf:CodeGenBuffer -> unit
    val GenUnitThenSequel :
      cenv:cenv ->
        eenv:IlxGenEnv ->
          m:Range.range ->
            cloc:CompileLocation -> cgbuf:CodeGenBuffer -> sequel:sequel -> unit
    val GenAllocTuple :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            tupInfo:TypedTree.TupInfo * args:TypedTree.Exprs *
            argtys:TypedTree.TypeInst * m:Range.range -> sequel:sequel -> unit
    val GenGetTupleField :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            tupInfo:TypedTree.TupInfo * e:TypedTree.Expr *
            tys:TypedTree.TypeInst * n:int * m:Range.range ->
              sequel:sequel -> unit
    val GenAllocExn :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            c:TypedTree.TyconRef * args:TypedTree.Exprs * m:Range.range ->
              sequel:sequel -> unit
    val GenAllocUnionCaseCore :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            c:TypedTree.UnionCaseRef * tyargs:TypedTree.TypeInst * n:int *
            m:Range.range -> unit
    val GenAllocUnionCase :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            c:TypedTree.UnionCaseRef * tyargs:TypedTree.TypeInst *
            args:TypedTree.Exprs * m:Range.range -> sequel:sequel -> unit
    val GenLinearExpr :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            sp:EmitDebugPointState ->
              expr:TypedTree.Expr ->
                sequel:sequel ->
                  preSteps:bool -> contf:(FakeUnit -> FakeUnit) -> FakeUnit
    val GenAllocRecd :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            ctorInfo:TypedTree.RecordConstructionInfo ->
              tcref:TypedTree.TyconRef * argtys:TypedTree.TypeInst *
              args:TypedTree.Exprs * m:Range.range -> sequel:sequel -> unit
    val GenAllocAnonRecd :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            anonInfo:TypedTree.AnonRecdTypeInfo * tyargs:TypedTree.TypeInst *
            args:TypedTree.Exprs * m:Range.range -> sequel:sequel -> unit
    val GenGetAnonRecdField :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            anonInfo:TypedTree.AnonRecdTypeInfo * e:TypedTree.Expr *
            tyargs:TypedTree.TypeInst * n:int * m:Range.range ->
              sequel:sequel -> unit
    val GenNewArraySimple :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            elems:TypedTree.Expr list * elemTy:TypedTree.TType * m:Range.range ->
              sequel:sequel -> unit
    val GenNewArray :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            elems:TypedTree.Expr list * elemTy:TypedTree.TType * m:Range.range ->
              sequel:sequel -> unit
    val GenCoerce :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            e:TypedTree.Expr * tgty:TypedTree.TType * m:Range.range *
            srcty:TypedTree.TType -> sequel:sequel -> unit
    val GenReraise :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            rtnty:TypedTree.TType * m:Range.range -> sequel:sequel -> unit
    val GenGetExnField :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            e:TypedTree.Expr * ecref:TypedTree.TyconRef * fieldNum:int *
            m:Range.range -> sequel:sequel -> unit
    val GenSetExnField :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            e:TypedTree.Expr * ecref:TypedTree.TyconRef * fieldNum:int *
            e2:TypedTree.Expr * m:Range.range -> sequel:sequel -> unit
    val UnionCodeGen :
      cgbuf:CodeGenBuffer ->
        AbstractIL.Extensions.ILX.EraseUnions.ICodeGen<Mark>
    val GenUnionCaseProof :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            e:TypedTree.Expr * ucref:TypedTree.UnionCaseRef *
            tyargs:TypedTree.TypeInst * m:Range.range -> sequel:sequel -> unit
    val GenGetUnionCaseField :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            e:TypedTree.Expr * ucref:TypedTree.UnionCaseRef *
            tyargs:TypedTree.TypeInst * n:int * m:Range.range ->
              sequel:sequel -> unit
    val GenGetUnionCaseFieldAddr :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            e:TypedTree.Expr * ucref:TypedTree.UnionCaseRef *
            tyargs:TypedTree.TypeInst * n:int * m:Range.range ->
              sequel:sequel -> unit
    val GenGetUnionCaseTag :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            e:TypedTree.Expr * tcref:TypedTree.TyconRef *
            tyargs:TypedTree.TypeInst * m:Range.range -> sequel:sequel -> unit
    val GenSetUnionCaseField :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            e:TypedTree.Expr * ucref:TypedTree.UnionCaseRef *
            tyargs:TypedTree.TypeInst * n:int * e2:TypedTree.Expr *
            m:Range.range -> sequel:sequel -> unit
    val GenGetRecdFieldAddr :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            e:TypedTree.Expr * f:TypedTree.RecdFieldRef *
            tyargs:TypedTree.TypeInst * m:Range.range -> sequel:sequel -> unit
    val GenGetStaticFieldAddr :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            f:TypedTree.RecdFieldRef * tyargs:TypedTree.TypeInst * m:Range.range ->
              sequel:sequel -> unit
    val GenGetRecdField :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            e:TypedTree.Expr * f:TypedTree.RecdFieldRef *
            tyargs:TypedTree.TypeInst * m:Range.range -> sequel:sequel -> unit
    val GenSetRecdField :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            e1:TypedTree.Expr * f:TypedTree.RecdFieldRef *
            tyargs:TypedTree.TypeInst * e2:TypedTree.Expr * m:Range.range ->
              sequel:sequel -> unit
    val GenGetStaticField :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            f:TypedTree.RecdFieldRef * tyargs:TypedTree.TypeInst * m:Range.range ->
              sequel:sequel -> unit
    val GenSetStaticField :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            f:TypedTree.RecdFieldRef * tyargs:TypedTree.TypeInst *
            e2:TypedTree.Expr * m:Range.range -> sequel:sequel -> unit
    val mk_field_pops : isStatic:bool -> n:int -> Pops
    val GenFieldGet :
      isStatic:bool ->
        cenv:cenv ->
          cgbuf:CodeGenBuffer ->
            eenv:IlxGenEnv ->
              rfref:TypedTree.RecdFieldRef * tyargs:TypedTree.TypeInst *
              m:Range.range -> unit
    val GenFieldStore :
      isStatic:bool ->
        cenv:cenv ->
          cgbuf:CodeGenBuffer ->
            eenv:IlxGenEnv ->
              rfref:TypedTree.RecdFieldRef * tyargs:TypedTree.TypeInst *
              m:Range.range -> sequel:sequel -> unit
    val GenUntupledArgsDiscardingLoneUnit :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            m:Range.range ->
              numObjArgs:int ->
                curriedArgInfos:(TypedTree.TType * TypedTree.ArgReprInfo) list list ->
                  args:TypedTree.Expr list -> unit
    val GenUntupledArgExpr :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            m:Range.range ->
              argInfos:(TypedTree.TType * TypedTree.ArgReprInfo) list ->
                expr:TypedTree.Expr -> unit
    val GenWitnessArgFromTraitInfo :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            m:Range.range -> traitInfo:TypedTree.TraitConstraintInfo -> unit
    val GenWitnessArgFromWitnessInfo :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            m:Range.range -> witnessInfo:TypedTree.TraitWitnessInfo -> unit
    val GenWitnessArgsFromWitnessInfos :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            m:Range.range ->
              witnessInfos:seq<TypedTree.TraitWitnessInfo> -> unit
    val GenWitnessArgs :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            m:Range.range ->
              tps:TypedTree.Typars -> tyargs:TypedTree.TType list -> unit
    val GenApp :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            f:TypedTree.Expr * fty:TypedTree.TType * tyargs:TypedTree.TypeInst *
            curriedArgs:TypedTree.Exprs * m:Range.range -> sequel:sequel -> unit
    val CanTailcall :
      hasStructObjArg:bool * ccallInfo:TypedTree.TType option * withinSEH:bool *
      hasByrefArg:bool * mustGenerateUnitAfterCall:bool * isDllImport:bool *
      isSelfInit:bool * makesNoCriticalTailcalls:bool * sequel:sequel ->
        AbstractIL.IL.ILTailcall
    val GenNamedLocalTyFuncCall :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            ty:TypedTree.TType ->
              cloinfo:IlxClosureInfo ->
                tyargs:TypedTree.TypeInst -> m:Range.range -> TypedTree.TType
    val GenCurriedArgsAndIndirectCall :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            functy:TypedTree.TType * tyargs:TypedTree.TypeInst *
            curriedArgs:TypedTree.Exprs * m:Range.range -> sequel:sequel -> unit
    val GenIndirectCall :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            functy:TypedTree.TType * tyargs:TypedTree.TType list *
            curriedArgs:TypedTree.Expr list * m:Range.range ->
              sequel:sequel -> unit
    val GenTry :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            Mark * Mark ->
              e1:TypedTree.Expr * m:Range.range * resty:TypedTree.TType *
              spTry:SyntaxTree.DebugPointAtTry ->
                int * IlxGenEnv * (AbstractIL.IL.ILType list * int list) *
                (AbstractIL.IL.ILCodeLabel * AbstractIL.IL.ILCodeLabel) * Mark *
                AbstractIL.IL.ILType
    val GenTryWith :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            e1:TypedTree.Expr * vf:TypedTree.Val * ef:TypedTree.Expr *
            vh:TypedTree.Val * eh:TypedTree.Expr * m:Range.range *
            resty:TypedTree.TType * spTry:SyntaxTree.DebugPointAtTry *
            spWith:SyntaxTree.DebugPointAtWith -> sequel:sequel -> unit
    val GenTryFinally :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            bodyExpr:TypedTree.Expr * handlerExpr:TypedTree.Expr * m:Range.range *
            resty:TypedTree.TType * spTry:SyntaxTree.DebugPointAtTry *
            spFinally:SyntaxTree.DebugPointAtFinally -> sequel:sequel -> unit
    val GenForLoop :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            spFor:SyntaxTree.DebugPointAtFor * v:TypedTree.Val *
            e1:TypedTree.Expr * dir:TypedTree.ForLoopStyle * e2:TypedTree.Expr *
            loopBody:TypedTree.Expr * m:Range.range -> sequel:sequel -> unit
    val GenWhileLoop :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            spWhile:SyntaxTree.DebugPointAtWhile * e1:TypedTree.Expr *
            e2:TypedTree.Expr * m:Range.range -> sequel:sequel -> unit
    val GenAsmCode :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            il:AbstractIL.IL.ILInstr list * tyargs:TypedTree.TypeInst *
            args:TypedTree.Exprs * returnTys:TypedTree.TTypes * m:Range.range ->
              sequel:sequel -> unit
    val GenQuotation :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            ast:TypedTree.Expr *
            qdataCell:((AbstractIL.IL.ILTypeRef list * TypedTree.TTypes *
                        TypedTree.Exprs * QuotationPickler.ExprData) *
                       (AbstractIL.IL.ILTypeRef list * TypedTree.TTypes *
                        TypedTree.Exprs * QuotationPickler.ExprData)) option ref *
            m:Range.range * ety:TypedTree.TType -> sequel:sequel -> unit
    val GenILCall :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            virt:bool * valu:bool * newobj:bool *
            valUseFlags:TypedTree.ValUseFlag * isDllImport:bool *
            ilMethRef:AbstractIL.IL.ILMethodRef * enclArgTys:TypedTree.TypeInst *
            methArgTys:TypedTree.TypeInst * argExprs:TypedTree.Exprs *
            returnTys:TypedTree.TTypes * m:Range.range -> sequel:sequel -> unit
    val CommitCallSequel :
      cenv:cenv ->
        eenv:IlxGenEnv ->
          m:Range.range ->
            cloc:CompileLocation ->
              cgbuf:CodeGenBuffer ->
                mustGenerateUnitAfterCall:bool -> sequel:sequel -> unit
    val MakeNotSupportedExnExpr :
      cenv:cenv ->
        eenv:IlxGenEnv ->
          argExpr:TypedTree.Expr * m:Range.range -> TypedTree.Expr
    val GenTraitCall :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            traitInfo:TypedTree.TraitConstraintInfo * argExprs:TypedTree.Exprs *
            m:Range.range -> expr:TypedTree.Expr -> sequel:sequel -> unit
    val GenGetAddrOfRefCellField :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            e:TypedTree.Expr * ty:TypedTree.TType * m:Range.range ->
              sequel:sequel -> unit
    val GenGetValAddr :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            v:TypedTree.ValRef * m:Range.range -> sequel:sequel -> unit
    val GenGetByref :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            v:TypedTree.ValRef * m:Range.range -> sequel:sequel -> unit
    val GenSetByref :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            v:TypedTree.ValRef * e:TypedTree.Expr * m:Range.range ->
              sequel:sequel -> unit
    val GenDefaultValue :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv -> ty:TypedTree.TType * m:Range.range -> unit
    val GenGenericParam :
      cenv:cenv ->
        eenv:IlxGenEnv ->
          tp:TypedTree.Typar -> AbstractIL.IL.ILGenericParameterDef
    val GenSlotParam :
      m:Range.range ->
        cenv:cenv ->
          eenv:IlxGenEnv -> TypedTree.SlotParam -> AbstractIL.IL.ILParameter
    val GenFormalSlotsig :
      m:Range.range ->
        cenv:cenv ->
          eenv:IlxGenEnv ->
            TypedTree.SlotSig ->
              AbstractIL.IL.ILType * AbstractIL.IL.ILParameter list *
              AbstractIL.IL.ILReturn
    val instSlotParam :
      inst:TypedTreeOps.TyparInst -> TypedTree.SlotParam -> TypedTree.SlotParam
    val GenActualSlotsig :
      m:Range.range ->
        cenv:cenv ->
          eenv:IlxGenEnv ->
            TypedTree.SlotSig ->
              methTyparsOfOverridingMethod:TypedTree.Typars ->
                methodParams:TypedTree.Val list ->
                  AbstractIL.IL.ILParameter list * AbstractIL.IL.ILReturn
    val GenNameOfOverridingMethod :
      cenv:cenv -> useMethodImpl:bool * slotsig:TypedTree.SlotSig -> string
    val GenMethodImpl :
      cenv:cenv ->
        eenv:IlxGenEnv ->
          useMethodImpl:bool * TypedTree.SlotSig ->
            m:Range.range ->
              string *
              (AbstractIL.IL.ILType * TypedTree.Typar list ->
                 AbstractIL.IL.ILMethodImplDef)
    val bindBaseOrThisVarOpt :
      cenv:cenv ->
        eenv:IlxGenEnv -> baseValOpt:TypedTree.Val option -> IlxGenEnv
    val fixupVirtualSlotFlags :
      mdef:AbstractIL.IL.ILMethodDef -> AbstractIL.IL.ILMethodDef
    val renameMethodDef :
      nameOfOverridingMethod:string ->
        mdef:AbstractIL.IL.ILMethodDef -> AbstractIL.IL.ILMethodDef
    val fixupMethodImplFlags :
      mdef:AbstractIL.IL.ILMethodDef -> AbstractIL.IL.ILMethodDef
    val GenObjectMethod :
      cenv:cenv ->
        eenvinner:IlxGenEnv ->
          cgbuf:CodeGenBuffer ->
            useMethodImpl:bool ->
              tmethod:TypedTree.ObjExprMethod ->
                ((bool *
                  (AbstractIL.IL.ILType * TypedTree.Typar list ->
                     AbstractIL.IL.ILMethodImplDef) * TypedTree.Typars) *
                 AbstractIL.IL.ILMethodDef) list
    val GenObjectExpr :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenvouter:IlxGenEnv ->
            expr:TypedTree.Expr ->
              baseType:TypedTree.TType * baseValOpt:TypedTree.Val option *
              basecall:TypedTree.Expr * overrides:TypedTree.ObjExprMethod list *
              interfaceImpls:(TypedTree.TType * TypedTree.ObjExprMethod list) list *
              m:Range.range -> sequel:sequel -> unit
    val GenSequenceExpr :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenvouter:IlxGenEnv ->
            nextEnumeratorValRef:TypedTree.ValRef * pcvref:TypedTree.ValRef *
            currvref:TypedTree.ValRef * stateVars:TypedTree.ValRef list *
            generateNextExpr:TypedTree.Expr * closeExpr:TypedTree.Expr *
            checkCloseExpr:TypedTree.Expr * seqElemTy:TypedTree.TType *
            m:Range.range -> sequel:sequel -> unit
    val GenClosureTypeDefs :
      cenv:cenv ->
        tref:AbstractIL.IL.ILTypeRef *
        ilGenParams:AbstractIL.IL.ILGenericParameterDefs *
        attrs:AbstractIL.IL.ILAttribute list *
        ilCloAllFreeVars:AbstractIL.Extensions.ILX.Types.IlxClosureFreeVar [] *
        ilCloLambdas:AbstractIL.Extensions.ILX.Types.IlxClosureLambdas *
        ilCtorBody:AbstractIL.IL.ILMethodBody *
        mdefs:AbstractIL.IL.ILMethodDef list *
        mimpls:AbstractIL.IL.ILMethodImplDef list * ext:AbstractIL.IL.ILType *
        ilIntfTys:AbstractIL.IL.ILType list *
        cloSpec:AbstractIL.Extensions.ILX.Types.IlxClosureSpec option ->
          AbstractIL.IL.ILTypeDef list
    val GenStaticDelegateClosureTypeDefs :
      cenv:cenv ->
        tref:AbstractIL.IL.ILTypeRef *
        ilGenParams:AbstractIL.IL.ILGenericParameterDefs *
        attrs:AbstractIL.IL.ILAttribute list *
        ilCloAllFreeVars:AbstractIL.Extensions.ILX.Types.IlxClosureFreeVar [] *
        ilCloLambdas:AbstractIL.Extensions.ILX.Types.IlxClosureLambdas *
        ilCtorBody:AbstractIL.IL.ILMethodBody *
        mdefs:AbstractIL.IL.ILMethodDef list *
        mimpls:AbstractIL.IL.ILMethodImplDef list * ext:AbstractIL.IL.ILType *
        ilIntfTys:AbstractIL.IL.ILType list *
        staticCloInfo:AbstractIL.Extensions.ILX.Types.IlxClosureSpec option ->
          AbstractIL.IL.ILTypeDef list
    val GenGenericParams :
      cenv:cenv ->
        eenv:IlxGenEnv ->
          tps:TypedTree.Typar list -> AbstractIL.IL.ILGenericParameterDefs
    val GenGenericArgs :
      m:Range.range ->
        tyenv:TypeReprEnv ->
          tps:TypedTree.Typar list -> AbstractIL.IL.ILGenericArgs
    val GenLambdaClosure :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            isLocalTypeFunc:bool ->
              thisVars:TypedTree.ValRef list ->
                expr:TypedTree.Expr -> IlxClosureInfo * Range.range
    val GenClosureAlloc :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv -> cloinfo:IlxClosureInfo * m:Range.range -> unit
    val GenLambda :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            isLocalTypeFunc:bool ->
              thisVars:TypedTree.ValRef list ->
                expr:TypedTree.Expr -> sequel:sequel -> unit
    val GenTypeOfVal :
      cenv:cenv -> eenv:IlxGenEnv -> v:TypedTree.Val -> AbstractIL.IL.ILType
    val GenFreevar :
      cenv:cenv ->
        m:Range.range ->
          eenvouter:IlxGenEnv ->
            tyenvinner:TypeReprEnv -> fv:TypedTree.Val -> AbstractIL.IL.ILType
    val GetIlxClosureFreeVars :
      cenv:cenv ->
        m:Range.range ->
          thisVars:TypedTree.ValRef list ->
            eenvouter:IlxGenEnv ->
              takenNames:string list ->
                expr:TypedTree.Expr ->
                  TypedTree.Attribs * TypedTree.Typar list *
                  TypedTree.Typar list * TypedTree.Typar list *
                  TypedTreeOps.TraitWitnessInfos * TypedTree.Val list *
                  AbstractIL.IL.ILTypeRef *
                  AbstractIL.Extensions.ILX.Types.IlxClosureFreeVar [] *
                  IlxGenEnv
    val GetIlxClosureInfo :
      cenv:cenv ->
        m:Range.range ->
          isLocalTypeFunc:bool ->
            canUseStaticField:bool ->
              thisVars:TypedTree.ValRef list ->
                eenvouter:IlxGenEnv ->
                  expr:TypedTree.Expr ->
                    IlxClosureInfo * TypedTree.Expr * IlxGenEnv
    val IsNamedLocalTypeFuncVal :
      g:TcGlobals.TcGlobals -> v:TypedTree.Val -> expr:TypedTree.Expr -> bool
    val GenNamedLocalTypeFuncContractInfo :
      cenv:cenv ->
        eenv:IlxGenEnv ->
          m:Range.range ->
            cloinfo:IlxClosureInfo ->
              AbstractIL.IL.ILGenericParameterDef list *
              AbstractIL.IL.ILGenericParameterDefs * AbstractIL.IL.ILTypeSpec *
              AbstractIL.IL.ILType
    val GenDelegateExpr :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenvouter:IlxGenEnv ->
            expr:TypedTree.Expr ->
              TypedTree.ObjExprMethod * m:Range.range -> sequel:sequel -> unit
    val GenStaticOptimization :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            constraints:TypedTree.StaticOptimization list * e2:TypedTree.Expr *
            e3:TypedTree.Expr * _m:Range.range -> sequel:sequel -> unit
    val IsSequelImmediate : sequel:sequel -> bool
    val GenJoinPoint :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          pos:string ->
            eenv:IlxGenEnv ->
              ty:TypedTree.TType ->
                m:Range.range ->
                  sequel:sequel ->
                    sequel * Mark * AbstractIL.IL.ILType list * sequel
    val GenDecisionTreeAndTargets :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          stackAtTargets:AbstractIL.IL.ILType list ->
            eenv:IlxGenEnv ->
              tree:TypedTree.DecisionTree ->
                targets:TypedTree.DecisionTreeTarget array ->
                  repeatSP:(unit -> unit) ->
                    sequel:sequel -> contf:(FakeUnit -> FakeUnit) -> FakeUnit
    val GenPostponedDecisionTreeTargets :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          targetInfos:System.Collections.Generic.KeyValuePair<int,
                                                              ((Mark * Mark *
                                                                IlxGenEnv *
                                                                TypedTree.Expr *
                                                                SyntaxTree.DebugPointForTarget *
                                                                (unit -> unit) *
                                                                TypedTree.Val list *
                                                                TypedTree.Bindings *
                                                                Mark * Mark) *
                                                               bool)> list ->
            stackAtTargets:AbstractIL.IL.ILType list ->
              sequel:sequel -> contf:(FakeUnit -> FakeUnit) -> FakeUnit
    val TryFindTargetInfo :
      targetInfos:Lib.IntMap<'a * 'b> -> n:int -> 'a option
    val GenDecisionTreeAndTargetsInner :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          inplabOpt:Mark option ->
            stackAtTargets:AbstractIL.IL.ILType list ->
              eenv:IlxGenEnv ->
                tree:TypedTree.DecisionTree ->
                  targets:TypedTree.DecisionTreeTarget array ->
                    repeatSP:(unit -> unit) ->
                      targetInfos:AbstractIL.Internal.Zmap<int,
                                                           ((Mark * Mark *
                                                             IlxGenEnv *
                                                             TypedTree.Expr *
                                                             SyntaxTree.DebugPointForTarget *
                                                             (unit -> unit) *
                                                             TypedTree.Val list *
                                                             TypedTree.Bindings *
                                                             Mark * Mark) * bool)> ->
                        sequel:sequel ->
                          contf:(AbstractIL.Internal.Zmap<int,
                                                          ((Mark * Mark *
                                                            IlxGenEnv *
                                                            TypedTree.Expr *
                                                            SyntaxTree.DebugPointForTarget *
                                                            (unit -> unit) *
                                                            TypedTree.Val list *
                                                            TypedTree.Bindings *
                                                            Mark * Mark) * bool)> ->
                                   FakeUnit) -> FakeUnit
    val GetTarget : targets:'c [] -> n:int -> 'c
    val GenDecisionTreeSuccess :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          inplabOpt:Mark option ->
            stackAtTargets:AbstractIL.IL.ILType list ->
              eenv:IlxGenEnv ->
                es:TypedTree.Exprs ->
                  targetIdx:int ->
                    targets:TypedTree.DecisionTreeTarget array ->
                      repeatSP:(unit -> unit) ->
                        targetInfos:AbstractIL.Internal.Zmap<int,
                                                             ((Mark * Mark *
                                                               IlxGenEnv *
                                                               TypedTree.Expr *
                                                               SyntaxTree.DebugPointForTarget *
                                                               (unit -> unit) *
                                                               TypedTree.Val list *
                                                               TypedTree.Bindings *
                                                               Mark * Mark) *
                                                              bool)> ->
                          sequel:sequel ->
                            AbstractIL.Internal.Zmap<int,
                                                     ((Mark * Mark * IlxGenEnv *
                                                       TypedTree.Expr *
                                                       SyntaxTree.DebugPointForTarget *
                                                       (unit -> unit) *
                                                       TypedTree.Val list *
                                                       TypedTree.Bindings * Mark *
                                                       Mark) * bool)> *
                            (IlxGenEnv * EmitDebugPointState * TypedTree.Expr *
                             sequel) option
    val GenDecisionTreeTarget :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          stackAtTargets:AbstractIL.IL.ILType list ->
            targetMarkBeforeBinds:Mark * targetMarkAfterBinds:Mark *
            eenvAtTarget:IlxGenEnv * successExpr:TypedTree.Expr *
            spTarget:SyntaxTree.DebugPointForTarget * repeatSP:(unit -> unit) *
            vs:TypedTree.Val list * binds:TypedTree.Bindings * startScope:Mark *
            endScope:Mark ->
              sequel:sequel ->
                IlxGenEnv * EmitDebugPointState * TypedTree.Expr * sequel
    val GenDecisionTreeSwitch :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          inplabOpt:Mark option ->
            stackAtTargets:AbstractIL.IL.ILType list ->
              eenv:IlxGenEnv ->
                e:TypedTree.Expr ->
                  cases:TypedTree.DecisionTreeCase list ->
                    defaultTargetOpt:TypedTree.DecisionTree option ->
                      switchm:Range.range ->
                        targets:TypedTree.DecisionTreeTarget array ->
                          repeatSP:(unit -> unit) ->
                            targetInfos:AbstractIL.Internal.Zmap<int,
                                                                 ((Mark * Mark *
                                                                   IlxGenEnv *
                                                                   TypedTree.Expr *
                                                                   SyntaxTree.DebugPointForTarget *
                                                                   (unit -> unit) *
                                                                   TypedTree.Val list *
                                                                   TypedTree.Bindings *
                                                                   Mark * Mark) *
                                                                  bool)> ->
                              sequel:sequel ->
                                contf:(AbstractIL.Internal.Zmap<int,
                                                                ((Mark * Mark *
                                                                  IlxGenEnv *
                                                                  TypedTree.Expr *
                                                                  SyntaxTree.DebugPointForTarget *
                                                                  (unit -> unit) *
                                                                  TypedTree.Val list *
                                                                  TypedTree.Bindings *
                                                                  Mark * Mark) *
                                                                 bool)> ->
                                         FakeUnit) -> FakeUnit
    val GenDecisionTreeCases :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          stackAtTargets:AbstractIL.IL.ILType list ->
            eenv:IlxGenEnv ->
              defaultTargetOpt:TypedTree.DecisionTree option ->
                targets:TypedTree.DecisionTreeTarget array ->
                  repeatSP:(unit -> unit) ->
                    targetInfos:AbstractIL.Internal.Zmap<int,
                                                         ((Mark * Mark *
                                                           IlxGenEnv *
                                                           TypedTree.Expr *
                                                           SyntaxTree.DebugPointForTarget *
                                                           (unit -> unit) *
                                                           TypedTree.Val list *
                                                           TypedTree.Bindings *
                                                           Mark * Mark) * bool)> ->
                      sequel:sequel ->
                        caseLabels:Mark list ->
                          cases:TypedTree.DecisionTreeCase list ->
                            contf:(AbstractIL.Internal.Zmap<int,
                                                            ((Mark * Mark *
                                                              IlxGenEnv *
                                                              TypedTree.Expr *
                                                              SyntaxTree.DebugPointForTarget *
                                                              (unit -> unit) *
                                                              TypedTree.Val list *
                                                              TypedTree.Bindings *
                                                              Mark * Mark) *
                                                             bool)> -> FakeUnit) ->
                              FakeUnit
    val ( |BoolExpr|_| ) : _arg42:TypedTree.Expr -> bool option
    val GenDecisionTreeTest :
      cenv:cenv ->
        cloc:CompileLocation ->
          cgbuf:CodeGenBuffer ->
            stackAtTargets:AbstractIL.IL.ILType list ->
              e:TypedTree.Expr ->
                tester:(Pops * Pushes *
                        Choice<(bool *
                                AbstractIL.Extensions.ILX.Types.IlxUnionSpec *
                                int),AbstractIL.IL.ILInstr>) option ->
                  eenv:IlxGenEnv ->
                    successTree:TypedTree.DecisionTree ->
                      failureTree:TypedTree.DecisionTree ->
                        targets:TypedTree.DecisionTreeTarget array ->
                          repeatSP:(unit -> unit) ->
                            targetInfos:AbstractIL.Internal.Zmap<int,
                                                                 ((Mark * Mark *
                                                                   IlxGenEnv *
                                                                   TypedTree.Expr *
                                                                   SyntaxTree.DebugPointForTarget *
                                                                   (unit -> unit) *
                                                                   TypedTree.Val list *
                                                                   TypedTree.Bindings *
                                                                   Mark * Mark) *
                                                                  bool)> ->
                              sequel:sequel ->
                                contf:(AbstractIL.Internal.Zmap<int,
                                                                ((Mark * Mark *
                                                                  IlxGenEnv *
                                                                  TypedTree.Expr *
                                                                  SyntaxTree.DebugPointForTarget *
                                                                  (unit -> unit) *
                                                                  TypedTree.Val list *
                                                                  TypedTree.Bindings *
                                                                  Mark * Mark) *
                                                                 bool)> ->
                                         FakeUnit) -> FakeUnit
    val GenLetRecFixup :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            ilxCloSpec:AbstractIL.Extensions.ILX.Types.IlxClosureSpec *
            e:TypedTree.Expr * ilField:AbstractIL.IL.ILFieldSpec *
            e2:TypedTree.Expr * _m:'d -> unit
    val GenLetRecBindings :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv -> allBinds:TypedTree.Bindings * m:Range.range -> unit
    val GenLetRec :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            binds:TypedTree.Bindings * body:TypedTree.Expr * m:Range.range ->
              sequel:sequel -> unit
    val GenDebugPointForBind :
      cenv:cenv ->
        cgbuf:CodeGenBuffer -> bind:TypedTree.Binding -> EmitDebugPointState
    val GenBinding :
      cenv:cenv ->
        cgbuf:CodeGenBuffer -> eenv:IlxGenEnv -> bind:TypedTree.Binding -> unit
    val ComputeMemberAccessRestrictedBySig :
      eenv:IlxGenEnv -> vspec:TypedTree.Val -> AbstractIL.IL.ILMemberAccess
    val ComputeMethodAccessRestrictedBySig :
      eenv:IlxGenEnv -> vspec:TypedTree.Val -> AbstractIL.IL.ILMemberAccess
    val GenBindingAfterDebugPoint :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            sp:EmitDebugPointState ->
              TypedTree.Binding -> startScopeMarkOpt:Mark option -> unit
    val GenMarshal :
      cenv:cenv ->
        attribs:TypedTree.Attrib list ->
          AbstractIL.IL.ILNativeType option * TypedTree.Attrib list
    val GenParamAttribs :
      cenv:cenv ->
        paramTy:TypedTree.TType ->
          attribs:TypedTree.Attribs ->
            bool * bool * bool * AbstractIL.IL.ILFieldInit option *
            AbstractIL.IL.ILNativeType option * TypedTree.Attribs
    val GenParams :
      cenv:cenv ->
        eenv:IlxGenEnv ->
          m:Range.range ->
            mspec:AbstractIL.IL.ILMethodSpec ->
              witnessInfos:TypedTreeOps.TraitWitnessInfos ->
                argInfos:TypedTree.ArgReprInfo list ->
                  methArgTys:TypedTree.TType list ->
                    implValsOpt:TypedTree.Val list option ->
                      AbstractIL.IL.ILParameter list
    val GenReturnInfo :
      cenv:cenv ->
        eenv:IlxGenEnv ->
          returnTy:TypedTree.TType option ->
            ilRetTy:AbstractIL.IL.ILType ->
              retInfo:TypedTree.ArgReprInfo -> AbstractIL.IL.ILReturn
    val GenPropertyForMethodDef :
      compileAsInstance:bool ->
        tref:AbstractIL.IL.ILTypeRef ->
          mdef:AbstractIL.IL.ILMethodDef ->
            v:TypedTree.Val ->
              memberInfo:TypedTree.ValMemberInfo ->
                ilArgTys:AbstractIL.IL.ILTypes ->
                  ilPropTy:AbstractIL.IL.ILType ->
                    ilAttrs:AbstractIL.IL.ILAttributes ->
                      compiledName:string option -> AbstractIL.IL.ILPropertyDef
    val GenEventForProperty :
      cenv:cenv ->
        eenvForMeth:IlxGenEnv ->
          mspec:AbstractIL.IL.ILMethodSpec ->
            v:TypedTree.Val ->
              ilAttrsThatGoOnPrimaryItem:AbstractIL.IL.ILAttribute list ->
                m:Range.range ->
                  returnTy:TypedTree.TType -> AbstractIL.IL.ILEventDef
    val ComputeUseMethodImpl :
      cenv:cenv -> v:TypedTree.Val * slotsig:TypedTree.SlotSig -> bool
    val ComputeMethodImplNameFixupForMemberBinding :
      cenv:cenv ->
        v:TypedTree.Val * memberInfo:TypedTree.ValMemberInfo -> string option
    val ComputeFlagFixupsForMemberBinding :
      cenv:cenv ->
        v:TypedTree.Val * memberInfo:TypedTree.ValMemberInfo ->
          (#AbstractIL.IL.ILMethodDef -> AbstractIL.IL.ILMethodDef) list
    val ComputeMethodImplAttribs :
      cenv:cenv ->
        _v:TypedTree.Val ->
          attrs:TypedTree.Attribs ->
            bool * bool * bool * bool * TypedTree.Attrib list
    val DelayGenMethodForBinding :
      cenv:cenv ->
        mgbuf:AssemblyBuilder ->
          eenv:IlxGenEnv ->
            TypedTree.Val * AbstractIL.IL.ILMethodSpec * bool * bool *
            AbstractIL.IL.ILMemberAccess * TypedTree.Typars * TypedTree.Typars *
            TypedTree.TraitWitnessInfo list * TypedTreeOps.CurriedArgInfos *
            TypedTree.ArgReprInfo list * TypedTree.TType list *
            TypedTree.ArgReprInfo * TypedTree.ValReprInfo * TypedTree.Val option *
            TypedTree.Val option * TypedTree.Typars * TypedTree.Val list *
            TypedTree.Expr * TypedTree.TType -> unit
    val GenMethodForBinding :
      cenv:cenv ->
        mgbuf:AssemblyBuilder ->
          eenv:IlxGenEnv ->
            v:TypedTree.Val * mspec:AbstractIL.IL.ILMethodSpec *
            hasWitnessEntry:bool * generateWitnessArgs:bool *
            access:AbstractIL.IL.ILMemberAccess * ctps:TypedTree.Typars *
            mtps:TypedTree.Typars * witnessInfos:TypedTree.TraitWitnessInfo list *
            curriedArgInfos:TypedTreeOps.CurriedArgInfos *
            paramInfos:TypedTree.ArgReprInfo list * argTys:TypedTree.TType list *
            retInfo:TypedTree.ArgReprInfo * topValInfo:TypedTree.ValReprInfo *
            ctorThisValOpt:TypedTree.Val option *
            baseValOpt:TypedTree.Val option * methLambdaTypars:TypedTree.Typars *
            methLambdaVars:TypedTree.Val list * methLambdaBody:TypedTree.Expr *
            returnTy:TypedTree.TType -> unit
    val GenPInvokeMethod :
      nm:string * dll:string * namedArgs:TypedTree.AttribNamedArg list ->
        bool * AbstractIL.IL.MethodBody
    val GenBindings :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv -> binds:TypedTree.Bindings -> unit
    val GenSetVal :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            vref:TypedTree.ValRef * e:TypedTree.Expr * m:Range.range ->
              sequel:sequel -> unit
    val GenGetValRefAndSequel :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            m:Range.range ->
              v:TypedTree.ValRef ->
                storeSequel:(TypedTree.TypeInst * TypedTree.Exprs * Range.range *
                             sequel) option -> unit
    val GenGetVal :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            v:TypedTree.ValRef * m:Range.range -> sequel:sequel -> unit
    val GenBindingRhs :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            sp:EmitDebugPointState ->
              vspec:TypedTree.Val -> e:TypedTree.Expr -> unit
    val CommitStartScope :
      cgbuf:CodeGenBuffer -> startScopeMarkOpt:Mark option -> unit
    val EmitInitLocal :
      cgbuf:CodeGenBuffer -> ty:AbstractIL.IL.ILType -> idx:int -> unit
    val EmitSetLocal : cgbuf:CodeGenBuffer -> idx:int -> unit
    val EmitGetLocal :
      cgbuf:CodeGenBuffer -> ty:AbstractIL.IL.ILType -> idx:int -> unit
    val EmitSetStaticField :
      cgbuf:CodeGenBuffer -> fspec:AbstractIL.IL.ILFieldSpec -> unit
    val EmitGetStaticFieldAddr :
      cgbuf:CodeGenBuffer ->
        ty:AbstractIL.IL.ILType -> fspec:AbstractIL.IL.ILFieldSpec -> unit
    val EmitGetStaticField :
      cgbuf:CodeGenBuffer ->
        ty:AbstractIL.IL.ILType -> fspec:AbstractIL.IL.ILFieldSpec -> unit
    val GenSetStorage :
      m:Range.range -> cgbuf:CodeGenBuffer -> storage:ValStorage -> unit
    val CommitGetStorageSequel :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            m:Range.range ->
              ty:TypedTree.TType ->
                localCloInfo:Ref<NamedLocalIlxClosureInfo> option ->
                  storeSequel:(TypedTree.TType list * TypedTree.Expr list *
                               Range.range * sequel) option -> unit
    val GenGetStorageAndSequel :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            m:Range.range ->
              ty:TypedTree.TType * ilTy:AbstractIL.IL.ILType ->
                storage:ValStorage ->
                  storeSequel:(TypedTree.TType list * TypedTree.Expr list *
                               Range.range * sequel) option -> unit
    val GenGetLocalVals :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenvouter:IlxGenEnv -> m:Range.range -> fvs:TypedTree.Val list -> unit
    val GenGetLocalVal :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            m:Range.range ->
              vspec:TypedTree.Val ->
                storeSequel:(TypedTree.TType list * TypedTree.Expr list *
                             Range.range * sequel) option -> unit
    val GenGetLocalVRef :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            m:Range.range ->
              vref:TypedTree.ValRef ->
                storeSequel:(TypedTree.TType list * TypedTree.Expr list *
                             Range.range * sequel) option -> unit
    val GenStoreVal :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv -> m:Range.range -> vspec:TypedTree.Val -> unit
    val AllocLocal :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            compgen:bool ->
              v:string * ty:AbstractIL.IL.ILType * isFixed:bool ->
                Mark * Mark -> int * bool * IlxGenEnv
    val AllocLocalVal :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          v:TypedTree.Val ->
            eenv:IlxGenEnv ->
              repr:TypedTree.Expr option ->
                Mark * Mark -> ValStorage option * IlxGenEnv
    val AllocStorageForBind :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          Mark * Mark -> eenv:IlxGenEnv -> bind:TypedTree.Binding -> IlxGenEnv
    val AllocStorageForBinds :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          Mark * Mark -> eenv:IlxGenEnv -> binds:TypedTree.Bindings -> IlxGenEnv
    val AllocValForBind :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          Mark * Mark ->
            eenv:IlxGenEnv -> TypedTree.Binding -> ValStorage option * IlxGenEnv
    val AllocTopValWithinExpr :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          cloc:CompileLocation ->
            Mark * Mark -> v:TypedTree.Val -> eenv:IlxGenEnv -> IlxGenEnv
    val EmitSaveStack :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          eenv:IlxGenEnv ->
            m:Range.range ->
              Mark * Mark -> (AbstractIL.IL.ILType list * int list) * IlxGenEnv
    val EmitRestoreStack :
      cgbuf:CodeGenBuffer ->
        savedStack:AbstractIL.IL.ILType list * savedStackLocals:int list -> unit
    val GenAttribArg :
      amap:Import.ImportMap ->
        g:TcGlobals.TcGlobals ->
          eenv:IlxGenEnv ->
            x:TypedTree.Expr ->
              ilArgTy:AbstractIL.IL.ILType -> AbstractIL.IL.ILAttribElem
    val GenAttr :
      amap:Import.ImportMap ->
        g:TcGlobals.TcGlobals ->
          eenv:IlxGenEnv -> TypedTree.Attrib -> AbstractIL.IL.ILAttribute
    val GenAttrs :
      cenv:cenv ->
        eenv:IlxGenEnv ->
          attrs:TypedTree.Attribs -> AbstractIL.IL.ILAttribute list
    val GenCompilationArgumentCountsAttr :
      cenv:cenv -> v:TypedTree.Val -> AbstractIL.IL.ILAttribute list
    val CreatePermissionSets :
      cenv:cenv ->
        eenv:IlxGenEnv ->
          securityAttributes:TypedTree.Attrib list ->
            AbstractIL.IL.ILSecurityDecl list
    val GenTypeDefForCompLoc :
      cenv:cenv * eenv:IlxGenEnv * mgbuf:AssemblyBuilder * cloc:CompileLocation *
      hidden:bool * attribs:TypedTree.Attribs *
      initTrigger:AbstractIL.IL.ILTypeInit * eliminateIfEmpty:bool *
      addAtEnd:bool -> unit
    val GenModuleExpr :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          qname:SyntaxTree.QualifiedNameOfFile ->
            lazyInitInfo:ResizeArray<(AbstractIL.IL.ILFieldSpec ->
                                        AbstractIL.IL.ILInstr list ->
                                        AbstractIL.IL.ILInstr list -> unit)> ->
              eenv:IlxGenEnv -> x:TypedTree.ModuleOrNamespaceExprWithSig -> unit
    val GenModuleDefs :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          qname:SyntaxTree.QualifiedNameOfFile ->
            lazyInitInfo:ResizeArray<(AbstractIL.IL.ILFieldSpec ->
                                        AbstractIL.IL.ILInstr list ->
                                        AbstractIL.IL.ILInstr list -> unit)> ->
              eenv:IlxGenEnv ->
                mdefs:TypedTree.ModuleOrNamespaceExpr list -> unit
    val GenModuleDef :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          qname:SyntaxTree.QualifiedNameOfFile ->
            lazyInitInfo:ResizeArray<(AbstractIL.IL.ILFieldSpec ->
                                        AbstractIL.IL.ILInstr list ->
                                        AbstractIL.IL.ILInstr list -> unit)> ->
              eenv:IlxGenEnv -> x:TypedTree.ModuleOrNamespaceExpr -> unit
    val GenModuleBinding :
      cenv:cenv ->
        cgbuf:CodeGenBuffer ->
          qname:SyntaxTree.QualifiedNameOfFile ->
            lazyInitInfo:ResizeArray<(AbstractIL.IL.ILFieldSpec ->
                                        AbstractIL.IL.ILInstr list ->
                                        AbstractIL.IL.ILInstr list -> unit)> ->
              eenv:IlxGenEnv ->
                m:Range.range -> x:TypedTree.ModuleOrNamespaceBinding -> unit
    val GenImplFile :
      cenv:cenv ->
        mgbuf:AssemblyBuilder ->
          mainInfoOpt:TypedTree.Attribs option ->
            eenv:IlxGenEnv ->
              implFile:TypedTree.TypedImplFileAfterOptimization -> IlxGenEnv
    val GenForceWholeFileInitializationAsPartOfCCtor :
      cenv:cenv ->
        mgbuf:AssemblyBuilder ->
          lazyInitInfo:ResizeArray<(AbstractIL.IL.ILFieldSpec ->
                                      AbstractIL.IL.ILInstr list ->
                                      AbstractIL.IL.ILInstr list -> unit)> ->
            tref:AbstractIL.IL.ILTypeRef -> m:Range.range -> unit
    val GenEqualsOverrideCallingIComparable :
      cenv:cenv ->
        tcref:TypedTree.TyconRef * ilThisTy:AbstractIL.IL.ILType * _ilThatTy:'f ->
          AbstractIL.IL.ILMethodDef
    val GenFieldInit :
      m:Range.range -> c:TypedTree.Const -> AbstractIL.IL.ILFieldInit
    val GenWitnessParams :
      cenv:cenv ->
        eenv:IlxGenEnv ->
          m:Range.range ->
            witnessInfos:TypedTreeOps.TraitWitnessInfos ->
              AbstractIL.IL.ILParameter list
    val GenAbstractBinding :
      cenv:cenv ->
        eenv:IlxGenEnv ->
          tref:AbstractIL.IL.ILTypeRef ->
            vref:TypedTree.ValRef ->
              AbstractIL.IL.ILMethodDef list * AbstractIL.IL.ILPropertyDef list *
              AbstractIL.IL.ILEventDef list
    val GenToStringMethod :
      cenv:cenv ->
        eenv:IlxGenEnv ->
          ilThisTy:AbstractIL.IL.ILType ->
            m:Range.range -> AbstractIL.IL.ILMethodDef list
    val GenTypeDef :
      cenv:cenv ->
        mgbuf:AssemblyBuilder ->
          lazyInitInfo:ResizeArray<(AbstractIL.IL.ILFieldSpec ->
                                      AbstractIL.IL.ILInstr list ->
                                      AbstractIL.IL.ILInstr list -> unit)> ->
            eenv:IlxGenEnv -> m:Range.range -> tycon:TypedTree.Tycon -> unit
    val GenExnDef :
      cenv:cenv ->
        mgbuf:AssemblyBuilder ->
          eenv:IlxGenEnv -> m:Range.range -> exnc:TypedTree.Tycon -> unit
    val CodegenAssembly :
      cenv:cenv ->
        eenv:IlxGenEnv ->
          mgbuf:AssemblyBuilder ->
            implFiles:TypedTree.TypedImplFileAfterOptimization list -> unit
    val GetEmptyIlxGenEnv :
      g:TcGlobals.TcGlobals -> ccu:TypedTree.CcuThunk -> IlxGenEnv
    type IlxGenResults =
      { ilTypeDefs: AbstractIL.IL.ILTypeDef list
        ilAssemAttrs: AbstractIL.IL.ILAttribute list
        ilNetModuleAttrs: AbstractIL.IL.ILAttribute list
        topAssemblyAttrs: TypedTree.Attribs
        permissionSets: AbstractIL.IL.ILSecurityDecl list
        quotationResourceInfo: (AbstractIL.IL.ILTypeRef list * byte []) list }
    val GenerateCode :
      cenv:cenv * anonTypeTable:AnonTypeGenerationTable * eenv:IlxGenEnv *
      TypedTree.TypedAssemblyAfterOptimization * assemAttribs:TypedTree.Attribs *
      moduleAttribs:TypedTree.Attribs -> IlxGenResults
    type ExecutionContext =
      { LookupFieldRef: AbstractIL.IL.ILFieldRef -> System.Reflection.FieldInfo
        LookupMethodRef:
          AbstractIL.IL.ILMethodRef -> System.Reflection.MethodInfo
        LookupTypeRef: AbstractIL.IL.ILTypeRef -> System.Type
        LookupType: AbstractIL.IL.ILType -> System.Type }
    val defaultOf : (System.Type -> obj)
    val LookupGeneratedValue :
      amap:Import.ImportMap ->
        ctxt:ExecutionContext ->
          eenv:IlxGenEnv -> v:TypedTree.Val -> (obj * System.Type) option
    val SetGeneratedValue :
      ctxt:ExecutionContext ->
        g:TcGlobals.TcGlobals ->
          eenv:IlxGenEnv ->
            isForced:bool -> v:TypedTree.Val -> value:obj -> unit
    val ClearGeneratedValue :
      ctxt:ExecutionContext ->
        g:TcGlobals.TcGlobals -> eenv:IlxGenEnv -> v:TypedTree.Val -> unit
    type IlxAssemblyGenerator =
      class
        new : Import.ImportMap * TcGlobals.TcGlobals * ConstraintSolver.TcValF *
              TypedTree.CcuThunk -> IlxAssemblyGenerator
        member AddExternalCcus : TypedTree.CcuThunk list -> unit
        member
          AddIncrementalLocalAssemblyFragment : isIncrementalFragment:bool *
                                                fragName:string *
                                                typedImplFiles:TypedTree.TypedImplFile list ->
                                                  unit
        member ClearGeneratedValue : ExecutionContext * TypedTree.Val -> unit
        member
          ForceSetGeneratedValue : ExecutionContext * TypedTree.Val * obj ->
                                     unit
        member
          GenerateCode : IlxGenOptions *
                         TypedTree.TypedAssemblyAfterOptimization *
                         TypedTree.Attribs * TypedTree.Attribs -> IlxGenResults
        member
          LookupGeneratedValue : ExecutionContext * TypedTree.Val ->
                                   (obj * System.Type) option
      end
  end

namespace FSharp.Compiler
  module internal DotNetFrameworkDependencies = begin
    type private TypeInThisAssembly
    val fSharpCompilerLocation : string
    val inline ifEmptyUse : alternative:string -> filename:string -> string
    val getFSharpCoreLibraryName : string
    val getFsiLibraryName : string
    val getDefaultFSharpCoreLocation : string
    val getDefaultFsiLibraryLocation : string
    val implementationAssemblyDir : string
    val getDefaultSystemValueTupleReference : unit -> string option
    val zeroVersion : System.Version
    val version : string option
    val frameworkRefsPackDirectoryRoot : string option
    val netcoreTfm : string option
    val getWindowsDesktopTfm : unit -> string
    val executionTfm : string
    val executionRid : string
    val isInReferenceAssemblyPackDirectory : filename:string -> bool
    val frameworkRefsPackDirectory : string option
    val getDependenciesOf :
      assemblyReferences:string list ->
        System.Collections.Generic.Dictionary<string,string>
    val getDesktopDefaultReferences : useFsiAuxLib:bool -> string list
    val fetchPathsForDefaultReferencesForScriptsAndOutOfProjectSources :
      useFsiAuxLib:bool ->
        useSdkRefs:bool -> assumeDotNetFramework:bool -> string list
    val defaultReferencesForScriptsAndOutOfProjectSources :
      useFsiAuxLib:bool ->
        assumeDotNetFramework:bool -> useSdkRefs:bool -> string list
    val systemAssemblies : System.Collections.Generic.HashSet<string>
    val basicReferencesForScriptLoadClosure :
      useFsiAuxLib:bool ->
        useSdkRefs:bool -> assumeDotNetFramework:bool -> string list
  end

namespace Microsoft.DotNet.DependencyManager
  type AssemblyResolutionProbe =
    delegate of Unit -> seq<string>
  type AssemblyResolveHandlerCoreclr =
    class
      interface System.IDisposable
      new : assemblyProbingPaths:AssemblyResolutionProbe ->
              AssemblyResolveHandlerCoreclr
    end
  type AssemblyResolveHandlerDeskTop =
    class
      interface System.IDisposable
      new : assemblyProbingPaths:AssemblyResolutionProbe ->
              AssemblyResolveHandlerDeskTop
    end
  type AssemblyResolveHandler =
    class
      interface System.IDisposable
      new : assemblyProbingPaths:AssemblyResolutionProbe ->
              AssemblyResolveHandler
    end

namespace Microsoft.DotNet.DependencyManager
  type NativeResolutionProbe =
    delegate of Unit -> seq<string>
  type NativeAssemblyLoadContext =
    class
      inherit System.Runtime.Loader.AssemblyLoadContext
      new : unit -> NativeAssemblyLoadContext
      override
        Load : _path:System.Reflection.AssemblyName ->
                 System.Reflection.Assembly
      member LoadNativeLibrary : path:string -> System.IntPtr
      static member NativeLoadContext : NativeAssemblyLoadContext
    end
  type NativeDllResolveHandlerCoreClr =
    class
      interface System.IDisposable
      new : nativeProbingRoots:NativeResolutionProbe ->
              NativeDllResolveHandlerCoreClr
    end
  type NativeDllResolveHandler =
    class
      interface System.IDisposable
      new : _nativeProbingRoots:NativeResolutionProbe -> NativeDllResolveHandler
      member internal RefreshPathsInEnvironment : seq<string> -> unit
    end

namespace Microsoft.DotNet.DependencyManager
  module Option = begin
    val ofString : s:string -> string option
  end
  module ReflectionHelper = begin
    val dependencyManagerPattern : string
    val dependencyManagerAttributeName : string
    val resolveDependenciesMethodName : string
    val namePropertyName : string
    val keyPropertyName : string
    val helpMessagesPropertyName : string
    val arrEmpty : string []
    val seqEmpty : seq<string>
    val assemblyHasAttribute :
      theAssembly:System.Reflection.Assembly -> attributeName:string -> bool
    val getAttributeNamed :
      theType:System.Type -> attributeName:string -> obj option
    val getInstanceProperty<'treturn> :
      theType:System.Type ->
        propertyName:string -> System.Reflection.PropertyInfo option
    val getInstanceMethod<'treturn> :
      theType:System.Type ->
        parameterTypes:System.Type array ->
          methodName:string -> System.Reflection.MethodInfo option
    val stripTieWrapper : e:System.Exception -> exn
  end
  [<RequireQualifiedAccessAttribute ()>]
  type ErrorReportType =
    | Warning
    | Error
  type ResolvingErrorReport =
    delegate of ErrorReportType * int * string -> unit
  type IResolveDependenciesResult =
    interface
      abstract member Resolutions : seq<string>
      abstract member Roots : seq<string>
      abstract member SourceFiles : seq<string>
      abstract member StdError : string []
      abstract member StdOut : string []
      abstract member Success : bool
    end
  [<AllowNullLiteralAttribute ()>]
  type IDependencyManagerProvider =
    interface
      abstract member
        ResolveDependencies : scriptDir:string * mainScriptName:string *
                              scriptName:string * scriptExt:string *
                              packageManagerTextLines:seq<string * string> *
                              tfm:string * rid:string ->
                                IResolveDependenciesResult
      abstract member HelpMessages : string []
      abstract member Key : string
      abstract member Name : string
    end
  type ReflectionDependencyManagerProvider =
    class
      interface IDependencyManagerProvider
      new : theType:System.Type * nameProperty:System.Reflection.PropertyInfo *
            keyProperty:System.Reflection.PropertyInfo *
            helpMessagesProperty:System.Reflection.PropertyInfo option *
            resolveDeps:System.Reflection.MethodInfo option *
            resolveDepsEx:System.Reflection.MethodInfo option *
            outputDir:string option -> ReflectionDependencyManagerProvider
      static member
        InstanceMaker : theType:System.Type * outputDir:string option ->
                          (unit -> IDependencyManagerProvider) option
      static member
        MakeResultFromFields : success:bool * stdOut:string array *
                               stdError:string array * resolutions:seq<string> *
                               sourceFiles:seq<string> * roots:seq<string> ->
                                 IResolveDependenciesResult
      static member
        MakeResultFromObject : result:obj -> IResolveDependenciesResult
    end
  type DependencyProvider =
    class
      interface System.IDisposable
      new : unit -> DependencyProvider
      new : nativeProbingRoots:NativeResolutionProbe -> DependencyProvider
      new : assemblyProbingPaths:AssemblyResolutionProbe *
            nativeProbingRoots:NativeResolutionProbe -> DependencyProvider
      member
        CreatePackageManagerUnknownError : seq<string> * string * string *
                                           ResolvingErrorReport -> int * string
      member
        GetRegisteredDependencyManagerHelpText : seq<string> * string *
                                                 ResolvingErrorReport ->
                                                   string []
      member
        Resolve : packageManager:IDependencyManagerProvider * scriptExt:string *
                  packageManagerTextLines:seq<string * string> *
                  reportError:ResolvingErrorReport * executionTfm:string *
                  executionRid:string * implicitIncludeDir:string *
                  mainScriptName:string * fileName:string ->
                    IResolveDependenciesResult
      member
        TryFindDependencyManagerByKey : compilerTools:seq<string> *
                                        outputDir:string *
                                        reportError:ResolvingErrorReport *
                                        key:string -> IDependencyManagerProvider
      member
        TryFindDependencyManagerInPath : compilerTools:seq<string> *
                                         outputDir:string *
                                         reportError:ResolvingErrorReport *
                                         path:string ->
                                           string * IDependencyManagerProvider
    end

namespace FSharp.Compiler
  module internal CompilerConfig = begin
    val ( ++ ) : x:'a list -> s:'a -> 'a list
    val FSharpSigFileSuffixes : string list
    val mlCompatSuffixes : string list
    val FSharpImplFileSuffixes : string list
    val FSharpScriptFileSuffixes : string list
    val doNotRequireNamespaceOrModuleSuffixes : string list
    val FSharpLightSyntaxFileSuffixes : string list
    exception FileNameNotResolved of string * string * Range.range
    exception LoadedSourceNotFoundIgnoring of string * Range.range
    val TryResolveFileUsingPaths :
      paths:string list * m:Range.range * name:string -> string option
    val ResolveFileUsingPaths :
      paths:string list * m:Range.range * name:string -> string
    val GetWarningNumber : m:Range.range * warningNumber:string -> int32 option
    val ComputeMakePathAbsolute :
      implicitIncludeDir:string -> path:string -> string
    [<RequireQualifiedAccessAttribute ()>]
    type CompilerTarget =
      | WinExe
      | ConsoleExe
      | Dll
      | Module
      with
        member IsExe : bool
      end
    [<RequireQualifiedAccessAttribute ()>]
    type ResolveAssemblyReferenceMode =
      | Speculative
      | ReportErrors
    [<RequireQualifiedAccessAttribute ()>]
    type CopyFSharpCoreFlag =
      | Yes
      | No
    type VersionFlag =
      | VersionString of string
      | VersionFile of string
      | VersionNone
      with
        member
          GetVersionInfo : implicitIncludeDir:string ->
                             AbstractIL.IL.ILVersionInfo
        member GetVersionString : implicitIncludeDir:string -> string
      end
    type IRawFSharpAssemblyData =
      interface
        abstract member
          GetAutoOpenAttributes : AbstractIL.IL.ILGlobals -> string list
        abstract member
          GetInternalsVisibleToAttributes : AbstractIL.IL.ILGlobals ->
                                              string list
        abstract member
          GetRawFSharpOptimizationData : Range.range * ilShortAssemName:string *
                                         fileName:string ->
                                           (string *
                                            (unit ->
                                               AbstractIL.Internal.ReadOnlyByteMemory)) list
        abstract member
          GetRawFSharpSignatureData : Range.range * ilShortAssemName:string *
                                      fileName:string ->
                                        (string *
                                         (unit ->
                                            AbstractIL.Internal.ReadOnlyByteMemory)) list
        abstract member
          GetRawTypeForwarders : unit ->
                                   AbstractIL.IL.ILExportedTypesAndForwarders
        abstract member
          HasMatchingFSharpSignatureDataAttribute : AbstractIL.IL.ILGlobals ->
                                                      bool
        abstract member
          TryGetILModuleDef : unit -> AbstractIL.IL.ILModuleDef option
        abstract member HasAnyFSharpSignatureDataAttribute : bool
        abstract member ILAssemblyRefs : AbstractIL.IL.ILAssemblyRef list
        abstract member ILScopeRef : AbstractIL.IL.ILScopeRef
        abstract member ShortAssemblyName : string
      end
    type TimeStampCache =
      class
        new : defaultTimeStamp:System.DateTime -> TimeStampCache
        member GetFileTimeStamp : string -> System.DateTime
        member
          GetProjectReferenceTimeStamp : IProjectReference *
                                         AbstractIL.Internal.Library.CompilationThreadToken ->
                                           System.DateTime
      end
    and IProjectReference =
      interface
        abstract member
          EvaluateRawContents : AbstractIL.Internal.Library.CompilationThreadToken ->
                                  AbstractIL.Internal.Library.Cancellable<IRawFSharpAssemblyData option>
        abstract member
          TryGetLogicalTimeStamp : TimeStampCache *
                                   AbstractIL.Internal.Library.CompilationThreadToken ->
                                     System.DateTime option
        abstract member FileName : string
      end
    type AssemblyReference =
      | AssemblyReference of Range.range * string * IProjectReference option
      with
        member SimpleAssemblyNameIs : string -> bool
        override ToString : unit -> string
        member ProjectReference : IProjectReference option
        member Range : Range.range
        member Text : string
      end
    type UnresolvedAssemblyReference =
      | UnresolvedAssemblyReference of string * AssemblyReference list
    type ResolvedExtensionReference =
      | ResolvedExtensionReference of
        string * AssemblyReference list *
        Tainted<CompilerServices.ITypeProvider> list
    type ImportedAssembly =
      { ILScopeRef: AbstractIL.IL.ILScopeRef
        FSharpViewOfMetadata: TypedTree.CcuThunk
        AssemblyAutoOpenAttributes: string list
        AssemblyInternalsVisibleToAttributes: string list
        IsProviderGenerated: bool
        mutable TypeProviders: Tainted<CompilerServices.ITypeProvider> list
        FSharpOptimizationData: Lazy<Option<Optimizer.LazyModuleInfo>> }
    type AvailableImportedAssembly =
      | ResolvedImportedAssembly of ImportedAssembly
      | UnresolvedImportedAssembly of string
    type CcuLoadFailureAction =
      | RaiseError
      | ReturnNone
    type Directive =
      | Resolution
      | Include
    type LStatus =
      | Unprocessed
      | Processed
    type PackageManagerLine =
      { Directive: Directive
        LineStatus: LStatus
        Line: string
        Range: Range.range }
      with
        static member
          AddLineWithKey : string ->
                             Directive ->
                               string ->
                                 Range.range ->
                                   Map<string,PackageManagerLine list> ->
                                     Map<string,PackageManagerLine list>
        static member
          RemoveUnprocessedLines : string ->
                                     Map<string,PackageManagerLine list> ->
                                       Map<string,PackageManagerLine list>
        static member
          SetLinesAsProcessed : string ->
                                  Map<string,PackageManagerLine list> ->
                                    Map<string,PackageManagerLine list>
        static member StripDependencyManagerKey : string -> string -> string
      end
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type TcConfigBuilder =
      { mutable primaryAssembly: AbstractIL.IL.PrimaryAssembly
        mutable noFeedback: bool
        mutable stackReserveSize: int32 option
        mutable implicitIncludeDir: string
        mutable openDebugInformationForLaterStaticLinking: bool
        defaultFSharpBinariesDir: string
        mutable compilingFslib: bool
        mutable useIncrementalBuilder: bool
        mutable includes: string list
        mutable implicitOpens: string list
        mutable useFsiAuxLib: bool
        mutable framework: bool
        mutable resolutionEnvironment: ReferenceResolver.ResolutionEnvironment
        mutable implicitlyResolveAssemblies: bool
        mutable light: bool option
        mutable conditionalCompilationDefines: string list
        mutable loadedSources: (Range.range * string * string) list
        mutable compilerToolPaths: string list
        mutable referencedDLLs: AssemblyReference list
        mutable packageManagerLines: Map<string,PackageManagerLine list>
        mutable projectReferences: IProjectReference list
        mutable knownUnresolvedReferences: UnresolvedAssemblyReference list
        reduceMemoryUsage: AbstractIL.ILBinaryReader.ReduceMemoryFlag
        mutable subsystemVersion: int * int
        mutable useHighEntropyVA: bool
        mutable inputCodePage: int option
        mutable embedResources: string list
        mutable errorSeverityOptions: ErrorLogger.FSharpErrorSeverityOptions
        mutable mlCompatibility: bool
        mutable checkOverflow: bool
        mutable showReferenceResolutions: bool
        mutable outputDir: string option
        mutable outputFile: string option
        mutable platform: AbstractIL.IL.ILPlatform option
        mutable prefer32Bit: bool
        mutable useSimpleResolution: bool
        mutable target: CompilerTarget
        mutable debuginfo: bool
        mutable testFlagEmitFeeFeeAs100001: bool
        mutable dumpDebugInfo: bool
        mutable debugSymbolFile: string option
        mutable typeCheckOnly: bool
        mutable parseOnly: bool
        mutable importAllReferencesOnly: bool
        mutable simulateException: string option
        mutable printAst: bool
        mutable tokenizeOnly: bool
        mutable testInteractionParser: bool
        mutable reportNumDecls: bool
        mutable printSignature: bool
        mutable printSignatureFile: string
        mutable xmlDocOutputFile: string option
        mutable stats: bool
        mutable generateFilterBlocks: bool
        mutable signer: string option
        mutable container: string option
        mutable delaysign: bool
        mutable publicsign: bool
        mutable version: VersionFlag
        mutable metadataVersion: string option
        mutable standalone: bool
        mutable extraStaticLinkRoots: string list
        mutable noSignatureData: bool
        mutable onlyEssentialOptimizationData: bool
        mutable useOptimizationDataFile: bool
        mutable jitTracking: bool
        mutable portablePDB: bool
        mutable embeddedPDB: bool
        mutable embedAllSource: bool
        mutable embedSourceList: string list
        mutable sourceLink: string
        mutable ignoreSymbolStoreSequencePoints: bool
        mutable internConstantStrings: bool
        mutable extraOptimizationIterations: int
        mutable win32res: string
        mutable win32manifest: string
        mutable includewin32manifest: bool
        mutable linkResources: string list
        mutable legacyReferenceResolver: ReferenceResolver.Resolver
        mutable showFullPaths: bool
        mutable errorStyle: ErrorLogger.ErrorStyle
        mutable utf8output: bool
        mutable flatErrors: bool
        mutable maxErrors: int
        mutable abortOnError: bool
        mutable baseAddress: int32 option
        mutable checksumAlgorithm: AbstractIL.ILPdbWriter.HashAlgorithm
        mutable showOptimizationData: bool
        mutable showTerms: bool
        mutable writeTermsToFiles: bool
        mutable doDetuple: bool
        mutable doTLR: bool
        mutable doFinalSimplify: bool
        mutable optsOn: bool
        mutable optSettings: Optimizer.OptimizationSettings
        mutable emitTailcalls: bool
        mutable deterministic: bool
        mutable preferredUiLang: string option
        mutable lcid: int option
        mutable productNameForBannerText: string
        mutable showBanner: bool
        mutable showTimes: bool
        mutable showLoadedAssemblies: bool
        mutable continueAfterParseFailure: bool
        mutable showExtensionTypeMessages: bool
        mutable pause: bool
        mutable alwaysCallVirt: bool
        mutable noDebugData: bool
        isInteractive: bool
        isInvalidationSupported: bool
        mutable emitDebugInfoInQuotations: bool
        mutable exename: string option
        mutable copyFSharpCore: CopyFSharpCoreFlag
        mutable shadowCopyReferences: bool
        mutable useSdkRefs: bool
        mutable tryGetMetadataSnapshot:
          AbstractIL.ILBinaryReader.ILReaderTryGetMetadataSnapshot
        mutable internalTestSpanStackReferring: bool
        mutable noConditionalErasure: bool
        mutable pathMap: Internal.Utilities.PathMap
        mutable langVersion: Features.LanguageVersion }
      with
        static member
          CreateNew : legacyReferenceResolver:ReferenceResolver.Resolver *
                      defaultFSharpBinariesDir:string *
                      reduceMemoryUsage:AbstractIL.ILBinaryReader.ReduceMemoryFlag *
                      implicitIncludeDir:string * isInteractive:bool *
                      isInvalidationSupported:bool *
                      defaultCopyFSharpCore:CopyFSharpCoreFlag *
                      tryGetMetadataSnapshot:AbstractIL.ILBinaryReader.ILReaderTryGetMetadataSnapshot ->
                        TcConfigBuilder
        static member
          SplitCommandLineResourceInfo : string ->
                                           string * string *
                                           AbstractIL.IL.ILResourceAccess
        member AddCompilerToolsByPath : string -> unit
        member
          AddDependencyManagerText : packageManager:Microsoft.DotNet.DependencyManager.IDependencyManagerProvider *
                                     lt:Directive * m:Range.range * path:string ->
                                       unit
        member AddEmbeddedResource : string -> unit
        member AddEmbeddedSourceFile : string -> unit
        member AddIncludePath : Range.range * string * string -> unit
        member
          AddLoadedSource : m:Range.range * originalPath:string *
                            pathLoadedFrom:string -> unit
        member AddPathMapping : oldPrefix:string * newPrefix:string -> unit
        member
          AddReferenceDirective : dependencyProvider:Microsoft.DotNet.DependencyManager.DependencyProvider *
                                  m:Range.range * path:string *
                                  directive:Directive -> unit
        member AddReferencedAssemblyByPath : Range.range * string -> unit
        member DecideNames : string list -> string * string option * string
        member GetNativeProbingRoots : unit -> seq<string>
        member RemoveReferencedAssemblyByPath : Range.range * string -> unit
        member
          ResolveSourceFile : m:Range.range * nm:string * pathLoadedFrom:string ->
                                string
        member TurnWarningOff : Range.range * string -> unit
        member TurnWarningOn : Range.range * string -> unit
        static member Initial : TcConfigBuilder
      end
    [<SealedAttribute ()>]
    type TcConfig =
      class
        private new : data:TcConfigBuilder * validate:bool -> TcConfig
        static member Create : TcConfigBuilder * validate:bool -> TcConfig
        member CloneToBuilder : unit -> TcConfigBuilder
        member
          ComputeCanContainEntryPoint : sourceFiles:string list ->
                                          bool list * bool
        member ComputeLightSyntaxInitialStatus : string -> bool
        member CoreLibraryDllReference : unit -> AssemblyReference
        member GetAvailableLoadedSources : unit -> (Range.range * string) list
        member GetNativeProbingRoots : unit -> seq<string>
        member GetSearchPathsForLibraryFiles : unit -> string list
        member GetTargetFrameworkDirectories : unit -> string list
        member IsSystemAssembly : string -> bool
        member MakePathAbsolute : string -> string
        member PrimaryAssemblyDllReference : unit -> AssemblyReference
        member
          ResolveSourceFile : Range.range * filename:string *
                              pathLoadedFrom:string -> string
        member GenerateOptimizationData : bool
        member GenerateSignatureData : bool
        member alwaysCallVirt : bool
        member baseAddress : int32 option
        member checkOverflow : bool
        member checksumAlgorithm : AbstractIL.ILPdbWriter.HashAlgorithm
        member clrRoot : string option
        member compilerToolPaths : string list
        member compilingFslib : bool
        member conditionalCompilationDefines : string list
        member container : string option
        member continueAfterParseFailure : bool
        member copyFSharpCore : CopyFSharpCoreFlag
        member debugSymbolFile : string option
        member debuginfo : bool
        member delaysign : bool
        member deterministic : bool
        member doDetuple : bool
        member doFinalSimplify : bool
        member doTLR : bool
        member dumpDebugInfo : bool
        member embedAllSource : bool
        member embedResources : string list
        member embedSourceList : string list
        member embeddedPDB : bool
        member emitDebugInfoInQuotations : bool
        member emitTailcalls : bool
        member errorSeverityOptions : ErrorLogger.FSharpErrorSeverityOptions
        member errorStyle : ErrorLogger.ErrorStyle
        member extraOptimizationIterations : int
        member extraStaticLinkRoots : string list
        member flatErrors : bool
        member framework : bool
        member fsharpBinariesDir : string
        member generateFilterBlocks : bool
        member ignoreSymbolStoreSequencePoints : bool
        member implicitIncludeDir : string
        member implicitOpens : string list
        member implicitlyResolveAssemblies : bool
        member importAllReferencesOnly : bool
        member includes : string list
        member includewin32manifest : bool
        member inputCodePage : int option
        member internConstantStrings : bool
        member internalTestSpanStackReferring : bool
        member isInteractive : bool
        member isInvalidationSupported : bool
        member jitTracking : bool
        member knownUnresolvedReferences : UnresolvedAssemblyReference list
        member langVersion : Features.LanguageVersion
        member lcid : int option
        member legacyReferenceResolver : ReferenceResolver.Resolver
        member light : bool option
        member linkResources : string list
        member loadedSources : (Range.range * string * string) list
        member maxErrors : int
        member metadataVersion : string option
        member mlCompatibility : bool
        member noConditionalErasure : bool
        member noDebugData : bool
        member noFeedback : bool
        member noSignatureData : bool
        member onlyEssentialOptimizationData : bool
        member openDebugInformationForLaterStaticLinking : bool
        member optSettings : Optimizer.OptimizationSettings
        member optsOn : bool
        member outputDir : string option
        member outputFile : string option
        member packageManagerLines : Map<string,PackageManagerLine list>
        member parseOnly : bool
        member pathMap : Internal.Utilities.PathMap
        member pause : bool
        member platform : AbstractIL.IL.ILPlatform option
        member portablePDB : bool
        member prefer32Bit : bool
        member preferredUiLang : string option
        member primaryAssembly : AbstractIL.IL.PrimaryAssembly
        member printAst : bool
        member printSignature : bool
        member printSignatureFile : string
        member productNameForBannerText : string
        member publicsign : bool
        member reduceMemoryUsage : AbstractIL.ILBinaryReader.ReduceMemoryFlag
        member referencedDLLs : AssemblyReference list
        member reportNumDecls : bool
        member resolutionEnvironment : ReferenceResolver.ResolutionEnvironment
        member shadowCopyReferences : bool
        member showBanner : bool
        member showExtensionTypeMessages : bool
        member showFullPaths : bool
        member showLoadedAssemblies : bool
        member showOptimizationData : bool
        member showReferenceResolutions : bool
        member showTerms : bool
        member showTimes : bool
        member signer : string option
        member simulateException : string option
        member sourceLink : string
        member stackReserveSize : int32 option
        member standalone : bool
        member stats : bool
        member subsystemVersion : int * int
        member target : CompilerTarget
        member targetFrameworkVersion : string
        member testFlagEmitFeeFeeAs100001 : bool
        member testInteractionParser : bool
        member tokenizeOnly : bool
        member
          tryGetMetadataSnapshot : AbstractIL.ILBinaryReader.ILReaderTryGetMetadataSnapshot
        member typeCheckOnly : bool
        member useFsiAuxLib : bool
        member useHighEntropyVA : bool
        member useIncrementalBuilder : bool
        member useOptimizationDataFile : bool
        member useSdkRefs : bool
        member useSimpleResolution : bool
        member utf8output : bool
        member version : VersionFlag
        member win32manifest : string
        member win32res : string
        member writeTermsToFiles : bool
        member xmlDocOutputFile : string option
      end
    [<SealedAttribute ()>]
    type TcConfigProvider =
      | TcConfigProvider of
        (AbstractIL.Internal.Library.CompilationThreadToken -> TcConfig)
      with
        static member
          BasedOnMutableBuilder : TcConfigBuilder -> TcConfigProvider
        static member Constant : TcConfig -> TcConfigProvider
        member
          Get : AbstractIL.Internal.Library.CompilationThreadToken -> TcConfig
      end
    val GetFSharpCoreLibraryName : unit -> string
  end

namespace FSharp.Compiler
  module internal CompilerImports = begin
    val ( ++ ) : x:'a list -> s:'a -> 'a list
    val IsSignatureDataResource : AbstractIL.IL.ILResource -> bool
    val IsOptimizationDataResource : AbstractIL.IL.ILResource -> bool
    val GetSignatureDataResourceName : AbstractIL.IL.ILResource -> string
    val GetOptimizationDataResourceName : r:AbstractIL.IL.ILResource -> string
    val IsReflectedDefinitionsResource : AbstractIL.IL.ILResource -> bool
    val MakeILResource :
      rName:string -> bytes:byte [] -> AbstractIL.IL.ILResource
    val PickleToResource :
      inMem:bool ->
        file:string ->
          g:TcGlobals.TcGlobals ->
            scope:TypedTree.CcuThunk ->
              rName:string ->
                p:TypedTreePickle.pickler<'a> ->
                  x:'a -> AbstractIL.IL.ILResource
    val GetSignatureData :
      file:string * ilScopeRef:AbstractIL.IL.ILScopeRef *
      ilModule:AbstractIL.IL.ILModuleDef option *
      byteReader:(unit -> AbstractIL.Internal.ReadOnlyByteMemory) ->
        TypedTreePickle.PickledDataWithReferences<TypedTree.PickledCcuInfo>
    val WriteSignatureData :
      CompilerConfig.TcConfig * TcGlobals.TcGlobals * TypedTreeOps.Remap *
      TypedTree.CcuThunk * filename:string * inMem:bool ->
        AbstractIL.IL.ILResource
    val GetOptimizationData :
      file:string * ilScopeRef:AbstractIL.IL.ILScopeRef *
      ilModule:AbstractIL.IL.ILModuleDef option *
      byteReader:(unit -> AbstractIL.Internal.ReadOnlyByteMemory) ->
        TypedTreePickle.PickledDataWithReferences<Optimizer.CcuOptimizationInfo>
    val WriteOptimizationData :
      TcGlobals.TcGlobals * filename:string * inMem:bool * TypedTree.CcuThunk *
      Optimizer.CcuOptimizationInfo -> AbstractIL.IL.ILResource
    exception AssemblyNotResolved of string * Range.range
    exception MSBuildReferenceResolutionWarning of string * string * Range.range
    exception MSBuildReferenceResolutionError of string * string * Range.range
    val OpenILBinary :
      filename:string *
      reduceMemoryUsage:AbstractIL.ILBinaryReader.ReduceMemoryFlag *
      pdbDirPath:string option * shadowCopyReferences:bool *
      tryGetMetadataSnapshot:AbstractIL.ILBinaryReader.ILReaderTryGetMetadataSnapshot ->
        AbstractIL.ILBinaryReader.ILModuleReader
    [<RequireQualifiedAccessAttribute ()>]
    type ResolveAssemblyReferenceMode =
      | Speculative
      | ReportErrors
    type ResolvedExtensionReference =
      | ResolvedExtensionReference of
        string * CompilerConfig.AssemblyReference list *
        Tainted<CompilerServices.ITypeProvider> list
    [<System.Diagnostics.DebuggerDisplay ("AssemblyResolution({resolvedPath})")>]
    type AssemblyResolution =
      { originalReference: CompilerConfig.AssemblyReference
        resolvedPath: string
        prepareToolTip: unit -> string
        sysdir: bool
        mutable ilAssemblyRef: AbstractIL.IL.ILAssemblyRef option }
      with
        member
          GetILAssemblyRef : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                             reduceMemoryUsage:AbstractIL.ILBinaryReader.ReduceMemoryFlag *
                             tryGetMetadataSnapshot:AbstractIL.ILBinaryReader.ILReaderTryGetMetadataSnapshot ->
                               AbstractIL.Internal.Library.Cancellable<AbstractIL.IL.ILAssemblyRef>
        override ToString : unit -> string
        member ProjectReference : CompilerConfig.IProjectReference option
      end
    [<RequireQualifiedAccessAttribute ()>]
    type ImportedBinary =
      { FileName: string
        RawMetadata: CompilerConfig.IRawFSharpAssemblyData
        ProviderGeneratedAssembly: System.Reflection.Assembly option
        IsProviderGenerated: bool
        ProviderGeneratedStaticLinkMap:
          ExtensionTyping.ProvidedAssemblyStaticLinkingMap option
        ILAssemblyRefs: AbstractIL.IL.ILAssemblyRef list
        ILScopeRef: AbstractIL.IL.ILScopeRef }
    [<RequireQualifiedAccessAttribute ()>]
    type ImportedAssembly =
      { ILScopeRef: AbstractIL.IL.ILScopeRef
        FSharpViewOfMetadata: TypedTree.CcuThunk
        AssemblyAutoOpenAttributes: string list
        AssemblyInternalsVisibleToAttributes: string list
        IsProviderGenerated: bool
        mutable TypeProviders: Tainted<CompilerServices.ITypeProvider> list
        FSharpOptimizationData: Lazy<Option<Optimizer.LazyModuleInfo>> }
    type AvailableImportedAssembly =
      | ResolvedImportedAssembly of ImportedAssembly
      | UnresolvedImportedAssembly of string
    type CcuLoadFailureAction =
      | RaiseError
      | ReturnNone
    type TcConfig with
      member
        TryResolveLibWithDirectories : r:CompilerConfig.AssemblyReference ->
                                         AssemblyResolution option
    type TcConfig with
      member
        ResolveLibWithDirectories : ccuLoadFailureAction:CcuLoadFailureAction *
                                    r:CompilerConfig.AssemblyReference ->
                                      AssemblyResolution option
    type TcConfig with
      member
        MsBuildResolve : references:(string * string) [] *
                         mode:ResolveAssemblyReferenceMode *
                         errorAndWarningRange:Range.range * showMessages:bool ->
                           ReferenceResolver.ResolvedFile []
    type TcConfig with
      static member
        TryResolveLibsUsingMSBuildRules : tcConfig:CompilerConfig.TcConfig *
                                          originalReferences:CompilerConfig.AssemblyReference list *
                                          errorAndWarningRange:Range.range *
                                          mode:ResolveAssemblyReferenceMode ->
                                            AssemblyResolution list *
                                            CompilerConfig.UnresolvedAssemblyReference list
    [<SealedAttribute ()>]
    type TcAssemblyResolutions =
      class
        new : tcConfig:CompilerConfig.TcConfig * results:AssemblyResolution list *
              unresolved:CompilerConfig.UnresolvedAssemblyReference list ->
                TcAssemblyResolutions
        static member
          BuildFromPriorResolutions : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                      tcConfig:CompilerConfig.TcConfig *
                                      AssemblyResolution list *
                                      CompilerConfig.UnresolvedAssemblyReference list ->
                                        TcAssemblyResolutions
        static member
          GetAllDllReferences : tcConfig:CompilerConfig.TcConfig ->
                                  CompilerConfig.AssemblyReference list
        static member
          GetAssemblyResolutionInformation : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                             tcConfig:CompilerConfig.TcConfig ->
                                               AssemblyResolution list *
                                               CompilerConfig.UnresolvedAssemblyReference list
        static member
          ResolveAssemblyReferences : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                      tcConfig:CompilerConfig.TcConfig *
                                      assemblyList:CompilerConfig.AssemblyReference list *
                                      knownUnresolved:CompilerConfig.UnresolvedAssemblyReference list ->
                                        TcAssemblyResolutions
        static member
          SplitNonFoundationalResolutions : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                            tcConfig:CompilerConfig.TcConfig ->
                                              AssemblyResolution list *
                                              AssemblyResolution list *
                                              CompilerConfig.UnresolvedAssemblyReference list
        member
          AddResolutionResults : newResults:AssemblyResolution list ->
                                   TcAssemblyResolutions
        member
          AddUnresolvedReferences : newUnresolved:CompilerConfig.UnresolvedAssemblyReference list ->
                                      TcAssemblyResolutions
        member GetAssemblyResolutions : unit -> AssemblyResolution list
        member
          GetUnresolvedReferences : unit ->
                                      CompilerConfig.UnresolvedAssemblyReference list
        member
          TryFindByExactILAssemblyRef : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                        assemblyRef:AbstractIL.IL.ILAssemblyRef ->
                                          AssemblyResolution option
        member
          TryFindByOriginalReference : assemblyReference:CompilerConfig.AssemblyReference ->
                                         AssemblyResolution option
        member
          TryFindByOriginalReferenceText : nm:string ->
                                             AssemblyResolution option
        member TryFindByResolvedPath : nm:string -> AssemblyResolution option
        member
          TryFindBySimpleAssemblyName : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                        simpleAssemName:string ->
                                          AssemblyResolution option
      end
    val GetNameOfILModule : m:AbstractIL.IL.ILModuleDef -> string
    val MakeScopeRefForILModule :
      ilModule:AbstractIL.IL.ILModuleDef -> AbstractIL.IL.ILScopeRef
    val GetCustomAttributesOfILModule :
      ilModule:AbstractIL.IL.ILModuleDef -> AbstractIL.IL.ILAttribute list
    val GetAutoOpenAttributes :
      ilg:AbstractIL.IL.ILGlobals ->
        ilModule:AbstractIL.IL.ILModuleDef -> string list
    val GetInternalsVisibleToAttributes :
      ilg:AbstractIL.IL.ILGlobals ->
        ilModule:AbstractIL.IL.ILModuleDef -> string list
    type RawFSharpAssemblyDataBackedByFileOnDisk =
      class
        interface CompilerConfig.IRawFSharpAssemblyData
        new : ilModule:AbstractIL.IL.ILModuleDef *
              ilAssemblyRefs:AbstractIL.IL.ILAssemblyRef list ->
                RawFSharpAssemblyDataBackedByFileOnDisk
      end
    [<SealedAttribute ()>]
    type TcImportsSafeDisposal =
      class
        interface System.IDisposable
        new : disposeActions:ResizeArray<(unit -> unit)> *
              disposeTypeProviderActions:ResizeArray<(unit -> unit)> ->
                TcImportsSafeDisposal
        override Finalize : unit -> unit
      end
    type TcImportsDllInfoHack =
      { FileName: string }
    and TcImportsWeakHack =
      class
        new : tcImports:System.WeakReference<TcImports> -> TcImportsWeakHack
        member SetDllInfos : value:ImportedBinary list -> unit
        member SystemRuntimeContainsType : typeName:string -> bool
        member Base : TcImportsWeakHack option
      end
    [<SealedAttribute ()>]
    and TcImports =
      class
        interface System.IDisposable
        new : tcConfigP:CompilerConfig.TcConfigProvider *
              initialResolutions:TcAssemblyResolutions *
              importsBase:TcImports option *
              ilGlobalsOpt:AbstractIL.IL.ILGlobals option *
              dependencyProviderOpt:Microsoft.DotNet.DependencyManager.DependencyProvider option ->
                TcImports
        static member
          BuildFrameworkTcImports : AbstractIL.Internal.Library.CompilationThreadToken *
                                    CompilerConfig.TcConfigProvider *
                                    AssemblyResolution list *
                                    AssemblyResolution list ->
                                      AbstractIL.Internal.Library.Cancellable<TcGlobals.TcGlobals *
                                                                              TcImports>
        static member
          BuildNonFrameworkTcImports : AbstractIL.Internal.Library.CompilationThreadToken *
                                       CompilerConfig.TcConfigProvider *
                                       TcGlobals.TcGlobals * TcImports *
                                       AssemblyResolution list *
                                       CompilerConfig.UnresolvedAssemblyReference list *
                                       Microsoft.DotNet.DependencyManager.DependencyProvider ->
                                         AbstractIL.Internal.Library.Cancellable<TcImports>
        static member
          BuildTcImports : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                           tcConfigP:CompilerConfig.TcConfigProvider *
                           dependencyProvider:Microsoft.DotNet.DependencyManager.DependencyProvider ->
                             AbstractIL.Internal.Library.Cancellable<TcGlobals.TcGlobals *
                                                                     TcImports>
        member AllAssemblyResolutions : unit -> AssemblyResolution list
        member private AttachDisposeAction : action:(unit -> unit) -> unit
        member
          private AttachDisposeTypeProviderAction : action:(unit -> unit) ->
                                                      unit
        member
          FindCcu : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                    m:Range.range * assemblyName:string * lookupOnly:bool ->
                      TypedTree.CcuResolutionResult
        member
          FindCcuFromAssemblyRef : AbstractIL.Internal.Library.CompilationThreadToken *
                                   Range.range * AbstractIL.IL.ILAssemblyRef ->
                                     TypedTree.CcuResolutionResult
        member
          FindCcuInfo : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                        m:Range.range * assemblyName:string * lookupOnly:bool ->
                          AvailableImportedAssembly
        member
          FindDllInfo : AbstractIL.Internal.Library.CompilationThreadToken *
                        Range.range * string -> ImportedBinary
        member GetCcusExcludingBase : unit -> TypedTree.CcuThunk list
        member GetCcusInDeclOrder : unit -> TypedTree.CcuThunk list
        member GetDllInfos : unit -> ImportedBinary list
        member GetImportMap : unit -> Import.ImportMap
        member GetImportedAssemblies : unit -> ImportedAssembly list
        member
          GetProvidedAssemblyInfo : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                    m:Range.range *
                                    assembly:Tainted<ExtensionTyping.ProvidedAssembly> ->
                                      bool *
                                      ExtensionTyping.ProvidedAssemblyStaticLinkingMap option
        member GetTcGlobals : unit -> TcGlobals.TcGlobals
        member
          ImplicitLoadIfAllowed : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                  m:Range.range * assemblyName:string *
                                  lookupOnly:bool -> unit
        member
          ImportTypeProviderExtensions : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                         tcConfig:CompilerConfig.TcConfig *
                                         fileNameOfRuntimeAssembly:string *
                                         ilScopeRefOfRuntimeAssembly:AbstractIL.IL.ILScopeRef *
                                         runtimeAssemblyAttributes:AbstractIL.IL.ILAttribute list *
                                         entityToInjectInto:TypedTree.Entity *
                                         invalidateCcu:Event<string> *
                                         m:Range.range ->
                                           Tainted<CompilerServices.ITypeProvider> list
        member
          private InjectProvidedNamespaceOrTypeIntoEntity : typeProviderEnvironment:ExtensionTyping.ResolutionEnvironment *
                                                            tcConfig:CompilerConfig.TcConfig *
                                                            m:Range.range *
                                                            entity:TypedTree.Entity *
                                                            injectedNamespace:string list *
                                                            remainingNamespace:string list *
                                                            provider:Tainted<CompilerServices.ITypeProvider> *
                                                            st:Tainted<ExtensionTyping.ProvidedType> option ->
                                                              unit
        member IsAlreadyRegistered : nm:string -> bool
        member
          MkLoaderForMultiModuleILAssemblies : ctok:AbstractIL.Internal.Library.CompilationThreadToken ->
                                                 m:Range.range ->
                                                   (AbstractIL.IL.ILScopeRef ->
                                                      AbstractIL.IL.ILModuleDef)
        member
          OpenILBinaryModule : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                               filename:string * m:Range.range ->
                                 AbstractIL.IL.ILModuleDef *
                                 AbstractIL.IL.ILAssemblyRef list
        member
          PrepareToImportReferencedFSharpAssembly : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                                    m:Range.range *
                                                    filename:string *
                                                    dllinfo:ImportedBinary ->
                                                      (unit ->
                                                         AvailableImportedAssembly list)
        member
          PrepareToImportReferencedILAssembly : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                                m:Range.range * filename:string *
                                                dllinfo:ImportedBinary ->
                                                  (unit ->
                                                     AvailableImportedAssembly list)
        member
          RecordGeneratedTypeRoot : root:ExtensionTyping.ProviderGeneratedType ->
                                      unit
        member
          RegisterAndImportReferencedAssemblies : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                                  nms:AssemblyResolution list ->
                                                    AbstractIL.Internal.Library.Cancellable<ImportedBinary list *
                                                                                            AvailableImportedAssembly list>
        member
          RegisterAndPrepareToImportReferencedDll : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                                    r:AssemblyResolution ->
                                                      AbstractIL.Internal.Library.Cancellable<ImportedBinary *
                                                                                              (unit ->
                                                                                                 AvailableImportedAssembly list)>
        member RegisterCcu : ccuInfo:ImportedAssembly -> unit
        member RegisterDll : dllInfo:ImportedBinary -> unit
        member
          ReportUnresolvedAssemblyReferences : CompilerConfig.UnresolvedAssemblyReference list ->
                                                 unit
        member
          ResolveAssemblyReference : AbstractIL.Internal.Library.CompilationThreadToken *
                                     CompilerConfig.AssemblyReference *
                                     ResolveAssemblyReferenceMode ->
                                       AssemblyResolution list
        member private SetILGlobals : ilg:AbstractIL.IL.ILGlobals -> unit
        member private SetTcGlobals : g:TcGlobals.TcGlobals -> unit
        member SystemRuntimeContainsType : string -> bool
        override ToString : unit -> string
        member
          TryFindDllInfo : AbstractIL.Internal.Library.CompilationThreadToken *
                           Range.range * string * lookupOnly:bool ->
                             ImportedBinary option
        member
          TryFindExistingFullyQualifiedPathByExactAssemblyRef : AbstractIL.Internal.Library.CompilationThreadToken *
                                                                AbstractIL.IL.ILAssemblyRef ->
                                                                  string option
        member
          TryFindExistingFullyQualifiedPathBySimpleAssemblyName : AbstractIL.Internal.Library.CompilationThreadToken *
                                                                  string ->
                                                                    string option
        member
          TryFindProviderGeneratedAssemblyByName : AbstractIL.Internal.Library.CompilationThreadToken *
                                                   assemblyName:string ->
                                                     System.Reflection.Assembly option
        member
          TryResolveAssemblyReference : AbstractIL.Internal.Library.CompilationThreadToken *
                                        CompilerConfig.AssemblyReference *
                                        ResolveAssemblyReferenceMode ->
                                          ErrorLogger.OperationResult<AssemblyResolution list>
        member Base : TcImports option
        member CcuTable : AbstractIL.Internal.Library.NameMap<ImportedAssembly>
        member
          DependencyProvider : Microsoft.DotNet.DependencyManager.DependencyProvider
        member DllTable : AbstractIL.Internal.Library.NameMap<ImportedBinary>
        member
          ProviderGeneratedTypeRoots : ExtensionTyping.ProviderGeneratedType list
        member Weak : TcImportsWeakHack
      end
    val RequireDLL :
      ctok:AbstractIL.Internal.Library.CompilationThreadToken *
      tcImports:TcImports * tcEnv:CheckExpressions.TcEnv *
      thisAssemblyName:string * referenceRange:Range.range * file:string ->
        CheckExpressions.TcEnv * (ImportedBinary list * ImportedAssembly list)
    val DefaultReferencesForScriptsAndOutOfProjectSources : bool -> string list
  end

namespace FSharp.Compiler
  module internal CompilerDiagnostics = begin
    module CompilerService = begin
      val showAssertForUnexpectedException : bool ref
    end
    exception HashIncludeNotAllowedInNonScript of Range.range
    exception HashReferenceNotAllowedInNonScript of Range.range
    exception HashLoadedSourceHasIssues of exn list * exn list * Range.range
    exception HashLoadedScriptConsideredSource of Range.range
    exception HashDirectiveNotAllowedInNonScript of Range.range
    exception DeprecatedCommandLineOptionFull of string * Range.range
    exception DeprecatedCommandLineOptionForHtmlDoc of string * Range.range
    exception DeprecatedCommandLineOptionSuggestAlternative of
                                                              string * string *
                                                              Range.range
    exception DeprecatedCommandLineOptionNoDescription of string * Range.range
    exception InternalCommandLineOption of string * Range.range
    val GetRangeOfDiagnostic :
      ErrorLogger.PhasedDiagnostic -> Range.range option
    val GetDiagnosticNumber : ErrorLogger.PhasedDiagnostic -> int
    val GetWarningLevel : err:ErrorLogger.PhasedDiagnostic -> int
    val warningOn :
      err:ErrorLogger.PhasedDiagnostic ->
        level:int -> specificWarnOn:int list -> bool
    val SplitRelatedDiagnostics :
      ErrorLogger.PhasedDiagnostic ->
        ErrorLogger.PhasedDiagnostic * ErrorLogger.PhasedDiagnostic list
    val DeclareMessage :
      (string * Printf.StringFormat<'a> -> DiagnosticMessage.ResourceString<'a>)
    val SeeAlsoE : unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val ConstraintSolverTupleDiffLengthsE :
      unit -> DiagnosticMessage.ResourceString<(int -> int -> string)>
    val ConstraintSolverInfiniteTypesE :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val ConstraintSolverMissingConstraintE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val ConstraintSolverTypesNotInEqualityRelation1E :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val ConstraintSolverTypesNotInEqualityRelation2E :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val ConstraintSolverTypesNotInSubsumptionRelationE :
      unit ->
        DiagnosticMessage.ResourceString<(string -> string -> string -> string)>
    val ErrorFromAddingTypeEquation1E :
      unit ->
        DiagnosticMessage.ResourceString<(string -> string -> string -> string)>
    val ErrorFromAddingTypeEquation2E :
      unit ->
        DiagnosticMessage.ResourceString<(string -> string -> string -> string)>
    val ErrorFromApplyingDefault1E :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val ErrorFromApplyingDefault2E :
      unit -> DiagnosticMessage.ResourceString<string>
    val ErrorsFromAddingSubsumptionConstraintE :
      unit ->
        DiagnosticMessage.ResourceString<(string -> string -> string -> string)>
    val UpperCaseIdentifierInPatternE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NotUpperCaseConstructorE :
      unit -> DiagnosticMessage.ResourceString<string>
    val FunctionExpectedE : unit -> DiagnosticMessage.ResourceString<string>
    val BakedInMemberConstraintNameE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val BadEventTransformationE :
      unit -> DiagnosticMessage.ResourceString<string>
    val ParameterlessStructCtorE :
      unit -> DiagnosticMessage.ResourceString<string>
    val InterfaceNotRevealedE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val TyconBadArgsE :
      unit -> DiagnosticMessage.ResourceString<(string -> int -> int -> string)>
    val IndeterminateTypeE : unit -> DiagnosticMessage.ResourceString<string>
    val NameClash1E :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val NameClash2E :
      unit ->
        DiagnosticMessage.ResourceString<(string -> string -> string ->
                                            string -> string -> string)>
    val Duplicate1E :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val Duplicate2E :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val UndefinedName2E : unit -> DiagnosticMessage.ResourceString<string>
    val FieldNotMutableE : unit -> DiagnosticMessage.ResourceString<string>
    val FieldsFromDifferentTypesE :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val VarBoundTwiceE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val RecursionE :
      unit ->
        DiagnosticMessage.ResourceString<(string -> string -> string ->
                                            string -> string)>
    val InvalidRuntimeCoercionE :
      unit ->
        DiagnosticMessage.ResourceString<(string -> string -> string -> string)>
    val IndeterminateRuntimeCoercionE :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val IndeterminateStaticCoercionE :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val StaticCoercionShouldUseBoxE :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val TypeIsImplicitlyAbstractE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NonRigidTypar1E :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val NonRigidTypar2E :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val NonRigidTypar3E :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val OBlockEndSentenceE : unit -> DiagnosticMessage.ResourceString<string>
    val UnexpectedEndOfInputE : unit -> DiagnosticMessage.ResourceString<string>
    val UnexpectedE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val NONTERM_interactionE : unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_hashDirectiveE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_fieldDeclE : unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_unionCaseReprE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_localBindingE : unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_hardwhiteLetBindingsE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_classDefnMemberE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_defnBindingsE : unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_classMemberSpfnE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_valSpfnE : unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_tyconSpfnE : unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_anonLambdaExprE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_attrUnionCaseDeclE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_cPrototypeE : unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_objectImplementationMembersE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_ifExprCasesE : unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_openDeclE : unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_fileModuleSpecE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_patternClausesE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_beginEndExprE : unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_recdExprE : unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_tyconDefnE : unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_exconCoreE : unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_typeNameInfoE : unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_attributeListE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_quoteExprE : unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_typeConstraintE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_Category_ImplementationFileE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_Category_DefinitionE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_Category_SignatureFileE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_Category_PatternE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_Category_ExprE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_Category_TypeE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NONTERM_typeArgsActualE :
      unit -> DiagnosticMessage.ResourceString<string>
    val TokenName1E :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val TokenName1TokenName2E :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val TokenName1TokenName2TokenName3E :
      unit ->
        DiagnosticMessage.ResourceString<(string -> string -> string -> string)>
    val RuntimeCoercionSourceSealed1E :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val RuntimeCoercionSourceSealed2E :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val CoercionTargetSealedE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val UpcastUnnecessaryE : unit -> DiagnosticMessage.ResourceString<string>
    val TypeTestUnnecessaryE : unit -> DiagnosticMessage.ResourceString<string>
    val OverrideDoesntOverride1E :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val OverrideDoesntOverride2E :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val OverrideDoesntOverride3E :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val OverrideDoesntOverride4E :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val UnionCaseWrongArgumentsE :
      unit -> DiagnosticMessage.ResourceString<(int -> int -> string)>
    val UnionPatternsBindDifferentNamesE :
      unit -> DiagnosticMessage.ResourceString<string>
    val RequiredButNotSpecifiedE :
      unit ->
        DiagnosticMessage.ResourceString<(string -> string -> string -> string)>
    val UseOfAddressOfOperatorE :
      unit -> DiagnosticMessage.ResourceString<string>
    val DefensiveCopyWarningE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val DeprecatedThreadStaticBindingWarningE :
      unit -> DiagnosticMessage.ResourceString<string>
    val FunctionValueUnexpectedE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val UnitTypeExpectedE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val UnitTypeExpectedWithEqualityE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val UnitTypeExpectedWithPossiblePropertySetterE :
      unit ->
        DiagnosticMessage.ResourceString<(string -> string -> string -> string)>
    val UnitTypeExpectedWithPossibleAssignmentE :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val UnitTypeExpectedWithPossibleAssignmentToMutableE :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val RecursiveUseCheckedAtRuntimeE :
      unit -> DiagnosticMessage.ResourceString<string>
    val LetRecUnsound1E :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val LetRecUnsound2E :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val LetRecUnsoundInnerE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val LetRecEvaluatedOutOfOrderE :
      unit -> DiagnosticMessage.ResourceString<string>
    val LetRecCheckedAtRuntimeE :
      unit -> DiagnosticMessage.ResourceString<string>
    val SelfRefObjCtor1E : unit -> DiagnosticMessage.ResourceString<string>
    val SelfRefObjCtor2E : unit -> DiagnosticMessage.ResourceString<string>
    val VirtualAugmentationOnNullValuedTypeE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NonVirtualAugmentationOnNullValuedTypeE :
      unit -> DiagnosticMessage.ResourceString<string>
    val NonUniqueInferredAbstractSlot1E :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val NonUniqueInferredAbstractSlot2E :
      unit -> DiagnosticMessage.ResourceString<string>
    val NonUniqueInferredAbstractSlot3E :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val NonUniqueInferredAbstractSlot4E :
      unit -> DiagnosticMessage.ResourceString<string>
    val Failure3E : unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val Failure4E : unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val MatchIncomplete1E : unit -> DiagnosticMessage.ResourceString<string>
    val MatchIncomplete2E :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val MatchIncomplete3E :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val MatchIncomplete4E : unit -> DiagnosticMessage.ResourceString<string>
    val RuleNeverMatchedE : unit -> DiagnosticMessage.ResourceString<string>
    val EnumMatchIncomplete1E : unit -> DiagnosticMessage.ResourceString<string>
    val ValNotMutableE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val ValNotLocalE : unit -> DiagnosticMessage.ResourceString<string>
    val Obsolete1E : unit -> DiagnosticMessage.ResourceString<string>
    val Obsolete2E :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val ExperimentalE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val PossibleUnverifiableCodeE :
      unit -> DiagnosticMessage.ResourceString<string>
    val DeprecatedE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val LibraryUseOnlyE : unit -> DiagnosticMessage.ResourceString<string>
    val MissingFieldsE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val ValueRestriction1E :
      unit ->
        DiagnosticMessage.ResourceString<(string -> string -> string -> string)>
    val ValueRestriction2E :
      unit ->
        DiagnosticMessage.ResourceString<(string -> string -> string -> string)>
    val ValueRestriction3E :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val ValueRestriction4E :
      unit ->
        DiagnosticMessage.ResourceString<(string -> string -> string -> string)>
    val ValueRestriction5E :
      unit ->
        DiagnosticMessage.ResourceString<(string -> string -> string -> string)>
    val RecoverableParseErrorE :
      unit -> DiagnosticMessage.ResourceString<string>
    val ReservedKeywordE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val IndentationProblemE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val OverrideInIntrinsicAugmentationE :
      unit -> DiagnosticMessage.ResourceString<string>
    val OverrideInExtrinsicAugmentationE :
      unit -> DiagnosticMessage.ResourceString<string>
    val IntfImplInIntrinsicAugmentationE :
      unit -> DiagnosticMessage.ResourceString<string>
    val IntfImplInExtrinsicAugmentationE :
      unit -> DiagnosticMessage.ResourceString<string>
    val UnresolvedReferenceNoRangeE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val UnresolvedPathReferenceNoRangeE :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val HashIncludeNotAllowedInNonScriptE :
      unit -> DiagnosticMessage.ResourceString<string>
    val HashReferenceNotAllowedInNonScriptE :
      unit -> DiagnosticMessage.ResourceString<string>
    val HashDirectiveNotAllowedInNonScriptE :
      unit -> DiagnosticMessage.ResourceString<string>
    val FileNameNotResolvedE :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val AssemblyNotResolvedE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val HashLoadedSourceHasIssues1E :
      unit -> DiagnosticMessage.ResourceString<string>
    val HashLoadedSourceHasIssues2E :
      unit -> DiagnosticMessage.ResourceString<string>
    val HashLoadedScriptConsideredSourceE :
      unit -> DiagnosticMessage.ResourceString<string>
    val InvalidInternalsVisibleToAssemblyName1E :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val InvalidInternalsVisibleToAssemblyName2E :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val LoadedSourceNotFoundIgnoringE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val MSBuildReferenceResolutionErrorE :
      unit -> DiagnosticMessage.ResourceString<(string -> string -> string)>
    val TargetInvocationExceptionWrapperE :
      unit -> DiagnosticMessage.ResourceString<(string -> string)>
    val getErrorString : key:string -> string
    val ( |InvalidArgument|_| ) : exn:exn -> string option
    val OutputPhasedErrorR :
      os:System.Text.StringBuilder ->
        err:ErrorLogger.PhasedDiagnostic -> canSuggestNames:bool -> unit
    val OutputPhasedDiagnostic :
      System.Text.StringBuilder ->
        ErrorLogger.PhasedDiagnostic ->
          flattenErrors:bool -> suggestNames:bool -> unit
    val SanitizeFileName :
      fileName:string -> implicitIncludeDir:string -> string
    [<RequireQualifiedAccessAttribute ()>]
    type DiagnosticLocation =
      { Range: Range.range
        File: string
        TextRepresentation: string
        IsEmpty: bool }
    [<RequireQualifiedAccessAttribute ()>]
    type DiagnosticCanonicalInformation =
      { ErrorNumber: int
        Subcategory: string
        TextRepresentation: string }
    [<RequireQualifiedAccessAttribute ()>]
    type DiagnosticDetailedInfo =
      { Location: DiagnosticLocation option
        Canonical: DiagnosticCanonicalInformation
        Message: string }
    [<RequireQualifiedAccessAttribute ()>]
    type Diagnostic =
      | Short of bool * string
      | Long of bool * DiagnosticDetailedInfo
    val CollectDiagnostic :
      implicitIncludeDir:string * showFullPaths:bool * flattenErrors:bool *
      errorStyle:ErrorLogger.ErrorStyle * isError:bool *
      ErrorLogger.PhasedDiagnostic * suggestNames:bool -> seq<Diagnostic>
    val OutputDiagnostic :
      implicitIncludeDir:string * showFullPaths:bool * flattenErrors:bool *
      errorStyle:ErrorLogger.ErrorStyle * isError:bool ->
        System.Text.StringBuilder -> ErrorLogger.PhasedDiagnostic -> unit
    val OutputDiagnosticContext :
      prefix:string ->
        fileLineFunction:(string -> int -> string) ->
          System.Text.StringBuilder -> ErrorLogger.PhasedDiagnostic -> unit
    val ReportWarning :
      ErrorLogger.FSharpErrorSeverityOptions ->
        ErrorLogger.PhasedDiagnostic -> bool
    val ReportWarningAsError :
      ErrorLogger.FSharpErrorSeverityOptions ->
        ErrorLogger.PhasedDiagnostic -> bool
    type ErrorLoggerFilteringByScopedPragmas =
      class
        inherit ErrorLogger.ErrorLogger
        new : checkFile:bool * scopedPragmas:SyntaxTree.ScopedPragma list *
              errorLogger:ErrorLogger.ErrorLogger ->
                ErrorLoggerFilteringByScopedPragmas
        override
          DiagnosticSink : phasedError:ErrorLogger.PhasedDiagnostic *
                           isError:bool -> unit
        override ErrorCount : int
      end
    val GetErrorLoggerFilteringByScopedPragmas :
      checkFile:bool * SyntaxTree.ScopedPragma list * ErrorLogger.ErrorLogger ->
        ErrorLogger.ErrorLogger
  end

namespace FSharp.Compiler
  module internal ParseAndCheckInputs = begin
    val CanonicalizeFilename : filename:string -> string
    val IsScript : string -> bool
    val QualFileNameOfModuleName :
      m:Range.range ->
        filename:string ->
          modname:SyntaxTree.Ident list -> SyntaxTree.QualifiedNameOfFile
    val QualFileNameOfFilename :
      m:Range.range -> filename:string -> SyntaxTree.QualifiedNameOfFile
    val ComputeQualifiedNameOfFileFromUniquePath :
      Range.range * string list -> SyntaxTree.QualifiedNameOfFile
    val QualFileNameOfSpecs :
      filename:string ->
        specs:SyntaxTree.SynModuleOrNamespaceSig list ->
          SyntaxTree.QualifiedNameOfFile
    val QualFileNameOfImpls :
      filename:string ->
        specs:SyntaxTree.SynModuleOrNamespace list ->
          SyntaxTree.QualifiedNameOfFile
    val PrependPathToQualFileName :
      x:SyntaxTree.Ident list ->
        SyntaxTree.QualifiedNameOfFile -> SyntaxTree.QualifiedNameOfFile
    val PrependPathToImpl :
      x:SyntaxTree.Ident list ->
        SyntaxTree.SynModuleOrNamespace -> SyntaxTree.SynModuleOrNamespace
    val PrependPathToSpec :
      x:SyntaxTree.Ident list ->
        SyntaxTree.SynModuleOrNamespaceSig -> SyntaxTree.SynModuleOrNamespaceSig
    val PrependPathToInput :
      SyntaxTree.Ident list -> SyntaxTree.ParsedInput -> SyntaxTree.ParsedInput
    val ComputeAnonModuleName :
      check:bool ->
        defaultNamespace:string option ->
          filename:string -> m:Range.range -> SyntaxTree.Ident list
    val PostParseModuleImpl :
      _i:'a * defaultNamespace:string option * isLastCompiland:(bool * bool) *
      filename:string * impl:SyntaxTree.ParsedImplFileFragment ->
        SyntaxTree.SynModuleOrNamespace
    val PostParseModuleSpec :
      _i:'a * defaultNamespace:string option * isLastCompiland:(bool * bool) *
      filename:string * intf:SyntaxTree.ParsedSigFileFragment ->
        SyntaxTree.SynModuleOrNamespaceSig
    val GetScopedPragmasForInput :
      input:SyntaxTree.ParsedInput -> SyntaxTree.ScopedPragma list
    val GetScopedPragmasForHashDirective :
      hd:SyntaxTree.ParsedHashDirective -> SyntaxTree.ScopedPragma list
    val PostParseModuleImpls :
      defaultNamespace:string option * filename:string *
      isLastCompiland:(bool * bool) * SyntaxTree.ParsedImplFile ->
        SyntaxTree.ParsedInput
    val PostParseModuleSpecs :
      defaultNamespace:string option * filename:string *
      isLastCompiland:(bool * bool) * SyntaxTree.ParsedSigFile ->
        SyntaxTree.ParsedInput
    type ModuleNamesDict =
      Map<string,Map<string,SyntaxTree.QualifiedNameOfFile>>
    val DeduplicateModuleName :
      moduleNamesDict:ModuleNamesDict ->
        fileName:string ->
          qualNameOfFile:SyntaxTree.QualifiedNameOfFile ->
            SyntaxTree.QualifiedNameOfFile * ModuleNamesDict
    val DeduplicateParsedInputModuleName :
      ModuleNamesDict ->
        SyntaxTree.ParsedInput -> SyntaxTree.ParsedInput * ModuleNamesDict
    val ParseInput :
      (Internal.Utilities.Text.Lexing.LexBuffer<char> -> Parser.token) *
      ErrorLogger.ErrorLogger * UnicodeLexing.Lexbuf * string option * string *
      isLastCompiland:(bool * bool) -> SyntaxTree.ParsedInput
    val ShowAllTokensAndExit :
      shortFilename:string * tokenizer:LexFilter.LexFilter *
      lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> -> unit
    val TestInteractionParserAndExit :
      tokenizer:LexFilter.LexFilter *
      lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> -> 'a
    val ReportParsingStatistics : res:SyntaxTree.ParsedInput -> unit
    val ParseOneInputLexbuf :
      tcConfig:CompilerConfig.TcConfig *
      lexResourceManager:Lexhelp.LexResourceManager *
      conditionalCompilationDefines:string list * lexbuf:UnicodeLexing.Lexbuf *
      filename:string * isLastCompiland:(bool * bool) *
      errorLogger:ErrorLogger.ErrorLogger -> SyntaxTree.ParsedInput option
    val ValidSuffixes : string list
    val ParseOneInputFile :
      CompilerConfig.TcConfig * Lexhelp.LexResourceManager * string list *
      string * isLastCompiland:(bool * bool) * ErrorLogger.ErrorLogger * bool ->
        SyntaxTree.ParsedInput option
    val ProcessMetaCommandsFromInput :
      (('T -> Range.range * string -> 'T) *
       ('T -> Range.range * string * CompilerConfig.Directive -> 'T) *
       ('T -> Range.range * string -> unit)) ->
        CompilerConfig.TcConfigBuilder * SyntaxTree.ParsedInput * string * 'T ->
          'T
    val ApplyNoWarnsToTcConfig :
      CompilerConfig.TcConfig * SyntaxTree.ParsedInput * string ->
        CompilerConfig.TcConfig
    val ApplyMetaCommandsFromInputToTcConfig :
      CompilerConfig.TcConfig * SyntaxTree.ParsedInput * string *
      Microsoft.DotNet.DependencyManager.DependencyProvider ->
        CompilerConfig.TcConfig
    val GetInitialTcEnv :
      assemblyName:string * Range.range * CompilerConfig.TcConfig *
      CompilerImports.TcImports * TcGlobals.TcGlobals -> CheckExpressions.TcEnv
    val CheckSimulateException : tcConfig:CompilerConfig.TcConfig -> unit
    type RootSigs =
      AbstractIL.Internal.Zmap<SyntaxTree.QualifiedNameOfFile,
                               TypedTree.ModuleOrNamespaceType>
    type RootImpls = AbstractIL.Internal.Zset<SyntaxTree.QualifiedNameOfFile>
    val qnameOrder :
      System.Collections.Generic.IComparer<SyntaxTree.QualifiedNameOfFile>
    [<SealedAttribute ()>]
    type TcState =
      { tcsCcu: TypedTree.CcuThunk
        tcsCcuType: TypedTree.ModuleOrNamespace
        tcsNiceNameGen: CompilerGlobalState.NiceNameGenerator
        tcsTcSigEnv: CheckExpressions.TcEnv
        tcsTcImplEnv: CheckExpressions.TcEnv
        tcsCreatesGeneratedProvidedTypes: bool
        tcsRootSigs: RootSigs
        tcsRootImpls: RootImpls
        tcsCcuSig: TypedTree.ModuleOrNamespaceType }
      with
        member
          NextStateAfterIncrementalFragment : CheckExpressions.TcEnv -> TcState
        member Ccu : TypedTree.CcuThunk
        member CcuSig : TypedTree.ModuleOrNamespaceType
        member CcuType : TypedTree.ModuleOrNamespace
        member CreatesGeneratedProvidedTypes : bool
        member NiceNameGenerator : CompilerGlobalState.NiceNameGenerator
        member TcEnvFromImpls : CheckExpressions.TcEnv
        member TcEnvFromSignatures : CheckExpressions.TcEnv
      end
    val GetInitialTcState :
      Range.range * string * CompilerConfig.TcConfig * TcGlobals.TcGlobals *
      CompilerImports.TcImports * CompilerGlobalState.NiceNameGenerator *
      CheckExpressions.TcEnv -> TcState
    val TypeCheckOneInputEventually :
      checkForErrors:(unit -> bool) * CompilerConfig.TcConfig *
      CompilerImports.TcImports * TcGlobals.TcGlobals *
      SyntaxTree.LongIdent option * NameResolution.TcResultsSink * TcState *
      SyntaxTree.ParsedInput * skipImplIfSigExists:bool ->
        AbstractIL.Internal.Library.Eventually<(CheckExpressions.TcEnv *
                                                CheckDeclarations.TopAttribs *
                                                TypedTree.TypedImplFile option *
                                                TypedTree.ModuleOrNamespaceType) *
                                               TcState>
    val TypeCheckOneInput :
      ctok:AbstractIL.Internal.Library.CompilationThreadToken *
      checkForErrors:(unit -> bool) * tcConfig:CompilerConfig.TcConfig *
      tcImports:CompilerImports.TcImports * tcGlobals:TcGlobals.TcGlobals *
      prefixPathOpt:SyntaxTree.LongIdent option ->
        tcState:TcState ->
          inp:SyntaxTree.ParsedInput ->
            (CheckExpressions.TcEnv * CheckDeclarations.TopAttribs *
             TypedTree.TypedImplFile option * TypedTree.ModuleOrNamespaceType) *
            TcState
    val TypeCheckMultipleInputsFinish :
      (CheckExpressions.TcEnv * CheckDeclarations.TopAttribs * 'T option * 'U) list *
      TcState ->
        (CheckExpressions.TcEnv * CheckDeclarations.TopAttribs * 'T list *
         'U list) * TcState
    val TypeCheckOneInputAndFinishEventually :
      checkForErrors:(unit -> bool) * CompilerConfig.TcConfig *
      CompilerImports.TcImports * TcGlobals.TcGlobals *
      SyntaxTree.LongIdent option * NameResolution.TcResultsSink * TcState *
      SyntaxTree.ParsedInput ->
        AbstractIL.Internal.Library.Eventually<(CheckExpressions.TcEnv *
                                                CheckDeclarations.TopAttribs *
                                                TypedTree.TypedImplFile list *
                                                TypedTree.ModuleOrNamespaceType list) *
                                               TcState>
    val TypeCheckClosedInputSetFinish :
      TypedTree.TypedImplFile list * TcState ->
        TcState * TypedTree.TypedImplFile list
    val TypeCheckClosedInputSet :
      AbstractIL.Internal.Library.CompilationThreadToken *
      checkForErrors:(unit -> bool) * CompilerConfig.TcConfig *
      CompilerImports.TcImports * TcGlobals.TcGlobals *
      SyntaxTree.LongIdent option * TcState * SyntaxTree.ParsedInput list ->
        TcState * CheckDeclarations.TopAttribs * TypedTree.TypedImplFile list *
        CheckExpressions.TcEnv
  end

namespace FSharp.Compiler
  module internal ScriptClosure = begin
    [<RequireQualifiedAccessAttribute ()>]
    type LoadClosureInput =
      { FileName: string
        SyntaxTree: SyntaxTree.ParsedInput option
        ParseDiagnostics: (ErrorLogger.PhasedDiagnostic * bool) list
        MetaCommandDiagnostics: (ErrorLogger.PhasedDiagnostic * bool) list }
    [<RequireQualifiedAccessAttribute ()>]
    type LoadClosure =
      { SourceFiles: (string * Range.range list) list
        References: (string * CompilerImports.AssemblyResolution list) list
        PackageReferences: (Range.range * string list) []
        UnresolvedReferences: CompilerConfig.UnresolvedAssemblyReference list
        Inputs: LoadClosureInput list
        OriginalLoadReferences: (Range.range * string * string) list
        NoWarns: (string * Range.range list) list
        ResolutionDiagnostics: (ErrorLogger.PhasedDiagnostic * bool) list
        AllRootFileDiagnostics: (ErrorLogger.PhasedDiagnostic * bool) list
        LoadClosureRootFileDiagnostics:
          (ErrorLogger.PhasedDiagnostic * bool) list }
      with
        static member
          ComputeClosureOfScriptFiles : AbstractIL.Internal.Library.CompilationThreadToken *
                                        tcConfig:CompilerConfig.TcConfig *
                                        (string * Range.range) list *
                                        implicitDefines:CodeContext *
                                        lexResourceManager:Lexhelp.LexResourceManager *
                                        dependencyProvider:Microsoft.DotNet.DependencyManager.DependencyProvider ->
                                          LoadClosure
        static member
          ComputeClosureOfScriptText : AbstractIL.Internal.Library.CompilationThreadToken *
                                       legacyReferenceResolver:ReferenceResolver.Resolver *
                                       defaultFSharpBinariesDir:string *
                                       filename:string *
                                       sourceText:Text.ISourceText *
                                       implicitDefines:CodeContext *
                                       useSimpleResolution:bool *
                                       useFsiAuxLib:bool * useSdkRefs:bool *
                                       lexResourceManager:Lexhelp.LexResourceManager *
                                       applyCompilerOptions:(CompilerConfig.TcConfigBuilder ->
                                                               unit) *
                                       assumeDotNetFramework:bool *
                                       tryGetMetadataSnapshot:AbstractIL.ILBinaryReader.ILReaderTryGetMetadataSnapshot *
                                       reduceMemoryUsage:AbstractIL.ILBinaryReader.ReduceMemoryFlag *
                                       dependencyProvider:Microsoft.DotNet.DependencyManager.DependencyProvider ->
                                         LoadClosure
      end
    [<RequireQualifiedAccessAttribute ()>]
    type CodeContext =
      | CompilationAndEvaluation
      | Compilation
      | Editing
    module ScriptPreprocessClosure = begin
      type ClosureSource =
        | ClosureSource of
          filename: string * referenceRange: Range.range *
          sourceText: Text.ISourceText * parseRequired: bool
      type ClosureFile =
        | ClosureFile of
          string * Range.range * SyntaxTree.ParsedInput option *
          (ErrorLogger.PhasedDiagnostic * bool) list *
          (ErrorLogger.PhasedDiagnostic * bool) list *
          (string * Range.range) list
      type Observed =
        class
          new : unit -> Observed
          member HaveSeen : check:string -> bool
          member SetSeen : check:string -> unit
        end
      val ParseScriptText :
        filename:string * sourceText:Text.ISourceText *
        tcConfig:CompilerConfig.TcConfig * codeContext:CodeContext *
        lexResourceManager:Lexhelp.LexResourceManager *
        errorLogger:ErrorLogger.ErrorLogger -> SyntaxTree.ParsedInput option
      val CreateScriptTextTcConfig :
        legacyReferenceResolver:ReferenceResolver.Resolver *
        defaultFSharpBinariesDir:string * filename:string *
        codeContext:CodeContext * useSimpleResolution:bool * useFsiAuxLib:bool *
        basicReferences:#seq<Range.range * string> option *
        applyCommandLineArgs:(CompilerConfig.TcConfigBuilder -> unit) *
        assumeDotNetFramework:bool * useSdkRefs:bool *
        tryGetMetadataSnapshot:AbstractIL.ILBinaryReader.ILReaderTryGetMetadataSnapshot *
        reduceMemoryUsage:AbstractIL.ILBinaryReader.ReduceMemoryFlag ->
          CompilerConfig.TcConfig
      val ClosureSourceOfFilename :
        filename:string * m:Range.range * inputCodePage:int option *
        parseRequired:bool -> ClosureSource list
      val ApplyMetaCommandsFromInputToTcConfigAndGatherNoWarn :
        tcConfig:CompilerConfig.TcConfig * inp:SyntaxTree.ParsedInput *
        pathOfMetaCommandSource:string *
        dependencyProvider:Microsoft.DotNet.DependencyManager.DependencyProvider ->
          CompilerConfig.TcConfig * (string * Range.range) list
      val FindClosureFiles :
        mainFile:string * _m:'a * closureSources:ClosureSource list *
        origTcConfig:CompilerConfig.TcConfig * codeContext:CodeContext *
        lexResourceManager:Lexhelp.LexResourceManager *
        dependencyProvider:Microsoft.DotNet.DependencyManager.DependencyProvider ->
          ClosureFile list * CompilerConfig.TcConfig *
          (Range.range * string list) []
      val GetLoadClosure :
        ctok:AbstractIL.Internal.Library.CompilationThreadToken *
        rootFilename:string * closureFiles:ClosureFile list *
        tcConfig:CompilerConfig.TcConfig * codeContext:CodeContext *
        packageReferences:(Range.range * string list) [] -> LoadClosure
      val GetFullClosureOfScriptText :
        ctok:AbstractIL.Internal.Library.CompilationThreadToken *
        legacyReferenceResolver:ReferenceResolver.Resolver *
        defaultFSharpBinariesDir:string * filename:string *
        sourceText:Text.ISourceText * codeContext:CodeContext *
        useSimpleResolution:bool * useFsiAuxLib:bool * useSdkRefs:bool *
        lexResourceManager:Lexhelp.LexResourceManager *
        applyCommandLineArgs:(CompilerConfig.TcConfigBuilder -> unit) *
        assumeDotNetFramework:bool *
        tryGetMetadataSnapshot:AbstractIL.ILBinaryReader.ILReaderTryGetMetadataSnapshot *
        reduceMemoryUsage:AbstractIL.ILBinaryReader.ReduceMemoryFlag *
        dependencyProvider:Microsoft.DotNet.DependencyManager.DependencyProvider ->
          LoadClosure
      val GetFullClosureOfScriptFiles :
        ctok:AbstractIL.Internal.Library.CompilationThreadToken *
        tcConfig:CompilerConfig.TcConfig * files:(string * Range.range) list *
        codeContext:CodeContext * lexResourceManager:Lexhelp.LexResourceManager *
        dependencyProvider:Microsoft.DotNet.DependencyManager.DependencyProvider ->
          LoadClosure
    end
  end

namespace FSharp.Compiler
  module internal CompilerOptions = begin
    module Attributes = begin
    end
    [<RequireQualifiedAccessAttribute ()>]
    type OptionSwitch =
      | On
      | Off
    type OptionSpec =
      | OptionClear of bool ref
      | OptionFloat of (float -> unit)
      | OptionInt of (int -> unit)
      | OptionSwitch of (OptionSwitch -> unit)
      | OptionIntList of (int -> unit)
      | OptionIntListSwitch of (int -> OptionSwitch -> unit)
      | OptionRest of (string -> unit)
      | OptionSet of bool ref
      | OptionString of (string -> unit)
      | OptionStringList of (string -> unit)
      | OptionStringListSwitch of (string -> OptionSwitch -> unit)
      | OptionUnit of (unit -> unit)
      | OptionHelp of (CompilerOptionBlock list -> unit)
      | OptionGeneral of (string list -> bool) * (string list -> string list)
    and CompilerOption =
      | CompilerOption of
        string * string * OptionSpec * Option<exn> * string option
    and CompilerOptionBlock =
      | PublicOptions of string * CompilerOption list
      | PrivateOptions of CompilerOption list
    val GetOptionsOfBlock : block:CompilerOptionBlock -> CompilerOption list
    val FilterCompilerOptionBlock :
      (CompilerOption -> bool) -> CompilerOptionBlock -> CompilerOptionBlock
    val compilerOptionUsage : CompilerOption -> string
    val PrintCompilerOption : CompilerOption -> unit
    val PrintPublicOptions : heading:string * opts:CompilerOption list -> unit
    val PrintCompilerOptionBlocks : CompilerOptionBlock list -> unit
    val dumpCompilerOption : prefix:string -> CompilerOption -> unit
    val dumpCompilerOptionBlock : _arg1:CompilerOptionBlock -> unit
    val DumpCompilerOptionBlocks : CompilerOptionBlock list -> unit
    val isSlashOpt : opt:string -> bool
    module ResponseFile = begin
      type ResponseFileData = ResponseFileLine list
      and ResponseFileLine =
        | CompilerOptionSpec of string
        | Comment of string
      val parseFile : path:string -> Choice<ResponseFileData,System.Exception>
    end
    val ParseCompilerOptions :
      (string -> unit) * CompilerOptionBlock list * string list -> unit
    val lexFilterVerbose : bool
    val mutable enableConsoleColoring : bool
    val setFlag : r:(bool -> 'a) -> n:int -> 'a
    val SetOptimizeOff : tcConfigB:CompilerConfig.TcConfigBuilder -> unit
    val SetOptimizeOn : tcConfigB:CompilerConfig.TcConfigBuilder -> unit
    val SetOptimizeSwitch :
      CompilerConfig.TcConfigBuilder -> OptionSwitch -> unit
    val SetTailcallSwitch :
      CompilerConfig.TcConfigBuilder -> OptionSwitch -> unit
    val SetDeterministicSwitch :
      tcConfigB:CompilerConfig.TcConfigBuilder -> switch:OptionSwitch -> unit
    val AddPathMapping :
      tcConfigB:CompilerConfig.TcConfigBuilder -> pathPair:string -> unit
    val jitoptimizeSwitch :
      tcConfigB:CompilerConfig.TcConfigBuilder -> switch:OptionSwitch -> unit
    val localoptimizeSwitch :
      tcConfigB:CompilerConfig.TcConfigBuilder -> switch:OptionSwitch -> unit
    val crossOptimizeSwitch :
      tcConfigB:CompilerConfig.TcConfigBuilder -> switch:OptionSwitch -> unit
    val splittingSwitch :
      tcConfigB:CompilerConfig.TcConfigBuilder -> switch:OptionSwitch -> unit
    val callVirtSwitch :
      tcConfigB:CompilerConfig.TcConfigBuilder -> switch:OptionSwitch -> unit
    val useHighEntropyVASwitch :
      tcConfigB:CompilerConfig.TcConfigBuilder -> switch:OptionSwitch -> unit
    val subSystemVersionSwitch :
      tcConfigB:CompilerConfig.TcConfigBuilder -> text:string -> unit
    val SetUseSdkSwitch :
      tcConfigB:CompilerConfig.TcConfigBuilder -> switch:OptionSwitch -> unit
    val ( ++ ) : x:'a list -> s:'a -> 'a list
    val SetTarget : tcConfigB:CompilerConfig.TcConfigBuilder -> s:string -> unit
    val SetDebugSwitch :
      CompilerConfig.TcConfigBuilder -> string option -> OptionSwitch -> unit
    val SetEmbedAllSourceSwitch :
      tcConfigB:CompilerConfig.TcConfigBuilder -> switch:OptionSwitch -> unit
    val setOutFileName :
      tcConfigB:CompilerConfig.TcConfigBuilder -> path:string -> unit
    val setSignatureFile :
      tcConfigB:CompilerConfig.TcConfigBuilder -> s:string -> unit
    val tagString : string
    val tagExe : string
    val tagWinExe : string
    val tagLibrary : string
    val tagModule : string
    val tagFile : string
    val tagFileList : string
    val tagDirList : string
    val tagPathList : string
    val tagResInfo : string
    val tagFullPDBOnlyPortable : string
    val tagWarnList : string
    val tagSymbolList : string
    val tagAddress : string
    val tagAlgorithm : string
    val tagInt : string
    val tagPathMap : string
    val tagNone : string
    val tagLangVersionValues : string
    val PrintOptionInfo : CompilerConfig.TcConfigBuilder -> unit
    val inputFileFlagsBoth :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val referenceFlagAbbrev :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption
    val compilerToolFlagAbbrev :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption
    val inputFileFlagsFsc :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val inputFileFlagsFsiBase :
      _tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val inputFileFlagsFsi :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val errorsAndWarningsFlags :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val outputFileFlagsFsi :
      _tcConfigB:CompilerConfig.TcConfigBuilder -> 'a list
    val outputFileFlagsFsc :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val resourcesFlagsFsi : _tcConfigB:CompilerConfig.TcConfigBuilder -> 'a list
    val resourcesFlagsFsc :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val codeGenerationFlags :
      isFsi:bool ->
        tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val defineSymbol :
      tcConfigB:CompilerConfig.TcConfigBuilder -> s:string -> unit
    val mlCompatibilityFlag :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption
    val setLanguageVersion : specifiedVersion:string -> Features.LanguageVersion
    val languageFlags :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val libFlag : tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption
    val codePageFlag :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption
    val preferredUiLang :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption
    val utf8OutputFlag :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption
    val fullPathsFlag :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption
    val cliRootFlag :
      _tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption
    val SetTargetProfile : CompilerConfig.TcConfigBuilder -> string -> unit
    val advancedFlagsBoth :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val noFrameworkFlag :
      isFsc:bool -> tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption
    val advancedFlagsFsi :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val advancedFlagsFsc :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val testFlag : tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption
    val editorSpecificFlags :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val internalFlags :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val compilingFsLibFlag :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption
    val compilingFsLib20Flag : CompilerOption
    val compilingFsLib40Flag : CompilerOption
    val compilingFsLibNoBigIntFlag : CompilerOption
    val mlKeywordsFlag : CompilerOption
    val gnuStyleErrorsFlag :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption
    val deprecatedFlagsBoth :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val deprecatedFlagsFsi :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val deprecatedFlagsFsc :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val DisplayBannerText : CompilerConfig.TcConfigBuilder -> unit
    val displayHelpFsc :
      tcConfigB:CompilerConfig.TcConfigBuilder ->
        blocks:CompilerOptionBlock list -> 'a
    val displayVersion : tcConfigB:CompilerConfig.TcConfigBuilder -> 'a
    val miscFlagsBoth :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val miscFlagsFsc :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val miscFlagsFsi :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val abbreviatedFlagsBoth :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val abbreviatedFlagsFsi :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val abbreviatedFlagsFsc :
      tcConfigB:CompilerConfig.TcConfigBuilder -> CompilerOption list
    val GetAbbrevFlagSet : CompilerConfig.TcConfigBuilder -> bool -> Set<string>
    val PostProcessCompilerArgs : Set<string> -> string [] -> string list
    val testingAndQAFlags : _tcConfigB:'a -> CompilerOption list
    val GetCoreFscCompilerOptions :
      CompilerConfig.TcConfigBuilder -> CompilerOptionBlock list
    val GetCoreServiceCompilerOptions :
      CompilerConfig.TcConfigBuilder -> CompilerOptionBlock list
    val GetCoreFsiCompilerOptions :
      CompilerConfig.TcConfigBuilder -> CompilerOptionBlock list
    val ApplyCommandLineArgs :
      tcConfigB:CompilerConfig.TcConfigBuilder * sourceFiles:string list *
      argv:string list -> string list
    val mutable showTermFileCount : int
    val PrintWholeAssemblyImplementation :
      g:TcGlobals.TcGlobals ->
        tcConfig:CompilerConfig.TcConfig ->
          outfile:string ->
            header:string -> expr:TypedTree.TypedImplFile list -> unit
    val mutable tPrev : (float * int []) option
    val mutable nPrev : string option
    val ReportTime : CompilerConfig.TcConfig -> string -> unit
    val ignoreFailureOnMono1_1_16 : (unit -> unit) -> unit
    val foreBackColor :
      unit -> (System.ConsoleColor * System.ConsoleColor) option
    val DoWithColor : System.ConsoleColor -> (unit -> 'a) -> 'a
    val DoWithErrorColor : bool -> (unit -> 'a) -> 'a
  end

namespace FSharp.Compiler
  module internal OptimizeInputs = begin
    val mutable showTermFileCount : int
    val PrintWholeAssemblyImplementation :
      g:TcGlobals.TcGlobals ->
        tcConfig:CompilerConfig.TcConfig ->
          outfile:string ->
            header:string -> expr:TypedTree.TypedImplFile list -> unit
    val AddExternalCcuToOptimizationEnv :
      TcGlobals.TcGlobals ->
        Optimizer.IncrementalOptimizationEnv ->
          CompilerImports.ImportedAssembly ->
            Optimizer.IncrementalOptimizationEnv
    val GetInitialOptimizationEnv :
      CompilerImports.TcImports * TcGlobals.TcGlobals ->
        Optimizer.IncrementalOptimizationEnv
    val ApplyAllOptimizations :
      CompilerConfig.TcConfig * TcGlobals.TcGlobals * ConstraintSolver.TcValF *
      string * Import.ImportMap * bool * Optimizer.IncrementalOptimizationEnv *
      TypedTree.CcuThunk * TypedTree.TypedImplFile list ->
        TypedTree.TypedAssemblyAfterOptimization * Optimizer.CcuOptimizationInfo *
        Optimizer.IncrementalOptimizationEnv
    val CreateIlxAssemblyGenerator :
      CompilerConfig.TcConfig * CompilerImports.TcImports * TcGlobals.TcGlobals *
      ConstraintSolver.TcValF * TypedTree.CcuThunk ->
        IlxGen.IlxAssemblyGenerator
    val GenerateIlxCode :
      IlxGen.IlxGenBackend * isInteractiveItExpr:bool * isInteractiveOnMono:bool *
      CompilerConfig.TcConfig * CheckDeclarations.TopAttribs *
      TypedTree.TypedAssemblyAfterOptimization * fragName:string *
      IlxGen.IlxAssemblyGenerator -> IlxGen.IlxGenResults
    val NormalizeAssemblyRefs :
      AbstractIL.Internal.Library.CompilationThreadToken *
      AbstractIL.IL.ILGlobals * CompilerImports.TcImports ->
        (AbstractIL.IL.ILScopeRef -> AbstractIL.IL.ILScopeRef)
    val GetGeneratedILModuleName :
      CompilerConfig.CompilerTarget -> string -> string
  end

namespace FSharp.Compiler
  module internal XmlDocFileWriter = begin
    module XmlDocWriter = begin
      val hasDoc : doc:XmlDoc.XmlDoc -> bool
      val ComputeXmlDocSigs :
        tcGlobals:TcGlobals.TcGlobals * generatedCcu:TypedTree.CcuThunk -> unit
      val WriteXmlDocFile :
        assemblyName:string * generatedCcu:TypedTree.CcuThunk * xmlfile:string ->
          unit
    end
  end

namespace FSharp.Compiler
  module internal BinaryResourceFormats = begin
    module BinaryGenerationUtilities = begin
      val b0 : n:int -> byte
      val b1 : n:int -> byte
      val b2 : n:int -> byte
      val b3 : n:int -> byte
      val i16 : i:int32 -> byte []
      val i32 : i:int32 -> byte []
      val Padded : initialAlignment:int -> v:byte [] -> byte []
    end
    module ResFileFormat = begin
      val ResFileNode :
        dwTypeID:int32 * dwNameID:int32 * wMemFlags:int32 * wLangID:int32 *
        data:byte [] -> byte []
      val ResFileHeader : unit -> byte []
    end
    module VersionResourceFormat = begin
      val VersionInfoNode : data:byte [] -> byte []
      val VersionInfoElement :
        wType:int32 * szKey:byte [] * valueOpt:byte [] option *
        children:byte [] [] * isString:bool -> byte []
      val Version : version:AbstractIL.IL.ILVersionInfo -> byte []
      val String : string:string * value:string -> byte []
      val StringTable :
        language:string * strings:seq<string * string> -> byte []
      val StringFileInfo :
        stringTables:#seq<string * 'b> -> byte []
          when 'b :> seq<string * string>
      val VarFileInfo : vars:#seq<int32 * int32> -> byte []
      val VS_FIXEDFILEINFO :
        fileVersion:AbstractIL.IL.ILVersionInfo *
        productVersion:AbstractIL.IL.ILVersionInfo * dwFileFlagsMask:int32 *
        dwFileFlags:int32 * dwFileOS:int32 * dwFileType:int32 *
        dwFileSubtype:int32 * lwFileDate:int64 -> byte []
      val VS_VERSION_INFO :
        fixedFileInfo:(AbstractIL.IL.ILVersionInfo * AbstractIL.IL.ILVersionInfo *
                       int32 * int32 * int32 * int32 * int32 * int64) *
        stringFileInfo:seq<string * #seq<string * string>> *
        varFileInfo:seq<int32 * int32> -> byte []
      val VS_VERSION_INFO_RESOURCE :
        (AbstractIL.IL.ILVersionInfo * AbstractIL.IL.ILVersionInfo * int32 *
         int32 * int32 * int32 * int32 * int64) *
        seq<string * #seq<string * string>> * seq<int32 * int32> -> byte []
    end
    module ManifestResourceFormat = begin
      val VS_MANIFEST_RESOURCE : data:byte [] * isLibrary:bool -> byte []
    end
  end

namespace FSharp.Compiler
  module internal StaticLinking = begin
    type TypeForwarding =
      class
        new : tcImports:CompilerImports.TcImports -> TypeForwarding
        member
          TypeForwardILTypeRef : tref:AbstractIL.IL.ILTypeRef ->
                                   AbstractIL.IL.ILTypeRef
      end
    val debugStaticLinking : bool
    val StaticLinkILModules :
      tcConfig:CompilerConfig.TcConfig * ilGlobals:AbstractIL.IL.ILGlobals *
      tcImports:CompilerImports.TcImports *
      ilxMainModule:AbstractIL.IL.ILModuleDef *
      dependentILModules:(TypedTree.CcuThunk option * AbstractIL.IL.ILModuleDef) list ->
        AbstractIL.IL.ILModuleDef *
        (AbstractIL.IL.ILScopeRef -> AbstractIL.IL.ILScopeRef)
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type Node =
      { name: string
        data: AbstractIL.IL.ILModuleDef
        ccu: TypedTree.CcuThunk option
        refs: AbstractIL.IL.ILReferences
        mutable edges: Node list
        mutable visited: bool }
    val FindDependentILModulesForStaticLinking :
      ctok:AbstractIL.Internal.Library.CompilationThreadToken *
      tcConfig:CompilerConfig.TcConfig * tcImports:CompilerImports.TcImports *
      ilGlobals:AbstractIL.IL.ILGlobals *
      ilxMainModule:AbstractIL.IL.ILModuleDef ->
        (TypedTree.CcuThunk option * AbstractIL.IL.ILModuleDef) list
    val FindProviderGeneratedILModules :
      ctok:AbstractIL.Internal.Library.CompilationThreadToken *
      tcImports:CompilerImports.TcImports *
      providerGeneratedAssemblies:(CompilerImports.ImportedBinary * 'a) list ->
        ((TypedTree.CcuThunk option * AbstractIL.IL.ILScopeRef *
          AbstractIL.IL.ILModuleDef) * (string * 'a)) list
    val StaticLink :
      ctok:AbstractIL.Internal.Library.CompilationThreadToken *
      tcConfig:CompilerConfig.TcConfig * tcImports:CompilerImports.TcImports *
      ilGlobals:AbstractIL.IL.ILGlobals ->
        (AbstractIL.IL.ILModuleDef -> AbstractIL.IL.ILModuleDef)
  end

namespace FSharp.Compiler
  module internal CreateILModule = begin
    module AttributeHelpers = begin
      val TryFindStringAttribute :
        g:TcGlobals.TcGlobals ->
          attrib:string -> attribs:TypedTree.Attribs -> string option
      val TryFindIntAttribute :
        g:TcGlobals.TcGlobals ->
          attrib:string -> attribs:TypedTree.Attribs -> int32 option
      val TryFindBoolAttribute :
        g:TcGlobals.TcGlobals ->
          attrib:string -> attribs:TypedTree.Attribs -> bool option
      val ( |ILVersion|_| ) :
        versionString:string -> AbstractIL.IL.ILVersionInfo option
    end
    type StrongNameSigningInfo =
      | StrongNameSigningInfo of
        delaysign: bool * publicsign: bool * signer: string option *
        container: string option
    val ValidateKeySigningAttributes :
      tcConfig:CompilerConfig.TcConfig * tcGlobals:TcGlobals.TcGlobals *
      CheckDeclarations.TopAttribs -> StrongNameSigningInfo
    val GetStrongNameSigner :
      signingInfo:StrongNameSigningInfo ->
        AbstractIL.Internal.StrongNameSign.ILStrongNameSigner option
    module MainModuleBuilder = begin
      val injectedCompatTypes : Set<string>
      val typesForwardedToMscorlib : Set<string>
      val typesForwardedToSystemNumerics : Set<string>
      val createMscorlibExportList :
        tcGlobals:TcGlobals.TcGlobals ->
          AbstractIL.IL.ILExportedTypeOrForwarder list
      val createSystemNumericsExportList :
        tcConfig:CompilerConfig.TcConfig ->
          tcImports:CompilerImports.TcImports ->
            AbstractIL.IL.ILExportedTypeOrForwarder list
      val fileVersion :
        findStringAttr:(string -> string option) ->
          assemblyVersion:AbstractIL.IL.ILVersionInfo ->
            AbstractIL.IL.ILVersionInfo
      val productVersion :
        findStringAttr:(string -> string option) ->
          fileVersion:AbstractIL.IL.ILVersionInfo -> string
      val productVersionToILVersionInfo : string -> AbstractIL.IL.ILVersionInfo
      val CreateMainModule :
        ctok:AbstractIL.Internal.Library.CompilationThreadToken *
        tcConfig:CompilerConfig.TcConfig * tcGlobals:TcGlobals.TcGlobals *
        tcImports:CompilerImports.TcImports * pdbfile:'t option *
        assemblyName:string * outfile:string *
        topAttrs:CheckDeclarations.TopAttribs *
        sigDataAttributes:AbstractIL.IL.ILAttribute list *
        sigDataResources:AbstractIL.IL.ILResource list *
        optDataResources:AbstractIL.IL.ILResource list *
        codegenResults:IlxGen.IlxGenResults *
        assemVerFromAttrib:AbstractIL.IL.ILVersionInfo option *
        metadataVersion:string * secDecls:AbstractIL.IL.ILSecurityDecls ->
          AbstractIL.IL.ILModuleDef
    end
  end

namespace FSharp.Compiler
  module internal Driver = begin
    [<AbstractClassAttribute ()>]
    type ErrorLoggerUpToMaxErrors =
      class
        inherit ErrorLogger.ErrorLogger
        new : tcConfigB:CompilerConfig.TcConfigBuilder *
              exiter:ErrorLogger.Exiter * nameForDebugging:string ->
                ErrorLoggerUpToMaxErrors
        override
          DiagnosticSink : err:ErrorLogger.PhasedDiagnostic * isError:bool ->
                             unit
        abstract member
          HandleIssue : tcConfigB:CompilerConfig.TcConfigBuilder *
                        error:ErrorLogger.PhasedDiagnostic * isError:bool ->
                          unit
        abstract member HandleTooManyErrors : text:string -> unit
        override ErrorCount : int
      end
    val ConsoleErrorLoggerUpToMaxErrors :
      tcConfigB:CompilerConfig.TcConfigBuilder * exiter:ErrorLogger.Exiter ->
        ErrorLogger.ErrorLogger
    type DelayAndForwardErrorLogger =
      class
        inherit ErrorLogger.CapturingErrorLogger
        new : exiter:ErrorLogger.Exiter *
              errorLoggerProvider:ErrorLoggerProvider ->
                DelayAndForwardErrorLogger
        member
          ForwardDelayedDiagnostics : tcConfigB:CompilerConfig.TcConfigBuilder ->
                                        unit
      end
    [<AbstractClassAttribute ()>]
    and ErrorLoggerProvider =
      class
        new : unit -> ErrorLoggerProvider
        member
          CreateDelayAndForwardLogger : exiter:ErrorLogger.Exiter ->
                                          DelayAndForwardErrorLogger
        abstract member
          CreateErrorLoggerUpToMaxErrors : tcConfigBuilder:CompilerConfig.TcConfigBuilder *
                                           exiter:ErrorLogger.Exiter ->
                                             ErrorLogger.ErrorLogger
      end
    type InProcErrorLoggerProvider =
      class
        new : unit -> InProcErrorLoggerProvider
        member CapturedErrors : CompilerDiagnostics.Diagnostic []
        member CapturedWarnings : CompilerDiagnostics.Diagnostic []
        member Provider : ErrorLoggerProvider
      end
    type ConsoleLoggerProvider =
      class
        inherit ErrorLoggerProvider
        new : unit -> ConsoleLoggerProvider
        override
          CreateErrorLoggerUpToMaxErrors : tcConfigBuilder:CompilerConfig.TcConfigBuilder *
                                           exiter:ErrorLogger.Exiter ->
                                             ErrorLogger.ErrorLogger
      end
    val AbortOnError :
      errorLogger:ErrorLogger.ErrorLogger * exiter:ErrorLogger.Exiter -> unit
    val TypeCheck :
      ctok:AbstractIL.Internal.Library.CompilationThreadToken *
      tcConfig:CompilerConfig.TcConfig * tcImports:CompilerImports.TcImports *
      tcGlobals:TcGlobals.TcGlobals * errorLogger:ErrorLogger.ErrorLogger *
      assemblyName:string * niceNameGen:CompilerGlobalState.NiceNameGenerator *
      tcEnv0:CheckExpressions.TcEnv * inputs:SyntaxTree.ParsedInput list *
      exiter:ErrorLogger.Exiter ->
        ParseAndCheckInputs.TcState * CheckDeclarations.TopAttribs *
        TypedTree.TypedImplFile list * CheckExpressions.TcEnv
    val AdjustForScriptCompile :
      ctok:AbstractIL.Internal.Library.CompilationThreadToken *
      tcConfigB:CompilerConfig.TcConfigBuilder *
      commandLineSourceFiles:string list *
      lexResourceManager:Lexhelp.LexResourceManager *
      dependencyProvider:Microsoft.DotNet.DependencyManager.DependencyProvider ->
        string list
    val SetProcessThreadLocals :
      tcConfigB:CompilerConfig.TcConfigBuilder -> unit
    val ProcessCommandLineFlags :
      tcConfigB:CompilerConfig.TcConfigBuilder * lcidFromCodePage:int option *
      argv:string [] -> string list
    val EncodeSignatureData :
      tcConfig:CompilerConfig.TcConfig * tcGlobals:TcGlobals.TcGlobals *
      exportRemapping:TypedTreeOps.Remap * generatedCcu:TypedTree.CcuThunk *
      outfile:string * isIncrementalBuild:bool ->
        AbstractIL.IL.ILAttribute list * AbstractIL.IL.ILResource list
    val EncodeOptimizationData :
      tcGlobals:TcGlobals.TcGlobals * tcConfig:CompilerConfig.TcConfig *
      outfile:string * exportRemapping:TypedTreeOps.Remap *
      data:(TypedTree.CcuThunk * #Optimizer.CcuOptimizationInfo) *
      isIncrementalBuild:bool -> AbstractIL.IL.ILResource list
    module InterfaceFileWriter = begin
      val BuildInitialDisplayEnvForSigFileGeneration :
        tcGlobals:TcGlobals.TcGlobals -> TypedTreeOps.DisplayEnv
      val WriteInterfaceFile :
        tcGlobals:TcGlobals.TcGlobals * tcConfig:CompilerConfig.TcConfig *
        infoReader:InfoReader.InfoReader *
        declaredImpls:seq<TypedTree.TypedImplFile> -> unit
    end
    val CopyFSharpCore :
      outFile:string * referencedDlls:CompilerConfig.AssemblyReference list ->
        unit
    val TryFindVersionAttribute :
      g:TcGlobals.TcGlobals ->
        attrib:string ->
          attribName:System.String ->
            attribs:TypedTree.Attribs ->
              deterministic:bool -> AbstractIL.IL.ILVersionInfo option
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type Args<'T> = | Args of 'T
    val main1 :
      ctok:'a * argv:string [] *
      legacyReferenceResolver:ReferenceResolver.Resolver *
      bannerAlreadyPrinted:bool *
      reduceMemoryUsage:AbstractIL.ILBinaryReader.ReduceMemoryFlag *
      defaultCopyFSharpCore:CompilerConfig.CopyFSharpCoreFlag *
      exiter:ErrorLogger.Exiter * errorLoggerProvider:ErrorLoggerProvider *
      disposables:Lib.DisposablesTracker ->
        Args<'a * TcGlobals.TcGlobals * CompilerImports.TcImports *
             CompilerImports.TcImports * TypedTree.CcuThunk *
             TypedTree.TypedImplFile list * CheckDeclarations.TopAttribs *
             CompilerConfig.TcConfig * string * string option * string *
             ErrorLogger.ErrorLogger * ErrorLogger.Exiter>
        when 'a :> AbstractIL.Internal.Library.CompilationThreadToken
    val main1OfAst :
      ctok:'a * legacyReferenceResolver:ReferenceResolver.Resolver *
      reduceMemoryUsage:AbstractIL.ILBinaryReader.ReduceMemoryFlag *
      assemblyName:string * target:CompilerConfig.CompilerTarget * outfile:'b *
      pdbFile:'c option * dllReferences:string list * noframework:bool *
      exiter:ErrorLogger.Exiter * errorLoggerProvider:ErrorLoggerProvider *
      disposables:Lib.DisposablesTracker * inputs:SyntaxTree.ParsedInput list ->
        Args<'a * TcGlobals.TcGlobals * CompilerImports.TcImports *
             CompilerImports.TcImports * TypedTree.CcuThunk *
             TypedTree.TypedImplFile list * CheckDeclarations.TopAttribs *
             CompilerConfig.TcConfig * 'b * 'c option * string *
             ErrorLogger.ErrorLogger * ErrorLogger.Exiter>
        when 'a :> AbstractIL.Internal.Library.CompilationThreadToken
    val main2 :
      Args<'a * 'b * CompilerImports.TcImports * 'c * TypedTree.CcuThunk * 'd *
           CheckDeclarations.TopAttribs * CompilerConfig.TcConfig * 'e * 'f *
           string * #ErrorLogger.ErrorLogger * ErrorLogger.Exiter> ->
        Args<'a * CompilerConfig.TcConfig * CompilerImports.TcImports * 'c * 'b *
             ErrorLogger.ErrorLogger * TypedTree.CcuThunk * 'e * 'd *
             CheckDeclarations.TopAttribs * 'f * string *
             AbstractIL.IL.ILVersionInfo option *
             CreateILModule.StrongNameSigningInfo * ErrorLogger.Exiter>
        when 'b :> TcGlobals.TcGlobals and 'd :> seq<TypedTree.TypedImplFile>
    val main3 :
      Args<'a * CompilerConfig.TcConfig * CompilerImports.TcImports *
           CompilerImports.TcImports * 'b * ErrorLogger.ErrorLogger *
           TypedTree.CcuThunk * string * TypedTree.TypedImplFile list * 'c * 'd *
           'e * 'f * 'g * ErrorLogger.Exiter> ->
        Args<'a * CompilerConfig.TcConfig * CompilerImports.TcImports * 'b *
             ErrorLogger.ErrorLogger * TypedTree.CcuThunk * string *
             TypedTree.TypedAssemblyAfterOptimization * 'c * 'd * 'e *
             AbstractIL.IL.ILAttribute list * AbstractIL.IL.ILResource list *
             AbstractIL.IL.ILResource list * 'f * 'g * string *
             ErrorLogger.Exiter> when 'b :> TcGlobals.TcGlobals
    val main4 :
      tcImportsCapture:(CompilerImports.TcImports -> unit) option *
      dynamicAssemblyCreator:'a option ->
        Args<'b * CompilerConfig.TcConfig * CompilerImports.TcImports *
             TcGlobals.TcGlobals * 'c * TypedTree.CcuThunk * string *
             TypedTree.TypedAssemblyAfterOptimization *
             CheckDeclarations.TopAttribs * 'd option * string *
             AbstractIL.IL.ILAttribute list * AbstractIL.IL.ILResource list *
             AbstractIL.IL.ILResource list * AbstractIL.IL.ILVersionInfo option *
             'e * string * ErrorLogger.Exiter> ->
          Args<'b * CompilerConfig.TcConfig * CompilerImports.TcImports *
               TcGlobals.TcGlobals * 'c *
               (AbstractIL.IL.ILModuleDef -> AbstractIL.IL.ILModuleDef) * string *
               'd option * AbstractIL.IL.ILModuleDef * 'e * ErrorLogger.Exiter>
        when 'b :> AbstractIL.Internal.Library.CompilationThreadToken and
             'c :> ErrorLogger.ErrorLogger
    val main5 :
      Args<'a * 'b * 'c * 'd * ErrorLogger.ErrorLogger * ('e -> 'f) * 'g * 'h *
           'e * 'i * ErrorLogger.Exiter> ->
        Args<'a * 'b * 'c * 'd * ErrorLogger.ErrorLogger * 'f * 'g * 'h * 'i *
             ErrorLogger.Exiter>
    val main6 :
      dynamicAssemblyCreator:(TcGlobals.TcGlobals * string *
                              AbstractIL.IL.ILModuleDef -> unit) option ->
        Args<#AbstractIL.Internal.Library.CompilationThreadToken *
             CompilerConfig.TcConfig * CompilerImports.TcImports *
             TcGlobals.TcGlobals * ErrorLogger.ErrorLogger *
             AbstractIL.IL.ILModuleDef * string * string option *
             CreateILModule.StrongNameSigningInfo * ErrorLogger.Exiter> -> unit
    val mainCompile :
      ctok:AbstractIL.Internal.Library.CompilationThreadToken * argv:string [] *
      legacyReferenceResolver:ReferenceResolver.Resolver *
      bannerAlreadyPrinted:bool *
      reduceMemoryUsage:AbstractIL.ILBinaryReader.ReduceMemoryFlag *
      defaultCopyFSharpCore:CompilerConfig.CopyFSharpCoreFlag *
      exiter:ErrorLogger.Exiter * loggerProvider:ErrorLoggerProvider *
      tcImportsCapture:(CompilerImports.TcImports -> unit) option *
      dynamicAssemblyCreator:(TcGlobals.TcGlobals * string *
                              AbstractIL.IL.ILModuleDef -> unit) option -> unit
    val compileOfAst :
      ctok:AbstractIL.Internal.Library.CompilationThreadToken *
      legacyReferenceResolver:ReferenceResolver.Resolver *
      reduceMemoryUsage:AbstractIL.ILBinaryReader.ReduceMemoryFlag *
      assemblyName:string * target:CompilerConfig.CompilerTarget *
      targetDll:string * targetPdb:string option * dependencies:string list *
      noframework:bool * exiter:ErrorLogger.Exiter *
      loggerProvider:ErrorLoggerProvider * inputs:SyntaxTree.ParsedInput list *
      tcImportsCapture:(CompilerImports.TcImports -> unit) option *
      dynamicAssemblyCreator:(TcGlobals.TcGlobals * string *
                              AbstractIL.IL.ILModuleDef -> unit) option -> unit
  end

namespace FSharp.Compiler.SourceCodeServices
  module EnvMisc2 = begin
    val maxMembers : int
  end
  [<RequireQualifiedAccessAttribute ()>]
  type FSharpErrorSeverity =
    | Warning
    | Error
  module FSharpErrorInfo = begin
    [<LiteralAttribute ()>]
    val ObsoleteMessage : string
    = "Use FSharpErrorInfo.Range. This API will be removed in a future update."
  end
  [<ClassAttribute ()>]
  type FSharpErrorInfo =
    class
      new : m:Range.range * severity:FSharpErrorSeverity * message:string *
            subcategory:string * errorNum:int -> FSharpErrorInfo
      static member
        CreateFromException : ErrorLogger.PhasedDiagnostic * isError:bool *
                              Range.range * suggestNames:bool -> FSharpErrorInfo
      static member
        CreateFromExceptionAndAdjustEof : ErrorLogger.PhasedDiagnostic *
                                          isError:bool * Range.range *
                                          lastPosInFile:(int * int) *
                                          suggestNames:bool -> FSharpErrorInfo
      override ToString : unit -> string
      member WithEnd : newEnd:Range.pos -> FSharpErrorInfo
      member WithStart : newStart:Range.pos -> FSharpErrorInfo
      [<System.Obsolete
        ("Use FSharpErrorInfo.Range. This API will be removed in a future update.")>]
      member End : Range.pos
      [<System.Obsolete
        ("Use FSharpErrorInfo.Range. This API will be removed in a future update.")>]
      member EndColumn : int
      [<System.Obsolete
        ("Use FSharpErrorInfo.Range. This API will be removed in a future update.")>]
      member EndLine : Range.Line0
      [<System.Obsolete
        ("Use FSharpErrorInfo.Range. This API will be removed in a future update.")>]
      member EndLineAlternate : int
      member ErrorNumber : int
      [<System.Obsolete
        ("Use FSharpErrorInfo.Range. This API will be removed in a future update.")>]
      member FileName : string
      member Message : string
      member Range : Range.range
      member Severity : FSharpErrorSeverity
      [<System.Obsolete
        ("Use FSharpErrorInfo.Range. This API will be removed in a future update.")>]
      member Start : Range.pos
      [<System.Obsolete
        ("Use FSharpErrorInfo.Range. This API will be removed in a future update.")>]
      member StartColumn : int
      [<System.Obsolete
        ("Use FSharpErrorInfo.Range. This API will be removed in a future update.")>]
      member StartLine : Range.Line0
      [<System.Obsolete
        ("Use FSharpErrorInfo.Range. This API will be removed in a future update.")>]
      member StartLineAlternate : int
      member Subcategory : string
    end
  [<SealedAttribute ()>]
  type ErrorScope =
    class
      interface System.IDisposable
      new : unit -> ErrorScope
      static member
        Protect : Range.range -> (unit -> 'a) -> (string -> 'a) -> 'a
      member TryGetFirstErrorText : unit -> string option
      member Diagnostics : FSharpErrorInfo list
      member Errors : FSharpErrorInfo list
      member FirstError : string option
      member Warnings : FSharpErrorInfo list
    end
  type internal CompilationErrorLogger =
    class
      inherit ErrorLogger.ErrorLogger
      new : debugName:string * options:ErrorLogger.FSharpErrorSeverityOptions ->
              CompilationErrorLogger
      override
        DiagnosticSink : exn:ErrorLogger.PhasedDiagnostic * isError:bool -> unit
      member
        GetErrors : unit ->
                      (ErrorLogger.PhasedDiagnostic * FSharpErrorSeverity) []
      override ErrorCount : int
    end
  type CompilationGlobalsScope =
    class
      interface System.IDisposable
      new : ErrorLogger.ErrorLogger * ErrorLogger.BuildPhase ->
              CompilationGlobalsScope
    end
  module ErrorHelpers = begin
    val ReportError :
      ErrorLogger.FSharpErrorSeverityOptions * allErrors:bool *
      mainInputFileName:string * fileInfo:(int * int) *
      (ErrorLogger.PhasedDiagnostic * FSharpErrorSeverity) * suggestNames:bool ->
        FSharpErrorInfo list
    val CreateErrorInfos :
      ErrorLogger.FSharpErrorSeverityOptions * allErrors:bool *
      mainInputFileName:string *
      seq<ErrorLogger.PhasedDiagnostic * FSharpErrorSeverity> *
      suggestNames:bool -> FSharpErrorInfo []
  end
  type Layout = Internal.Utilities.StructuredFormat.Layout
  [<RequireQualifiedAccessAttribute ()>]
  type FSharpXmlDoc =
    | None
    | Text of unprocessedLines: string [] * elaboratedXmlLines: string []
    | XmlDocFileSignature of string * string
  [<RequireQualifiedAccessAttribute ()>]
  type FSharpToolTipElementData<'T> =
    { MainDescription: 'T
      XmlDoc: FSharpXmlDoc
      TypeMapping: 'T list
      Remarks: 'T option
      ParamName: string option }
    with
      static member
        Create : layout:'T * xml:FSharpXmlDoc * ?typeMapping:'T list *
                 ?paramName:string * ?remarks:'T -> FSharpToolTipElementData<'T>
    end
  [<RequireQualifiedAccessAttribute ()>]
  type FSharpToolTipElement<'T> =
    | None
    | Group of FSharpToolTipElementData<'T> list
    | CompositionError of string
    with
      static member
        Single : 'T * FSharpXmlDoc * ?typeMapping:'T list * ?paramName:string *
                 ?remarks:'T -> FSharpToolTipElement<'T>
    end
  type FSharpToolTipElement = FSharpToolTipElement<string>
  type FSharpStructuredToolTipElement = FSharpToolTipElement<Layout>
  type FSharpToolTipText<'T> =
    | FSharpToolTipText of FSharpToolTipElement<'T> list
  type FSharpToolTipText = FSharpToolTipText<string>
  type FSharpStructuredToolTipText = FSharpToolTipText<Layout>
  module Tooltips = begin
    val ToFSharpToolTipElement :
      FSharpToolTipElement<Layout> -> FSharpToolTipElement<string>
    val ToFSharpToolTipText :
      FSharpToolTipText<Layout> -> FSharpToolTipText<string>
  end
  [<RequireQualifiedAccessAttribute ()>]
  type CompletionItemKind =
    | Field
    | Property
    | Method of isExtension: bool
    | Event
    | Argument
    | CustomOperation
    | Other
  type UnresolvedSymbol =
    { FullName: string
      DisplayName: string
      Namespace: string [] }
  type CompletionItem =
    { ItemWithInst: NameResolution.ItemWithInst
      Kind: CompletionItemKind
      IsOwnMember: bool
      MinorPriority: int
      Type: TypedTree.TyconRef option
      Unresolved: UnresolvedSymbol option }
    with
      member Item : NameResolution.Item
    end
  module internal SymbolHelpers = begin
    val OutputFullName :
      isListItem:bool ->
        ppF:('a -> 'b option) ->
          fnF:('a -> Internal.Utilities.StructuredFormat.Layout) ->
            r:'a -> Internal.Utilities.StructuredFormat.Layout
    val rangeOfValRef :
      preferFlag:bool option -> vref:TypedTree.ValRef -> Range.range
    val rangeOfEntityRef :
      preferFlag:bool option -> eref:TypedTree.EntityRef -> Range.range
    val rangeOfPropInfo :
      preferFlag:bool option -> pinfo:Infos.PropInfo -> Range.range option
    val rangeOfMethInfo :
      g:TcGlobals.TcGlobals ->
        preferFlag:bool option -> minfo:Infos.MethInfo -> Range.range option
    val rangeOfEventInfo :
      preferFlag:bool option -> einfo:Infos.EventInfo -> Range.range option
    val rangeOfUnionCaseInfo :
      preferFlag:bool option -> ucinfo:Infos.UnionCaseInfo -> Range.range
    val rangeOfRecdField :
      preferFlag:bool option -> rField:TypedTree.RecdField -> Range.range
    val rangeOfRecdFieldInfo :
      preferFlag:bool option -> rfinfo:Infos.RecdFieldInfo -> Range.range
    val rangeOfItem :
      TcGlobals.TcGlobals ->
        bool option -> NameResolution.Item -> Range.range option
    val computeCcuOfTyconRef :
      tcref:TypedTree.TyconRef -> TypedTree.CcuThunk option
    val ccuOfMethInfo :
      g:TcGlobals.TcGlobals -> minfo:Infos.MethInfo -> TypedTree.CcuThunk option
    val ccuOfItem :
      TcGlobals.TcGlobals -> NameResolution.Item -> TypedTree.CcuThunk option
    val fileNameOfItem :
      TcGlobals.TcGlobals ->
        string option -> Range.range -> NameResolution.Item -> string
    val cutFileName : s:string -> string
    val libFileOfEntityRef : x:TypedTree.EntityRef -> string option
    val ParamNameAndTypesOfUnaryCustomOperation :
      TcGlobals.TcGlobals -> Infos.MethInfo -> Infos.ParamNameAndType list
    val metaInfoOfEntityRef :
      infoReader:InfoReader.InfoReader ->
        m:Range.range ->
          tcref:TypedTree.EntityRef ->
            (string option * TypedTree.Typars * Infos.ILTypeInfo) option
    val mkXmlComment : thing:(string option * string) option -> FSharpXmlDoc
    val GetXmlDocSigOfEntityRef :
      InfoReader.InfoReader ->
        Range.range -> TypedTree.EntityRef -> (string option * string) option
    val GetXmlDocSigOfScopedValRef :
      TcGlobals.TcGlobals ->
        TypedTree.TyconRef ->
          TypedTree.ValRef -> (string option * string) option
    val GetXmlDocSigOfRecdFieldInfo :
      Infos.RecdFieldInfo -> (string option * string) option
    val GetXmlDocSigOfUnionCaseInfo :
      Infos.UnionCaseInfo -> (string option * string) option
    val GetXmlDocSigOfMethInfo :
      InfoReader.InfoReader ->
        Range.range -> Infos.MethInfo -> (string option * string) option
    val GetXmlDocSigOfValRef :
      TcGlobals.TcGlobals -> TypedTree.ValRef -> (string option * string) option
    val GetXmlDocSigOfProp :
      InfoReader.InfoReader ->
        Range.range -> Infos.PropInfo -> (string option * string) option
    val GetXmlDocSigOfEvent :
      InfoReader.InfoReader ->
        Range.range -> Infos.EventInfo -> (string option * string) option
    val GetXmlDocSigOfILFieldInfo :
      InfoReader.InfoReader ->
        Range.range -> Infos.ILFieldInfo -> (string option * string) option
    val GetXmlDocHelpSigOfItemForLookup :
      infoReader:InfoReader.InfoReader ->
        m:Range.range -> d:NameResolution.Item -> FSharpXmlDoc
    val GetXmlCommentForItemAux :
      xmlDoc:XmlDoc.XmlDoc option ->
        infoReader:InfoReader.InfoReader ->
          m:Range.range -> d:NameResolution.Item -> FSharpXmlDoc
    val mutable ToolTipFault : string option
    val GetXmlCommentForMethInfoItem :
      infoReader:InfoReader.InfoReader ->
        m:Range.range ->
          d:NameResolution.Item -> minfo:Infos.MethInfo -> FSharpXmlDoc
    val FormatTyparMapping :
      denv:TypedTreeOps.DisplayEnv ->
        prettyTyparInst:TypedTreeOps.TyparInst ->
          Internal.Utilities.StructuredFormat.Layout list
    val FormatOverloadsToList :
      infoReader:InfoReader.InfoReader ->
        m:Range.range ->
          denv:TypedTreeOps.DisplayEnv ->
            item:NameResolution.ItemWithInst ->
              minfos:seq<Infos.MethInfo> -> FSharpStructuredToolTipElement
    val pubpathOfValRef : v:TypedTree.ValRef -> TypedTree.ValPublicPath option
    val pubpathOfTyconRef : x:TypedTree.TyconRef -> TypedTree.PublicPath option
    val ( |ItemWhereTypIsPreferred|_| ) :
      item:NameResolution.Item -> TypedTree.TType option
    val ItemDisplayPartialEquality :
      g:TcGlobals.TcGlobals ->
        AbstractIL.Internal.Library.IPartialEqualityComparer<NameResolution.Item>
    val CompletionItemDisplayPartialEquality :
      g:TcGlobals.TcGlobals ->
        AbstractIL.Internal.Library.IPartialEqualityComparer<CompletionItem>
    val ItemWithTypeDisplayPartialEquality :
      g:TcGlobals.TcGlobals ->
        AbstractIL.Internal.Library.IPartialEqualityComparer<NameResolution.Item *
                                                             'a>
    val RemoveDuplicateModuleRefs :
      modrefs:TypedTree.ModuleOrNamespaceRef list ->
        TypedTree.ModuleOrNamespaceRef list
    val RemoveDuplicateItems :
      TcGlobals.TcGlobals ->
        NameResolution.ItemWithInst list -> NameResolution.ItemWithInst list
    val RemoveDuplicateCompletionItems :
      TcGlobals.TcGlobals -> CompletionItem list -> CompletionItem list
    val IsExplicitlySuppressed :
      TcGlobals.TcGlobals -> NameResolution.Item -> bool
    val RemoveExplicitlySuppressed :
      TcGlobals.TcGlobals ->
        NameResolution.ItemWithInst list -> NameResolution.ItemWithInst list
    val RemoveExplicitlySuppressedCompletionItems :
      TcGlobals.TcGlobals -> CompletionItem list -> CompletionItem list
    val SimplerDisplayEnv : TypedTreeOps.DisplayEnv -> TypedTreeOps.DisplayEnv
    val FullNameOfItem : TcGlobals.TcGlobals -> NameResolution.Item -> string
    val GetXmlCommentForItem :
      InfoReader.InfoReader ->
        Range.range -> NameResolution.Item -> FSharpXmlDoc
    val IsAttribute : InfoReader.InfoReader -> NameResolution.Item -> bool
    val FormatItemDescriptionToToolTipElement :
      isListItem:bool ->
        infoReader:InfoReader.InfoReader ->
          m:Range.range ->
            denv:TypedTreeOps.DisplayEnv ->
              item:NameResolution.ItemWithInst -> FSharpToolTipElement<Layout>
    val ( |ItemIsProvidedType|_| ) :
      TcGlobals.TcGlobals -> NameResolution.Item -> TypedTree.TyconRef option
    val ( |ItemIsProvidedTypeWithStaticArguments|_| ) :
      Range.range ->
        TcGlobals.TcGlobals ->
          NameResolution.Item ->
            Tainted<ExtensionTyping.ProvidedParameterInfo> [] option
    val ( |ItemIsProvidedMethodWithStaticArguments|_| ) :
      item:NameResolution.Item ->
        Tainted<ExtensionTyping.ProvidedParameterInfo> [] option
    val ( |ItemIsWithStaticArguments|_| ) :
      Range.range ->
        TcGlobals.TcGlobals ->
          NameResolution.Item ->
            Tainted<ExtensionTyping.ProvidedParameterInfo> [] option
    val GetF1Keyword :
      TcGlobals.TcGlobals -> NameResolution.Item -> string option
    val FormatStructuredDescriptionOfItem :
      isDecl:bool ->
        InfoReader.InfoReader ->
          Range.range ->
            TypedTreeOps.DisplayEnv ->
              NameResolution.ItemWithInst -> FSharpToolTipElement<Layout>
    val FlattenItems :
      TcGlobals.TcGlobals ->
        Range.range -> NameResolution.Item -> NameResolution.Item list
  end

namespace FSharp.Compiler.SourceCodeServices
  type FSharpAccessibility =
    class
      new : TypedTree.Accessibility * ?isProtected:bool -> FSharpAccessibility
      override ToString : unit -> string
      member internal Contents : TypedTree.Accessibility
      member IsInternal : bool
      member IsPrivate : bool
      member IsProtected : bool
      member IsPublic : bool
    end
  and SymbolEnv =
    class
      new : TcGlobals.TcGlobals * thisCcu:TypedTree.CcuThunk *
            thisCcuTyp:TypedTree.ModuleOrNamespaceType option *
            tcImports:CompilerImports.TcImports -> SymbolEnv
      new : TcGlobals.TcGlobals * thisCcu:TypedTree.CcuThunk *
            thisCcuTyp:TypedTree.ModuleOrNamespaceType option *
            tcImports:CompilerImports.TcImports * amap:Import.ImportMap *
            infoReader:InfoReader.InfoReader -> SymbolEnv
      member amap : Import.ImportMap
      member g : TcGlobals.TcGlobals
      member infoReader : InfoReader.InfoReader
      member tcImports : CompilerImports.TcImports
      member
        tcValF : (TypedTree.ValRef -> TypedTree.ValUseFlag ->
                    TypedTree.TTypes -> Range.range ->
                    TypedTree.Expr * TypedTree.TType)
      member thisCcu : TypedTree.CcuThunk
      member thisCcuTy : TypedTree.ModuleOrNamespaceType option
    end
  and FSharpDisplayContext =
    class
      new : denv:(TcGlobals.TcGlobals -> TypedTreeOps.DisplayEnv) ->
              FSharpDisplayContext
      member Contents : g:TcGlobals.TcGlobals -> TypedTreeOps.DisplayEnv
      member WithShortTypeNames : bool -> FSharpDisplayContext
      static member Empty : FSharpDisplayContext
    end
  [<ClassAttribute ()>]
  and FSharpSymbol =
    class
      new : cenv:SymbolEnv * item:(unit -> NameResolution.Item) *
            access:(FSharpSymbol -> TypedTree.CcuThunk ->
                      AccessibilityLogic.AccessorDomain -> bool) -> FSharpSymbol
      static member
        Create : cenv:SymbolEnv * item:NameResolution.Item -> FSharpSymbol
      static member
        Create : g:TcGlobals.TcGlobals * thisCcu:TypedTree.CcuThunk *
                 thisCcuTyp:TypedTree.ModuleOrNamespaceType *
                 tcImports:CompilerImports.TcImports * item:NameResolution.Item ->
                   FSharpSymbol
      static member
        GetAccessibility : FSharpSymbol -> FSharpAccessibility option
      override Equals : other:obj -> bool
      member GetEffectivelySameAsHash : unit -> int
      override GetHashCode : unit -> int
      member IsAccessible : FSharpAccessibilityRights -> bool
      member IsEffectivelySameAs : other:FSharpSymbol -> bool
      override ToString : unit -> string
      member Assembly : FSharpAssembly
      member DeclarationLocation : Range.range option
      member DisplayName : string
      member FullName : string
      member ImplementationLocation : Range.range option
      member IsExplicitlySuppressed : bool
      member internal Item : NameResolution.Item
      member SignatureLocation : Range.range option
    end
  and FSharpEntity =
    class
      inherit FSharpSymbol
      new : SymbolEnv * TypedTree.EntityRef -> FSharpEntity
      override Equals : other:obj -> bool
      override GetHashCode : unit -> int
      override ToString : unit -> string
      member AbbreviatedType : FSharpType
      member AccessPath : string
      member Accessibility : FSharpAccessibility
      member ActivePatternCases : FSharpActivePatternCase list
      member AllCompilationPaths : string list
      member AllInterfaces : System.Collections.Generic.IList<FSharpType>
      member ArrayRank : int
      member Attributes : System.Collections.Generic.IList<FSharpAttribute>
      member BaseType : FSharpType option
      member CompiledName : string
      member DeclarationLocation : Range.range
      member DeclaredInterfaces : System.Collections.Generic.IList<FSharpType>
      member DeclaringEntity : FSharpEntity option
      member DisplayName : string
      member ElaboratedXmlDoc : System.Collections.Generic.IList<string>
      member Entity : TypedTree.EntityRef
      member FSharpDelegateSignature : FSharpDelegateSignature
      member FSharpFields : System.Collections.Generic.IList<FSharpField>
      member FullName : string
      member
        GenericParameters : System.Collections.Generic.IList<FSharpGenericParameter>
      member HasAssemblyCodeRepresentation : bool
      member HasFSharpModuleSuffix : bool
      member IsAbstractClass : bool
      member IsArrayType : bool
      member IsAttributeType : bool
      member IsByRef : bool
      member IsClass : bool
      member IsDelegate : bool
      member IsDisposableType : bool
      member IsEnum : bool
      member IsFSharp : bool
      member IsFSharpAbbreviation : bool
      member IsFSharpExceptionDeclaration : bool
      member IsFSharpModule : bool
      member IsFSharpRecord : bool
      member IsFSharpUnion : bool
      member IsInterface : bool
      member IsMeasure : bool
      member IsNamespace : bool
      member IsOpaque : bool
      member IsProvided : bool
      member IsProvidedAndErased : bool
      member IsProvidedAndGenerated : bool
      member IsStaticInstantiation : bool
      member IsUnresolved : bool
      member IsValueType : bool
      member LogicalName : string
      member
        MembersFunctionsAndValues : System.Collections.Generic.IList<FSharpMemberOrFunctionOrValue>
      [<System.Obsolete ("Renamed to MembersFunctionsAndValues")>]
      member
        MembersOrValues : System.Collections.Generic.IList<FSharpMemberOrFunctionOrValue>
      member Namespace : string option
      member NestedEntities : System.Collections.Generic.IList<FSharpEntity>
      member QualifiedName : string
      [<System.Obsolete ("Renamed to FSharpFields")>]
      member RecordFields : System.Collections.Generic.IList<FSharpField>
      member RepresentationAccessibility : FSharpAccessibility
      member
        StaticParameters : System.Collections.Generic.IList<FSharpStaticParameter>
      member TryFullName : string option
      member UnionCases : System.Collections.Generic.IList<FSharpUnionCase>
      member UsesPrefixDisplay : bool
      member XmlDoc : System.Collections.Generic.IList<string>
      member XmlDocSig : string
    end
  [<ClassAttribute ()>]
  and FSharpUnionCase =
    class
      inherit FSharpSymbol
      new : SymbolEnv * TypedTree.UnionCaseRef -> FSharpUnionCase
      override Equals : other:obj -> bool
      override GetHashCode : unit -> int
      override ToString : unit -> string
      member Accessibility : FSharpAccessibility
      member Attributes : System.Collections.Generic.IList<FSharpAttribute>
      member CompiledName : string
      member DeclarationLocation : Range.range
      member ElaboratedXmlDoc : System.Collections.Generic.IList<string>
      member HasFields : bool
      member IsUnresolved : bool
      member Name : string
      member ReturnType : FSharpType
      member UnionCaseFields : System.Collections.Generic.IList<FSharpField>
      member private V : TypedTree.UnionCaseRef
      member XmlDoc : System.Collections.Generic.IList<string>
      member XmlDocSig : string
    end
  and FSharpFieldData =
    | AnonField of
      TypedTree.AnonRecdTypeInfo * TypedTree.TTypes * int * Range.range
    | ILField of Infos.ILFieldInfo
    | RecdOrClass of TypedTree.RecdFieldRef
    | Union of TypedTree.UnionCaseRef * int
    with
      member TryDeclaringTyconRef : TypedTree.TyconRef option
      member
        TryRecdField : Choice<TypedTree.RecdField,Infos.ILFieldInfo,
                              (TypedTree.AnonRecdTypeInfo * TypedTree.TTypes *
                               int * Range.range)>
    end
  [<ClassAttribute ()>]
  and FSharpAnonRecordTypeDetails =
    class
      new : cenv:SymbolEnv * anonInfo:TypedTree.AnonRecdTypeInfo ->
              FSharpAnonRecordTypeDetails
      member Assembly : FSharpAssembly
      member CompiledName : string
      member EnclosingCompiledTypeNames : string list
      member SortedFieldNames : string []
    end
  [<ClassAttribute ()>]
  and FSharpField =
    class
      inherit FSharpSymbol
      new : SymbolEnv * TypedTree.RecdFieldRef -> FSharpField
      new : SymbolEnv * TypedTree.UnionCaseRef * int -> FSharpField
      new : cenv:SymbolEnv * d:FSharpFieldData -> FSharpField
      override Equals : other:obj -> bool
      override GetHashCode : unit -> int
      override ToString : unit -> string
      member Accessibility : FSharpAccessibility
      member
        AnonRecordFieldDetails : FSharpAnonRecordTypeDetails * FSharpType [] *
                                 int
      member DeclarationLocation : Range.range
      member DeclaringEntity : FSharpEntity option
      member DeclaringUnionCase : FSharpUnionCase option
      member ElaboratedXmlDoc : System.Collections.Generic.IList<string>
      member FieldAttributes : System.Collections.Generic.IList<FSharpAttribute>
      member FieldType : FSharpType
      member IsAnonRecordField : bool
      member IsCompilerGenerated : bool
      member IsDefaultValue : bool
      member IsLiteral : bool
      member IsMutable : bool
      member IsNameGenerated : bool
      member IsStatic : bool
      member IsUnionCaseField : bool
      member IsUnresolved : bool
      member IsVolatile : bool
      member LiteralValue : obj option
      member Name : string
      member
        PropertyAttributes : System.Collections.Generic.IList<FSharpAttribute>
      member private V : FSharpFieldData
      member XmlDoc : System.Collections.Generic.IList<string>
      member XmlDocSig : string
    end
  [<System.Obsolete ("Renamed to FSharpField")>]
  and FSharpRecordField = FSharpField
  [<ClassAttribute ()>]
  and FSharpAccessibilityRights =
    class
      new : TypedTree.CcuThunk * AccessibilityLogic.AccessorDomain ->
              FSharpAccessibilityRights
      member internal Contents : AccessibilityLogic.AccessorDomain
      member internal ThisCcu : TypedTree.CcuThunk
    end
  [<ClassAttribute ()>]
  and FSharpActivePatternCase =
    class
      inherit FSharpSymbol
      new : cenv:SymbolEnv * apinfo:PrettyNaming.ActivePatternInfo *
            ty:TypedTree.TType * n:int * valOpt:TypedTree.ValRef option *
            item:NameResolution.Item -> FSharpActivePatternCase
      member DeclarationLocation : Range.range
      member ElaboratedXmlDoc : System.Collections.Generic.IList<string>
      member Group : FSharpActivePatternGroup
      member Index : int
      member Name : string
      member XmlDoc : System.Collections.Generic.IList<string>
      member XmlDocSig : string
    end
  [<ClassAttribute ()>]
  and FSharpActivePatternGroup =
    class
      new : cenv:SymbolEnv * apinfo:PrettyNaming.ActivePatternInfo *
            ty:TypedTree.TType * valOpt:TypedTree.ValRef option ->
              FSharpActivePatternGroup
      member DeclaringEntity : FSharpEntity option
      member IsTotal : bool
      member Name : string option
      member Names : System.Collections.Generic.IList<string>
      member OverallType : FSharpType
    end
  [<ClassAttribute ()>]
  and FSharpGenericParameter =
    class
      inherit FSharpSymbol
      new : SymbolEnv * TypedTree.Typar -> FSharpGenericParameter
      override Equals : other:obj -> bool
      override GetHashCode : unit -> int
      override ToString : unit -> string
      member Attributes : System.Collections.Generic.IList<FSharpAttribute>
      member
        Constraints : System.Collections.Generic.IList<FSharpGenericParameterConstraint>
      member DeclarationLocation : Range.range
      member ElaboratedXmlDoc : System.Collections.Generic.IList<string>
      member IsCompilerGenerated : bool
      member IsMeasure : bool
      member IsSolveAtCompileTime : bool
      member Name : string
      member internal V : TypedTree.Typar
      member XmlDoc : System.Collections.Generic.IList<string>
    end
  [<ClassAttribute ()>]
  and FSharpDelegateSignature =
    class
      new : cenv:SymbolEnv * info:TypedTree.SlotSig -> FSharpDelegateSignature
      override ToString : unit -> string
      member
        DelegateArguments : System.Collections.Generic.IList<string option *
                                                             FSharpType>
      member DelegateReturnType : FSharpType
    end
  [<ClassAttribute ()>]
  and FSharpAbstractParameter =
    class
      new : cenv:SymbolEnv * info:TypedTree.SlotParam -> FSharpAbstractParameter
      member Attributes : System.Collections.Generic.IList<FSharpAttribute>
      member IsInArg : bool
      member IsOptionalArg : bool
      member IsOutArg : bool
      member Name : string option
      member Type : FSharpType
    end
  [<ClassAttribute ()>]
  and FSharpAbstractSignature =
    class
      new : SymbolEnv * TypedTree.SlotSig -> FSharpAbstractSignature
      member
        AbstractArguments : System.Collections.Generic.IList<System.Collections.Generic.IList<FSharpAbstractParameter>>
      member AbstractReturnType : FSharpType
      member DeclaringType : FSharpType
      member
        DeclaringTypeGenericParameters : System.Collections.Generic.IList<FSharpGenericParameter>
      member
        MethodGenericParameters : System.Collections.Generic.IList<FSharpGenericParameter>
      member Name : string
    end
  [<ClassAttribute (); NoEqualityAttribute (); NoComparisonAttribute ()>]
  and FSharpGenericParameterMemberConstraint =
    class
      new : cenv:SymbolEnv * info:TypedTree.TraitConstraintInfo ->
              FSharpGenericParameterMemberConstraint
      override ToString : unit -> string
      member MemberArgumentTypes : System.Collections.Generic.IList<FSharpType>
      member MemberIsStatic : bool
      member MemberName : string
      member MemberReturnType : FSharpType
      member MemberSources : System.Collections.Generic.IList<FSharpType>
    end
  [<ClassAttribute (); NoEqualityAttribute (); NoComparisonAttribute ()>]
  and FSharpGenericParameterDelegateConstraint =
    class
      new : cenv:SymbolEnv * tupledArgTy:TypedTree.TType * rty:TypedTree.TType ->
              FSharpGenericParameterDelegateConstraint
      override ToString : unit -> string
      member DelegateReturnType : FSharpType
      member DelegateTupledArgumentType : FSharpType
    end
  [<ClassAttribute (); NoEqualityAttribute (); NoComparisonAttribute ()>]
  and FSharpGenericParameterDefaultsToConstraint =
    class
      new : cenv:SymbolEnv * pri:int * ty:TypedTree.TType ->
              FSharpGenericParameterDefaultsToConstraint
      override ToString : unit -> string
      member DefaultsToPriority : int
      member DefaultsToTarget : FSharpType
    end
  [<ClassAttribute (); NoEqualityAttribute (); NoComparisonAttribute ()>]
  and FSharpGenericParameterConstraint =
    class
      new : cenv:SymbolEnv * cx:TypedTree.TyparConstraint ->
              FSharpGenericParameterConstraint
      override ToString : unit -> string
      member CoercesToTarget : FSharpType
      member
        DefaultsToConstraintData : FSharpGenericParameterDefaultsToConstraint
      member DelegateConstraintData : FSharpGenericParameterDelegateConstraint
      member EnumConstraintTarget : FSharpType
      member IsCoercesToConstraint : bool
      member IsComparisonConstraint : bool
      member IsDefaultsToConstraint : bool
      member IsDelegateConstraint : bool
      member IsEnumConstraint : bool
      member IsEqualityConstraint : bool
      member IsMemberConstraint : bool
      member IsNonNullableValueTypeConstraint : bool
      member IsReferenceTypeConstraint : bool
      member IsRequiresDefaultConstructorConstraint : bool
      member IsSimpleChoiceConstraint : bool
      member IsSupportsNullConstraint : bool
      member IsUnmanagedConstraint : bool
      member MemberConstraintData : FSharpGenericParameterMemberConstraint
      member SimpleChoices : System.Collections.Generic.IList<FSharpType>
    end
  [<RequireQualifiedAccessAttribute ()>]
  and FSharpInlineAnnotation =
    | PseudoValue
    | AlwaysInline
    | OptionalInline
    | NeverInline
    | AggressiveInline
  and FSharpMemberOrValData =
    | E of Infos.EventInfo
    | P of Infos.PropInfo
    | M of Infos.MethInfo
    | C of Infos.MethInfo
    | V of TypedTree.ValRef
  and FSharpMemberOrVal = FSharpMemberOrFunctionOrValue
  and FSharpMemberFunctionOrValue = FSharpMemberOrFunctionOrValue
  [<ClassAttribute ()>]
  and FSharpMemberOrFunctionOrValue =
    class
      inherit FSharpSymbol
      new : SymbolEnv * Infos.MethInfo -> FSharpMemberOrFunctionOrValue
      new : SymbolEnv * TypedTree.ValRef -> FSharpMemberOrFunctionOrValue
      new : cenv:SymbolEnv * d:FSharpMemberOrValData * item:NameResolution.Item ->
              FSharpMemberOrFunctionOrValue
      override Equals : other:obj -> bool
      member
        FormatLayout : context:FSharpDisplayContext ->
                         Internal.Utilities.StructuredFormat.Layout
      override GetHashCode : unit -> int
      member
        GetWitnessPassingInfo : unit ->
                                  (string *
                                   System.Collections.Generic.IList<FSharpParameter>) option
      member
        Overloads : bool ->
                      System.Collections.Generic.IList<FSharpMemberOrFunctionOrValue> option
      override ToString : unit -> string
      member Accessibility : FSharpAccessibility
      member ApparentEnclosingEntity : FSharpEntity
      member Attributes : System.Collections.Generic.IList<FSharpAttribute>
      member CompiledName : string
      member
        CurriedParameterGroups : System.Collections.Generic.IList<System.Collections.Generic.IList<FSharpParameter>>
      member Data : FSharpMemberOrValData
      member DeclarationLocation : Range.range
      member DeclarationLocationOpt : Range.range option
      member DeclaringEntity : FSharpEntity option
      member DisplayName : string
      member ElaboratedXmlDoc : System.Collections.Generic.IList<string>
      member EventAddMethod : FSharpMemberOrFunctionOrValue
      member EventDelegateType : FSharpType
      member EventForFSharpProperty : FSharpMemberOrFunctionOrValue option
      member EventIsStandard : bool
      member EventRemoveMethod : FSharpMemberOrFunctionOrValue
      member FullType : FSharpType
      member
        GenericParameters : System.Collections.Generic.IList<FSharpGenericParameter>
      member GetterMethod : FSharpMemberOrFunctionOrValue
      member HasGetterMethod : bool
      member HasSetterMethod : bool
      member
        ImplementedAbstractSignatures : System.Collections.Generic.IList<FSharpAbstractSignature>
      member InlineAnnotation : FSharpInlineAnnotation
      member IsActivePattern : bool
      member IsBaseValue : bool
      member IsCompilerGenerated : bool
      member IsConstructor : bool
      member IsConstructorThisValue : bool
      member IsDispatchSlot : bool
      member IsEvent : bool
      member IsEventAddMethod : bool
      member IsEventRemoveMethod : bool
      member IsExplicitInterfaceImplementation : bool
      member IsExtensionMember : bool
      [<System.Obsolete
        ("Renamed to IsPropertyGetterMethod, which returns 'true' only for method symbols, not for property symbols")>]
      member IsGetterMethod : bool
      member IsImplicitConstructor : bool
      member IsInstanceMember : bool
      member IsInstanceMemberInCompiledCode : bool
      member IsMember : bool
      member IsMemberThisValue : bool
      member IsModuleValueOrMember : bool
      member IsMutable : bool
      member IsOverrideOrExplicitInterfaceImplementation : bool
      [<System.Obsolete
        ("Renamed to IsOverrideOrExplicitInterfaceImplementation")>]
      member IsOverrideOrExplicitMember : bool
      member IsProperty : bool
      member IsPropertyGetterMethod : bool
      member IsPropertySetterMethod : bool
      [<System.Obsolete
        ("Renamed to IsPropertySetterMethod, which returns 'true' only for method symbols, not for property symbols")>]
      member IsSetterMethod : bool
      member IsTypeFunction : bool
      member IsUnresolved : bool
      member IsValCompiledAsMethod : bool
      member IsValue : bool
      member LiteralValue : obj option
      member LogicalName : string
      member ReturnParameter : FSharpParameter
      member SetterMethod : FSharpMemberOrFunctionOrValue
      member XmlDoc : System.Collections.Generic.IList<string>
      member XmlDocSig : string
    end
  [<ClassAttribute ()>]
  and FSharpType =
    class
      new : g:TcGlobals.TcGlobals * thisCcu:TypedTree.CcuThunk *
            thisCcuTyp:TypedTree.ModuleOrNamespaceType *
            tcImports:CompilerImports.TcImports * ty:TypedTree.TType ->
              FSharpType
      new : SymbolEnv * ty:TypedTree.TType -> FSharpType
      static member
        Prettify : parameters:System.Collections.Generic.IList<System.Collections.Generic.IList<FSharpParameter>> ->
                     System.Collections.Generic.IList<System.Collections.Generic.IList<FSharpParameter>>
      static member
        Prettify : parameters:System.Collections.Generic.IList<FSharpParameter> ->
                     System.Collections.Generic.IList<FSharpParameter>
      static member Prettify : parameter:FSharpParameter -> FSharpParameter
      static member
        Prettify : types:System.Collections.Generic.IList<FSharpType> ->
                     System.Collections.Generic.IList<FSharpType>
      static member Prettify : ty:FSharpType -> FSharpType
      static member
        Prettify : parameters:System.Collections.Generic.IList<System.Collections.Generic.IList<FSharpParameter>> *
                   returnParameter:FSharpParameter ->
                     System.Collections.Generic.IList<System.Collections.Generic.IList<FSharpParameter>> *
                     FSharpParameter
      member private AdjustType : t:TypedTree.TType -> FSharpType
      override Equals : other:obj -> bool
      member Format : context:FSharpDisplayContext -> string
      member
        FormatLayout : context:FSharpDisplayContext ->
                         Internal.Utilities.StructuredFormat.Layout
      override GetHashCode : unit -> int
      member
        Instantiate : (FSharpGenericParameter * FSharpType) list -> FSharpType
      override ToString : unit -> string
      member AbbreviatedType : FSharpType
      member AllInterfaces : System.Collections.Generic.IList<FSharpType>
      member AnonRecordTypeDetails : FSharpAnonRecordTypeDetails
      member BaseType : FSharpType option
      member GenericArguments : System.Collections.Generic.IList<FSharpType>
      member GenericParameter : FSharpGenericParameter
      member HasTypeDefinition : bool
      member IsAbbreviation : bool
      member IsAnonRecordType : bool
      member IsFunctionType : bool
      member IsGenericParameter : bool
      [<System.Obsolete ("Renamed to HasTypeDefinition")>]
      member IsNamedType : bool
      member IsStructTupleType : bool
      member IsTupleType : bool
      member IsUnresolved : bool
      [<System.Obsolete ("Renamed to TypeDefinition")>]
      member NamedEntity : FSharpEntity
      member TypeDefinition : FSharpEntity
      member private V : TypedTree.TType
      member private cenv : SymbolEnv
    end
  [<ClassAttribute ()>]
  and FSharpAttribute =
    class
      new : cenv:SymbolEnv * attrib:AttributeChecking.AttribInfo ->
              FSharpAttribute
      member Format : context:FSharpDisplayContext -> string
      override ToString : unit -> string
      member AttributeType : FSharpEntity
      member
        ConstructorArguments : System.Collections.Generic.IList<FSharpType * obj>
      member IsUnresolved : bool
      member
        NamedArguments : System.Collections.Generic.IList<FSharpType * string *
                                                          bool * obj>
      member Range : Range.range
    end
  [<ClassAttribute ()>]
  and FSharpStaticParameter =
    class
      inherit FSharpSymbol
      new : cenv:SymbolEnv * sp:Tainted<ExtensionTyping.ProvidedParameterInfo> *
            m:Range.range -> FSharpStaticParameter
      override Equals : other:obj -> bool
      override GetHashCode : unit -> int
      override ToString : unit -> string
      member DeclarationLocation : Range.range
      member DefaultValue : obj
      [<System.Obsolete
        ("This member is no longer used, use IsOptional instead")>]
      member HasDefaultValue : bool
      member IsOptional : bool
      member Kind : FSharpType
      member Name : string
      member Range : Range.range
    end
  [<ClassAttribute ()>]
  and FSharpParameter =
    class
      inherit FSharpSymbol
      new : cenv:SymbolEnv * ty:TypedTree.TType * argInfo:TypedTree.ArgReprInfo *
            ownerRangeOpt:Range.range option -> FSharpParameter
      new : cenv:SymbolEnv * id:SyntaxTree.Ident * ty:TypedTree.TType *
            container:NameResolution.ArgumentContainer option -> FSharpParameter
      new : cenv:SymbolEnv * paramTy:TypedTree.TType *
            topArgInfo:TypedTree.ArgReprInfo *
            ownerOpt:NameResolution.ArgumentContainer option *
            ownerRangeOpt:Range.range option * isParamArrayArg:bool *
            isInArg:bool * isOutArg:bool * isOptionalArg:bool *
            isWitnessArg:bool -> FSharpParameter
      member AdjustType : ty:TypedTree.TType -> FSharpParameter
      override Equals : other:obj -> bool
      override GetHashCode : unit -> int
      override ToString : unit -> string
      member Attributes : System.Collections.Generic.IList<FSharpAttribute>
      member DeclarationLocation : Range.range
      member IsInArg : bool
      member IsOptionalArg : bool
      member IsOutArg : bool
      member IsParamArrayArg : bool
      member IsWitnessArg : bool
      member Name : string option
      member Owner : FSharpSymbol option
      member Type : FSharpType
      member V : TypedTree.TType
      member private ValReprInfo : TypedTree.ArgReprInfo
      member cenv : SymbolEnv
    end
  and FSharpAssemblySignature =
    class
      new : tcGlobals:TcGlobals.TcGlobals * thisCcu:TypedTree.CcuThunk *
            thisCcuTyp:TypedTree.ModuleOrNamespaceType *
            tcImports:CompilerImports.TcImports *
            topAttribs:CheckDeclarations.TopAttribs option *
            contents:TypedTree.ModuleOrNamespaceType -> FSharpAssemblySignature
      new : cenv:SymbolEnv * ccu:TypedTree.CcuThunk -> FSharpAssemblySignature
      new : cenv:SymbolEnv * topAttribs:CheckDeclarations.TopAttribs option *
            optViewedCcu:TypedTree.CcuThunk option *
            mtyp:TypedTree.ModuleOrNamespaceType -> FSharpAssemblySignature
      member FindEntityByPath : string list -> FSharpEntity option
      override ToString : unit -> string
      member Attributes : System.Collections.Generic.IList<FSharpAttribute>
      member Entities : System.Collections.Generic.IList<FSharpEntity>
    end
  and FSharpAssembly =
    class
      new : tcGlobals:TcGlobals.TcGlobals * tcImports:CompilerImports.TcImports *
            ccu:TypedTree.CcuThunk -> FSharpAssembly
      internal new : cenv:SymbolEnv * ccu:TypedTree.CcuThunk -> FSharpAssembly
      override ToString : unit -> string
      [<System.Obsolete ("This item is obsolete, it is not useful")>]
      member CodeLocation : string
      member Contents : FSharpAssemblySignature
      member FileName : string option
      member IsProviderGenerated : bool
      member QualifiedName : string
      member RawCcuThunk : TypedTree.CcuThunk
      member SimpleName : string
    end
  [<SealedAttribute ()>]
  and FSharpOpenDeclaration =
    class
      new : target:SyntaxTree.SynOpenDeclTarget * range:Range.range option *
            modules:FSharpEntity list * types:FSharpType list *
            appliedScope:Range.range * isOwnNamespace:bool ->
              FSharpOpenDeclaration
      member AppliedScope : Range.range
      member IsOwnNamespace : bool
      member LongId : SyntaxTree.LongIdent
      member Modules : FSharpEntity list
      member Range : Range.range option
      member Target : SyntaxTree.SynOpenDeclTarget
      member Types : FSharpType list
    end
  [<SealedAttribute ()>]
  and FSharpSymbolUse =
    class
      new : g:TcGlobals.TcGlobals * denv:TypedTreeOps.DisplayEnv *
            symbol:FSharpSymbol * itemOcc:NameResolution.ItemOccurence *
            range:Range.range -> FSharpSymbolUse
      override ToString : unit -> string
      member DisplayContext : FSharpDisplayContext
      member FileName : string
      member IsDefinition : bool
      member IsFromAttribute : bool
      member IsFromComputationExpression : bool
      member IsFromDefinition : bool
      member IsFromDispatchSlotImplementation : bool
      member IsFromOpenStatement : bool
      member IsFromPattern : bool
      member IsFromType : bool
      member IsPrivateToFile : bool
      member Range : Range.Range01
      member RangeAlternate : Range.range
      member Symbol : FSharpSymbol
    end
  module Impl = begin
    val protect : f:(unit -> 'a) -> 'a
    val makeReadOnlyCollection :
      arr:seq<'T> -> System.Collections.Generic.IList<'T>
    val makeXmlDoc :
      doc:XmlDoc.XmlDoc -> System.Collections.Generic.IList<string>
    val makeElaboratedXmlDoc :
      doc:XmlDoc.XmlDoc -> System.Collections.Generic.IList<string>
    val rescopeEntity :
      optViewedCcu:TypedTree.CcuThunk option ->
        entity:TypedTree.Entity -> TypedTree.EntityRef
    val entityIsUnresolved : entity:TypedTree.EntityRef -> bool
    val checkEntityIsResolved : entity:TypedTree.EntityRef -> unit
    val checkForCrossProjectAccessibility :
      ilg:AbstractIL.IL.ILGlobals ->
        thisCcu2:TypedTree.CcuThunk * ad2:AccessibilityLogic.AccessorDomain ->
          thisCcu1:TypedTree.CcuThunk * taccess1:TypedTree.Accessibility -> bool
    val getApproxFSharpAccessibilityOfMember :
      declaringEntity:TypedTree.EntityRef ->
        ilAccess:AbstractIL.IL.ILMemberAccess -> TypedTree.Accessibility
    val getApproxFSharpAccessibilityOfEntity :
      entity:TypedTree.EntityRef -> TypedTree.Accessibility
    val getLiteralValue : _arg6:TypedTree.Const option -> obj option
    val getXmlDocSigForEntity :
      cenv:SymbolEnv -> ent:TypedTree.EntityRef -> string
  end

namespace FSharp.Compiler.SourceCodeServices
  module ExprTranslationImpl = begin
    val nonNil : x:'a list -> bool
    type ExprTranslationEnv =
      { vs: TypedTreeOps.ValMap<unit>
        tyvs: TypedTree.StampMap<FSharpGenericParameter>
        isinstVals: TypedTreeOps.ValMap<TypedTree.TType * TypedTree.Expr>
        substVals: TypedTreeOps.ValMap<TypedTree.Expr>
        suppressWitnesses: bool
        witnessesInScope: TypedTreeOps.TraitWitnessInfoHashMap<int> }
      with
        static member Empty : g:TcGlobals.TcGlobals -> ExprTranslationEnv
        member
          BindCurriedVals : vsl:TypedTree.Val list list -> ExprTranslationEnv
        member
          BindIsInstVal : v:TypedTree.Val ->
                            ty:TypedTree.TType * e:TypedTree.Expr ->
                              ExprTranslationEnv
        member
          BindSubstVal : v:TypedTree.Val ->
                           e:TypedTree.Expr -> ExprTranslationEnv
        member
          BindTypar : v:TypedTree.Typar * gp:FSharpGenericParameter ->
                        ExprTranslationEnv
        member
          BindTypars : vs:(TypedTree.Typar * #FSharpGenericParameter) list ->
                         ExprTranslationEnv
        member BindVal : v:TypedTree.Val -> ExprTranslationEnv
        member BindVals : vs:TypedTree.Val list -> ExprTranslationEnv
      end
    exception IgnoringPartOfQuotedTermWarning of string * Range.range
    val wfail : msg:string * m:Range.range -> 'a
  end
  type E =
    | Value of FSharpMemberOrFunctionOrValue
    | ThisValue of FSharpType
    | BaseValue of FSharpType
    | Application of FSharpExpr * FSharpType list * FSharpExpr list
    | Lambda of FSharpMemberOrFunctionOrValue * FSharpExpr
    | TypeLambda of FSharpGenericParameter list * FSharpExpr
    | Quote of FSharpExpr
    | IfThenElse of FSharpExpr * FSharpExpr * FSharpExpr
    | DecisionTree of
      FSharpExpr * (FSharpMemberOrFunctionOrValue list * FSharpExpr) list
    | DecisionTreeSuccess of int * FSharpExpr list
    | Call of
      FSharpExpr option * FSharpMemberOrFunctionOrValue * FSharpType list *
      FSharpType list * FSharpExpr list * FSharpExpr list
    | NewObject of
      FSharpMemberOrFunctionOrValue * FSharpType list * FSharpExpr list
    | LetRec of (FSharpMemberOrFunctionOrValue * FSharpExpr) list * FSharpExpr
    | Let of (FSharpMemberOrFunctionOrValue * FSharpExpr) * FSharpExpr
    | NewRecord of FSharpType * FSharpExpr list
    | ObjectExpr of
      FSharpType * FSharpExpr * FSharpObjectExprOverride list *
      (FSharpType * FSharpObjectExprOverride list) list
    | FSharpFieldGet of FSharpExpr option * FSharpType * FSharpField
    | FSharpFieldSet of
      FSharpExpr option * FSharpType * FSharpField * FSharpExpr
    | NewUnionCase of FSharpType * FSharpUnionCase * FSharpExpr list
    | NewAnonRecord of FSharpType * FSharpExpr list
    | AnonRecordGet of FSharpExpr * FSharpType * int
    | UnionCaseGet of FSharpExpr * FSharpType * FSharpUnionCase * FSharpField
    | UnionCaseSet of
      FSharpExpr * FSharpType * FSharpUnionCase * FSharpField * FSharpExpr
    | UnionCaseTag of FSharpExpr * FSharpType
    | UnionCaseTest of FSharpExpr * FSharpType * FSharpUnionCase
    | TraitCall of
      FSharpType list * string * SyntaxTree.MemberFlags * FSharpType list *
      FSharpType list * FSharpExpr list
    | NewTuple of FSharpType * FSharpExpr list
    | TupleGet of FSharpType * int * FSharpExpr
    | Coerce of FSharpType * FSharpExpr
    | NewArray of FSharpType * FSharpExpr list
    | TypeTest of FSharpType * FSharpExpr
    | AddressSet of FSharpExpr * FSharpExpr
    | ValueSet of FSharpMemberOrFunctionOrValue * FSharpExpr
    | Unused
    | DefaultValue of FSharpType
    | Const of obj * FSharpType
    | AddressOf of FSharpExpr
    | Sequential of FSharpExpr * FSharpExpr
    | FastIntegerForLoop of FSharpExpr * FSharpExpr * FSharpExpr * bool
    | WhileLoop of FSharpExpr * FSharpExpr
    | TryFinally of FSharpExpr * FSharpExpr
    | TryWith of
      FSharpExpr * FSharpMemberOrFunctionOrValue * FSharpExpr *
      FSharpMemberOrFunctionOrValue * FSharpExpr
    | NewDelegate of FSharpType * FSharpExpr
    | ILFieldGet of FSharpExpr option * FSharpType * string
    | ILFieldSet of FSharpExpr option * FSharpType * string * FSharpExpr
    | ILAsm of string * FSharpType list * FSharpExpr list
    | WitnessArg of int
  [<SealedAttribute ()>]
  and FSharpObjectExprOverride =
    class
      new : sgn:FSharpAbstractSignature * gps:FSharpGenericParameter list *
            args:FSharpMemberOrFunctionOrValue list list * body:FSharpExpr ->
              FSharpObjectExprOverride
      member Body : FSharpExpr
      member CurriedParameterGroups : FSharpMemberOrFunctionOrValue list list
      member GenericParameters : FSharpGenericParameter list
      member Signature : FSharpAbstractSignature
    end
  [<SealedAttribute ()>]
  and FSharpExpr =
    class
      new : cenv:SymbolEnv * f:(unit -> FSharpExpr) option * e:E * m:Range.range *
            ty:TypedTree.TType -> FSharpExpr
      override ToString : unit -> string
      member E : E
      member ImmediateSubExpressions : FSharpExpr list
      member Range : Range.range
      member Type : FSharpType
      member cenv : SymbolEnv
    end
  module FSharpExprConvert = begin
    val IsStaticInitializationField : rfref:TypedTree.RecdFieldRef -> bool
    val ( |StaticInitializationCheck|_| ) : e:TypedTree.Expr -> unit option
    val ( |StaticInitializationCount|_| ) : e:TypedTree.Expr -> unit option
    val ( |ILUnaryOp|_| ) :
      e:AbstractIL.IL.ILInstr ->
        (#TcGlobals.TcGlobals -> Range.range -> TypedTree.TType ->
           TypedTree.Expr -> TypedTree.Expr) option
    val ( |ILMulDivOp|_| ) :
      e:AbstractIL.IL.ILInstr ->
        ((#TcGlobals.TcGlobals -> Range.range -> TypedTree.TType ->
            TypedTree.TType -> TypedTree.TType -> TypedTree.Expr ->
            TypedTree.Expr -> TypedTree.Expr) * bool) option
    val ( |ILBinaryOp|_| ) :
      e:AbstractIL.IL.ILInstr ->
        (#TcGlobals.TcGlobals -> Range.range -> TypedTree.TType ->
           TypedTree.Expr -> TypedTree.Expr -> TypedTree.Expr) option
    val ( |ILConvertOp|_| ) :
      e:AbstractIL.IL.ILInstr ->
        (#TcGlobals.TcGlobals -> Range.range -> TypedTree.TType ->
           TypedTree.Expr -> TypedTree.Expr) option
    val ( |TTypeConvOp|_| ) :
      cenv:SymbolEnv ->
        ty:TypedTree.TType ->
          (#TcGlobals.TcGlobals -> Range.range -> TypedTree.TType ->
             TypedTree.Expr -> TypedTree.Expr) option
    val ConvType : cenv:SymbolEnv -> ty:TypedTree.TType -> FSharpType
    val ConvTypes :
      cenv:SymbolEnv -> tys:TypedTree.TType list -> FSharpType list
    val ConvILTypeRefApp :
      cenv:SymbolEnv ->
        m:Range.range ->
          tref:AbstractIL.IL.ILTypeRef ->
            tyargs:TypedTree.TypeInst -> FSharpType
    val ConvUnionCaseRef :
      cenv:SymbolEnv -> ucref:TypedTree.UnionCaseRef -> FSharpUnionCase
    val ConvRecdFieldRef :
      cenv:SymbolEnv -> rfref:TypedTree.RecdFieldRef -> FSharpField
    val exprOfExprAddr : cenv:SymbolEnv -> expr:TypedTree.Expr -> TypedTree.Expr
    val Mk :
      cenv:SymbolEnv -> m:Range.range -> ty:TypedTree.TType -> e:E -> FSharpExpr
    val Mk2 : cenv:SymbolEnv -> orig:TypedTree.Expr -> e:E -> FSharpExpr
    val ConvLValueExpr :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          expr:TypedTree.Expr -> FSharpExpr
    val ConvExpr :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          expr:TypedTree.Expr -> FSharpExpr
    val ConvExprLinear :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          expr:TypedTree.Expr -> contF:(FSharpExpr -> E) -> E
    val ConvExprPrimLinear :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          expr:TypedTree.Expr -> contF:(E -> E) -> E
    val ConvModuleValueOrMemberUseLinear :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          expr:TypedTree.Expr * vref:TypedTree.ValRef *
          vFlags:TypedTree.ValUseFlag * tyargs:TypedTree.TypeInst *
          curriedArgs:TypedTree.Expr list -> contF:(E -> E) -> E
    val GetWitnessArgs :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          vref:TypedTree.ValRef ->
            m:Range.range ->
              tps:TypedTree.Typars ->
                tyargs:TypedTree.TypeInst -> FSharpExpr list
    val ConvExprPrim :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv -> expr:TypedTree.Expr -> E
    val ConvWitnessInfoPrim :
      _cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          traitInfo:TypedTree.TraitConstraintInfo -> E
    val ConvWitnessInfo :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          m:Range.range -> traitInfo:TypedTree.TraitConstraintInfo -> FSharpExpr
    val ConvLetBind :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          bind:TypedTree.Binding ->
            (FSharpMemberOrFunctionOrValue * FSharpExpr) option *
            ExprTranslationImpl.ExprTranslationEnv
    val ConvILCall :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          isNewObj:bool * valUseFlags:TypedTree.ValUseFlag *
          ilMethRef:AbstractIL.IL.ILMethodRef * enclTypeArgs:TypedTree.TypeInst *
          methTypeArgs:TypedTree.TypeInst * callArgs:TypedTree.Exprs *
          m:Range.range -> E
    val ConvObjectModelCallLinear :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          isNewObj:bool * v:FSharpMemberOrFunctionOrValue *
          enclTyArgs:TypedTree.TType list * methTyArgs:TypedTree.TType list *
          witnessArgsR:FSharpExpr list * callArgs:TypedTree.Expr list ->
            contF:(E -> E) -> E
    val ConvExprs :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          args:TypedTree.Exprs -> FSharpExpr list
    val ConvExprsLinear :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          args:TypedTree.Expr list -> contF:(FSharpExpr list -> E) -> E
    val ConvTargetsLinear :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          tgs:TypedTree.DecisionTreeTarget list ->
            contF:((FSharpMemberOrFunctionOrValue list * FSharpExpr) list -> E) ->
              E
    val ConvValRef :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          m:Range.range -> vref:TypedTree.ValRef -> E
    val ConvVal :
      cenv:SymbolEnv -> v:TypedTree.Val -> FSharpMemberOrFunctionOrValue
    val ConvConst :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          m:Range.range -> c:TypedTree.Const -> ty:TypedTree.TType -> E
    val ConvDecisionTree :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          dtreeRetTy:TypedTree.TType ->
            x:TypedTree.DecisionTree -> m:Range.range -> FSharpExpr
    val ConvDecisionTreePrim :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          dtreeRetTy:TypedTree.TType -> x:TypedTree.DecisionTree -> E
    val ConvExprOnDemand :
      cenv:SymbolEnv ->
        env:ExprTranslationImpl.ExprTranslationEnv ->
          expr:TypedTree.Expr -> FSharpExpr
  end
  type FSharpAssemblyContents =
    class
      new : tcGlobals:TcGlobals.TcGlobals * thisCcu:TypedTree.CcuThunk *
            thisCcuType:TypedTree.ModuleOrNamespaceType option *
            tcImports:CompilerImports.TcImports *
            mimpls:TypedTree.TypedImplFile list -> FSharpAssemblyContents
      new : cenv:SymbolEnv * mimpls:TypedTree.TypedImplFile list ->
              FSharpAssemblyContents
      member ImplementationFiles : FSharpImplementationFileContents list
    end
  and FSharpImplementationFileDeclaration =
    | Entity of FSharpEntity * FSharpImplementationFileDeclaration list
    | MemberOrFunctionOrValue of
      FSharpMemberOrFunctionOrValue * FSharpMemberOrFunctionOrValue list list *
      FSharpExpr
    | InitAction of FSharpExpr
  and FSharpImplementationFileContents =
    class
      new : cenv:SymbolEnv * mimpl:TypedTree.TypedImplFile ->
              FSharpImplementationFileContents
      member Declarations : FSharpImplementationFileDeclaration list
      member FileName : string
      member HasExplicitEntryPoint : bool
      member IsScript : bool
      member QualifiedName : string
    end
  module BasicPatterns = begin
    val ( |Value|_| ) : FSharpExpr -> FSharpMemberOrFunctionOrValue option
    val ( |Const|_| ) : FSharpExpr -> (obj * FSharpType) option
    val ( |TypeLambda|_| ) :
      FSharpExpr -> (FSharpGenericParameter list * FSharpExpr) option
    val ( |Lambda|_| ) :
      FSharpExpr -> (FSharpMemberOrFunctionOrValue * FSharpExpr) option
    val ( |Application|_| ) :
      FSharpExpr -> (FSharpExpr * FSharpType list * FSharpExpr list) option
    val ( |IfThenElse|_| ) :
      FSharpExpr -> (FSharpExpr * FSharpExpr * FSharpExpr) option
    val ( |Let|_| ) :
      FSharpExpr ->
        ((FSharpMemberOrFunctionOrValue * FSharpExpr) * FSharpExpr) option
    val ( |LetRec|_| ) :
      FSharpExpr ->
        ((FSharpMemberOrFunctionOrValue * FSharpExpr) list * FSharpExpr) option
    val ( |NewRecord|_| ) : FSharpExpr -> (FSharpType * FSharpExpr list) option
    val ( |NewAnonRecord|_| ) :
      FSharpExpr -> (FSharpType * FSharpExpr list) option
    val ( |NewUnionCase|_| ) :
      FSharpExpr -> (FSharpType * FSharpUnionCase * FSharpExpr list) option
    val ( |NewTuple|_| ) : FSharpExpr -> (FSharpType * FSharpExpr list) option
    val ( |TupleGet|_| ) : FSharpExpr -> (FSharpType * int * FSharpExpr) option
    val ( |Call|_| ) :
      FSharpExpr ->
        (FSharpExpr option * FSharpMemberOrFunctionOrValue * FSharpType list *
         FSharpType list * FSharpExpr list) option
    val ( |CallWithWitnesses|_| ) :
      FSharpExpr ->
        (FSharpExpr option * FSharpMemberOrFunctionOrValue * FSharpType list *
         FSharpType list * FSharpExpr list * FSharpExpr list) option
    val ( |NewObject|_| ) :
      FSharpExpr ->
        (FSharpMemberOrFunctionOrValue * FSharpType list * FSharpExpr list) option
    val ( |FSharpFieldGet|_| ) :
      FSharpExpr -> (FSharpExpr option * FSharpType * FSharpField) option
    val ( |AnonRecordGet|_| ) :
      FSharpExpr -> (FSharpExpr * FSharpType * int) option
    val ( |FSharpFieldSet|_| ) :
      FSharpExpr ->
        (FSharpExpr option * FSharpType * FSharpField * FSharpExpr) option
    val ( |UnionCaseGet|_| ) :
      FSharpExpr ->
        (FSharpExpr * FSharpType * FSharpUnionCase * FSharpField) option
    val ( |UnionCaseTag|_| ) : FSharpExpr -> (FSharpExpr * FSharpType) option
    val ( |UnionCaseTest|_| ) :
      FSharpExpr -> (FSharpExpr * FSharpType * FSharpUnionCase) option
    val ( |NewArray|_| ) : FSharpExpr -> (FSharpType * FSharpExpr list) option
    val ( |Coerce|_| ) : FSharpExpr -> (FSharpType * FSharpExpr) option
    val ( |Quote|_| ) : FSharpExpr -> FSharpExpr option
    val ( |TypeTest|_| ) : FSharpExpr -> (FSharpType * FSharpExpr) option
    val ( |Sequential|_| ) : FSharpExpr -> (FSharpExpr * FSharpExpr) option
    val ( |FastIntegerForLoop|_| ) :
      FSharpExpr -> (FSharpExpr * FSharpExpr * FSharpExpr * bool) option
    val ( |WhileLoop|_| ) : FSharpExpr -> (FSharpExpr * FSharpExpr) option
    val ( |TryFinally|_| ) : FSharpExpr -> (FSharpExpr * FSharpExpr) option
    val ( |TryWith|_| ) :
      FSharpExpr ->
        (FSharpExpr * FSharpMemberOrFunctionOrValue * FSharpExpr *
         FSharpMemberOrFunctionOrValue * FSharpExpr) option
    val ( |NewDelegate|_| ) : FSharpExpr -> (FSharpType * FSharpExpr) option
    val ( |DefaultValue|_| ) : FSharpExpr -> FSharpType option
    val ( |AddressSet|_| ) : FSharpExpr -> (FSharpExpr * FSharpExpr) option
    val ( |ValueSet|_| ) :
      FSharpExpr -> (FSharpMemberOrFunctionOrValue * FSharpExpr) option
    val ( |AddressOf|_| ) : FSharpExpr -> FSharpExpr option
    val ( |ThisValue|_| ) : FSharpExpr -> FSharpType option
    val ( |BaseValue|_| ) : FSharpExpr -> FSharpType option
    val ( |ILAsm|_| ) :
      FSharpExpr -> (string * FSharpType list * FSharpExpr list) option
    val ( |ILFieldGet|_| ) :
      FSharpExpr -> (FSharpExpr option * FSharpType * string) option
    val ( |ILFieldSet|_| ) :
      FSharpExpr ->
        (FSharpExpr option * FSharpType * string * FSharpExpr) option
    val ( |ObjectExpr|_| ) :
      FSharpExpr ->
        (FSharpType * FSharpExpr * FSharpObjectExprOverride list *
         (FSharpType * FSharpObjectExprOverride list) list) option
    val ( |DecisionTree|_| ) :
      FSharpExpr ->
        (FSharpExpr * (FSharpMemberOrFunctionOrValue list * FSharpExpr) list) option
    val ( |DecisionTreeSuccess|_| ) :
      FSharpExpr -> (int * FSharpExpr list) option
    val ( |UnionCaseSet|_| ) :
      FSharpExpr ->
        (FSharpExpr * FSharpType * FSharpUnionCase * FSharpField * FSharpExpr) option
    val ( |TraitCall|_| ) :
      FSharpExpr ->
        (FSharpType list * string * SyntaxTree.MemberFlags * FSharpType list *
         FSharpType list * FSharpExpr list) option
    val ( |WitnessArg|_| ) : FSharpExpr -> int option
  end

namespace FSharp.Compiler.SourceCodeServices
  module Symbol = begin
    val isAttribute<'T> : FSharpAttribute -> bool
    val tryGetAttribute<'T> : seq<FSharpAttribute> -> FSharpAttribute option
    module Option = begin
      val attempt : f:(unit -> 'a) -> 'a option
    end
    val hasModuleSuffixAttribute : FSharpEntity -> bool
    val isOperator : name:string -> bool
    val UnnamedUnionFieldRegex : System.Text.RegularExpressions.Regex
    val isUnnamedUnionCaseField : FSharpField -> bool
    val ( |AbbreviatedType|_| ) : FSharpEntity -> FSharpType option
    val ( |TypeWithDefinition|_| ) : FSharpType -> FSharpEntity option
    val getEntityAbbreviatedType :
      FSharpEntity -> FSharpEntity * FSharpType option
    val getAbbreviatedType : FSharpType -> FSharpType
    val ( |Attribute|_| ) : FSharpEntity -> unit option
    val hasAttribute<'T> : seq<FSharpAttribute> -> bool
    val ( |ValueType|_| ) : FSharpEntity -> unit option
    val ( |Class|_| ) :
      original:FSharpEntity * abbreviated:FSharpEntity * 'a -> unit option
    val ( |Record|_| ) : FSharpEntity -> unit option
    val ( |UnionType|_| ) : FSharpEntity -> unit option
    val ( |Delegate|_| ) : FSharpEntity -> unit option
    val ( |FSharpException|_| ) : FSharpEntity -> unit option
    val ( |Interface|_| ) : FSharpEntity -> unit option
    val ( |AbstractClass|_| ) : FSharpEntity -> unit option
    val ( |FSharpType|_| ) : FSharpEntity -> unit option
    val ( |ProvidedType|_| ) : FSharpEntity -> unit option
    val ( |ByRef|_| ) : FSharpEntity -> unit option
    val ( |Array|_| ) : FSharpEntity -> unit option
    val ( |FSharpModule|_| ) : FSharpEntity -> unit option
    val ( |Namespace|_| ) : FSharpEntity -> unit option
    val ( |ProvidedAndErasedType|_| ) : FSharpEntity -> unit option
    val ( |Enum|_| ) : FSharpEntity -> unit option
    val ( |Tuple|_| ) : FSharpType -> unit option
    val ( |RefCell|_| ) : FSharpType -> unit option
    val ( |FunctionType|_| ) : FSharpType -> unit option
    val ( |Pattern|_| ) : FSharpSymbol -> unit option
    val ( |Field|_| ) : FSharpSymbol -> (FSharpField * FSharpType) option
    val ( |MutableVar|_| ) : FSharpSymbol -> unit option
    val ( |FSharpEntity|_| ) :
      FSharpSymbol -> (FSharpEntity * FSharpEntity * FSharpType option) option
    val ( |Parameter|_| ) : FSharpSymbol -> unit option
    val ( |UnionCase|_| ) : FSharpSymbol -> FSharpUnionCase option
    val ( |RecordField|_| ) : FSharpSymbol -> FSharpField option
    val ( |ActivePatternCase|_| ) :
      FSharpSymbol -> FSharpActivePatternCase option
    val ( |MemberFunctionOrValue|_| ) :
      FSharpSymbol -> FSharpMemberOrFunctionOrValue option
    val ( |Constructor|_| ) :
      FSharpMemberOrFunctionOrValue -> FSharpEntity option
    val ( |Function|_| ) :
      excluded:bool -> FSharpMemberOrFunctionOrValue -> unit option
    val ( |ExtensionMember|_| ) : FSharpMemberOrFunctionOrValue -> unit option
    val ( |Event|_| ) : FSharpMemberOrFunctionOrValue -> unit option
  end

namespace FSharp.Compiler.SourceCodeServices
  type internal IReactorOperations =
    interface
      abstract member
        EnqueueAndAwaitOpAsync : userOpName:string * opName:string *
                                 opArg:string *
                                 action:(AbstractIL.Internal.Library.CompilationThreadToken ->
                                           AbstractIL.Internal.Library.Cancellable<'T>) ->
                                   Async<'T>
      abstract member
        EnqueueOp : userOpName:string * opName:string * opArg:string *
                    action:(AbstractIL.Internal.Library.CompilationThreadToken ->
                              unit) -> unit
    end
  [<NoEqualityAttribute (); NoComparisonAttribute ()>]
  type internal ReactorCommands =
    | SetBackgroundOp of
      (string * string * string *
       (AbstractIL.Internal.Library.CompilationThreadToken ->
          System.Threading.CancellationToken -> bool)) option
    | Op of
      userOpName: string * opName: string * opArg: string *
      System.Threading.CancellationToken *
      (AbstractIL.Internal.Library.CompilationThreadToken -> unit) *
      (unit -> unit)
    | WaitForBackgroundOpCompletion of AsyncReplyChannel<unit>
    | CompleteAllQueuedOps of AsyncReplyChannel<unit>
  [<SealedAttribute ()>]
  type Reactor =
    class
      new : unit -> Reactor
      member CancelBackgroundOp : unit -> unit
      member CompleteAllQueuedOps : unit -> unit
      member
        EnqueueAndAwaitOpAsync : userOpName:string * opName:string *
                                 opArg:string *
                                 (AbstractIL.Internal.Library.CompilationThreadToken ->
                                    AbstractIL.Internal.Library.Cancellable<'T>) ->
                                   Async<'T>
      member
        EnqueueOp : userOpName:string * opName:string * opArg:string *
                    op:(AbstractIL.Internal.Library.CompilationThreadToken ->
                          unit) -> unit
      member
        EnqueueOpPrim : userOpName:string * opName:string * opArg:string *
                        ct:System.Threading.CancellationToken *
                        op:(AbstractIL.Internal.Library.CompilationThreadToken ->
                              unit) * ccont:(unit -> unit) -> unit
      member
        SetBackgroundOp : (string * string * string *
                           (AbstractIL.Internal.Library.CompilationThreadToken ->
                              System.Threading.CancellationToken -> bool)) option ->
                            unit
      member SetPreferredUILang : string option -> unit
      member WaitForBackgroundOpCompletion : unit -> unit
      member CurrentQueueLength : int
      member PauseBeforeBackgroundWork : int
      static member Singleton : Reactor
    end

namespace FSharp.Compiler.SourceCodeServices
  [<RequireQualifiedAccessAttribute ()>]
  type SemanticClassificationType =
    | ReferenceType
    | ValueType
    | UnionCase
    | UnionCaseField
    | Function
    | Property
    | MutableVar
    | Module
    | Namespace
    | Printf
    | ComputationExpression
    | IntrinsicFunction
    | Enumeration
    | Interface
    | TypeArgument
    | Operator
    | DisposableType
    | DisposableTopLevelValue
    | DisposableLocalValue
    | Method
    | ExtensionMethod
    | ConstructorForReferenceType
    | ConstructorForValueType
    | Literal
    | RecordField
    | MutableRecordField
    | RecordFieldAsFunction
    | Exception
    | Field
    | Event
    | Delegate
    | NamedArgument
    | Value
    | LocalValue
    | Type
    | TypeDef
    | Plaintext
  module TcResolutionsExtensions = begin
    val ( |CNR| ) :
      cnr:NameResolution.CapturedNameResolution ->
        NameResolution.Item * NameResolution.ItemOccurence *
        TypedTreeOps.DisplayEnv * NameResolution.NameResolutionEnv *
        AccessibilityLogic.AccessorDomain * Range.range
    type internal TcResolutions with
      member
        GetSemanticClassification : g:TcGlobals.TcGlobals *
                                    amap:Import.ImportMap *
                                    formatSpecifierLocations:(Range.range * int) [] *
                                    range:Range.range option ->
                                      struct
                                        (Range.range *
                                         SemanticClassificationType) []
  end

namespace FSharp.Compiler.SourceCodeServices
  module ItemKeyTags = begin
    [<LiteralAttribute ()>]
    val entityRef : string = "#E#"
    [<LiteralAttribute ()>]
    val typeTuple : string = "#T#"
    [<LiteralAttribute ()>]
    val typeAnonymousRecord : string = "#N#"
    [<LiteralAttribute ()>]
    val typeFunction : string = "#F#"
    [<LiteralAttribute ()>]
    val typeMeasure : string = "#M#"
    [<LiteralAttribute ()>]
    val typeUnionCase : string = "#U#"
    [<LiteralAttribute ()>]
    val typeMeasureVar : string = "#p#"
    [<LiteralAttribute ()>]
    val typeMeasureCon : string = "#c#"
    [<LiteralAttribute ()>]
    val itemValueMember : string = "m$"
    [<LiteralAttribute ()>]
    val itemValue : string = "v$"
    [<LiteralAttribute ()>]
    val itemUnionCase : string = "u$"
    [<LiteralAttribute ()>]
    val itemActivePattern : string = "r$"
    [<LiteralAttribute ()>]
    val itemExnCase : string = "e$"
    [<LiteralAttribute ()>]
    val itemRecordField : string = "d$"
    [<LiteralAttribute ()>]
    val itemAnonymousRecordField : string = "a$"
    [<LiteralAttribute ()>]
    val itemNewDef : string = "n$"
    [<LiteralAttribute ()>]
    val itemILField : string = "l$"
    [<LiteralAttribute ()>]
    val itemEvent : string = "t$"
    [<LiteralAttribute ()>]
    val itemProperty : string = "p$"
    [<LiteralAttribute ()>]
    val itemTypeVar : string = "y$"
    [<LiteralAttribute ()>]
    val itemModuleOrNamespace : string = "o$"
    [<LiteralAttribute ()>]
    val itemDelegateCtor : string = "g$"
    [<LiteralAttribute ()>]
    val parameters : string = "p$p$"
  end
  [<SealedAttribute ()>]
  type ItemKeyStore =
    class
      interface System.IDisposable
      new : mmf:System.IO.MemoryMappedFiles.MemoryMappedFile * length:int64 ->
              ItemKeyStore
      member FindAll : NameResolution.Item -> seq<Range.range>
      member ReadFirstKeyString : unit -> System.ReadOnlySpan<byte>
      member
        ReadKeyString : reader:byref<System.Reflection.Metadata.BlobReader> ->
                          System.ReadOnlySpan<byte>
      member
        ReadRange : reader:byref<System.Reflection.Metadata.BlobReader> ->
                      Range.range
    end
  [<SealedAttribute ()>]
  and ItemKeyStoreBuilder =
    class
      new : unit -> ItemKeyStoreBuilder
      member TryBuildAndReset : unit -> ItemKeyStore option
      member Write : Range.range * NameResolution.Item -> unit
    end

namespace FSharp.Compiler
  module internal IncrementalBuild = begin
    val mutable injectCancellationFault : bool
    val LocallyInjectCancellationFault : unit -> System.IDisposable
  end
  module IncrementalBuilderEventTesting = begin
    type internal FixedLengthMRU<'T> =
      class
        new : unit -> FixedLengthMRU<'T>
        member Add : filename:'T -> unit
        member MostRecentList : n:int -> 'T list
        member CurrentEventNum : int
      end
    type IBEvent =
      | IBEParsed of string
      | IBETypechecked of string
      | IBECreated
    val MRU : FixedLengthMRU<IBEvent>
    val GetMostRecentIncrementalBuildEvents : int -> IBEvent list
    val GetCurrentIncrementalBuildEventNum : unit -> int
  end
  module IncrementalBuildSyntaxTree = begin
    [<SealedAttribute ()>]
    type SyntaxTree =
      class
        new : tcConfig:CompilerConfig.TcConfig * fileParsed:Event<string> *
              lexResourceManager:Lexhelp.LexResourceManager *
              sourceRange:Range.range * filename:string *
              isLastCompiland:(bool * bool) -> SyntaxTree
        member Invalidate : unit -> unit
        member
          Parse : sigNameOpt:SyntaxTree.QualifiedNameOfFile option ->
                    SyntaxTree.ParsedInput option * Range.range * string *
                    (ErrorLogger.PhasedDiagnostic *
                     SourceCodeServices.FSharpErrorSeverity) []
        member FileName : string
      end
  end
  [<NoEqualityAttribute (); NoComparisonAttribute ()>]
  type TcInfo =
    { tcState: ParseAndCheckInputs.TcState
      tcEnvAtEndOfFile: CheckExpressions.TcEnv
      moduleNamesDict: ParseAndCheckInputs.ModuleNamesDict
      topAttribs: CheckDeclarations.TopAttribs option
      latestCcuSigForFile: TypedTree.ModuleOrNamespaceType option
      tcErrorsRev:
        (ErrorLogger.PhasedDiagnostic * SourceCodeServices.FSharpErrorSeverity) [] list
      tcDependencyFiles: string list
      sigNameOpt: (string * SyntaxTree.QualifiedNameOfFile) option }
    with
      member
        TcErrors : (ErrorLogger.PhasedDiagnostic *
                    SourceCodeServices.FSharpErrorSeverity) []
    end
  [<NoEqualityAttribute (); NoComparisonAttribute ()>]
  type TcInfoOptional =
    { tcResolutionsRev: NameResolution.TcResolutions list
      tcSymbolUsesRev: NameResolution.TcSymbolUses list
      tcOpenDeclarationsRev: NameResolution.OpenDeclaration [] list
      latestImplFile: TypedTree.TypedImplFile option
      itemKeyStore: SourceCodeServices.ItemKeyStore option
      semanticClassification:
        struct (Range.range * SourceCodeServices.SemanticClassificationType) [] }
    with
      member TcSymbolUses : NameResolution.TcSymbolUses list
    end
  [<NoEqualityAttribute (); NoComparisonAttribute ()>]
  type TcInfoState =
    | PartialState of TcInfo
    | FullState of TcInfo * TcInfoOptional
    with
      member Partial : TcInfo
    end
  [<SealedAttribute ()>]
  type SemanticModel =
    class
      private new : tcConfig:CompilerConfig.TcConfig *
                    tcGlobals:TcGlobals.TcGlobals *
                    tcImports:CompilerImports.TcImports *
                    keepAssemblyContents:bool *
                    keepAllBackgroundResolutions:bool *
                    maxTimeShareMilliseconds:int64 *
                    keepAllBackgroundSymbolUses:bool *
                    enableBackgroundItemKeyStoreAndSemanticClassification:bool *
                    enablePartialTypeChecking:bool *
                    beforeFileChecked:Event<string> * fileChecked:Event<string> *
                    prevTcInfo:TcInfo *
                    prevTcInfoOptional:AbstractIL.Internal.Library.Eventually<TcInfoOptional option> *
                    syntaxTreeOpt:IncrementalBuildSyntaxTree.SyntaxTree option *
                    lazyTcInfoState:TcInfoState option ref -> SemanticModel
      static member
        Create : tcConfig:CompilerConfig.TcConfig *
                 tcGlobals:TcGlobals.TcGlobals *
                 tcImports:CompilerImports.TcImports * keepAssemblyContents:bool *
                 keepAllBackgroundResolutions:bool *
                 maxTimeShareMilliseconds:int64 *
                 keepAllBackgroundSymbolUses:bool *
                 enableBackgroundItemKeyStoreAndSemanticClassification:bool *
                 enablePartialTypeChecking:bool *
                 beforeFileChecked:Event<string> * fileChecked:Event<string> *
                 prevTcInfo:TcInfo *
                 prevTcInfoOptional:AbstractIL.Internal.Library.Eventually<TcInfoOptional option> *
                 syntaxTreeOpt:IncrementalBuildSyntaxTree.SyntaxTree option ->
                   SemanticModel
      member
        Finish : finalTcErrorsRev:(ErrorLogger.PhasedDiagnostic *
                                   SourceCodeServices.FSharpErrorSeverity) [] list *
                 finalTopAttribs:CheckDeclarations.TopAttribs option ->
                   AbstractIL.Internal.Library.Eventually<SemanticModel>
      member
        GetState : partialCheck:bool ->
                     AbstractIL.Internal.Library.Eventually<TcInfoState>
      member Invalidate : unit -> unit
      member
        Next : syntaxTree:IncrementalBuildSyntaxTree.SyntaxTree ->
                 AbstractIL.Internal.Library.Eventually<SemanticModel>
      member
        private TypeCheck : partialCheck:bool ->
                              AbstractIL.Internal.Library.Eventually<TcInfoState>
      member BackingSignature : SyntaxTree.QualifiedNameOfFile option
      member TcConfig : CompilerConfig.TcConfig
      member TcGlobals : TcGlobals.TcGlobals
      member TcImports : CompilerImports.TcImports
      member TcInfo : AbstractIL.Internal.Library.Eventually<TcInfo>
      member
        TcInfoWithOptional : AbstractIL.Internal.Library.Eventually<TcInfo *
                                                                    TcInfoOptional>
    end
  type FrameworkImportsCacheKey =
    string list * string * string list * string * decimal
  type FrameworkImportsCache =
    class
      new : size:int -> FrameworkImportsCache
      member Clear : AbstractIL.Internal.Library.CompilationThreadToken -> unit
      member
        Downsize : AbstractIL.Internal.Library.CompilationThreadToken -> unit
      member
        Get : AbstractIL.Internal.Library.CompilationThreadToken *
              CompilerConfig.TcConfig ->
                AbstractIL.Internal.Library.Cancellable<TcGlobals.TcGlobals *
                                                        CompilerImports.TcImports *
                                                        CompilerImports.AssemblyResolution list *
                                                        CompilerConfig.UnresolvedAssemblyReference list>
    end
  [<SealedAttribute ()>]
  type PartialCheckResults =
    class
      private new : semanticModel:SemanticModel * timeStamp:System.DateTime ->
                      PartialCheckResults
      static member
        Create : semanticModel:SemanticModel * timestamp:System.DateTime ->
                   PartialCheckResults
      member
        GetSemanticClassification : AbstractIL.Internal.Library.CompilationThreadToken ->
                                      struct
                                        (Range.range *
                                         SourceCodeServices.SemanticClassificationType) []
      member
        TcInfo : AbstractIL.Internal.Library.CompilationThreadToken -> TcInfo
      member
        TcInfoWithOptional : AbstractIL.Internal.Library.CompilationThreadToken ->
                               TcInfo * TcInfoOptional
      member
        TryGetItemKeyStore : AbstractIL.Internal.Library.CompilationThreadToken ->
                               SourceCodeServices.ItemKeyStore option
      member TcConfig : CompilerConfig.TcConfig
      member TcGlobals : TcGlobals.TcGlobals
      member TcImports : CompilerImports.TcImports
      member TimeStamp : System.DateTime
    end
  module Utilities = begin
    val TryFindFSharpStringAttribute :
      tcGlobals:TcGlobals.TcGlobals ->
        attribSpec:TcGlobals.BuiltinAttribInfo ->
          attribs:TypedTree.Attribs -> string option
  end
  type RawFSharpAssemblyDataBackedByLanguageService =
    class
      interface CompilerConfig.IRawFSharpAssemblyData
      new : tcConfig:CompilerConfig.TcConfig * tcGlobals:TcGlobals.TcGlobals *
            tcState:ParseAndCheckInputs.TcState * outfile:string *
            topAttrs:CheckDeclarations.TopAttribs * assemblyName:string *
            ilAssemRef:AbstractIL.IL.ILAssemblyRef ->
              RawFSharpAssemblyDataBackedByLanguageService
    end
  [<ClassAttribute ()>]
  type IncrementalBuilder =
    class
      new : tcGlobals:TcGlobals.TcGlobals *
            frameworkTcImports:CompilerImports.TcImports *
            nonFrameworkAssemblyInputs:(Choice<string,
                                               CompilerConfig.IProjectReference> *
                                        (CompilerConfig.TimeStampCache ->
                                           AbstractIL.Internal.Library.CompilationThreadToken ->
                                           System.DateTime)) list *
            nonFrameworkResolutions:CompilerImports.AssemblyResolution list *
            unresolvedReferences:CompilerConfig.UnresolvedAssemblyReference list *
            tcConfig:CompilerConfig.TcConfig * projectDirectory:string *
            outfile:string * assemblyName:string *
            niceNameGen:CompilerGlobalState.NiceNameGenerator *
            lexResourceManager:Lexhelp.LexResourceManager *
            sourceFiles:string list *
            loadClosureOpt:ScriptClosure.LoadClosure option *
            keepAssemblyContents:bool * keepAllBackgroundResolutions:bool *
            maxTimeShareMilliseconds:int64 * keepAllBackgroundSymbolUses:bool *
            enableBackgroundItemKeyStoreAndSemanticClassification:bool *
            enablePartialTypeChecking:bool *
            dependencyProviderOpt:Microsoft.DotNet.DependencyManager.DependencyProvider option ->
              IncrementalBuilder
      static member
        TryCreateIncrementalBuilderForProjectOptions : AbstractIL.Internal.Library.CompilationThreadToken *
                                                       ReferenceResolver.Resolver *
                                                       defaultFSharpBinariesDir:string *
                                                       FrameworkImportsCache *
                                                       loadClosureOpt:ScriptClosure.LoadClosure option *
                                                       sourceFiles:string list *
                                                       commandLineArgs:string list *
                                                       projectReferences:CompilerConfig.IProjectReference list *
                                                       projectDirectory:string *
                                                       useScriptResolutionRules:bool *
                                                       keepAssemblyContents:bool *
                                                       keepAllBackgroundResolutions:bool *
                                                       maxTimeShareMilliseconds:int64 *
                                                       tryGetMetadataSnapshot:AbstractIL.ILBinaryReader.ILReaderTryGetMetadataSnapshot *
                                                       suggestNamesForErrors:bool *
                                                       keepAllBackgroundSymbolUses:bool *
                                                       enableBackgroundItemKeyStoreAndSemanticClassification:bool *
                                                       enablePartialTypeChecking:bool *
                                                       dependencyProvider:Microsoft.DotNet.DependencyManager.DependencyProvider option ->
                                                         AbstractIL.Internal.Library.Cancellable<IncrementalBuilder option *
                                                                                                 SourceCodeServices.FSharpErrorInfo []>
      member AreCheckResultsBeforeFileInProjectReady : filename:string -> bool
      member ContainsFile : filename:string -> bool
      member
        GetCheckResultsAfterFileInProject : AbstractIL.Internal.Library.CompilationThreadToken *
                                            filename:string ->
                                              AbstractIL.Internal.Library.Cancellable<PartialCheckResults>
      member
        GetCheckResultsAfterLastFileInProject : AbstractIL.Internal.Library.CompilationThreadToken ->
                                                  AbstractIL.Internal.Library.Cancellable<PartialCheckResults>
      member
        GetCheckResultsAndImplementationsForProject : AbstractIL.Internal.Library.CompilationThreadToken ->
                                                        AbstractIL.Internal.Library.Cancellable<PartialCheckResults *
                                                                                                AbstractIL.IL.ILAssemblyRef *
                                                                                                CompilerConfig.IRawFSharpAssemblyData option *
                                                                                                TypedTree.TypedImplFile list option>
      member
        GetCheckResultsBeforeFileInProject : AbstractIL.Internal.Library.CompilationThreadToken *
                                             filename:string ->
                                               AbstractIL.Internal.Library.Cancellable<PartialCheckResults>
      member
        GetCheckResultsBeforeFileInProjectEvenIfStale : filename:string ->
                                                          PartialCheckResults option
      member
        GetCheckResultsBeforeSlotInProject : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                             slotOfFile:int ->
                                               AbstractIL.Internal.Library.Cancellable<PartialCheckResults>
      member
        GetFullCheckResultsAfterFileInProject : AbstractIL.Internal.Library.CompilationThreadToken *
                                                filename:string ->
                                                  AbstractIL.Internal.Library.Cancellable<PartialCheckResults>
      member
        GetFullCheckResultsAndImplementationsForProject : AbstractIL.Internal.Library.CompilationThreadToken ->
                                                            AbstractIL.Internal.Library.Cancellable<PartialCheckResults *
                                                                                                    AbstractIL.IL.ILAssemblyRef *
                                                                                                    CompilerConfig.IRawFSharpAssemblyData option *
                                                                                                    TypedTree.TypedImplFile list option>
      member
        GetLogicalTimeStampForProject : CompilerConfig.TimeStampCache *
                                        AbstractIL.Internal.Library.CompilationThreadToken ->
                                          System.DateTime
      member
        GetParseResultsForFile : AbstractIL.Internal.Library.CompilationThreadToken *
                                 filename:string ->
                                   AbstractIL.Internal.Library.Cancellable<SyntaxTree.ParsedInput option *
                                                                           Range.range *
                                                                           string *
                                                                           (ErrorLogger.PhasedDiagnostic *
                                                                            SourceCodeServices.FSharpErrorSeverity) []>
      member GetSlotOfFileName : filename:string -> int
      member GetSlotsCount : unit -> int
      member
        Step : AbstractIL.Internal.Library.CompilationThreadToken ->
                 AbstractIL.Internal.Library.Cancellable<bool>
      member TryGetCurrentTcImports : unit -> CompilerImports.TcImports option
      member TryGetSlotOfFileName : filename:string -> int option
      member AllDependenciesDeprecated : string []
      member BeforeFileChecked : IEvent<string>
      member FileChecked : IEvent<string>
      member FileParsed : IEvent<string>
      member ImportsInvalidatedByTypeProvider : IEvent<string>
      member ProjectChecked : IEvent<unit>
      member SourceFiles : string list
      member TcConfig : CompilerConfig.TcConfig
    end

namespace FSharp.Compiler.SourceCodeServices
  type DiagnosticKind =
    | AddIndexerDot
    | ReplaceWithSuggestion of suggestion: string
  module CompilerDiagnostics = begin
    val getErrorMessage : diagnosticKind:DiagnosticKind -> string
  end

namespace FSharp.Compiler.SourceCodeServices
  [<RequireQualifiedAccessAttribute ()>]
  type FSharpGlyph =
    | Class
    | Constant
    | Delegate
    | Enum
    | EnumMember
    | Event
    | Exception
    | Field
    | Interface
    | Method
    | OverridenMethod
    | Module
    | NameSpace
    | Property
    | Struct
    | Typedef
    | Type
    | Union
    | Variable
    | ExtensionMethod
    | Error

namespace FSharp.Compiler.SourceCodeServices
  [<SealedAttribute ()>]
  type FSharpMethodGroupItemParameter =
    class
      new : name:string * canonicalTypeTextForSorting:string *
            display:Layout.layout * isOptional:bool ->
              FSharpMethodGroupItemParameter
      member CanonicalTypeTextForSorting : string
      member Display : string
      member IsOptional : bool
      member ParameterName : string
      member StructuredDisplay : Layout.layout
    end
  module internal DescriptionListsImpl = begin
    val isFunction : g:TcGlobals.TcGlobals -> ty:TypedTree.TType -> bool
    val printCanonicalizedTypeName :
      g:TcGlobals.TcGlobals ->
        denv:TypedTreeOps.DisplayEnv -> tau:TypedTree.TType -> string
    val PrettyParamOfRecdField :
      g:TcGlobals.TcGlobals ->
        denv:TypedTreeOps.DisplayEnv ->
          f:TypedTree.RecdField -> FSharpMethodGroupItemParameter
    val PrettyParamOfUnionCaseField :
      g:TcGlobals.TcGlobals ->
        denv:TypedTreeOps.DisplayEnv ->
          isGenerated:(int -> TypedTree.RecdField -> bool) ->
            i:int -> f:TypedTree.RecdField -> FSharpMethodGroupItemParameter
    val ParamOfParamData :
      g:TcGlobals.TcGlobals ->
        denv:TypedTreeOps.DisplayEnv ->
          Infos.ParamData -> FSharpMethodGroupItemParameter
    val PrettyParamsOfParamDatas :
      g:TcGlobals.TcGlobals ->
        denv:TypedTreeOps.DisplayEnv ->
          typarInst:TypedTreeOps.TyparInst ->
            paramDatas:Infos.ParamData list ->
              rty:TypedTree.TType ->
                TypedTreeOps.TyparInst * FSharpMethodGroupItemParameter list *
                Internal.Utilities.StructuredFormat.Layout *
                Internal.Utilities.StructuredFormat.Layout
    val PrettyParamsOfTypes :
      g:TcGlobals.TcGlobals ->
        denv:TypedTreeOps.DisplayEnv ->
          typarInst:TypedTreeOps.TyparInst ->
            paramTys:TypedTree.TTypes ->
              retTy:TypedTree.TType ->
                TypedTreeOps.TyparInst * FSharpMethodGroupItemParameter list *
                Internal.Utilities.StructuredFormat.Layout *
                Internal.Utilities.StructuredFormat.Layout
    val StaticParamsOfItem :
      infoReader:InfoReader.InfoReader ->
        m:Range.range ->
          denv:TypedTreeOps.DisplayEnv ->
            item:NameResolution.Item -> FSharpMethodGroupItemParameter []
    val PrettyParamsAndReturnTypeOfItem :
      infoReader:InfoReader.InfoReader ->
        m:Range.range ->
          denv:TypedTreeOps.DisplayEnv ->
            item:NameResolution.ItemWithInst ->
              FSharpMethodGroupItemParameter list *
              Internal.Utilities.StructuredFormat.Layout
    val GlyphOfItem :
      denv:TypedTreeOps.DisplayEnv * item:NameResolution.Item -> FSharpGlyph
    val AnotherFlattenItems :
      g:TcGlobals.TcGlobals ->
        m:Range.range -> item:NameResolution.Item -> NameResolution.Item list
  end
  [<SealedAttribute ()>]
  type FSharpDeclarationListItem =
    class
      new : name:string * nameInCode:string * fullName:string *
            glyph:FSharpGlyph *
            info:Choice<(CompletionItem list * InfoReader.InfoReader *
                         Range.range * TypedTreeOps.DisplayEnv),
                        FSharpToolTipText<Layout>> *
            accessibility:FSharpAccessibility option * kind:CompletionItemKind *
            isOwnMember:bool * priority:int * isResolved:bool *
            namespaceToOpen:string option -> FSharpDeclarationListItem
      member Accessibility : FSharpAccessibility option
      member DescriptionText : FSharpToolTipText
      [<System.Obsolete
        ("This operation is no longer asynchronous, please use the non-async version")>]
      member DescriptionTextAsync : Async<FSharpToolTipText>
      member FullName : string
      member Glyph : FSharpGlyph
      member IsOwnMember : bool
      member IsResolved : bool
      member Kind : CompletionItemKind
      member MinorPriority : int
      member Name : string
      member NameInCode : string
      member NamespaceToOpen : string option
      member StructuredDescriptionText : FSharpToolTipText<Layout>
      [<System.Obsolete
        ("This operation is no longer asynchronous, please use the non-async version")>]
      member StructuredDescriptionTextAsync : Async<FSharpToolTipText<Layout>>
    end
  [<SealedAttribute ()>]
  type FSharpDeclarationListInfo =
    class
      new : declarations:FSharpDeclarationListItem [] * isForType:bool *
            isError:bool -> FSharpDeclarationListInfo
      static member
        Create : infoReader:InfoReader.InfoReader * m:Range.range *
                 denv:TypedTreeOps.DisplayEnv *
                 getAccessibility:(NameResolution.Item ->
                                     FSharpAccessibility option) *
                 items:CompletionItem list * currentNamespace:string [] option *
                 isAttributeApplicationContext:bool -> FSharpDeclarationListInfo
      static member Error : message:string -> FSharpDeclarationListInfo
      member IsError : bool
      member IsForType : bool
      member Items : FSharpDeclarationListItem []
      static member Empty : FSharpDeclarationListInfo
    end
  [<SealedAttribute (); NoEqualityAttribute (); NoComparisonAttribute ()>]
  type FSharpMethodGroupItem =
    class
      new : description:FSharpToolTipText<Layout.layout> * xmlDoc:FSharpXmlDoc *
            returnType:Layout.layout *
            parameters:FSharpMethodGroupItemParameter [] * hasParameters:bool *
            hasParamArrayArg:bool *
            staticParameters:FSharpMethodGroupItemParameter [] ->
              FSharpMethodGroupItem
      member Description : FSharpToolTipText
      member HasParamArrayArg : bool
      member HasParameters : bool
      member Parameters : FSharpMethodGroupItemParameter []
      member ReturnTypeText : string
      member StaticParameters : FSharpMethodGroupItemParameter []
      member StructuredDescription : FSharpToolTipText<Layout.layout>
      member StructuredReturnTypeText : Layout.layout
      member XmlDoc : FSharpXmlDoc
    end
  [<SealedAttribute ()>]
  type FSharpMethodGroup =
    class
      new : string * FSharpMethodGroupItem [] -> FSharpMethodGroup
      static member
        Create : InfoReader.InfoReader * Range.range * TypedTreeOps.DisplayEnv *
                 NameResolution.ItemWithInst list -> FSharpMethodGroup
      member MethodName : string
      member Methods : FSharpMethodGroupItem []
    end

namespace FSharp.Compiler.SourceCodeServices
  type Position = int * int
  type Range = Position * Position
  module FSharpTokenTag = begin
    val Identifier : int
    val String : int
    val IDENT : int
    val STRING : int
    val INTERP_STRING_BEGIN_END : int
    val INTERP_STRING_BEGIN_PART : int
    val INTERP_STRING_PART : int
    val INTERP_STRING_END : int
    val LPAREN : int
    val RPAREN : int
    val LBRACK : int
    val RBRACK : int
    val LBRACE : int
    val RBRACE : int
    val LBRACK_LESS : int
    val GREATER_RBRACK : int
    val LESS : int
    val GREATER : int
    val LBRACK_BAR : int
    val BAR_RBRACK : int
    val PLUS_MINUS_OP : int
    val MINUS : int
    val STAR : int
    val INFIX_STAR_DIV_MOD_OP : int
    val PERCENT_OP : int
    val INFIX_AT_HAT_OP : int
    val QMARK : int
    val COLON : int
    val EQUALS : int
    val SEMICOLON : int
    val COMMA : int
    val DOT : int
    val DOT_DOT : int
    val DOT_DOT_HAT : int
    val INT32_DOT_DOT : int
    val UNDERSCORE : int
    val BAR : int
    val COLON_GREATER : int
    val COLON_QMARK_GREATER : int
    val COLON_QMARK : int
    val INFIX_BAR_OP : int
    val INFIX_COMPARE_OP : int
    val COLON_COLON : int
    val AMP_AMP : int
    val PREFIX_OP : int
    val COLON_EQUALS : int
    val BAR_BAR : int
    val RARROW : int
    val LARROW : int
    val QUOTE : int
    val WHITESPACE : int
    val COMMENT : int
    val LINE_COMMENT : int
    val BEGIN : int
    val DO : int
    val FUNCTION : int
    val THEN : int
    val ELSE : int
    val STRUCT : int
    val CLASS : int
    val TRY : int
    val NEW : int
    val WITH : int
    val OWITH : int
  end
  type FSharpTokenColorKind =
    | Default = 0
    | Text = 0
    | Keyword = 1
    | Comment = 2
    | Identifier = 3
    | String = 4
    | UpperIdentifier = 5
    | InactiveCode = 7
    | PreprocessorKeyword = 8
    | Number = 9
    | Operator = 10
    | Punctuation = 11
  type FSharpTokenTriggerClass =
    | None = 0
    | MemberSelect = 1
    | MatchBraces = 2
    | ChoiceSelect = 4
    | MethodTip = 240
    | ParamStart = 16
    | ParamNext = 32
    | ParamEnd = 64
  type FSharpTokenCharKind =
    | Default = 0
    | Text = 0
    | Keyword = 1
    | Identifier = 2
    | String = 3
    | Literal = 4
    | Operator = 5
    | Delimiter = 6
    | WhiteSpace = 8
    | LineComment = 9
    | Comment = 10
  type FSharpTokenInfo =
    { LeftColumn: int
      RightColumn: int
      ColorClass: FSharpTokenColorKind
      CharClass: FSharpTokenCharKind
      FSharpTokenTriggerClass: FSharpTokenTriggerClass
      Tag: int
      TokenName: string
      FullMatchedLength: int }
  module internal TokenClassifications = begin
    val tokenInfo :
      token:Parser.token ->
        FSharpTokenColorKind * FSharpTokenCharKind * FSharpTokenTriggerClass
  end
  module internal TestExpose = begin
    val TokenInfo :
      Parser.token ->
        FSharpTokenColorKind * FSharpTokenCharKind * FSharpTokenTriggerClass
  end
  [<StructAttribute (); CustomEqualityAttribute (); NoComparisonAttribute ()>]
  type FSharpTokenizerLexState =
    { PosBits: int64
      OtherBits: int64 }
    with
      override Equals : obj:obj -> bool
      member Equals : FSharpTokenizerLexState -> bool
      override GetHashCode : unit -> int
      static member Initial : FSharpTokenizerLexState
    end
  type FSharpTokenizerColorState =
    | Token = 1
    | IfDefSkip = 3
    | String = 4
    | Comment = 5
    | StringInComment = 6
    | VerbatimStringInComment = 7
    | CamlOnly = 8
    | VerbatimString = 9
    | SingleLineComment = 10
    | EndLineThenSkip = 11
    | EndLineThenToken = 12
    | TripleQuoteString = 13
    | TripleQuoteStringInComment = 14
    | InitialState = 0
  module internal LexerStateEncoding = begin
    val computeNextLexState :
      token:Parser.token ->
        prevLexcont:ParseHelpers.LexerContinuation ->
          ParseHelpers.LexerContinuation
    val revertToDefaultLexCont : ParseHelpers.LexerContinuation
    val lexstateNumBits : int
    val ncommentsNumBits : int
    val hardwhiteNumBits : int
    val ifdefstackCountNumBits : int
    val ifdefstackNumBits : int
    val stringKindBits : int
    val nestingBits : int
    val lexstateStart : int
    val ncommentsStart : int
    val hardwhitePosStart : int
    val ifdefstackCountStart : int
    val ifdefstackStart : int
    val stringKindStart : int
    val nestingStart : int
    val lexstateMask : int64
    val ncommentsMask : int64
    val hardwhitePosMask : int64
    val ifdefstackCountMask : int64
    val ifdefstackMask : int64
    val stringKindMask : int64
    val nestingMask : int64
    val bitOfBool : b:bool -> int
    val boolOfBit : n:int64 -> bool
    val colorStateOfLexState :
      state:FSharpTokenizerLexState -> FSharpTokenizerColorState
    val lexStateOfColorState : state:FSharpTokenizerColorState -> int64
    val encodeStringStyle : kind:ParseHelpers.LexerStringStyle -> int
    val decodeStringStyle : kind:int -> ParseHelpers.LexerStringStyle
    val encodeLexCont :
      colorState:FSharpTokenizerColorState * numComments:int64 * b:Range.pos *
      ifdefStack:seq<ParseHelpers.LexerIfdefStackEntry * 'a> * light:bool *
      stringKind:ParseHelpers.LexerStringKind *
      stringNest:(int * ParseHelpers.LexerStringStyle * 'b) list ->
        FSharpTokenizerLexState
    val decodeLexCont :
      state:FSharpTokenizerLexState ->
        FSharpTokenizerColorState * int32 * Range.pos *
        (ParseHelpers.LexerIfdefStackEntry * Range.range) list * bool *
        ParseHelpers.LexerStringKind *
        ParseHelpers.LexerInterpolatedStringNesting
    val encodeLexInt :
      lightStatus:bool ->
        lexcont:ParseHelpers.LexerContinuation -> FSharpTokenizerLexState
    val decodeLexInt :
      state:FSharpTokenizerLexState -> bool * ParseHelpers.LexerContinuation
  end
  type SingleLineTokenState =
    | BeforeHash = 0
    | NoFurtherMatchPossible = 1
  [<SealedAttribute ()>]
  type FSharpLineTokenizer =
    class
      new : lexbuf:UnicodeLexing.Lexbuf * maxLength:int option *
            filename:string option * lexargs:Lexhelp.LexArgs ->
              FSharpLineTokenizer
      static member
        ColorStateOfLexState : FSharpTokenizerLexState ->
                                 FSharpTokenizerColorState
      static member
        LexStateOfColorState : FSharpTokenizerColorState ->
                                 FSharpTokenizerLexState
      member
        ScanToken : lexState:FSharpTokenizerLexState ->
                      FSharpTokenInfo option * FSharpTokenizerLexState
    end
  [<SealedAttribute ()>]
  type FSharpSourceTokenizer =
    class
      new : conditionalDefines:string list * filename:string option ->
              FSharpSourceTokenizer
      member
        CreateBufferTokenizer : bufferFiller:(char [] * int * int -> int) ->
                                  FSharpLineTokenizer
      member CreateLineTokenizer : lineText:string -> FSharpLineTokenizer
    end
  module Keywords = begin
    val DoesIdentifierNeedQuotation : string -> bool
    val QuoteIdentifierIfNeeded : string -> string
    val NormalizeIdentifierBackticks : string -> string
    val KeywordsWithDescription : (string * string) list
  end
  module Lexer = begin
    [<System.Flags ();
      ExperimentalAttribute
      ("This FCS API is experimental and subject to change.")>]
    type FSharpLexerFlags =
      | Default = 69649
      | LightSyntaxOn = 1
      | Compiling = 16
      | CompilingFSharpCore = 272
      | SkipTrivia = 4096
      | UseLexFilter = 65536
    [<RequireQualifiedAccessAttribute ();
      ExperimentalAttribute
      ("This FCS API is experimental and subject to change.")>]
    type FSharpSyntaxTokenKind =
      | None
      | HashIf
      | HashElse
      | HashEndIf
      | CommentTrivia
      | WhitespaceTrivia
      | HashLine
      | HashLight
      | InactiveCode
      | LineCommentTrivia
      | StringText
      | Fixed
      | OffsideInterfaceMember
      | OffsideBlockEnd
      | OffsideRightBlockEnd
      | OffsideDeclEnd
      | OffsideEnd
      | OffsideBlockSep
      | OffsideBlockBegin
      | OffsideReset
      | OffsideFun
      | OffsideFunction
      | OffsideWith
      | OffsideElse
      | OffsideThen
      | OffsideDoBang
      | OffsideDo
      | OffsideBinder
      | OffsideLet
      | HighPrecedenceTypeApp
      | HighPrecedenceParenthesisApp
      | HighPrecedenceBracketApp
      | Extern
      | Void
      | Public
      | Private
      | Internal
      | Global
      | Static
      | Member
      | Class
      | Abstract
      | Override
      | Default
      | Constructor
      | Inherit
      | GreaterRightBracket
      | Struct
      | Sig
      | Bar
      | RightBracket
      | RightBrace
      | Minus
      | Dollar
      | BarRightBracket
      | BarRightBrace
      | Underscore
      | Semicolon
      | SemicolonSemicolon
      | LeftArrow
      | Equals
      | LeftBracket
      | LeftBracketBar
      | LeftBraceBar
      | LeftBracketLess
      | LeftBrace
      | QuestionMark
      | QuestionMarkQuestionMark
      | Dot
      | Colon
      | ColonColon
      | ColonGreater
      | ColonQuestionMark
      | ColonQuestionMarkGreater
      | ColonEquals
      | When
      | While
      | With
      | Hash
      | Ampersand
      | AmpersandAmpersand
      | Quote
      | LeftParenthesis
      | RightParenthesis
      | Star
      | Comma
      | RightArrow
      | GreaterBarRightBracket
      | LeftParenthesisStarRightParenthesis
      | Open
      | Or
      | Rec
      | Then
      | To
      | True
      | Try
      | Type
      | Val
      | Inline
      | Interface
      | Instance
      | Const
      | Lazy
      | OffsideLazy
      | Match
      | MatchBang
      | Mutable
      | New
      | Of
      | Exception
      | False
      | For
      | Fun
      | Function
      | If
      | In
      | JoinIn
      | Finally
      | DoBang
      | And
      | As
      | Assert
      | OffsideAssert
      | Begin
      | Do
      | Done
      | DownTo
      | Else
      | Elif
      | End
      | DotDot
      | DotDotHat
      | BarBar
      | Upcast
      | Downcast
      | Null
      | Reserved
      | Module
      | Namespace
      | Delegate
      | Constraint
      | Base
      | LeftQuote
      | RightQuote
      | RightQuoteDot
      | PercentOperator
      | Binder
      | Less
      | Greater
      | Let
      | Yield
      | YieldBang
      | BigNumber
      | Decimal
      | Char
      | Ieee64
      | Ieee32
      | NativeInt
      | UNativeInt
      | UInt64
      | UInt32
      | UInt16
      | UInt8
      | Int64
      | Int32
      | Int32DotDot
      | Int16
      | Int8
      | FunkyOperatorName
      | AdjacentPrefixOperator
      | PlusMinusOperator
      | InfixAmpersandOperator
      | InfixStarDivideModuloOperator
      | PrefixOperator
      | InfixBarOperator
      | InfixAtHatOperator
      | InfixCompareOperator
      | InfixStarStarOperator
      | Identifier
      | KeywordString
      | String
      | ByteArray
      | Asr
      | InfixAsr
      | InfixLand
      | InfixLor
      | InfixLsl
      | InfixLsr
      | InfixLxor
      | InfixMod
    [<StructAttribute (); NoComparisonAttribute (); NoEqualityAttribute ();
      ExperimentalAttribute
      ("This FCS API is experimental and subject to change.")>]
    type FSharpSyntaxToken =
      struct
        new : tok:Parser.token * tokRange:Range.range -> FSharpSyntaxToken
        val private tok: Parser.token
        val private tokRange: Range.range
        member IsCommentTrivia : bool
        member IsIdentifier : bool
        member IsKeyword : bool
        member IsNumericLiteral : bool
        member IsStringLiteral : bool
        member Kind : FSharpSyntaxTokenKind
        member Range : Range.range
      end
    val lexWithErrorLogger :
      text:Text.ISourceText ->
        conditionalCompilationDefines:string list ->
          flags:FSharpLexerFlags ->
            supportsFeature:(Features.LanguageFeature -> bool) ->
              errorLogger:ErrorLogger.ErrorLogger ->
                onToken:(Parser.token -> Range.range -> unit) ->
                  pathMap:Internal.Utilities.PathMap ->
                    ct:System.Threading.CancellationToken -> unit
    val lex :
      text:Text.ISourceText ->
        conditionalCompilationDefines:string list ->
          flags:FSharpLexerFlags ->
            supportsFeature:(Features.LanguageFeature -> bool) ->
              lexCallback:(Parser.token -> Range.range -> unit) ->
                pathMap:Internal.Utilities.PathMap ->
                  ct:System.Threading.CancellationToken -> unit
    [<AbstractClassAttribute (); SealedAttribute ();
      ExperimentalAttribute
      ("This FCS API is experimental and subject to change.")>]
    type FSharpLexer =
      class
        [<ExperimentalAttribute
          ("This FCS API is experimental and subject to change.")>]
        static member
          Lex : text:Text.ISourceText *
                tokenCallback:(FSharpSyntaxToken -> unit) * ?langVersion:string *
                ?filePath:string * ?conditionalCompilationDefines:string list *
                ?flags:FSharpLexerFlags * ?pathMap:Map<string,string> *
                ?ct:System.Threading.CancellationToken -> unit
      end
  end

namespace FSharp.Compiler.SourceCodeServices
  module AstTraversal = begin
    val rangeContainsPosLeftEdgeInclusive :
      m1:Range.range -> p:Range.pos -> bool
    val rangeContainsPosEdgesExclusive : m1:Range.range -> p:Range.pos -> bool
    val rangeContainsPosLeftEdgeExclusiveAndRightEdgeInclusive :
      m1:Range.range -> p:Range.pos -> bool
    [<RequireQualifiedAccessAttribute ()>]
    type TraverseStep =
      | Expr of SyntaxTree.SynExpr
      | Module of SyntaxTree.SynModuleDecl
      | ModuleOrNamespace of SyntaxTree.SynModuleOrNamespace
      | TypeDefn of SyntaxTree.SynTypeDefn
      | MemberDefn of SyntaxTree.SynMemberDefn
      | MatchClause of SyntaxTree.SynMatchClause
      | Binding of SyntaxTree.SynBinding
    type TraversePath = TraverseStep list
    [<AbstractClassAttribute ()>]
    type AstVisitorBase<'T> =
      class
        new : unit -> AstVisitorBase<'T>
        override
          VisitBinding : defaultTraverse:(SyntaxTree.SynBinding -> 'T option) *
                         binding:SyntaxTree.SynBinding -> 'T option
        abstract member
          VisitBinding : (SyntaxTree.SynBinding -> 'T option) *
                         SyntaxTree.SynBinding -> 'T option
        override VisitComponentInfo : SyntaxTree.SynComponentInfo -> 'T option
        abstract member
          VisitComponentInfo : SyntaxTree.SynComponentInfo -> 'T option
        abstract member
          VisitExpr : TraversePath * (SyntaxTree.SynExpr -> 'T option) *
                      (SyntaxTree.SynExpr -> 'T option) * SyntaxTree.SynExpr ->
                        'T option
        override VisitHashDirective : Range.range -> 'T option
        abstract member VisitHashDirective : Range.range -> 'T option
        override
          VisitImplicitInherit : defaultTraverse:(SyntaxTree.SynExpr ->
                                                    'T option) *
                                 _ty:SyntaxTree.SynType *
                                 expr:SyntaxTree.SynExpr * _m:Range.range ->
                                   'T option
        abstract member
          VisitImplicitInherit : (SyntaxTree.SynExpr -> 'T option) *
                                 SyntaxTree.SynType * SyntaxTree.SynExpr *
                                 Range.range -> 'T option
        override
          VisitInheritSynMemberDefn : _componentInfo:SyntaxTree.SynComponentInfo *
                                      _typeDefnKind:SyntaxTree.SynTypeDefnKind *
                                      _synType:SyntaxTree.SynType *
                                      _members:SyntaxTree.SynMemberDefns *
                                      _range:Range.range -> 'T option
        abstract member
          VisitInheritSynMemberDefn : SyntaxTree.SynComponentInfo *
                                      SyntaxTree.SynTypeDefnKind *
                                      SyntaxTree.SynType *
                                      SyntaxTree.SynMemberDefns * Range.range ->
                                        'T option
        override
          VisitInterfaceSynMemberDefnType : _synType:SyntaxTree.SynType ->
                                              'T option
        abstract member
          VisitInterfaceSynMemberDefnType : SyntaxTree.SynType -> 'T option
        override
          VisitLetOrUse : TraversePath * (SyntaxTree.SynBinding -> 'T option) *
                          SyntaxTree.SynBinding list * Range.range -> 'T option
        abstract member
          VisitLetOrUse : TraversePath * (SyntaxTree.SynBinding -> 'T option) *
                          SyntaxTree.SynBinding list * Range.range -> 'T option
        override
          VisitMatchClause : defaultTraverse:(SyntaxTree.SynMatchClause ->
                                                'T option) *
                             mc:SyntaxTree.SynMatchClause -> 'T option
        abstract member
          VisitMatchClause : (SyntaxTree.SynMatchClause -> 'T option) *
                             SyntaxTree.SynMatchClause -> 'T option
        override
          VisitModuleDecl : defaultTraverse:(SyntaxTree.SynModuleDecl ->
                                               'T option) *
                            decl:SyntaxTree.SynModuleDecl -> 'T option
        abstract member
          VisitModuleDecl : (SyntaxTree.SynModuleDecl -> 'T option) *
                            SyntaxTree.SynModuleDecl -> 'T option
        override
          VisitModuleOrNamespace : SyntaxTree.SynModuleOrNamespace -> 'T option
        abstract member
          VisitModuleOrNamespace : SyntaxTree.SynModuleOrNamespace -> 'T option
        override
          VisitPat : defaultTraverse:(SyntaxTree.SynPat -> 'T option) *
                     pat:SyntaxTree.SynPat -> 'T option
        abstract member
          VisitPat : (SyntaxTree.SynPat -> 'T option) * SyntaxTree.SynPat ->
                       'T option
        override
          VisitRecordField : _path:TraversePath *
                             _copyOpt:SyntaxTree.SynExpr option *
                             _recordField:SyntaxTree.LongIdentWithDots option ->
                               'T option
        abstract member
          VisitRecordField : TraversePath * SyntaxTree.SynExpr option *
                             SyntaxTree.LongIdentWithDots option -> 'T option
        override VisitSimplePats : SyntaxTree.SynSimplePat list -> 'T option
        abstract member
          VisitSimplePats : SyntaxTree.SynSimplePat list -> 'T option
        override
          VisitType : defaultTraverse:(SyntaxTree.SynType -> 'T option) *
                      ty:SyntaxTree.SynType -> 'T option
        abstract member
          VisitType : (SyntaxTree.SynType -> 'T option) * SyntaxTree.SynType ->
                        'T option
        override
          VisitTypeAbbrev : _ty:SyntaxTree.SynType * _m:Range.range -> 'T option
        abstract member
          VisitTypeAbbrev : SyntaxTree.SynType * Range.range -> 'T option
      end
    val dive : node:'a -> range:'b -> project:('a -> 'c) -> 'b * (unit -> 'c)
    val pick :
      pos:Range.pos ->
        outerRange:Range.range ->
          _debugObj:obj ->
            diveResults:(Range.range * (unit -> 'a option)) list -> 'a option
    val Traverse :
      pos:Range.pos * parseTree:SyntaxTree.ParsedInput *
      visitor:AstVisitorBase<'T> -> 'T option
  end

namespace FSharp.Compiler.SourceCodeServices
  type FSharpNavigationDeclarationItemKind =
    | NamespaceDecl
    | ModuleFileDecl
    | ExnDecl
    | ModuleDecl
    | TypeDecl
    | MethodDecl
    | PropertyDecl
    | FieldDecl
    | OtherDecl
  [<RequireQualifiedAccessAttribute ()>]
  type FSharpEnclosingEntityKind =
    | Namespace
    | Module
    | Class
    | Exception
    | Interface
    | Record
    | Enum
    | DU
  [<SealedAttribute ()>]
  type FSharpNavigationDeclarationItem =
    class
      new : uniqueName:string * name:string *
            kind:FSharpNavigationDeclarationItemKind * glyph:FSharpGlyph *
            range:Range.range * bodyRange:Range.range * singleTopLevel:bool *
            enclosingEntityKind:FSharpEnclosingEntityKind * isAbstract:bool *
            access:SyntaxTree.SynAccess option ->
              FSharpNavigationDeclarationItem
      static member
        Create : name:string * kind:FSharpNavigationDeclarationItemKind *
                 glyph:FSharpGlyph * range:Range.range * bodyRange:Range.range *
                 singleTopLevel:bool *
                 enclosingEntityKind:FSharpEnclosingEntityKind * isAbstract:bool *
                 access:SyntaxTree.SynAccess option ->
                   FSharpNavigationDeclarationItem
      member
        WithUniqueName : uniqueName:string -> FSharpNavigationDeclarationItem
      member Access : SyntaxTree.SynAccess option
      member BodyRange : Range.range
      member EnclosingEntityKind : FSharpEnclosingEntityKind
      member Glyph : FSharpGlyph
      member IsAbstract : bool
      member IsSingleTopLevel : bool
      member Kind : FSharpNavigationDeclarationItemKind
      member Name : string
      member Range : Range.range
      member UniqueName : string
      member bodyRange : Range.range
    end
  [<NoEqualityAttribute (); NoComparisonAttribute ()>]
  type FSharpNavigationTopLevelDeclaration =
    { Declaration: FSharpNavigationDeclarationItem
      Nested: FSharpNavigationDeclarationItem [] }
  [<SealedAttribute ()>]
  type FSharpNavigationItems =
    class
      new : declarations:FSharpNavigationTopLevelDeclaration [] ->
              FSharpNavigationItems
      member Declarations : FSharpNavigationTopLevelDeclaration []
    end
  module NavigationImpl = begin
    val unionRangesChecked : r1:Range.range -> r2:Range.range -> Range.range
    val rangeOfDecls2 :
      f:('a -> FSharpNavigationDeclarationItem) -> decls:'a list -> Range.range
    val rangeOfDecls :
      ((FSharpNavigationDeclarationItem * int) list -> Range.range)
    val moduleRange :
      idm:Range.range ->
        others:(FSharpNavigationDeclarationItem * 'a * 'b) list -> Range.range
    val fldspecRange : fldspec:SyntaxTree.SynUnionCaseType -> Range.range
    val bodyRange :
      mb:Range.range ->
        decls:(FSharpNavigationDeclarationItem * int) list -> Range.range
    val getNavigationFromImplFile :
      modules:SyntaxTree.SynModuleOrNamespace list -> FSharpNavigationItems
    val getNavigationFromSigFile :
      modules:SyntaxTree.SynModuleOrNamespaceSig list -> FSharpNavigationItems
  end
  module FSharpNavigation = begin
    val getNavigation : SyntaxTree.ParsedInput -> FSharpNavigationItems
    val empty : FSharpNavigationItems
  end
  module NavigateTo = begin
    [<RequireQualifiedAccessAttribute ()>]
    type NavigableItemKind =
      | Module
      | ModuleAbbreviation
      | Exception
      | Type
      | ModuleValue
      | Field
      | Property
      | Constructor
      | Member
      | EnumCase
      | UnionCase
      with
        override ToString : unit -> string
      end
    [<RequireQualifiedAccessAttribute ()>]
    type ContainerType =
      | File
      | Namespace
      | Module
      | Type
      | Exception
    type Container =
      { Type: ContainerType
        Name: string }
    type NavigableItem =
      { Name: string
        Range: Range.range
        IsSignature: bool
        Kind: NavigableItemKind
        Container: Container }
    val getNavigableItems : SyntaxTree.ParsedInput -> NavigableItem []
  end

namespace FSharp.Compiler.SourceCodeServices
  [<SealedAttribute ()>]
  type FSharpNoteworthyParamInfoLocations =
    class
      new : longId:string list * longIdRange:Range.range *
            openParenLocation:Range.pos * tupleEndLocations:Range.pos list *
            isThereACloseParen:bool * namedParamNames:string option list ->
              FSharpNoteworthyParamInfoLocations
      static member
        Find : Range.pos * SyntaxTree.ParsedInput ->
                 FSharpNoteworthyParamInfoLocations option
      member IsThereACloseParen : bool
      member LongId : string list
      member LongIdEndLocation : Range.pos
      member LongIdStartLocation : Range.pos
      member NamedParamNames : string option []
      member OpenParenLocation : Range.pos
      member TupleEndLocations : Range.pos []
    end
  module internal NoteworthyParamInfoLocationsImpl = begin
    val isStaticArg : SyntaxTree.SynType -> bool
    val digOutIdentFromFuncExpr :
      synExpr:SyntaxTree.SynExpr -> (string list * Range.range) option
    type FindResult =
      | Found of
        openParen: Range.pos *
        commasAndCloseParen: (Range.pos * string option) list *
        hasClosedParen: bool
      | NotFound
    val digOutIdentFromStaticArg : SyntaxTree.SynType -> string option
    val getNamedParamName : e:SyntaxTree.SynExpr -> string option
    val getTypeName : synType:SyntaxTree.SynType -> string list
    val handleSingleArg :
      traverseSynExpr:(SyntaxTree.SynExpr -> 'a option) ->
        pos:Range.pos * synExpr:SyntaxTree.SynExpr * parenRange:Range.range *
        rpRangeOpt:'b option -> FindResult * 'c option
    val searchSynArgExpr :
      traverseSynExpr:(SyntaxTree.SynExpr -> 'a option) ->
        pos:Range.pos ->
          expr:SyntaxTree.SynExpr -> FindResult * 'a option option
    val ( |StaticParameters|_| ) :
      pos:Range.pos ->
        SyntaxTree.SynType -> FSharpNoteworthyParamInfoLocations option
    val traverseInput :
      pos:Range.pos * parseTree:SyntaxTree.ParsedInput ->
        FSharpNoteworthyParamInfoLocations option
  end
  module internal SynExprAppLocationsImpl = begin
    val private searchSynArgExpr :
      traverseSynExpr:(SyntaxTree.SynExpr -> 'a option) ->
        expr:SyntaxTree.SynExpr ->
          ranges:Range.range list -> Range.range list option * 'a option option
    val getAllCurriedArgsAtPosition :
      pos:Range.pos ->
        parseTree:SyntaxTree.ParsedInput -> Range.range list option
  end

namespace FSharp.Compiler.SourceCodeServices
  module SourceFile = begin
    val private compilableExtensions : string list
    val private singleFileProjectExtensions : string list
    val IsCompilable : string -> bool
    val MustBeSingleFileProject : string -> bool
  end
  module SourceFileImpl = begin
    val IsInterfaceFile : string -> bool
    val AdditionalDefinesForUseInEditor : isInteractive:bool -> string list
  end
  type CompletionPath = string list * string option
  [<RequireQualifiedAccessAttribute ()>]
  type InheritanceOrigin =
    | Class
    | Interface
    | Unknown
  [<RequireQualifiedAccessAttribute ()>]
  type InheritanceContext =
    | Class
    | Interface
    | Unknown
  [<RequireQualifiedAccessAttribute ()>]
  type RecordContext =
    | CopyOnUpdate of Range.range * CompletionPath
    | Constructor of string
    | New of CompletionPath
  [<RequireQualifiedAccessAttribute ()>]
  type CompletionContext =
    | Invalid
    | Inherit of InheritanceContext * CompletionPath
    | RecordField of RecordContext
    | RangeOperator
    | ParameterList of Range.pos * System.Collections.Generic.HashSet<string>
    | AttributeApplication
    | OpenDeclaration of isOpenType: bool
    | PatternType
  [<SealedAttribute ()>]
  type FSharpParseFileResults =
    class
      new : errors:FSharpErrorInfo [] * input:SyntaxTree.ParsedInput option *
            parseHadErrors:bool * dependencyFiles:string [] ->
              FSharpParseFileResults
      member
        FindNoteworthyParamInfoLocations : pos:Range.pos ->
                                             FSharpNoteworthyParamInfoLocations option
      member
        GetAllArgumentsForFunctionApplicationAtPostion : pos:Range.pos ->
                                                           Range.range list option
      member GetNavigationItems : unit -> FSharpNavigationItems
      member private GetNavigationItemsImpl : unit -> FSharpNavigationItems
      member IsPosContainedInApplication : pos:Range.pos -> bool
      member IsPositionContainedInACurriedParameter : pos:Range.pos -> bool
      member
        TryIdentOfPipelineContainingPosAndNumArgsApplied : pos:Range.pos ->
                                                             (SyntaxTree.Ident *
                                                              int) option
      member TryRangeOfExprInYieldOrReturn : pos:Range.pos -> Range.range option
      member
        TryRangeOfFunctionOrMethodBeingApplied : pos:Range.pos ->
                                                   Range.range option
      member
        TryRangeOfParenEnclosingOpEqualsGreaterUsage : opGreaterEqualPos:Range.pos ->
                                                         (Range.range *
                                                          Range.range *
                                                          Range.range) option
      member
        TryRangeOfRecordExpressionContainingPos : pos:Range.pos ->
                                                    Range.range option
      member
        TryRangeOfRefCellDereferenceContainingPos : expressionPos:Range.pos ->
                                                      Range.range option
      member ValidateBreakpointLocation : pos:Range.pos -> Range.range option
      member
        private ValidateBreakpointLocationImpl : pos:Range.pos ->
                                                   Range.range option
      member DependencyFiles : string []
      member Errors : FSharpErrorInfo []
      member FileName : string
      member ParseHadErrors : bool
      member ParseTree : SyntaxTree.ParsedInput option
    end
  type ModuleKind =
    { IsAutoOpen: bool
      HasModuleSuffix: bool }
  [<RequireQualifiedAccessAttribute ()>]
  type EntityKind =
    | Attribute
    | Type
    | FunctionOrValue of isActivePattern: bool
    | Module of ModuleKind
    with
      override ToString : unit -> string
    end
  module UntypedParseImpl = begin
    val emptyStringSet : System.Collections.Generic.HashSet<string>
    val GetRangeOfExprLeftOfDot :
      Range.pos * SyntaxTree.ParsedInput option -> Range.range option
    val TryFindExpressionIslandInPosition :
      Range.pos * SyntaxTree.ParsedInput option -> string option
    val TryFindExpressionASTLeftOfDotLeftOfCursor :
      Range.pos * SyntaxTree.ParsedInput option -> (Range.pos * bool) option
    val GetEntityKind : Range.pos * SyntaxTree.ParsedInput -> EntityKind option
    type internal TS = AstTraversal.TraverseStep
    val insideAttributeApplicationRegex : System.Text.RegularExpressions.Regex
    val TryGetCompletionContext :
      Range.pos * SyntaxTree.ParsedInput * lineStr:string ->
        CompletionContext option
    val GetFullNameOfSmallestModuleOrNamespaceAtPoint :
      SyntaxTree.ParsedInput * Range.pos -> string []
  end

namespace FSharp.Compiler.SourceCodeServices
  type ShortIdent = string
  type Idents = ShortIdent []
  type MaybeUnresolvedIdent =
    { Ident: ShortIdent
      Resolved: bool }
  type MaybeUnresolvedIdents = MaybeUnresolvedIdent []
  type IsAutoOpen = bool
  module Extensions = begin
    type FSharpEntity with
      member TryGetFullName : unit -> string option
    type FSharpEntity with
      member TryGetFullDisplayName : unit -> string option
    type FSharpEntity with
      member TryGetFullCompiledName : unit -> string option
    type FSharpEntity with
      member PublicNestedEntities : seq<FSharpEntity>
    type FSharpEntity with
      member
        TryGetMembersFunctionsAndValues : System.Collections.Generic.IList<FSharpMemberOrFunctionOrValue>
    type FSharpMemberOrFunctionOrValue with
      member FullTypeSafe : FSharpType option
    type FSharpMemberOrFunctionOrValue with
      member TryGetFullDisplayName : unit -> string option
    type FSharpMemberOrFunctionOrValue with
      member TryGetFullCompiledOperatorNameIdents : unit -> Idents option
    type FSharpAssemblySignature with
      member TryGetEntities : unit -> seq<FSharpEntity>
  end
  [<RequireQualifiedAccessAttribute ()>]
  type LookupType =
    | Fuzzy
    | Precise
  [<NoComparisonAttribute (); NoEqualityAttribute ()>]
  type AssemblySymbol =
    { FullName: string
      CleanedIdents: Idents
      Namespace: Idents option
      NearestRequireQualifiedAccessParent: Idents option
      TopRequireQualifiedAccessParent: Idents option
      AutoOpenParent: Idents option
      Symbol: FSharpSymbol
      Kind: LookupType -> EntityKind
      UnresolvedSymbol: UnresolvedSymbol }
    with
      override ToString : unit -> string
    end
  type AssemblyPath = string
  type AssemblyContentType =
    | Public
    | Full
  type Parent =
    { Namespace: Idents option
      ThisRequiresQualifiedAccess: bool -> Idents option
      TopRequiresQualifiedAccess: bool -> Idents option
      AutoOpen: Idents option
      WithModuleSuffix: Idents option
      IsModule: bool }
    with
      static member
        RewriteParentIdents : parentIdents:Idents option ->
                                idents:Idents -> Idents
      member FixParentModuleSuffix : idents:Idents -> Idents
      member
        FormatEntityFullName : entity:FSharpEntity ->
                                 (string * ShortIdent []) option
      static member Empty : Parent
    end
  type AssemblyContentCacheEntry =
    { FileWriteTime: System.DateTime
      ContentType: AssemblyContentType
      Symbols: AssemblySymbol list }
  [<NoComparisonAttribute (); NoEqualityAttribute ()>]
  type IAssemblyContentCache =
    interface
      abstract member Set : AssemblyPath -> AssemblyContentCacheEntry -> unit
      abstract member TryGet : AssemblyPath -> AssemblyContentCacheEntry option
    end
  module AssemblyContentProvider = begin
    val unresolvedSymbol :
      topRequireQualifiedAccessParent:Idents option ->
        cleanedIdents:Idents -> fullName:string -> UnresolvedSymbol
    val createEntity :
      ns:Idents option ->
        parent:Parent -> entity:FSharpEntity -> AssemblySymbol option
    val traverseMemberFunctionAndValues :
      ns:Idents option ->
        parent:Parent ->
          membersFunctionsAndValues:seq<FSharpMemberOrFunctionOrValue> ->
            seq<AssemblySymbol>
    val traverseEntity :
      contentType:AssemblyContentType ->
        parent:Parent -> entity:FSharpEntity -> seq<AssemblySymbol>
    val getAssemblySignatureContent :
      AssemblyContentType -> FSharpAssemblySignature -> AssemblySymbol list
    val getAssemblySignaturesContent :
      contentType:AssemblyContentType ->
        assemblies:FSharpAssembly list -> AssemblySymbol list
    val getAssemblyContent :
      withCache:((IAssemblyContentCache -> AssemblySymbol list) ->
                   AssemblySymbol list) ->
        contentType:AssemblyContentType ->
          fileName:string option ->
            assemblies:FSharpAssembly list -> AssemblySymbol list
  end
  type EntityCache =
    class
      interface IAssemblyContentCache
      new : unit -> EntityCache
      member Clear : unit -> unit
      member Locking : (IAssemblyContentCache -> 'T) -> 'T
    end
  type StringLongIdent = string
  type Entity =
    { FullRelativeName: StringLongIdent
      Qualifier: StringLongIdent
      Namespace: StringLongIdent option
      Name: StringLongIdent
      LastIdent: string }
    with
      override ToString : unit -> string
    end
  module Entity = begin
    val getRelativeNamespace : targetNs:Idents -> sourceNs:Idents -> Idents
    val cutAutoOpenModules :
      autoOpenParent:Idents option -> candidateNs:Idents -> ShortIdent []
    val tryCreate :
      targetNamespace:Idents option * targetScope:Idents *
      partiallyQualifiedName:MaybeUnresolvedIdents *
      requiresQualifiedAccessParent:Idents option * autoOpenParent:Idents option *
      candidateNamespace:Idents option * candidate:Idents -> Entity []
  end
  type ScopeKind =
    | Namespace
    | TopModule
    | NestedModule
    | OpenDeclaration
    | HashDirective
    with
      override ToString : unit -> string
    end
  type InsertContext =
    { ScopeKind: ScopeKind
      Pos: Range.pos }
  type Module =
    { Idents: Idents
      Range: Range.range }
  type OpenStatementInsertionPoint =
    | TopLevel
    | Nearest
  module ParsedInput = begin
    val ( |Sequentials|_| ) :
      _arg1:SyntaxTree.SynExpr -> SyntaxTree.SynExpr list option
    val ( |ConstructorPats| ) :
      _arg1:SyntaxTree.SynArgPats -> SyntaxTree.SynPat list
    val getLongIdents :
      input:SyntaxTree.ParsedInput option ->
        System.Collections.Generic.IDictionary<Range.pos,SyntaxTree.LongIdent>
    val getLongIdentAt :
      ast:SyntaxTree.ParsedInput -> pos:Range.pos -> SyntaxTree.LongIdent option
    type Scope =
      { Idents: Idents
        Kind: ScopeKind }
    val tryFindNearestPointAndModules :
      currentLine:int ->
        ast:SyntaxTree.ParsedInput ->
          insertionPoint:OpenStatementInsertionPoint ->
            (Scope * string [] option * Range.pos) option * Module list
    val findBestPositionToInsertOpenDeclaration :
      modules:Module list ->
        scope:Scope -> pos:Range.pos -> entity:Idents -> InsertContext
    val tryFindInsertionContext :
      currentLine:int ->
        ast:SyntaxTree.ParsedInput ->
          MaybeUnresolvedIdents ->
            insertionPoint:OpenStatementInsertionPoint ->
              (Idents option * Idents option * Idents option * Idents ->
                 (Entity * InsertContext) [])
    val adjustInsertionPoint :
      getLineStr:(int -> string) -> ctx:InsertContext -> Range.pos
    val findNearestPointToInsertOpenDeclaration :
      currentLine:int ->
        ast:SyntaxTree.ParsedInput ->
          entity:Idents ->
            insertionPoint:OpenStatementInsertionPoint -> InsertContext
  end

namespace FSharp.Compiler.SourceCodeServices
  type XmlDocable =
    | XmlDocable of line: int * indent: int * paramNames: string list
  module XmlDocParsing = begin
    val ( |ConstructorPats| ) :
      _arg1:SyntaxTree.SynArgPats -> SyntaxTree.SynPat list
    val digNamesFrom : pat:SyntaxTree.SynPat -> string list
    val getXmlDocablesImpl :
      sourceText:Text.ISourceText * input:SyntaxTree.ParsedInput option ->
        XmlDocable list
  end
  module XmlDocComment = begin
    val private ws : s:string * pos:int -> (string * int) option
    val private str :
      prefix:string -> s:string * pos:int -> (string * int) option
    val private eol : s:string * pos:'a -> (string * 'a) option
    val inline private ( >=> ) :
      f:('a -> 'b option) -> g:('b -> 'c option) -> ('a -> 'c option)
    val isBlank : string -> int option
  end
  module XmlDocParser = begin
    val getXmlDocables :
      Text.ISourceText * input:SyntaxTree.ParsedInput option -> XmlDocable list
  end

namespace FSharp.Compiler.SourceCodeServices
  module private Option = begin
    val ofOptionList : xs:'a option list -> 'a list option
  end
  [<RequireQualifiedAccessAttribute ()>]
  type ExternalType =
    | Type of fullName: string * genericArgs: ExternalType list
    | Array of inner: ExternalType
    | Pointer of inner: ExternalType
    | TypeVar of typeName: string
    with
      override ToString : unit -> string
    end
  module ExternalType = begin
    val internal tryOfILType :
      string array -> AbstractIL.IL.ILType -> ExternalType option
  end
  [<RequireQualifiedAccessAttribute ()>]
  type ParamTypeSymbol =
    | Param of ExternalType
    | Byref of ExternalType
    with
      override ToString : unit -> string
    end
  module ParamTypeSymbol = begin
    val internal tryOfILType :
      string array -> AbstractIL.IL.ILType -> ParamTypeSymbol option
    val internal tryOfILTypes :
      string array -> AbstractIL.IL.ILType list -> ParamTypeSymbol list option
  end
  [<RequireQualifiedAccessAttribute ();
    System.Diagnostics.DebuggerDisplay ("{ToDebuggerDisplay(),nq}")>]
  type ExternalSymbol =
    | Type of fullName: string
    | Constructor of typeName: string * args: ParamTypeSymbol list
    | Method of
      typeName: string * name: string * paramSyms: ParamTypeSymbol list *
      genericArity: int
    | Field of typeName: string * name: string
    | Event of typeName: string * name: string
    | Property of typeName: string * name: string
    with
      member internal ToDebuggerDisplay : unit -> string
      override ToString : unit -> string
    end

namespace FSharp.Compiler
  type PartialLongName =
    { QualifyingIdents: string list
      PartialIdent: string
      EndColumn: int
      LastDotPos: int option }
    with
      static member Empty : endColumn:int -> PartialLongName
    end
  module QuickParse = begin
    val MagicalAdjustmentConstant : int
    val CorrectIdentifierToken : tokenText:string -> tokenTag:int -> int
    val isValidStrippedName : name:System.ReadOnlySpan<char> -> idx:int -> bool
    val private isValidActivePatternName : name:string -> bool
    val GetCompleteIdentifierIslandImpl :
      lineStr:string -> index:int -> (string * int * bool) option
    val GetCompleteIdentifierIsland :
      tolerateJustAfter:bool ->
        tokenText:string -> index:int -> (string * int * bool) option
    val private defaultName : 'a list * string
    val GetPartialLongName : lineStr:string * index:int -> string list * string
    type private EatCommentCallContext =
      | SkipWhiteSpaces of
        ident: string * current: string list * throwAwayNext: bool
      | StartIdentifier of current: string list * throwAway: bool
    val GetPartialLongNameEx : lineStr:string * index:int -> PartialLongName
    val TokenNameEquals :
      tokenInfo:SourceCodeServices.FSharpTokenInfo -> token2:string -> bool
    val private expected : string [] list
    val TestMemberOrOverrideDeclaration :
      tokens:SourceCodeServices.FSharpTokenInfo [] -> bool
  end

namespace FSharp.Compiler.SourceCodeServices
  module internal FSharpCheckerResultsSettings = begin
    val getToolTipTextSize : int
    val maxTypeCheckErrorsOutOfProjectContext : int
    val maxTimeShareMilliseconds : int64
    val defaultFSharpBinariesDir : string
  end
  [<RequireQualifiedAccessAttribute ()>]
  type FSharpFindDeclFailureReason =
    | Unknown of message: string
    | NoSourceCode
    | ProvidedType of string
    | ProvidedMember of string
  [<RequireQualifiedAccessAttribute ()>]
  type FSharpFindDeclResult =
    | DeclNotFound of FSharpFindDeclFailureReason
    | DeclFound of Range.range
    | ExternalDecl of assembly: string * externalSym: ExternalSymbol
  [<RequireQualifiedAccessAttribute (); NoEqualityAttribute ();
    NoComparisonAttribute ()>]
  type internal NameResResult =
    | Members of
      (NameResolution.ItemWithInst list * TypedTreeOps.DisplayEnv * Range.range)
    | Cancel of TypedTreeOps.DisplayEnv * Range.range
    | Empty
  [<RequireQualifiedAccessAttribute ()>]
  type ResolveOverloads =
    | Yes
    | No
  [<RequireQualifiedAccessAttribute ()>]
  type GetPreciseCompletionListFromExprTypingsResult =
    | NoneBecauseTypecheckIsStaleAndTextChanged
    | NoneBecauseThereWereTypeErrors
    | None
    | Some of
      (NameResolution.ItemWithInst list * TypedTreeOps.DisplayEnv * Range.range) *
      TypedTree.TType
  type Names = string list
  [<SealedAttribute ()>]
  type internal TypeCheckInfo =
    class
      new : _sTcConfig:CompilerConfig.TcConfig * g:TcGlobals.TcGlobals *
            ccuSigForFile:TypedTree.ModuleOrNamespaceType *
            thisCcu:TypedTree.CcuThunk * tcImports:CompilerImports.TcImports *
            tcAccessRights:AccessibilityLogic.AccessorDomain *
            projectFileName:string * mainInputFileName:string *
            sResolutions:NameResolution.TcResolutions *
            sSymbolUses:NameResolution.TcSymbolUses *
            sFallback:NameResolution.NameResolutionEnv *
            loadClosure:ScriptClosure.LoadClosure option *
            implFileOpt:TypedTree.TypedImplFile option *
            openDeclarations:NameResolution.OpenDeclaration [] -> TypeCheckInfo
      member
        GetBestDisplayEnvForPos : cursorPos:Range.pos ->
                                    (NameResolution.NameResolutionEnv *
                                     AccessibilityLogic.AccessorDomain) *
                                    Range.range
      member
        GetDeclarationListSymbols : parseResultsOpt:FSharpParseFileResults option *
                                    line:int * lineStr:string *
                                    partialName:PartialLongName *
                                    getAllEntities:(unit -> AssemblySymbol list) ->
                                      FSharpSymbolUse list list
      member
        GetDeclarationLocation : line:int * lineStr:string * colAtEndOfNames:int *
                                 names:string list * preferFlag:bool option ->
                                   FSharpFindDeclResult
      member
        GetDeclarations : parseResultsOpt:FSharpParseFileResults option *
                          line:int * lineStr:string *
                          partialName:PartialLongName *
                          getAllEntities:(unit -> AssemblySymbol list) ->
                            FSharpDeclarationListInfo
      member
        GetF1Keyword : line:int * lineStr:string * colAtEndOfNames:int *
                       names:string list -> string option
      member
        GetFormatSpecifierLocationsAndArity : unit -> (Range.range * int) []
      member
        GetMethods : line:int * lineStr:string * colAtEndOfNames:int *
                     namesOpt:string list option -> FSharpMethodGroup
      member
        GetMethodsAsSymbols : line:int * lineStr:string * colAtEndOfNames:int *
                              names:string list ->
                                (FSharpSymbol list * TypedTreeOps.DisplayEnv *
                                 Range.range) option
      member
        GetReferenceResolutionStructuredToolTipText : line:int * col:int ->
                                                        FSharpToolTipText<Layout>
      member GetReferencedAssemblies : unit -> FSharpAssembly list
      member
        GetSemanticClassification : range:Range.range option ->
                                      struct
                                        (Range.range *
                                         SemanticClassificationType) []
      member
        GetStructuredToolTipText : line:int * lineStr:string *
                                   colAtEndOfNames:int * names:string list ->
                                     FSharpToolTipText<Layout>
      member
        GetSymbolUseAtLocation : line:int * lineStr:string * colAtEndOfNames:int *
                                 names:string list ->
                                   (FSharpSymbol * TypedTreeOps.DisplayEnv *
                                    Range.range) option
      member
        GetVisibleNamespacesAndModulesAtPosition : cursorPos:Range.pos ->
                                                     TypedTree.ModuleOrNamespaceRef list
      member
        IsRelativeNameResolvable : cursorPos:Range.pos * plid:string list *
                                   item:NameResolution.Item -> bool
      member
        IsRelativeNameResolvableFromSymbol : cursorPos:Range.pos *
                                             plid:string list *
                                             symbol:FSharpSymbol -> bool
      override ToString : unit -> string
      member AccessRights : AccessibilityLogic.AccessorDomain
      member CcuSigForFile : TypedTree.ModuleOrNamespaceType
      member ImplementationFile : TypedTree.TypedImplFile option
      member OpenDeclarations : NameResolution.OpenDeclaration []
      member PartialAssemblySignatureForFile : FSharpAssemblySignature
      member ScopeResolutions : NameResolution.TcResolutions
      member ScopeSymbolUses : NameResolution.TcSymbolUses
      member SymbolEnv : SymbolEnv
      member TcGlobals : TcGlobals.TcGlobals
      member TcImports : CompilerImports.TcImports
      member ThisCcu : TypedTree.CcuThunk
    end
  type FSharpParsingOptions =
    { SourceFiles: string []
      ConditionalCompilationDefines: string list
      ErrorSeverityOptions: ErrorLogger.FSharpErrorSeverityOptions
      IsInteractive: bool
      LightSyntax: bool option
      CompilingFsLib: bool
      IsExe: bool }
    with
      static member
        FromTcConfig : tcConfig:CompilerConfig.TcConfig * sourceFiles:string [] *
                       isInteractive:bool -> FSharpParsingOptions
      static member
        FromTcConfigBuilder : tcConfigB:CompilerConfig.TcConfigBuilder *
                              sourceFiles:string [] * isInteractive:bool ->
                                FSharpParsingOptions
      member LastFileName : string
      static member Default : FSharpParsingOptions
    end
  module internal ParseAndCheckFile = begin
    type ErrorHandler =
      class
        new : reportErrors:bool * mainInputFileName:string *
              errorSeverityOptions:ErrorLogger.FSharpErrorSeverityOptions *
              sourceText:Text.ISourceText * suggestNamesForErrors:bool ->
                ErrorHandler
        member AnyErrors : bool
        member CollectedDiagnostics : FSharpErrorInfo []
        member ErrorCount : int
        member ErrorLogger : ErrorLogger.ErrorLogger
        member
          ErrorSeverityOptions : ErrorLogger.FSharpErrorSeverityOptions with set
      end
    val getLightSyntaxStatus :
      fileName:string ->
        options:FSharpParsingOptions -> Lexhelp.LightSyntaxStatus
    val createLexerFunction :
      fileName:string ->
        options:FSharpParsingOptions ->
          lexbuf:Internal.Utilities.Text.Lexing.LexBuffer<char> ->
            errHandler:ErrorHandler -> ('a -> Parser.token)
    val isFeatureSupported : _featureId:Features.LanguageFeature -> bool
    val createLexbuf : sourceText:Text.ISourceText -> UnicodeLexing.Lexbuf
    val matchBraces :
      sourceText:Text.ISourceText * fileName:string *
      options:FSharpParsingOptions * userOpName:string *
      suggestNamesForErrors:bool -> (Range.range * Range.range) []
    val parseFile :
      sourceText:Text.ISourceText * fileName:string *
      options:FSharpParsingOptions * userOpName:string *
      suggestNamesForErrors:bool ->
        FSharpErrorInfo [] * SyntaxTree.ParsedInput option * bool
    val ApplyLoadClosure :
      tcConfig:CompilerConfig.TcConfig * parsedMainInput:SyntaxTree.ParsedInput *
      mainInputFileName:string * loadClosure:ScriptClosure.LoadClosure option *
      tcImports:CompilerImports.TcImports *
      backgroundDiagnostics:(ErrorLogger.PhasedDiagnostic * FSharpErrorSeverity) [] ->
        unit
    val CheckOneFile :
      parseResults:FSharpParseFileResults * sourceText:Text.ISourceText *
      mainInputFileName:string * projectFileName:string *
      tcConfig:CompilerConfig.TcConfig * tcGlobals:TcGlobals.TcGlobals *
      tcImports:CompilerImports.TcImports * tcState:ParseAndCheckInputs.TcState *
      moduleNamesDict:ParseAndCheckInputs.ModuleNamesDict *
      loadClosure:ScriptClosure.LoadClosure option *
      backgroundDiagnostics:(ErrorLogger.PhasedDiagnostic * FSharpErrorSeverity) [] *
      reactorOps:IReactorOperations * userOpName:string *
      suggestNamesForErrors:bool ->
        Async<FSharpErrorInfo [] * Result<TypeCheckInfo,unit>>
  end
  [<SealedAttribute ()>]
  type FSharpProjectContext =
    class
      new : thisCcu:TypedTree.CcuThunk * assemblies:FSharpAssembly list *
            ad:AccessibilityLogic.AccessorDomain -> FSharpProjectContext
      member GetReferencedAssemblies : unit -> FSharpAssembly list
      member AccessibilityRights : FSharpAccessibilityRights
    end
  [<SealedAttribute ()>]
  type FSharpCheckFileResults =
    class
      new : filename:string * errors:FSharpErrorInfo [] *
            scopeOptX:TypeCheckInfo option * dependencyFiles:string [] *
            builderX:IncrementalBuilder option * keepAssemblyContents:bool ->
              FSharpCheckFileResults
      static member
        CheckOneFile : parseResults:FSharpParseFileResults *
                       sourceText:Text.ISourceText * mainInputFileName:string *
                       projectFileName:string * tcConfig:CompilerConfig.TcConfig *
                       tcGlobals:TcGlobals.TcGlobals *
                       tcImports:CompilerImports.TcImports *
                       tcState:ParseAndCheckInputs.TcState *
                       moduleNamesDict:ParseAndCheckInputs.ModuleNamesDict *
                       loadClosure:ScriptClosure.LoadClosure option *
                       backgroundDiagnostics:(ErrorLogger.PhasedDiagnostic *
                                              FSharpErrorSeverity) [] *
                       reactorOps:IReactorOperations * userOpName:string *
                       isIncompleteTypeCheckEnvironment:bool *
                       builder:IncrementalBuilder * dependencyFiles:string [] *
                       creationErrors:FSharpErrorInfo [] *
                       parseErrors:FSharpErrorInfo [] *
                       keepAssemblyContents:bool * suggestNamesForErrors:bool ->
                         Async<FSharpCheckFileAnswer>
      static member
        JoinErrors : isIncompleteTypeCheckEnvironment:bool *
                     creationErrors:FSharpErrorInfo [] *
                     parseErrors:FSharpErrorInfo [] *
                     tcErrors:FSharpErrorInfo [] -> FSharpErrorInfo []
      static member
        Make : mainInputFileName:string * projectFileName:string *
               tcConfig:CompilerConfig.TcConfig * tcGlobals:TcGlobals.TcGlobals *
               isIncompleteTypeCheckEnvironment:bool *
               builder:IncrementalBuilder * dependencyFiles:string [] *
               creationErrors:FSharpErrorInfo [] *
               parseErrors:FSharpErrorInfo [] * tcErrors:FSharpErrorInfo [] *
               keepAssemblyContents:bool *
               ccuSigForFile:TypedTree.ModuleOrNamespaceType *
               thisCcu:TypedTree.CcuThunk * tcImports:CompilerImports.TcImports *
               tcAccessRights:AccessibilityLogic.AccessorDomain *
               sResolutions:NameResolution.TcResolutions *
               sSymbolUses:NameResolution.TcSymbolUses *
               sFallback:NameResolution.NameResolutionEnv *
               loadClosure:ScriptClosure.LoadClosure option *
               implFileOpt:TypedTree.TypedImplFile option *
               openDeclarations:NameResolution.OpenDeclaration [] ->
                 FSharpCheckFileResults
      static member
        MakeEmpty : filename:string * creationErrors:FSharpErrorInfo [] *
                    keepAssemblyContents:bool -> FSharpCheckFileResults
      member
        GetAllUsesOfAllSymbolsInFile : ?cancellationToken:System.Threading.CancellationToken ->
                                         seq<FSharpSymbolUse>
      member
        GetDeclarationListInfo : parsedFileResults:FSharpParseFileResults option *
                                 line:int * lineText:string *
                                 partialName:PartialLongName *
                                 ?getAllEntities:(unit -> AssemblySymbol list) ->
                                   FSharpDeclarationListInfo
      member
        GetDeclarationListSymbols : parsedFileResults:FSharpParseFileResults option *
                                    line:int * lineText:string *
                                    partialName:PartialLongName *
                                    ?getAllEntities:(unit -> AssemblySymbol list) ->
                                      FSharpSymbolUse list list
      member
        GetDeclarationLocation : line:int * colAtEndOfNames:int *
                                 lineText:string * names:string list *
                                 ?preferFlag:bool -> FSharpFindDeclResult
      member
        GetDisplayContextForPos : cursorPos:Range.pos ->
                                    FSharpDisplayContext option
      member
        GetF1Keyword : line:int * colAtEndOfNames:int * lineText:string *
                       names:string list -> string option
      [<System.Obsolete
        ("This member has been replaced by GetFormatSpecifierLocationsAndArity, which returns both range and arity of specifiers")>]
      member GetFormatSpecifierLocations : unit -> Range.range []
      member
        GetFormatSpecifierLocationsAndArity : unit -> (Range.range * int) []
      member
        GetMethods : line:int * colAtEndOfNames:int * lineText:string *
                     names:string list option -> FSharpMethodGroup
      member
        GetMethodsAsSymbols : line:int * colAtEndOfNames:int * lineText:string *
                              names:string list -> FSharpSymbolUse list option
      member
        GetSemanticClassification : Range.range option ->
                                      struct
                                        (Range.range *
                                         SemanticClassificationType) []
      member
        GetStructuredToolTipText : line:int * colAtEndOfNames:int *
                                   lineText:string * names:string list *
                                   tokenTag:int -> FSharpToolTipText<Layout>
      member
        GetSymbolAtLocation : line:int * colAtEndOfNames:int * lineStr:string *
                              names:string list -> FSharpSymbol option
      member
        GetSymbolUseAtLocation : line:int * colAtEndOfNames:int *
                                 lineText:string * names:string list ->
                                   FSharpSymbolUse option
      member
        GetToolTipText : line:int * colAtEndOfNames:int * lineText:string *
                         names:string list * tokenTag:int -> FSharpToolTipText
      member
        GetUsesOfSymbolInFile : symbol:FSharpSymbol *
                                ?cancellationToken:System.Threading.CancellationToken ->
                                  FSharpSymbolUse []
      member
        GetVisibleNamespacesAndModulesAtPoint : Range.pos ->
                                                  TypedTree.ModuleOrNamespaceRef []
      member
        IsRelativeNameResolvable : cursorPos:Range.pos * plid:string list *
                                   item:NameResolution.Item -> bool
      member
        IsRelativeNameResolvableFromSymbol : cursorPos:Range.pos *
                                             plid:string list *
                                             symbol:FSharpSymbol -> bool
      override ToString : unit -> string
      member TryGetCurrentTcImports : unit -> CompilerImports.TcImports option
      member DependencyFiles : string []
      member Errors : FSharpErrorInfo []
      member HasFullTypeCheckInfo : bool
      member ImplementationFile : FSharpImplementationFileContents option
      member OpenDeclarations : FSharpOpenDeclaration []
      member PartialAssemblySignature : FSharpAssemblySignature
      member ProjectContext : FSharpProjectContext
    end
  [<RequireQualifiedAccessAttribute (); NoComparisonAttribute ()>]
  and FSharpCheckFileAnswer =
    | Aborted
    | Succeeded of FSharpCheckFileResults
  [<SealedAttribute ()>]
  type FSharpCheckProjectResults =
    class
      new : projectFileName:string *
            tcConfigOption:CompilerConfig.TcConfig option *
            keepAssemblyContents:bool * errors:FSharpErrorInfo [] *
            details:(TcGlobals.TcGlobals * CompilerImports.TcImports *
                     TypedTree.CcuThunk * TypedTree.ModuleOrNamespaceType *
                     NameResolution.TcSymbolUses list *
                     CheckDeclarations.TopAttribs option *
                     CompilerConfig.IRawFSharpAssemblyData option *
                     AbstractIL.IL.ILAssemblyRef *
                     AccessibilityLogic.AccessorDomain *
                     TypedTree.TypedImplFile list option * string []) option ->
              FSharpCheckProjectResults
      member
        GetAllUsesOfAllSymbols : ?cancellationToken:System.Threading.CancellationToken ->
                                   FSharpSymbolUse []
      member GetOptimizedAssemblyContents : unit -> FSharpAssemblyContents
      member
        GetUsesOfSymbol : symbol:FSharpSymbol *
                          ?cancellationToken:System.Threading.CancellationToken ->
                            FSharpSymbolUse []
      override ToString : unit -> string
      member AssemblyContents : FSharpAssemblyContents
      member AssemblyFullName : string
      member AssemblySignature : FSharpAssemblySignature
      member DependencyFiles : string []
      member Errors : FSharpErrorInfo []
      member HasCriticalErrors : bool
      member ProjectContext : FSharpProjectContext
      member
        RawFSharpAssemblyData : CompilerConfig.IRawFSharpAssemblyData option
      member
        TypedImplementationFiles : TcGlobals.TcGlobals * TypedTree.CcuThunk *
                                   CompilerImports.TcImports *
                                   TypedTree.TypedImplFile list
    end
  type FsiInteractiveChecker =
    class
      new : ReferenceResolver.Resolver * ops:IReactorOperations *
            tcConfig:CompilerConfig.TcConfig * tcGlobals:TcGlobals.TcGlobals *
            tcImports:CompilerImports.TcImports *
            tcState:ParseAndCheckInputs.TcState -> FsiInteractiveChecker
      member
        ParseAndCheckInteraction : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                   sourceText:Text.ISourceText *
                                   ?userOpName:string ->
                                     Async<FSharpParseFileResults *
                                           FSharpCheckFileResults *
                                           FSharpCheckProjectResults>
    end

namespace FSharp.Compiler.SourceCodeServices
  type internal Layout = Internal.Utilities.StructuredFormat.Layout
  module EnvMisc = begin
    val braceMatchCacheSize : int
    val parseFileCacheSize : int
    val checkFileInProjectCacheSize : int
    val projectCacheSizeDefault : int
    val frameworkTcImportsCacheStrongSize : int
    val maxMBDefault : int
  end
  type UnresolvedReferencesSet =
    | UnresolvedReferencesSet of CompilerConfig.UnresolvedAssemblyReference list
  type FSharpProjectOptions =
    { ProjectFileName: string
      ProjectId: string option
      SourceFiles: string []
      OtherOptions: string []
      ReferencedProjects: (string * FSharpProjectOptions) []
      IsIncompleteTypeCheckEnvironment: bool
      UseScriptResolutionRules: bool
      LoadTime: System.DateTime
      UnresolvedReferences: UnresolvedReferencesSet option
      OriginalLoadReferences: (Range.range * string * string) list
      ExtraProjectInfo: obj option
      Stamp: int64 option }
    with
      static member
        AreSameForChecking : options1:FSharpProjectOptions *
                             options2:FSharpProjectOptions -> bool
      static member
        UseSameProject : options1:FSharpProjectOptions *
                         options2:FSharpProjectOptions -> bool
      override ToString : unit -> string
      member ProjectDirectory : string
      member ProjectOptions : string []
    end
  [<NoComparisonAttribute (); NoEqualityAttribute ()>]
  type IsResultObsolete = | IsResultObsolete of (unit -> bool)
  module Helpers = begin
    val AreSameForChecking2 :
      (string * FSharpProjectOptions) * (string * FSharpProjectOptions) -> bool
    val AreSubsumable2 :
      (string * FSharpProjectOptions) * (string * FSharpProjectOptions) -> bool
    val AreSameForParsing :
      (string * int * 'a) * (string * int * 'a) -> bool when 'a : equality
    val AreSimilarForParsing :
      ('a * 'b * 'c) * ('a * 'd * 'e) -> bool when 'a : equality
    val AreSameForChecking3 :
      (string * int * FSharpProjectOptions) *
      (string * int * FSharpProjectOptions) -> bool
    val AreSubsumable3 :
      (string * 'a * FSharpProjectOptions) *
      (string * 'b * FSharpProjectOptions) -> bool
  end
  module CompileHelpers = begin
    val mkCompilationErrorHandlers :
      unit ->
        ResizeArray<FSharpErrorInfo> * ErrorLogger.ErrorLogger *
        Driver.ErrorLoggerProvider
    val tryCompile :
      errorLogger:ErrorLogger.ErrorLogger ->
        f:(ErrorLogger.Exiter -> unit) -> int
    val compileFromArgs :
      ctok:AbstractIL.Internal.Library.CompilationThreadToken * argv:string [] *
      legacyReferenceResolver:ReferenceResolver.Resolver *
      tcImportsCapture:(CompilerImports.TcImports -> unit) option *
      dynamicAssemblyCreator:(TcGlobals.TcGlobals * string *
                              AbstractIL.IL.ILModuleDef -> unit) option ->
        FSharpErrorInfo [] * int
    val compileFromAsts :
      ctok:AbstractIL.Internal.Library.CompilationThreadToken *
      legacyReferenceResolver:ReferenceResolver.Resolver *
      asts:SyntaxTree.ParsedInput list * assemblyName:string * outFile:string *
      dependencies:string list * noframework:bool * pdbFile:string option *
      executable:bool option *
      tcImportsCapture:(CompilerImports.TcImports -> unit) option *
      dynamicAssemblyCreator:(TcGlobals.TcGlobals * string *
                              AbstractIL.IL.ILModuleDef -> unit) option ->
        FSharpErrorInfo [] * int
    val createDynamicAssembly :
      ctok:AbstractIL.Internal.Library.CompilationThreadToken * debugInfo:bool *
      tcImportsRef:CompilerImports.TcImports option ref * execute:bool *
      assemblyBuilderRef:System.Reflection.Emit.AssemblyBuilder option ref ->
        tcGlobals:TcGlobals.TcGlobals * outfile:string *
        ilxMainModule:AbstractIL.IL.ILModuleDef -> unit
    val setOutputStreams :
      execute:(#System.IO.TextWriter * #System.IO.TextWriter) option -> unit
  end
  type SourceTextHash = int
  type FileName = string
  type FilePath = string
  type ProjectPath = string
  type FileVersion = int
  type ParseCacheLockToken =
    class
      interface AbstractIL.Internal.Library.LockToken
      new : unit -> ParseCacheLockToken
    end
  type ScriptClosureCacheToken =
    class
      interface AbstractIL.Internal.Library.LockToken
      new : unit -> ScriptClosureCacheToken
    end
  type BackgroundCompiler =
    class
      new : legacyReferenceResolver:ReferenceResolver.Resolver *
            projectCacheSize:int * keepAssemblyContents:bool *
            keepAllBackgroundResolutions:bool *
            tryGetMetadataSnapshot:AbstractIL.ILBinaryReader.ILReaderTryGetMetadataSnapshot *
            suggestNamesForErrors:bool * keepAllBackgroundSymbolUses:bool *
            enableBackgroundItemKeyStoreAndSemanticClassification:bool *
            enablePartialTypeChecking:bool -> BackgroundCompiler
      member
        CheckFileInProject : parseResults:FSharpParseFileResults *
                             filename:string * fileVersion:int *
                             sourceText:Text.ISourceText *
                             options:FSharpProjectOptions * userOpName:string ->
                               Async<FSharpCheckFileAnswer>
      member
        CheckFileInProjectAllowingStaleCachedResults : parseResults:FSharpParseFileResults *
                                                       filename:string *
                                                       fileVersion:int *
                                                       sourceText:Text.ISourceText *
                                                       options:FSharpProjectOptions *
                                                       userOpName:string ->
                                                         Async<FSharpCheckFileAnswer option>
      member
        private CheckOneFileImpl : parseResults:FSharpParseFileResults *
                                   sourceText:Text.ISourceText * fileName:string *
                                   options:FSharpProjectOptions *
                                   fileVersion:int * builder:IncrementalBuilder *
                                   tcConfig:CompilerConfig.TcConfig *
                                   tcGlobals:TcGlobals.TcGlobals *
                                   tcImports:CompilerImports.TcImports *
                                   tcDependencyFiles:string list *
                                   timeStamp:System.DateTime *
                                   prevTcState:ParseAndCheckInputs.TcState *
                                   prevModuleNamesDict:ParseAndCheckInputs.ModuleNamesDict *
                                   prevTcErrors:(ErrorLogger.PhasedDiagnostic *
                                                 FSharpErrorSeverity) [] *
                                   creationErrors:FSharpErrorInfo [] *
                                   userOpName:string ->
                                     Async<FSharpCheckFileAnswer>
      member
        CheckProjectInBackground : options:FSharpProjectOptions *
                                   userOpName:string -> unit
      member
        ClearCache : options:seq<FSharpProjectOptions> * userOpName:string ->
                       unit
      member ClearCachesAsync : userOpName:string -> Async<unit>
      member CompleteAllQueuedOps : unit -> unit
      member DownsizeCaches : userOpName:string -> Async<unit>
      member
        FindReferencesInFile : filename:string * options:FSharpProjectOptions *
                               symbol:FSharpSymbol * canInvalidateProject:bool *
                               userOpName:string -> Async<seq<Range.range>>
      member
        GetAssemblyData : options:FSharpProjectOptions *
                          ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                          userOpName:string ->
                            AbstractIL.Internal.Library.Cancellable<CompilerConfig.IRawFSharpAssemblyData option>
      member
        GetBackgroundCheckResultsForFileInProject : filename:string *
                                                    options:FSharpProjectOptions *
                                                    userOpName:string ->
                                                      Async<FSharpParseFileResults *
                                                            FSharpCheckFileResults>
      member
        GetBackgroundParseResultsForFileInProject : filename:string *
                                                    options:FSharpProjectOptions *
                                                    userOpName:string ->
                                                      Async<FSharpParseFileResults>
      member
        GetCachedCheckFileResult : builder:IncrementalBuilder *
                                   filename:FileName *
                                   sourceText:Text.ISourceText *
                                   options:FSharpProjectOptions ->
                                     (FSharpParseFileResults *
                                      FSharpCheckFileResults) option
      member
        GetProjectOptionsFromScript : filename:string *
                                      sourceText:Text.ISourceText *
                                      previewEnabled:bool option *
                                      loadedTimeStamp:System.DateTime option *
                                      otherFlags:string [] option *
                                      useFsiAuxLib:bool option *
                                      useSdkRefs:bool option *
                                      assumeDotNetFramework:bool option *
                                      extraProjectInfo:obj option *
                                      optionsStamp:int64 option *
                                      userOpName:string ->
                                        Async<FSharpProjectOptions *
                                              FSharpErrorInfo list>
      member
        GetSemanticClassificationForFile : filename:string *
                                           options:FSharpProjectOptions *
                                           userOpName:string ->
                                             Async<struct
                                                     (Range.range *
                                                      SemanticClassificationType) []>
      member
        ImplicitlyStartCheckProjectInBackground : options:FSharpProjectOptions *
                                                  userOpName:string -> unit
      member
        InvalidateConfiguration : options:FSharpProjectOptions *
                                  startBackgroundCompileIfAlreadySeen:bool option *
                                  userOpName:string -> unit
      member
        NotifyProjectCleaned : options:FSharpProjectOptions * userOpName:string ->
                                 Async<unit>
      member
        ParseAndCheckFileInProject : filename:string * fileVersion:int *
                                     sourceText:Text.ISourceText *
                                     options:FSharpProjectOptions *
                                     userOpName:string ->
                                       Async<FSharpParseFileResults *
                                             FSharpCheckFileAnswer>
      member
        ParseAndCheckProject : options:FSharpProjectOptions * userOpName:string ->
                                 Async<FSharpCheckProjectResults>
      member
        private ParseAndCheckProjectImpl : options:FSharpProjectOptions *
                                           ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                           userOpName:string ->
                                             AbstractIL.Internal.Library.Cancellable<FSharpCheckProjectResults>
      member
        ParseFile : filename:string * sourceText:Text.ISourceText *
                    options:FSharpParsingOptions * userOpName:string ->
                      Async<FSharpParseFileResults>
      member
        ParseFileNoCache : filename:string * sourceText:Text.ISourceText *
                           options:FSharpParsingOptions * userOpName:string ->
                             Async<FSharpParseFileResults>
      member
        RecordTypeCheckFileInProjectResults : filename:string *
                                              options:FSharpProjectOptions *
                                              parsingOptions:FSharpParsingOptions *
                                              parseResults:FSharpParseFileResults *
                                              fileVersion:int *
                                              priorTimeStamp:System.DateTime *
                                              checkAnswer:FSharpCheckFileAnswer option *
                                              sourceText:SourceTextHash -> unit
      member StopBackgroundCompile : unit -> unit
      member
        private TryGetLogicalTimeStampForProject : cache:CompilerConfig.TimeStampCache *
                                                   ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                                   options:FSharpProjectOptions *
                                                   userOpName:string ->
                                                     System.DateTime option
      member
        TryGetRecentCheckResultsForFile : filename:string *
                                          options:FSharpProjectOptions *
                                          sourceText:Text.ISourceText option *
                                          _userOpName:string ->
                                            (FSharpParseFileResults *
                                             FSharpCheckFileResults *
                                             FileVersion) option
      member WaitForBackgroundCompile : unit -> unit
      member BeforeBackgroundFileCheck : IEvent<string * obj option>
      member CurrentQueueLength : int
      member FileChecked : IEvent<string * obj option>
      member FileParsed : IEvent<string * obj option>
      member FrameworkImportsCache : FrameworkImportsCache
      member ImplicitlyStartBackgroundWork : bool
      member ProjectChecked : IEvent<string * obj option>
      member Reactor : Reactor
      member ReactorOps : IReactorOperations
      static member GlobalForegroundParseCountStatistic : int
      static member GlobalForegroundTypeCheckCountStatistic : int
    end
  [<SealedAttribute ()>]
  type FSharpChecker =
    class
      new : legacyReferenceResolver:ReferenceResolver.Resolver *
            projectCacheSize:int * keepAssemblyContents:bool *
            keepAllBackgroundResolutions:bool *
            tryGetMetadataSnapshot:AbstractIL.ILBinaryReader.ILReaderTryGetMetadataSnapshot *
            suggestNamesForErrors:bool * keepAllBackgroundSymbolUses:bool *
            enableBackgroundItemKeyStoreAndSemanticClassification:bool *
            enablePartialTypeChecking:bool -> FSharpChecker
      static member
        Create : ?projectCacheSize:int * ?keepAssemblyContents:bool *
                 ?keepAllBackgroundResolutions:bool *
                 ?legacyReferenceResolver:ReferenceResolver.Resolver *
                 ?tryGetMetadataSnapshot:(string * System.DateTime ->
                                            AbstractIL.ILBinaryReader.ILReaderMetadataSnapshot option) *
                 ?suggestNamesForErrors:bool * ?keepAllBackgroundSymbolUses:bool *
                 ?enableBackgroundItemKeyStoreAndSemanticClassification:bool *
                 ?enablePartialTypeChecking:bool -> FSharpChecker
      member
        CheckFileInProject : parseResults:FSharpParseFileResults *
                             filename:string * fileVersion:int *
                             sourceText:Text.ISourceText *
                             options:FSharpProjectOptions * ?userOpName:string ->
                               Async<FSharpCheckFileAnswer>
      [<System.Obsolete
        ("This member should no longer be used, please use 'CheckFileInProject'")>]
      member
        CheckFileInProjectAllowingStaleCachedResults : parseResults:FSharpParseFileResults *
                                                       filename:string *
                                                       fileVersion:int *
                                                       source:string *
                                                       options:FSharpProjectOptions *
                                                       ?userOpName:string ->
                                                         Async<FSharpCheckFileAnswer option>
      member CheckMaxMemoryReached : unit -> unit
      member
        CheckProjectInBackground : options:FSharpProjectOptions *
                                   ?userOpName:string -> unit
      member
        ClearCache : options:seq<FSharpProjectOptions> * ?userOpName:string ->
                       unit
      member ClearCaches : ?userOpName:string -> unit
      member ClearCachesAsync : ?userOpName:string -> Async<unit>
      member
        ClearLanguageServiceRootCachesAndCollectAndFinalizeAllTransients : unit ->
                                                                             unit
      member
        Compile : argv:string [] * ?userOpName:string ->
                    Async<FSharpErrorInfo [] * int>
      member
        Compile : ast:SyntaxTree.ParsedInput list * assemblyName:string *
                  outFile:string * dependencies:string list * ?pdbFile:string *
                  ?executable:bool * ?noframework:bool * ?userOpName:string ->
                    Async<FSharpErrorInfo [] * int>
      member
        CompileToDynamicAssembly : otherFlags:string [] *
                                   execute:(System.IO.TextWriter *
                                            System.IO.TextWriter) option *
                                   ?userOpName:string ->
                                     Async<FSharpErrorInfo [] * int *
                                           System.Reflection.Assembly option>
      member
        CompileToDynamicAssembly : ast:SyntaxTree.ParsedInput list *
                                   assemblyName:string *
                                   dependencies:string list *
                                   execute:(System.IO.TextWriter *
                                            System.IO.TextWriter) option *
                                   ?debug:bool * ?noframework:bool *
                                   ?userOpName:string ->
                                     Async<FSharpErrorInfo [] * int *
                                           System.Reflection.Assembly option>
      member
        FindBackgroundReferencesInFile : filename:string *
                                         options:FSharpProjectOptions *
                                         symbol:FSharpSymbol *
                                         ?canInvalidateProject:bool *
                                         ?userOpName:string ->
                                           Async<seq<Range.range>>
      member
        GetBackgroundCheckResultsForFileInProject : filename:string *
                                                    options:FSharpProjectOptions *
                                                    ?userOpName:string ->
                                                      Async<FSharpParseFileResults *
                                                            FSharpCheckFileResults>
      member
        GetBackgroundParseResultsForFileInProject : filename:string *
                                                    options:FSharpProjectOptions *
                                                    ?userOpName:string ->
                                                      Async<FSharpParseFileResults>
      member
        GetBackgroundSemanticClassificationForFile : filename:string *
                                                     options:FSharpProjectOptions *
                                                     ?userOpName:string ->
                                                       Async<struct
                                                               (Range.range *
                                                                SemanticClassificationType) []>
      member
        GetParsingOptionsFromCommandLineArgs : argv:string list *
                                               ?isInteractive:bool ->
                                                 FSharpParsingOptions *
                                                 FSharpErrorInfo list
      member
        GetParsingOptionsFromCommandLineArgs : sourceFiles:string list *
                                               argv:string list *
                                               ?isInteractive:bool ->
                                                 FSharpParsingOptions *
                                                 FSharpErrorInfo list
      member
        GetParsingOptionsFromProjectOptions : options:FSharpProjectOptions ->
                                                FSharpParsingOptions *
                                                FSharpErrorInfo list
      member
        GetProjectOptionsFromCommandLineArgs : projectFileName:string *
                                               argv:string [] *
                                               ?loadedTimeStamp:System.DateTime *
                                               ?extraProjectInfo:obj ->
                                                 FSharpProjectOptions
      member
        GetProjectOptionsFromScript : filename:string * source:Text.ISourceText *
                                      ?previewEnabled:bool *
                                      ?loadedTimeStamp:System.DateTime *
                                      ?otherFlags:string [] * ?useFsiAuxLib:bool *
                                      ?useSdkRefs:bool *
                                      ?assumeDotNetFramework:bool *
                                      ?extraProjectInfo:obj *
                                      ?optionsStamp:int64 * ?userOpName:string ->
                                        Async<FSharpProjectOptions *
                                              FSharpErrorInfo list>
      member InvalidateAll : unit -> unit
      member
        InvalidateConfiguration : options:FSharpProjectOptions *
                                  ?startBackgroundCompile:bool *
                                  ?userOpName:string -> unit
      [<System.Obsolete
        ("Please pass FSharpParsingOptions to MatchBraces. If necessary generate FSharpParsingOptions from FSharpProjectOptions by calling checker.GetParsingOptionsFromProjectOptions(options)")>]
      member
        MatchBraces : filename:string * source:string *
                      options:FSharpProjectOptions * ?userOpName:string ->
                        Async<(Range.range * Range.range) []>
      member
        MatchBraces : filename:string * sourceText:Text.ISourceText *
                      options:FSharpParsingOptions * ?userOpName:string ->
                        Async<(Range.range * Range.range) []>
      member
        NotifyProjectCleaned : options:FSharpProjectOptions * ?userOpName:string ->
                                 Async<unit>
      member
        ParseAndCheckFileInProject : filename:string * fileVersion:int *
                                     sourceText:Text.ISourceText *
                                     options:FSharpProjectOptions *
                                     ?userOpName:string ->
                                       Async<FSharpParseFileResults *
                                             FSharpCheckFileAnswer>
      member
        ParseAndCheckProject : options:FSharpProjectOptions * ?userOpName:string ->
                                 Async<FSharpCheckProjectResults>
      member
        ParseFile : filename:string * sourceText:Text.ISourceText *
                    options:FSharpParsingOptions * ?userOpName:string ->
                      Async<FSharpParseFileResults>
      [<System.Obsolete
        ("Please call checker.ParseFile instead.  To do this, you must also pass FSharpParsingOptions instead of FSharpProjectOptions. If necessary generate FSharpParsingOptions from FSharpProjectOptions by calling checker.GetParsingOptionsFromProjectOptions(options)")>]
      member
        ParseFileInProject : filename:string * source:string *
                             options:FSharpProjectOptions * ?userOpName:string ->
                               Async<FSharpParseFileResults>
      member
        ParseFileNoCache : filename:string * sourceText:Text.ISourceText *
                           options:FSharpParsingOptions * ?userOpName:string ->
                             Async<FSharpParseFileResults>
      member
        StartBackgroundCompile : options:FSharpProjectOptions *
                                 ?userOpName:string -> unit
      member StopBackgroundCompile : unit -> unit
      member TokenizeFile : source:string -> FSharpTokenInfo [] []
      member
        TokenizeLine : line:string * state:FSharpTokenizerLexState ->
                         FSharpTokenInfo [] * FSharpTokenizerLexState
      member
        TryGetRecentCheckResultsForFile : filename:string *
                                          options:FSharpProjectOptions *
                                          ?sourceText:Text.ISourceText *
                                          ?userOpName:string ->
                                            (FSharpParseFileResults *
                                             FSharpCheckFileResults *
                                             FileVersion) option
      member WaitForBackgroundCompile : unit -> unit
      member BeforeBackgroundFileCheck : IEvent<string * obj option>
      member CurrentQueueLength : int
      member FileChecked : IEvent<string * obj option>
      member FileParsed : IEvent<string * obj option>
      member internal FrameworkImportsCache : FrameworkImportsCache
      member ImplicitlyStartBackgroundWork : bool
      member MaxMemory : int
      member MaxMemoryReached : IEvent<unit>
      member PauseBeforeBackgroundWork : int
      member ProjectChecked : IEvent<string * obj option>
      member ReactorOps : IReactorOperations
      member ReferenceResolver : ReferenceResolver.Resolver
      static member GlobalForegroundParseCountStatistic : int
      static member GlobalForegroundTypeCheckCountStatistic : int
      [<System.Obsolete
        ("Please create an instance of FSharpChecker using FSharpChecker.Create")>]
      static member Instance : FSharpChecker
    end
  [<ClassAttribute ()>]
  type CompilerEnvironment =
    class
      static member
        BinFolderOfDefaultFSharpCompiler : ?probePoint:string -> string option
    end
  module CompilerEnvironment = begin
    val DefaultReferencesForOrphanSources :
      assumeDotNetFramework:bool -> string list
    val GetCompilationDefinesForEditing :
      parsingOptions:FSharpParsingOptions -> string list
    val IsCheckerSupportedSubcategory : string -> bool
  end
  module DebuggerEnvironment = begin
    val GetLanguageID : unit -> System.Guid
  end
  module PrettyNaming = begin
    val IsIdentifierPartCharacter : char -> bool
    val IsLongIdentifierPartCharacter : char -> bool
    val IsOperatorName : string -> bool
    val GetLongNameFromString : string -> string list
    val FormatAndOtherOverloadsString : System.Int32 -> string
    val QuoteIdentifierIfNeeded : string -> string
    val KeywordNames : string list
  end
  module FSharpFileUtilities = begin
    val isScriptFile : string -> bool
  end

namespace FSharp.Compiler.SourceCodeServices
  module ErrorResolutionHints = begin
    val getSuggestedNames :
      suggestionsF:ErrorLogger.Suggestions ->
        unresolvedIdentifier:string -> seq<string>
  end



namespace FSharp.Compiler.SourceCodeServices
  module Structure = begin
    module Range = begin
      val endToEnd : r1:Range.range -> r2:Range.range -> Range.range
      val endToStart : r1:Range.range -> r2:Range.range -> Range.range
      val startToEnd : r1:Range.range -> r2:Range.range -> Range.range
      val startToStart : r1:Range.range -> r2:Range.range -> Range.range
      val modStart : m:int -> r:Range.range -> Range.range
      val modEnd : m:int -> r:Range.range -> Range.range
      val modBoth : modStart:int -> modEnd:int -> r:Range.range -> Range.range
    end
    val longIdentRange : longId:SyntaxTree.LongIdent -> Range.range
    val rangeOfTypeArgsElse :
      other:Range.range -> typeArgs:SyntaxTree.SynTyparDecl list -> Range.range
    val rangeOfSynPatsElse :
      other:Range.range -> synPats:SyntaxTree.SynSimplePat list -> Range.range
    [<RequireQualifiedAccessAttribute ()>]
    type Collapse =
      | Below
      | Same
    [<RequireQualifiedAccessAttribute ()>]
    type Scope =
      | Open
      | Namespace
      | Module
      | Type
      | Member
      | LetOrUse
      | Val
      | CompExpr
      | IfThenElse
      | ThenInIfThenElse
      | ElseInIfThenElse
      | TryWith
      | TryInTryWith
      | WithInTryWith
      | TryFinally
      | TryInTryFinally
      | FinallyInTryFinally
      | ArrayOrList
      | ObjExpr
      | For
      | While
      | Match
      | MatchBang
      | MatchLambda
      | MatchClause
      | Lambda
      | CompExprInternal
      | Quote
      | Record
      | SpecialFunc
      | Do
      | New
      | Attribute
      | Interface
      | HashDirective
      | LetOrUseBang
      | TypeExtension
      | YieldOrReturn
      | YieldOrReturnBang
      | Tuple
      | UnionCase
      | EnumCase
      | RecordField
      | RecordDefn
      | UnionDefn
      | Comment
      | XmlDocComment
      with
        override ToString : unit -> string
      end
    [<NoComparisonAttribute ()>]
    type ScopeRange =
      { Scope: Scope
        Collapse: Collapse
        Range: Range.range
        CollapseRange: Range.range }
    type LineNumber = int
    type LineStr = string
    type CommentType =
      | SingleLine
      | XmlDoc
    [<NoComparisonAttribute ()>]
    type CommentList =
      { Lines: ResizeArray<LineNumber * LineStr>
        Type: CommentType }
      with
        static member
          New : ty:CommentType -> lineStr:(LineNumber * LineStr) -> CommentList
      end
    val getOutliningRanges :
      sourceLines:string [] ->
        parsedInput:SyntaxTree.ParsedInput -> seq<ScopeRange>
  end

namespace FSharp.Compiler.SourceCodeServices
  module UnusedOpens = begin
    val symbolHash : System.Collections.Generic.IEqualityComparer<FSharpSymbol>
    type OpenedModule =
      class
        new : entity:FSharpEntity * isNestedAutoOpen:bool -> OpenedModule
        member RevealedSymbolsContains : symbol:FSharpSymbol -> bool
        member Entity : FSharpEntity
        member IsNestedAutoOpen : bool
      end
    type OpenedModuleGroup =
      { OpenedModules: OpenedModule [] }
      with
        static member Create : modul:FSharpEntity -> OpenedModuleGroup
      end
    type OpenStatement =
      { OpenedGroups: OpenedModuleGroup list
        Range: Range.range
        AppliedScope: Range.range }
    val getOpenStatements :
      openDeclarations:FSharpOpenDeclaration [] -> OpenStatement []
    val filterSymbolUses :
      getSourceLineStr:(int -> string) ->
        symbolUses:seq<FSharpSymbolUse> -> FSharpSymbolUse []
    val splitSymbolUses :
      symbolUses:FSharpSymbolUse [] -> FSharpSymbolUse [] * FSharpSymbolUse []
    val isOpenStatementUsed :
      symbolUses2:FSharpSymbolUse [] ->
        symbolUsesRangesByDeclaringEntity:System.Collections.Generic.Dictionary<FSharpEntity,
                                                                                Range.range list> ->
          usedModules:System.Collections.Generic.Dictionary<FSharpEntity,
                                                            Range.range list> ->
            openStatement:OpenStatement -> bool
    val filterOpenStatementsIncremental :
      symbolUses2:FSharpSymbolUse [] ->
        symbolUsesRangesByDeclaringEntity:System.Collections.Generic.Dictionary<FSharpEntity,
                                                                                Range.range list> ->
          openStatements:OpenStatement list ->
            usedModules:System.Collections.Generic.Dictionary<FSharpEntity,
                                                              Range.range list> ->
              acc:OpenStatement list -> Async<OpenStatement list>
    val entityHash : System.Collections.Generic.IEqualityComparer<FSharpEntity>
    val filterOpenStatements :
      symbolUses1:FSharpSymbolUse [] * symbolUses2:FSharpSymbolUse [] ->
        openStatements:OpenStatement [] -> Async<Range.range list>
    val getUnusedOpens :
      checkFileResults:FSharpCheckFileResults * getSourceLineStr:(int -> string) ->
        Async<Range.range list>
  end
  module SimplifyNames = begin
    type SimplifiableRange =
      { Range: Range.range
        RelativeName: string }
    val getPlidLength : plid:string list -> int
    val getSimplifiableNames :
      checkFileResults:FSharpCheckFileResults * getSourceLineStr:(int -> string) ->
        Async<seq<SimplifiableRange>>
  end
  module UnusedDeclarations = begin
    val isPotentiallyUnusedDeclaration : symbol:FSharpSymbol -> bool
    val getUnusedDeclarationRanges :
      symbolsUses:seq<FSharpSymbolUse> -> isScript:bool -> seq<Range.range>
    val getUnusedDeclarations :
      checkFileResults:FSharpCheckFileResults * isScriptFile:bool ->
        Async<seq<Range.range>>
  end

namespace FSharp.Compiler.Interactive
  module Shell = begin
    [<ClassAttribute ()>]
    type FsiValue =
      class
        new : reflectionValue:obj * reflectionType:System.Type *
              fsharpType:SourceCodeServices.FSharpType -> FsiValue
        member FSharpType : SourceCodeServices.FSharpType
        member ReflectionType : System.Type
        member ReflectionValue : obj
      end
    [<SealedAttribute ()>]
    type FsiBoundValue =
      class
        new : name:string * value:FsiValue -> FsiBoundValue
        member Name : string
        member Value : FsiValue
      end
    module internal Utilities = begin
      type IAnyToLayoutCall =
        interface
          abstract member
            AnyToLayout : Internal.Utilities.StructuredFormat.FormatOptions *
                          obj * System.Type ->
                            Internal.Utilities.StructuredFormat.Layout
          abstract member
            FsiAnyToLayout : Internal.Utilities.StructuredFormat.FormatOptions *
                             obj * System.Type ->
                               Internal.Utilities.StructuredFormat.Layout
        end
      type private AnyToLayoutSpecialization<'T> =
        class
          interface IAnyToLayoutCall
          new : unit -> AnyToLayoutSpecialization<'T>
        end
      val getAnyToLayoutCall : ty:System.Type -> IAnyToLayoutCall
      val callStaticMethod :
        ty:System.Type -> name:string -> args:obj list -> obj
      val ignoreAllErrors : f:(unit -> unit) -> unit
      val getMember :
        name:string ->
          memberType:System.Reflection.MemberTypes ->
            attr:System.Reflection.BindingFlags ->
              declaringType:System.Type -> System.Reflection.MemberInfo []
      val tryFindMember :
        name:string ->
          memberType:System.Reflection.MemberTypes ->
            declaringType:System.Type -> System.Reflection.MemberInfo option
      val getInstanceProperty : obj:obj -> nm:string -> 'a
      val setInstanceProperty : obj:obj -> nm:string -> v:obj -> 'a
      val callInstanceMethod0 :
        obj:obj -> typeArgs:System.Type [] -> nm:string -> 'a
      val callInstanceMethod1 :
        obj:obj -> typeArgs:System.Type [] -> nm:string -> v:obj -> 'a
      val callInstanceMethod3 :
        obj:obj ->
          typeArgs:System.Type [] ->
            nm:string -> v1:obj -> v2:obj -> v3:obj -> 'a
      val colorPrintL :
        outWriter:System.IO.TextWriter ->
          opts:Internal.Utilities.StructuredFormat.FormatOptions ->
            layout:Internal.Utilities.StructuredFormat.Layout -> unit
      val reportError :
        m:Range.range -> Microsoft.DotNet.DependencyManager.ResolvingErrorReport
      val getOutputDir : tcConfigB:CompilerConfig.TcConfigBuilder -> string
    end
    type internal FsiTimeReporter =
      class
        new : outWriter:System.IO.TextWriter -> FsiTimeReporter
        member TimeOp : f:(unit -> 'b) -> 'b
        member TimeOpIf : flag:bool -> f:(unit -> 'a) -> 'a
      end
    type internal FsiValuePrinterMode =
      | PrintExpr
      | PrintDecl
    [<ClassAttribute ()>]
    type EvaluationEventArgs =
      class
        inherit System.EventArgs
        new : fsivalue:FsiValue option *
              symbolUse:SourceCodeServices.FSharpSymbolUse *
              decl:SourceCodeServices.FSharpImplementationFileDeclaration ->
                EvaluationEventArgs
        member FsiValue : FsiValue option
        member
          ImplementationDeclaration : SourceCodeServices.FSharpImplementationFileDeclaration
        member Name : string
        member Symbol : SourceCodeServices.FSharpSymbol
        member SymbolUse : SourceCodeServices.FSharpSymbolUse
      end
    [<AbstractClassAttribute ()>]
    type FsiEvaluationSessionHostConfig =
      class
        new : unit -> FsiEvaluationSessionHostConfig
        abstract member EventLoopInvoke : codeToRun:(unit -> 'T) -> 'T
        abstract member EventLoopRun : unit -> bool
        abstract member EventLoopScheduleRestart : unit -> unit
        abstract member
          GetOptionalConsoleReadLine : probeToSeeIfConsoleWorks:bool ->
                                         (unit -> string) option
        abstract member ReportUserCommandLineArgs : string [] -> unit
        abstract member StartServer : fsiServerName:string -> unit
        member
          internal TriggerEvaluation : value:FsiValue option *
                                       symbolUse:SourceCodeServices.FSharpSymbolUse *
                                       decl:SourceCodeServices.FSharpImplementationFileDeclaration ->
                                         unit
        abstract member
          AddedPrinters : Choice<(System.Type * (obj -> string)),
                                 (System.Type * (obj -> obj))> list
        abstract member FloatingPointFormat : string
        abstract member FormatProvider : System.IFormatProvider
        member OnEvaluation : IEvent<EvaluationEventArgs>
        abstract member PrintDepth : int
        abstract member PrintLength : int
        abstract member PrintSize : int
        abstract member PrintWidth : int
        abstract member ShowDeclarationValues : bool
        abstract member ShowIEnumerable : bool
        abstract member ShowProperties : bool
        abstract member UseFsiAuxLib : bool
      end
    type internal FsiValuePrinter =
      class
        new : fsi:FsiEvaluationSessionHostConfig * g:TcGlobals.TcGlobals *
              generateDebugInfo:bool *
              resolveAssemblyRef:(AbstractIL.IL.ILAssemblyRef ->
                                    Choice<string,System.Reflection.Assembly> option) *
              outWriter:System.IO.TextWriter -> FsiValuePrinter
        member FormatValue : obj:obj * objTy:System.Type -> string
        member
          GetEvaluationContext : emEnv:AbstractIL.ILRuntimeWriter.emEnv ->
                                   IlxGen.ExecutionContext
        member
          GetFsiPrintOptions : unit ->
                                 Internal.Utilities.StructuredFormat.FormatOptions
        member
          InvokeDeclLayout : emEnv:AbstractIL.ILRuntimeWriter.emEnv *
                             ilxGenerator:IlxGen.IlxAssemblyGenerator *
                             v:TypedTree.Val ->
                               Internal.Utilities.StructuredFormat.Layout option
        member
          InvokeExprPrinter : denv:TypedTreeOps.DisplayEnv *
                              emEnv:AbstractIL.ILRuntimeWriter.emEnv *
                              ilxGenerator:IlxGen.IlxAssemblyGenerator *
                              vref:TypedTree.Val -> unit
        member
          PrintValue : printMode:FsiValuePrinterMode *
                       opts:Internal.Utilities.StructuredFormat.FormatOptions *
                       x:obj * ty:System.Type ->
                         Internal.Utilities.StructuredFormat.Layout
      end
    type internal FsiStdinSyphon =
      class
        new : errorWriter:System.IO.TextWriter -> FsiStdinSyphon
        member Add : str:string -> unit
        member GetLine : filename:string -> i:int -> string
        member
          PrintError : tcConfig:CompilerConfig.TcConfigBuilder *
                       err:ErrorLogger.PhasedDiagnostic -> unit
        member Reset : unit -> unit
      end
    type internal FsiConsoleOutput =
      class
        new : tcConfigB:CompilerConfig.TcConfigBuilder *
              outWriter:System.IO.TextWriter * errorWriter:System.IO.TextWriter ->
                FsiConsoleOutput
        member uprintf : fmt:Printf.TextWriterFormat<'f> -> 'f
        member uprintfn : fmt:Printf.TextWriterFormat<'e> -> 'e
        member uprintfnn : fmt:Printf.TextWriterFormat<'d,unit> -> 'd
        member uprintnf : fmt:Printf.TextWriterFormat<'c> -> 'c
        member uprintnfn : fmt:Printf.TextWriterFormat<'b> -> 'b
        member uprintnfnn : fmt:Printf.TextWriterFormat<'a,unit> -> 'a
        member Error : System.IO.TextWriter
        member Out : System.IO.TextWriter
      end
    type internal ErrorLoggerThatStopsOnFirstError =
      class
        inherit ErrorLogger.ErrorLogger
        new : tcConfigB:CompilerConfig.TcConfigBuilder *
              fsiStdinSyphon:FsiStdinSyphon * fsiConsoleOutput:FsiConsoleOutput ->
                ErrorLoggerThatStopsOnFirstError
        override
          DiagnosticSink : err:ErrorLogger.PhasedDiagnostic * isError:bool ->
                             unit
        member ResetErrorCount : unit -> unit
        member SetError : unit -> unit
        override ErrorCount : int
      end
    type ErrorLogger with
      member CheckForErrors : unit -> bool
    type ErrorLogger with
      member AbortOnError : fsiConsoleOutput:FsiConsoleOutput -> unit
    val internal directoryName : s:string -> string
    type internal FsiCommandLineOptions =
      class
        new : fsi:FsiEvaluationSessionHostConfig * argv:string [] *
              tcConfigB:CompilerConfig.TcConfigBuilder *
              fsiConsoleOutput:FsiConsoleOutput -> FsiCommandLineOptions
        member ShowBanner : unit -> unit
        member ShowHelp : m:Range.range -> unit
        member
          DependencyProvider : Microsoft.DotNet.DependencyManager.DependencyProvider
        member EnableConsoleKeyProcessing : bool
        member FsiLCID : int option
        member FsiServerInputCodePage : int option
        member FsiServerName : string
        member FsiServerOutputCodePage : int option
        member Gui : bool
        member Interact : bool
        member IsInteractiveServer : bool
        member PeekAheadOnConsoleToPermitTyping : bool
        member ProbeToSeeIfConsoleWorks : bool
        member ShowILCode : bool
        member ShowTypes : bool
        member SourceFiles : (string * bool) list
      end
    val internal SetCurrentUICultureForThread :
      lcid:int option -> System.IDisposable
    val internal InstallErrorLoggingOnThisThread :
      errorLogger:ErrorLogger.ErrorLogger -> unit
    val internal SetServerCodePages : fsiOptions:FsiCommandLineOptions -> unit
    type internal FsiConsolePrompt =
      class
        new : fsiOptions:FsiCommandLineOptions *
              fsiConsoleOutput:FsiConsoleOutput -> FsiConsolePrompt
        member Print : unit -> unit
        member PrintAhead : unit -> unit
        member SkipNext : unit -> unit
        member FsiOptions : FsiCommandLineOptions
      end
    type internal FsiConsoleInput =
      class
        new : fsi:FsiEvaluationSessionHostConfig *
              fsiOptions:FsiCommandLineOptions * inReader:System.IO.TextReader *
              outWriter:System.IO.TextWriter -> FsiConsoleInput
        member TryGetConsole : unit -> (unit -> string) option
        member TryGetFirstLine : unit -> string option
        member WaitForInitialConsoleInput : unit -> unit
        member In : System.IO.TextReader
      end
    type internal FsiInteractionStepStatus =
      | CtrlC
      | EndOfFile
      | Completed of FsiValue option
      | CompletedWithAlreadyReportedError
      | CompletedWithReportedError of exn
    [<NoEqualityAttribute (); NoComparisonAttribute ()>]
    type internal FsiDynamicCompilerState =
      { optEnv: Optimizer.IncrementalOptimizationEnv
        emEnv: AbstractIL.ILRuntimeWriter.emEnv
        tcGlobals: TcGlobals.TcGlobals
        tcState: ParseAndCheckInputs.TcState
        tcImports: CompilerImports.TcImports
        ilxGenerator: IlxGen.IlxAssemblyGenerator
        boundValues: AbstractIL.Internal.Library.NameMap<TypedTree.Val>
        timing: bool
        debugBreak: bool }
    val internal WithImplicitHome :
      tcConfigB:CompilerConfig.TcConfigBuilder * dir:string ->
        f:(unit -> 'a) -> 'a
    val internal convertReflectionTypeToILTypeRef :
      reflectionTy:System.Type -> AbstractIL.IL.ILTypeRef
    val internal convertReflectionTypeToILType :
      reflectionTy:System.Type -> AbstractIL.IL.ILType
    val internal mkBoundValueTypedImpl :
      tcGlobals:TcGlobals.TcGlobals ->
        m:Range.range ->
          moduleName:string ->
            name:string ->
              ty:TypedTree.TType ->
                TypedTree.ModuleOrNamespace * TypedTree.Val *
                TypedTree.TypedImplFile
    type internal FsiDynamicCompiler =
      class
        new : fsi:FsiEvaluationSessionHostConfig * timeReporter:FsiTimeReporter *
              tcConfigB:CompilerConfig.TcConfigBuilder * tcLockObject:obj *
              outWriter:System.IO.TextWriter *
              tcImports:CompilerImports.TcImports *
              tcGlobals:TcGlobals.TcGlobals * fsiOptions:FsiCommandLineOptions *
              fsiConsoleOutput:FsiConsoleOutput * fsiCollectible:bool *
              niceNameGen:CompilerGlobalState.NiceNameGenerator *
              resolveAssemblyRef:(AbstractIL.IL.ILAssemblyRef ->
                                    Choice<string,System.Reflection.Assembly> option) ->
                FsiDynamicCompiler
        member
          AddBoundValue : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                          errorLogger:ErrorLogger.ErrorLogger *
                          istate:FsiDynamicCompilerState * name:string *
                          value:obj ->
                            FsiDynamicCompilerState * FsiInteractionStepStatus
        member
          BuildItBinding : expr:SyntaxTree.SynExpr ->
                             SyntaxTree.SynModuleDecl list
        member
          CommitDependencyManagerText : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                        istate:FsiDynamicCompilerState *
                                        lexResourceManager:Lexhelp.LexResourceManager *
                                        errorLogger:ErrorLogger.ErrorLogger ->
                                          FsiDynamicCompilerState
        member CreateDebuggerBreak : m:Range.range -> SyntaxTree.SynModuleDecl
        member
          CurrentPartialAssemblySignature : istate:FsiDynamicCompilerState ->
                                              SourceCodeServices.FSharpAssemblySignature
        member
          EvalDependencyManagerTextFragment : packageManager:Microsoft.DotNet.DependencyManager.IDependencyManagerProvider *
                                              lt:CompilerConfig.Directive *
                                              m:Range.range * path:string ->
                                                unit
        member
          EvalParsedDefinitions : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                  errorLogger:ErrorLogger.ErrorLogger *
                                  istate:FsiDynamicCompilerState *
                                  showTypes:bool * isInteractiveItExpr:bool *
                                  defs:SyntaxTree.SynModuleDecl list ->
                                    FsiDynamicCompilerState *
                                    FsiInteractionStepStatus
        member
          EvalParsedExpression : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                 errorLogger:ErrorLogger.ErrorLogger *
                                 istate:FsiDynamicCompilerState *
                                 expr:SyntaxTree.SynExpr ->
                                   FsiDynamicCompilerState *
                                   FsiInteractionStepStatus
        member
          EvalParsedSourceFiles : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                  errorLogger:ErrorLogger.ErrorLogger *
                                  istate:FsiDynamicCompilerState *
                                  inputs:SyntaxTree.ParsedInput list ->
                                    FsiDynamicCompilerState
        member
          EvalRequireReference : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                 istate:FsiDynamicCompilerState * m:Range.range *
                                 path:string ->
                                   CompilerImports.AssemblyResolution list *
                                   FsiDynamicCompilerState
        member
          EvalSourceFiles : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                            istate:FsiDynamicCompilerState * m:Range.range *
                            sourceFiles:string list *
                            lexResourceManager:Lexhelp.LexResourceManager *
                            errorLogger:ErrorLogger.ErrorLogger ->
                              FsiDynamicCompilerState
        member FormatValue : obj:obj * objTy:System.Type -> string
        member
          GetBoundValues : istate:FsiDynamicCompilerState -> FsiBoundValue list
        member GetInitialInteractiveState : unit -> FsiDynamicCompilerState
        member
          ProcessMetaCommandsFromInputAsInteractiveCommands : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                                              istate:FsiDynamicCompilerState *
                                                              sourceFile:string *
                                                              inp:SyntaxTree.ParsedInput ->
                                                                FsiDynamicCompilerState
        member
          TryFindBoundValue : istate:FsiDynamicCompilerState * nm:string ->
                                FsiBoundValue option
        member DynamicAssembly : System.Reflection.Assembly
        member DynamicAssemblyName : string
        member ValueBound : IEvent<obj * System.Type * string>
      end
    type ControlEventHandler =
      delegate of int -> bool
    type internal FsiInterruptStdinState =
      | StdinEOFPermittedBecauseCtrlCRecentlyPressed
      | StdinNormal
    type internal FsiInterruptControllerState =
      | InterruptCanRaiseException
      | InterruptIgnored
    type internal FsiInterruptControllerKillerThreadRequest =
      | ThreadAbortRequest
      | NoRequest
      | ExitRequest
      | PrintInterruptRequest
    type internal FsiInterruptController =
      class
        new : fsiOptions:FsiCommandLineOptions *
              fsiConsoleOutput:FsiConsoleOutput -> FsiInterruptController
        member ClearInterruptRequest : unit -> unit
        member Exit : unit -> 'a
        member
          InstallKillThread : threadToKill:System.Threading.Thread *
                              pauseMilliseconds:int -> unit
        member Interrupt : unit -> unit
        member PosixInvoke : n:int -> unit
        member EventHandlers : ControlEventHandler list
        member FsiInterruptStdinState : FsiInterruptStdinState
        member InterruptAllowed : FsiInterruptControllerState with set
      end
    module internal MagicAssemblyResolution = begin
      val private assemblyLoadFrom : path:string -> System.Reflection.Assembly
      val Install :
        tcConfigB:CompilerConfig.TcConfigBuilder *
        tcImports:CompilerImports.TcImports *
        fsiDynamicCompiler:FsiDynamicCompiler *
        fsiConsoleOutput:FsiConsoleOutput -> System.IDisposable
    end
    type internal FsiStdinLexerProvider =
      class
        new : tcConfigB:CompilerConfig.TcConfigBuilder *
              fsiStdinSyphon:FsiStdinSyphon * fsiConsoleInput:FsiConsoleInput *
              fsiConsoleOutput:FsiConsoleOutput *
              fsiOptions:FsiCommandLineOptions *
              lexResourceManager:Lexhelp.LexResourceManager ->
                FsiStdinLexerProvider
        member
          CreateBufferLexer : sourceFileName:string *
                              lexbuf:UnicodeLexing.Lexbuf *
                              errorLogger:ErrorLogger.ErrorLogger ->
                                LexFilter.LexFilter
        member
          CreateIncludedScriptLexer : sourceFileName:string *
                                      reader:System.IO.StreamReader *
                                      errorLogger:ErrorLogger.ErrorLogger ->
                                        LexFilter.LexFilter
        member
          CreateStdinLexer : errorLogger:ErrorLogger.ErrorLogger ->
                               LexFilter.LexFilter
        member
          CreateStringLexer : sourceFileName:string * source:string *
                              errorLogger:ErrorLogger.ErrorLogger ->
                                LexFilter.LexFilter
        member ConsoleInput : FsiConsoleInput
      end
    type internal FsiInteractionProcessor =
      class
        new : fsi:FsiEvaluationSessionHostConfig *
              tcConfigB:CompilerConfig.TcConfigBuilder *
              fsiOptions:FsiCommandLineOptions *
              fsiDynamicCompiler:FsiDynamicCompiler *
              fsiConsolePrompt:FsiConsolePrompt *
              fsiConsoleOutput:FsiConsoleOutput *
              fsiInterruptController:FsiInterruptController *
              fsiStdinLexerProvider:FsiStdinLexerProvider *
              lexResourceManager:Lexhelp.LexResourceManager *
              initialInteractiveState:FsiDynamicCompilerState ->
                FsiInteractionProcessor
        member
          AddBoundValue : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                          errorLogger:ErrorLogger.ErrorLogger * name:string *
                          value:obj -> Choice<FsiValue option,exn option>
        member
          CompletionsForPartialLID : istate:FsiDynamicCompilerState *
                                     prefix:string -> string list
        member
          EvalExpression : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                           sourceText:string * scriptFileName:string *
                           errorLogger:ErrorLogger.ErrorLogger ->
                             Choice<FsiValue option,exn option>
        member
          EvalIncludedScript : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                               istate:FsiDynamicCompilerState *
                               sourceFile:string * m:Range.range *
                               errorLogger:ErrorLogger.ErrorLogger ->
                                 FsiDynamicCompilerState *
                                 FsiInteractionStepStatus
        member
          EvalIncludedScripts : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                istate:FsiDynamicCompilerState *
                                sourceFiles:string list *
                                errorLogger:ErrorLogger.ErrorLogger ->
                                  FsiDynamicCompilerState
        member
          EvalInteraction : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                            sourceText:string * scriptFileName:string *
                            errorLogger:ErrorLogger.ErrorLogger *
                            ?cancellationToken:System.Threading.CancellationToken ->
                              Choice<FsiValue option,exn option>
        member
          EvalScript : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                       scriptPath:string * errorLogger:ErrorLogger.ErrorLogger ->
                         Choice<FsiValue option,exn option>
        member
          LoadDummyInteraction : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                 errorLogger:ErrorLogger.ErrorLogger -> unit
        member
          LoadInitialFiles : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                             errorLogger:ErrorLogger.ErrorLogger -> unit
        member
          ParseAndCheckInteraction : ctok:AbstractIL.Internal.Library.CompilationThreadToken *
                                     legacyReferenceResolver:ReferenceResolver.Resolver *
                                     checker:SourceCodeServices.IReactorOperations *
                                     istate:FsiDynamicCompilerState *
                                     text:string ->
                                       Async<SourceCodeServices.FSharpParseFileResults *
                                             SourceCodeServices.FSharpCheckFileResults *
                                             SourceCodeServices.FSharpCheckProjectResults>
        member
          ParseAndExecOneSetOfInteractionsFromLexbuf : runCodeOnMainThread:((#AbstractIL.Internal.Library.CompilationThreadToken ->
                                                                               FsiDynamicCompilerState ->
                                                                               FsiDynamicCompilerState *
                                                                               FsiInteractionStepStatus) ->
                                                                              FsiDynamicCompilerState ->
                                                                              FsiDynamicCompilerState *
                                                                              FsiInteractionStepStatus) *
                                                       istate:FsiDynamicCompilerState *
                                                       tokenizer:LexFilter.LexFilter *
                                                       errorLogger:ErrorLogger.ErrorLogger *
                                                       ?cancellationToken:System.Threading.CancellationToken ->
                                                         FsiDynamicCompilerState *
                                                         FsiInteractionStepStatus
        member
          StartStdinReadAndProcessThread : errorLogger:ErrorLogger.ErrorLogger ->
                                             unit
        member CurrentState : FsiDynamicCompilerState
        member PartialAssemblySignatureUpdated : IEvent<unit>
      end
    val internal SpawnThread : name:string -> f:(unit -> unit) -> unit
    val internal SpawnInteractiveServer :
      fsi:FsiEvaluationSessionHostConfig * fsiOptions:FsiCommandLineOptions *
      fsiConsoleOutput:FsiConsoleOutput -> unit
    val internal DriveFsiEventLoop :
      fsi:FsiEvaluationSessionHostConfig * fsiConsoleOutput:FsiConsoleOutput ->
        unit
    [<ClassAttribute ()>]
    type FsiCompilationException =
      class
        inherit System.Exception
        new : string * SourceCodeServices.FSharpErrorInfo [] option ->
                FsiCompilationException
        member ErrorInfos : SourceCodeServices.FSharpErrorInfo [] option
      end
    [<ClassAttribute ()>]
    type FsiEvaluationSession =
      class
        interface System.IDisposable
        new : fsi:FsiEvaluationSessionHostConfig * argv:string [] *
              inReader:System.IO.TextReader * outWriter:System.IO.TextWriter *
              errorWriter:System.IO.TextWriter * fsiCollectible:bool *
              legacyReferenceResolver:ReferenceResolver.Resolver option ->
                FsiEvaluationSession
        static member
          Create : fsiConfig:FsiEvaluationSessionHostConfig * argv:string [] *
                   inReader:System.IO.TextReader *
                   outWriter:System.IO.TextWriter *
                   errorWriter:System.IO.TextWriter * ?collectible:bool *
                   ?legacyReferenceResolver:ReferenceResolver.Resolver ->
                     FsiEvaluationSession
        static member
          GetDefaultConfiguration : unit -> FsiEvaluationSessionHostConfig
        static member
          GetDefaultConfiguration : fsiObj:obj -> FsiEvaluationSessionHostConfig
        static member
          GetDefaultConfiguration : fsiObj:obj * useFsiAuxLib:bool ->
                                      FsiEvaluationSessionHostConfig
        member AddBoundValue : name:string * value:obj -> unit
        member EvalExpression : code:string -> FsiValue option
        member
          EvalExpressionNonThrowing : code:string ->
                                        Choice<FsiValue option,exn> *
                                        SourceCodeServices.FSharpErrorInfo []
        member
          EvalInteraction : code:string *
                            ?cancellationToken:System.Threading.CancellationToken ->
                              unit
        member
          EvalInteractionNonThrowing : code:string *
                                       ?cancellationToken:System.Threading.CancellationToken ->
                                         Choice<FsiValue option,exn> *
                                         SourceCodeServices.FSharpErrorInfo []
        member EvalScript : filePath:string -> unit
        member
          EvalScriptNonThrowing : filePath:string ->
                                    Choice<unit,exn> *
                                    SourceCodeServices.FSharpErrorInfo []
        member
          FormatValue : reflectionValue:obj * reflectionType:System.Type ->
                          string
        member GetBoundValues : unit -> FsiBoundValue list
        member GetCompletions : longIdent:string -> seq<string>
        member Interrupt : unit -> unit
        member
          ParseAndCheckInteraction : code:string ->
                                       Async<SourceCodeServices.FSharpParseFileResults *
                                             SourceCodeServices.FSharpCheckFileResults *
                                             SourceCodeServices.FSharpCheckProjectResults>
        member ReportUnhandledException : exn:exn -> unit
        member Run : unit -> unit
        member TryFindBoundValue : name:string -> FsiBoundValue option
        member
          CurrentPartialAssemblySignature : SourceCodeServices.FSharpAssemblySignature
        member DynamicAssembly : System.Reflection.Assembly
        member InteractiveChecker : SourceCodeServices.FSharpChecker
        member IsGui : bool
        member LCID : int option
        member PartialAssemblySignatureUpdated : IEvent<unit>
        member ValueBound : IEvent<obj * System.Type * string>
      end
    module Settings = begin
      type IEventLoop =
        interface
          abstract member Invoke : (unit -> 'T) -> 'T
          abstract member Run : unit -> bool
          abstract member ScheduleRestart : unit -> unit
        end
      type internal SimpleEventLoop =
        class
          interface System.IDisposable
          interface IEventLoop
          new : unit -> SimpleEventLoop
        end
      [<SealedAttribute ()>]
      type InteractiveSettings =
        class
          new : unit -> InteractiveSettings
          member AddPrintTransformer : ('T -> obj) -> unit
          member AddPrinter : ('T -> string) -> unit
          member
            AddedPrinters : Choice<(System.Type * (obj -> string)),
                                   (System.Type * (obj -> obj))> list
          member CommandLineArgs : string []
          member EventLoop : IEventLoop
          member FloatingPointFormat : string
          member FormatProvider : System.IFormatProvider
          member PrintDepth : int
          member PrintLength : int
          member PrintSize : int
          member PrintWidth : int
          member ShowDeclarationValues : bool
          member ShowIDictionary : bool
          member ShowIEnumerable : bool
          member ShowProperties : bool
        end
      val fsi : InteractiveSettings
    end
    [<AllowNullLiteralAttribute ()>]
    type CompilerInputStream =
      class
        inherit System.IO.Stream
        new : unit -> CompilerInputStream
        member Add : str:string -> unit
        override Flush : unit -> unit
        override Read : buffer:byte [] * offset:int * count:int -> int
        override Seek : _offset:int64 * _origin:System.IO.SeekOrigin -> int64
        override SetLength : _value:int64 -> unit
        override Write : _buffer:byte [] * _offset:int * _count:int -> unit
        override CanRead : bool
        override CanSeek : bool
        override CanWrite : bool
        override Length : int64
        override Position : int64
      end
    [<AllowNullLiteralAttribute ()>]
    type CompilerOutputStream =
      class
        inherit System.IO.Stream
        new : unit -> CompilerOutputStream
        override Flush : unit -> unit
        member Read : unit -> string
        override Read : _buffer:byte [] * _offset:int * _count:int -> int
        override Seek : _offset:int64 * _origin:System.IO.SeekOrigin -> int64
        override SetLength : _value:int64 -> unit
        override Write : buffer:byte [] * offset:int * count:int -> unit
        override CanRead : bool
        override CanSeek : bool
        override CanWrite : bool
        override Length : int64
        override Position : int64
      end
  end

