// Copyright (c) Microsoft Corporation.  All Rights Reserved.  See License.txt in the project root for license information.

namespace Microsoft.FSharp.Build

open System
open System.Collections
open System.Globalization
open System.IO
open System.Linq
open System.Text
open System.Xml.Linq
open Microsoft.Build.Framework
open Microsoft.Build.Utilities

type FSharpEmbedResXSource() =
    let mutable _buildEngine : IBuildEngine = null
    let mutable _hostObject : ITaskHost = null
    let mutable _embeddedText : ITaskItem[] = [||]
    let mutable _generatedSource : ITaskItem[] = [||]
    let mutable _outputPath : string = ""

    let boilerplate = @"// <auto-generated>

namespace {0}

open System.Reflection

module internal {1} =
    type private C (_dummy:System.Object) = class end
    let mutable Culture = System.Globalization.CultureInfo.CurrentUICulture
    let ResourceManager = new System.Resources.ResourceManager(""{2}"", C(null).GetType().GetTypeInfo().Assembly)
    let GetString(name:System.String) : System.String = ResourceManager.GetString(name, Culture)"

    let generateSource (resx:string) (fullModuleName:string) (generateLegacy:bool) =
        try
            let printMessage = printfn "FSharpEmbedResXSource: %s"
            let justFileName = Path.GetFileNameWithoutExtension(resx)
            let namespaceName, moduleName =
                let parts = fullModuleName.Split('.')
                if parts.Length = 1 then ("global", parts.[0])
                else (String.Join(".", parts, 0, parts.Length - 1), parts.[parts.Length - 1])
            let sb = StringBuilder().AppendLine(String.Format(boilerplate, namespaceName, moduleName, justFileName))
            let sourcePath = Path.Combine(_outputPath, justFileName + ".fs")
            printMessage <| sprintf "Generating: %s" sourcePath
            let body =
                XDocument.Load(resx).Descendants(XName.op_Implicit "data")
                |> Seq.fold (fun (sb:StringBuilder) (node:XElement) ->
                    let name =
                        match node.Attribute(XName.op_Implicit "name") with
                        | null -> failwith "Missing resource name"
                        | attr -> attr.Value
                    let docComment =
                        match node.Elements(XName.op_Implicit "value").FirstOrDefault() with
                        | null -> failwith <| sprintf "Missing resource value for '%s'" name
                        | element -> element.Value.Trim()
                    let identifier = if Char.IsLetter(name.[0]) || name.[0] = '_' then name else "_" + name
                    let commentBody =
                        XElement(XName.op_Implicit "summary", docComment).ToString().Split([|"\r\n"; "\r"; "\n"|], StringSplitOptions.None)
                        |> Array.fold (fun (sb:StringBuilder) line -> sb.AppendLine("    /// " + line)) (StringBuilder())
                    // add the resource
                    let accessorBody =
                        if generateLegacy then sprintf "    let %s = \"%s\"" identifier name
                        else sprintf "    let %s() = GetString(\"%s\")" identifier name
                    sb.AppendLine().Append(commentBody).AppendLine(accessorBody)
                ) sb
            File.WriteAllText(sourcePath, body.ToString())
            printMessage <| sprintf "Done: %s" sourcePath
            Some(sourcePath)
        with e ->
            printf "An exception occurred when processing '%s'\n%s" resx (e.ToString())
            None

    [<Required>]
    member this.EmbeddedResource
        with get() = _embeddedText
         and set(value) = _embeddedText <- value

    [<Required>]
    member this.IntermediateOutputPath
        with get() = _outputPath
         and set(value) = _outputPath <- value

    [<Output>]
    member this.GeneratedSource
        with get() = _generatedSource

    interface ITask with
        member this.BuildEngine
            with get() = _buildEngine
             and set(value) = _buildEngine <- value
        member this.HostObject
            with get() = _hostObject
             and set(value) = _hostObject <- value
        member this.Execute() =
            let getBooleanMetadata (metadataName:string) (item:ITaskItem) = String.Compare(item.GetMetadata(metadataName), "true", StringComparison.OrdinalIgnoreCase) = 0
            let generatedFiles, generatedResult =
                this.EmbeddedResource
                |> Array.filter (getBooleanMetadata "GenerateSource")
                |> Array.fold (fun (resultList, aggregateResult) item ->
                    let moduleName =
                        match item.GetMetadata("GeneratedModuleName") with
                        | null -> Path.GetFileNameWithoutExtension(item.ItemSpec)
                        | value -> value
                    let generateLegacy = getBooleanMetadata "GenerateLegacyCode" item
                    match generateSource item.ItemSpec moduleName generateLegacy with
                    | Some (source) -> ((source :: resultList), aggregateResult)
                    | None -> (resultList, false)
                ) ([], true)
            let generatedSources = generatedFiles |> List.map (fun item -> TaskItem(item) :> ITaskItem)
            _generatedSource <- generatedSources |> List.rev |> List.toArray
            generatedResult
