// Copyright (c) Microsoft Corporation.  All Rights Reserved.  See License.txt in the project root for license information.

namespace Microsoft.FSharp.Build

open System
open System.Collections
open System.Globalization
open System.IO
open System.Linq
open System.Text
open System.Xml.Linq
open Microsoft.Build.Framework
open Microsoft.Build.Utilities

type FSharpEmbedResXSource() =
    let mutable _buildEngine : IBuildEngine = null
    let mutable _hostObject : ITaskHost = null
    let mutable _embeddedText : ITaskItem[] = [||]
    let mutable _generatedSource : ITaskItem[] = [||]
    let mutable _outputPath : string = ""
    let mutable _targetFramework : string = ""

    let boilerplate = @"// <auto-generated>

namespace {0}

open System.Reflection

module internal {1} =
    type private C (_dummy:System.Object) = class end
    let mutable Culture = System.Globalization.CultureInfo.CurrentUICulture
    let ResourceManager = new System.Resources.ResourceManager(""{2}"", C(null).GetType().GetTypeInfo().Assembly)
    let GetString(name:System.String) : System.String = ResourceManager.GetString(name, Culture)"

    let boilerplateGetObject = "    let GetObject(name:System.String) : System.Object = ResourceManager.GetObject(name, Culture)"

    let generateSource (resx:string) (fullModuleName:string) (generateLegacy:bool) (generateLiteral:bool) =
        try
            let printMessage = printfn "FSharpEmbedResXSource: %s"
            let justFileName = Path.GetFileNameWithoutExtension(resx)
            let namespaceName, moduleName =
                let parts = fullModuleName.Split('.')
                if parts.Length = 1 then ("global", parts.[0])
                else (String.Join(".", parts, 0, parts.Length - 1), parts.[parts.Length - 1])
            let generateGetObject =
                match _targetFramework with
                | "netstandard1.0"
                | "netstandard1.1"
                | "netstandard1.2"
                | "netstandard1.3"
                | "netstandard1.4"
                | "netstandard1.5"
                | "netstandard1.6" -> false // these targets don't support the `ResourceManager.GetObject()` method
                | _ -> true // other supported runtimes, do
            let sb = StringBuilder().AppendLine(String.Format(boilerplate, namespaceName, moduleName, justFileName))
            if generateGetObject then sb.AppendLine(boilerplateGetObject) |> ignore
            let sourcePath = Path.Combine(_outputPath, justFileName + ".fs")
            printMessage <| sprintf "Generating: %s" sourcePath
            let body =
                let xname = XName.op_Implicit
                XDocument.Load(resx).Descendants(xname "data")
                |> Seq.fold (fun (sb:StringBuilder) (node:XElement) ->
                    let name =
                        match node.Attribute(xname "name") with
                        | null -> failwith "Missing resource name"
                        | attr -> attr.Value
                    let docComment =
                        match node.Elements(xname "value").FirstOrDefault() with
                        | null -> failwith <| sprintf "Missing resource value for '%s'" name
                        | element -> element.Value.Trim()
                    let identifier = if Char.IsLetter(name.[0]) || name.[0] = '_' then name else "_" + name
                    let commentBody =
                        XElement(xname "summary", docComment).ToString().Split([|"\r\n"; "\r"; "\n"|], StringSplitOptions.None)
                        |> Array.fold (fun (sb:StringBuilder) line -> sb.AppendLine("    /// " + line)) (StringBuilder())
                    // add the resource
                    let accessorBody =
                        match (generateLegacy, generateLiteral) with
                        | (true, true) -> sprintf "    [<Literal>]\n    let %s = \"%s\"" identifier name
                        | (true, false) -> sprintf "    let %s = \"%s\"" identifier name // the [<Literal>] attribute can't be used for FSharp.Core
                        | (false, _) ->
                            let isStringResource = match node.Attribute(xname "type") with
                                                   | null -> true
                                                   | _ -> false
                            match (isStringResource, generateGetObject) with
                            | (true, _) -> sprintf "    let %s() = GetString(\"%s\")" identifier name
                            | (false, true) -> sprintf "    let %s() = GetObject(\"%s\")" identifier name
                            | (false, false) -> "" // the target runtime doesn't support non-string resources
                            // TODO: When calling the `GetObject` version, parse the `type` attribute to discover the proper return type
                    sb.AppendLine().Append(commentBody).AppendLine(accessorBody)
                ) sb
            File.WriteAllText(sourcePath, body.ToString())
            printMessage <| sprintf "Done: %s" sourcePath
            Some(sourcePath)
        with e ->
            printf "An exception occurred when processing '%s'\n%s" resx (e.ToString())
            None

    [<Required>]
    member this.EmbeddedResource
        with get() = _embeddedText
         and set(value) = _embeddedText <- value

    [<Required>]
    member this.IntermediateOutputPath
        with get() = _outputPath
         and set(value) = _outputPath <- value

    member this.TargetFramework
        with get() = _targetFramework
         and set(value) = _targetFramework <- value

    [<Output>]
    member this.GeneratedSource
        with get() = _generatedSource

    interface ITask with
        member this.BuildEngine
            with get() = _buildEngine
             and set(value) = _buildEngine <- value
        member this.HostObject
            with get() = _hostObject
             and set(value) = _hostObject <- value
        member this.Execute() =
            let getBooleanMetadata (metadataName:string) (defaultValue:bool) (item:ITaskItem) =
                match item.GetMetadata(metadataName) with
                | value when String.IsNullOrWhiteSpace(value) -> defaultValue
                | value -> String.Compare(value, "true", StringComparison.OrdinalIgnoreCase) = 0
            let generatedFiles, generatedResult =
                this.EmbeddedResource
                |> Array.filter (getBooleanMetadata "GenerateSource" false)
                |> Array.fold (fun (resultList, aggregateResult) item ->
                    let moduleName =
                        match item.GetMetadata("GeneratedModuleName") with
                        | null -> Path.GetFileNameWithoutExtension(item.ItemSpec)
                        | value -> value
                    let generateLegacy = getBooleanMetadata "GenerateLegacyCode" false item
                    let generateLiteral = getBooleanMetadata "GenerateLiterals" true item
                    match generateSource item.ItemSpec moduleName generateLegacy generateLiteral with
                    | Some (source) -> ((source :: resultList), aggregateResult)
                    | None -> (resultList, false)
                ) ([], true)
            let generatedSources = generatedFiles |> List.map (fun item -> TaskItem(item) :> ITaskItem)
            _generatedSource <- generatedSources |> List.rev |> List.toArray
            generatedResult
